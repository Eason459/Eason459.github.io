<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java后知后觉 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="那些Java中你可能不知道的一些事关于命令 123$ javac HelloWorld.java  $ java HelloWorld  HelloWorld 相信这是大家刚刚接触Java时接触到的第一个程序在这个命令行终端中我们用到了两个命令javac和java   javac后跟着的是一个典型的java文件，javac此时所做的事就是将java源文件编译成字节码文件此时如果编译成功的话是会生成">
<meta property="og:type" content="article">
<meta property="og:title" content="Java后知后觉">
<meta property="og:url" content="http://yoursite.com/2020/04/29/Java%E5%90%8E%E7%9F%A5%E5%90%8E%E8%A7%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="那些Java中你可能不知道的一些事关于命令 123$ javac HelloWorld.java  $ java HelloWorld  HelloWorld 相信这是大家刚刚接触Java时接触到的第一个程序在这个命令行终端中我们用到了两个命令javac和java   javac后跟着的是一个典型的java文件，javac此时所做的事就是将java源文件编译成字节码文件此时如果编译成功的话是会生成">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-04-29T08:30:57.000Z">
<meta property="article:modified_time" content="2020-04-29T08:35:06.890Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="一些Java中重要而又容易忽略的东西">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java后知后觉" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/29/Java%E5%90%8E%E7%9F%A5%E5%90%8E%E8%A7%89/" class="article-date">
  <time datetime="2020-04-29T08:30:57.000Z" itemprop="datePublished">2020-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java后知后觉
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="那些Java中你可能不知道的一些事"><a href="#那些Java中你可能不知道的一些事" class="headerlink" title="那些Java中你可能不知道的一些事"></a>那些Java中你可能不知道的一些事</h1><h2 id="关于命令"><a href="#关于命令" class="headerlink" title="关于命令"></a>关于命令</h2><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ javac HelloWorld.java  </span><br><span class="line">$ java HelloWorld  </span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure>
<h5 id="相信这是大家刚刚接触Java时接触到的第一个程序"><a href="#相信这是大家刚刚接触Java时接触到的第一个程序" class="headerlink" title="相信这是大家刚刚接触Java时接触到的第一个程序"></a>相信这是大家刚刚接触Java时接触到的第一个程序</h5><h5 id="在这个命令行终端中我们用到了两个命令javac和java"><a href="#在这个命令行终端中我们用到了两个命令javac和java" class="headerlink" title="在这个命令行终端中我们用到了两个命令javac和java"></a>在这个命令行终端中我们用到了两个命令javac和java</h5></li>
</ul>
<ol>
<li>javac后跟着的是一个典型的java文件，javac此时所做的事就是<em>将java源文件编译成字节码文件</em>此时如果编译成功的话是会生成一个名为HelloWorld.class的文件，此时就是成功编译为字节码文件；</li>
<li>java后跟的是Java文件中的类名，比如这里的HelloWorld但是不要加.class后缀。<h5 id="然后就编译成功啦"><a href="#然后就编译成功啦" class="headerlink" title="然后就编译成功啦"></a>然后就编译成功啦</h5><h2 id="关于修饰符"><a href="#关于修饰符" class="headerlink" title="关于修饰符"></a>关于修饰符</h2></li>
</ol>
<p>-<br><strong><em>synchronized修饰符</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void easonHe()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<strong>synchronized</strong>修饰符是在多线程的程序编码中常会用到的修饰符，<em>synchronized</em>修饰符旨在<em>确保方法在同一时间只能被一个线程访问</em>。同时<strong>synchronized</strong>可以用于四个访问修饰符。  </p>
<p>-</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread implements Runnable&#123;</span><br><span class="line">    private volatile boolean active;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        active &#x3D; true;</span><br><span class="line">        while(active)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void stop()&#123;</span><br><span class="line">        active &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>volatile</em>修饰词也是常用于多线程中，每当线程准备访问<em>volatile</em>所修饰的成员变量时，必须要从共享内存中重新读取该成员变量的值，另外，如果遇到该成员变量的值发生改变时，线程也必须将该成员变量的值写入到共享内存中更新，这样以来，多线程中每个线程所看到的都是成员变量的同一个值。  </p>
</blockquote>
<blockquote>
<p>这个成程序中，若是一个线程调用run()方法，此时另一线程调用stop()方法时，如果线程已经进入while的缓冲区，那么即使stop()方法中的active=false线程也不会停止，但是由于这个线程中的active是被<em>volatile</em>修饰符所修饰，所以这个循环会停止。</p>
</blockquote>
<p>-<br><strong><em>transient修饰符</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public transient int a &#x3D; 1;</span><br><span class="line">public int b;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>transient</em>修饰符用来定义变量时，其作用是用来预处理类与变量的数据类型，也就是说，如果序列化的对象包含别<em>transient</em>修饰的实例变量，那么JVM将会跳过此特定的变量。</p>
</blockquote>
<h2 id="关于运算符"><a href="#关于运算符" class="headerlink" title="关于运算符"></a>关于运算符</h2><p>-<br><strong><em>位运算符</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; 0101 1100</span><br><span class="line">B &#x3D; 0010 0101  </span><br><span class="line">---------------</span><br><span class="line">A&amp;B &#x3D; 0000 0100</span><br><span class="line">A|B &#x3D; 0111 1101</span><br><span class="line">A^B &#x3D; 0111 1001</span><br><span class="line">~A &#x3D; 1010 0011</span><br><span class="line">B&lt;&lt;2 &#x3D; 1001 0100</span><br><span class="line">B&gt;&gt;2 &#x3D; 1001</span><br><span class="line">B&gt;&gt;&gt;2 &#x3D; 0000 1001</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><em>^如果对应位值相等则为0不等则为1</em>；</li>
<li><em>～按位取反运算符</em>；</li>
<li>*&lt;&lt;按位左移运算符，左操作数按位左移右操作数指定的位数*;  </li>
<li><em>&gt;&gt;按位右移运算符，左操作数按位右移右操作数指定的位数</em>；</li>
<li><em>&gt;&gt;&gt;按位右移补零运算符，在按位右移的情况下将最高位的空位用零填充</em></li>
</ol>
</blockquote>
<p>但是其实我们真正用到它的时候并非如此使用，而是下面这种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void Demo()&#123;</span><br><span class="line">    public static void main (String[], args)&#123;</span><br><span class="line">        int a &#x3D; 13; &#x2F;&#x2F;即 a&#x3D;0000 1101</span><br><span class="line">        int b &#x3D; 28; &#x2F;&#x2F;即 b&#x3D;0001 1100</span><br><span class="line">        int c &#x3D; 0;</span><br><span class="line">        c &#x3D; a &amp; b;</span><br><span class="line">        System.out.println(&quot;a &amp; b &#x3D; &quot;+c) &#x2F;&#x2F;此时c的值为12 即0000 1100</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说我们平时使用的往往并非二进制编码，而是对应的十进制编码，但有时我们也会为了满足某种需求而使用到十进制编码进行位操作符的运算。  </p>
<p>-<br><strong><em>短路逻辑运算符</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">    public static void main(String[], args)&#123;</span><br><span class="line">        int a &#x3D; 6;</span><br><span class="line">        boolean result &#x3D; (a&lt;2&amp;&amp;++a&lt;8) &#x2F;&#x2F;a&#x3D;6</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码中，result结果为false，因为a&lt;2已经是false了所以结果必定是false，所以说第二个操作判断就不被执行了，也就是++a不被执行，所以此时a仍然为6.</p>
</blockquote>
<p>-<br><strong><em>instanceof运算符</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; &quot;watermelon&quot;;</span><br><span class="line">boolean isReal &#x3D; str instanceof String;</span><br><span class="line">&#x2F;&#x2F; is Real &#x3D; true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>instanceof运算符用于操作一个对象的实例，若为此特定类类型或接口类型则为真，否则为假，即如果运算符左侧所指的对象是右侧类或者接口的一个对象则结果为真。  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Cola&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">public class Pepsi extends Cola&#123;</span><br><span class="line">    public static void main(String[], args)&#123;</span><br><span class="line">        Cola cola &#x3D; new Pepsi();</span><br><span class="line">        boolean result &#x3D; cola instanceof Pepsi;</span><br><span class="line">        &#x2F;&#x2F;此时result&#x3D;true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用instanceof操作符如果被比较的对象兼容于右侧的类型，则同样成立。这里应该注意<strong><em>判断一个实例引用的类型时，使用的是实际类型，而不是声明的类型，如上代码中cola是Pepsi类型而不是Cola类型，并且，子类的实例可以声明为父类，但是父类的实例不可以声明为子类</em></strong>。</p>
</blockquote>
<h2 id="关于循环"><a href="#关于循环" class="headerlink" title="关于循环"></a>关于循环</h2><p>-<br><strong><em>加强型for循环(For-Each)</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">    public static void main(String[], args)&#123;</span><br><span class="line">        int [] num &#x3D; &#123;2, 6, 9, 30&#125;;</span><br><span class="line">        for(int i : num)&#123;</span><br><span class="line">            System.out.print(i+&quot; &quot;);</span><br><span class="line">            &#x2F;&#x2F;此时将会打印出2 6 9 30</span><br><span class="line">        &#125;</span><br><span class="line">        String [] drinks &#x3D; &#123;&quot;cola&quot;, &quot;coffee&quot;, &quot;tea&quot;&#125;;</span><br><span class="line">        for(String name : drinks)&#123;</span><br><span class="line">            System.out.print(name+&quot; &quot;);</span><br><span class="line">            &#x2F;&#x2F;此时将会打印出cola coffee tea </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种情况是Java引入的为了用于数组形式的增强版for循环。</p>
</blockquote>
<h4 id="ps-在循环或者条件以及选择语句中需要注意的几点："><a href="#ps-在循环或者条件以及选择语句中需要注意的几点：" class="headerlink" title="ps:在循环或者条件以及选择语句中需要注意的几点："></a>ps:在循环或者条件以及选择语句中需要注意的几点：</h4><ol>
<li>在循环操作语句中，如果遇到break语句被执行，那么将会直接跳出最内层的一个循环体，如果遇到continue语句被执行，那么接下来的语句将不会被执行，而是直接进入新一轮的循环，这种用法往往用来选择性退出或者是去刻意忽略某次循环体内的语句；</li>
<li>在选择操作语句中，如switch语句，如果case没有与变量类型相匹配的，那么将会执行default语句（如果有的话），如果匹配的case语句没有break，那么将会顺序输出以下的语句，直到遇到break或全部输出。  </li>
</ol>
<h2 id="关于Java类"><a href="#关于Java类" class="headerlink" title="关于Java类"></a>关于Java类</h2><p>-<br><strong><em>包装类</em></strong><br>由于java属于面向对象的编程语言，所以我们难免会遇到使用数据时需要使用对象而不是内置数据类型的情形，针对于此，java提供了包装类：Double,Float, Long, Integer, Short, Byte.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class IntergerTest&#123;</span><br><span class="line">    public static void main(String[], args)&#123;</span><br><span class="line">        int a &#x3D; 128;</span><br><span class="line">        Interger b &#x3D; 128;</span><br><span class="line">        Interger c &#x3D; new Interger(128);</span><br><span class="line">        System.out.println(a&#x3D;&#x3D;b); &#x2F;&#x2F;true 因为与内置数据类型比较，所以Interger会自动拆箱比较  </span><br><span class="line">        &#x2F;&#x2F; a&#x3D;&#x3D;c 与 a&#x3D;&#x3D;b情况相同</span><br><span class="line">        Interger b1 &#x3D; 127;</span><br><span class="line">        Interger c1 &#x3D; 127; &#x2F;&#x2F;此时经编译时为Interger b2 &#x3D; Interger.valueOf(127)  </span><br><span class="line">        System.out.println(b1&#x3D;&#x3D;c1); &#x2F;&#x2F;true</span><br><span class="line">        Interger b2 &#x3D; 128;</span><br><span class="line">        Interger c2 &#x3D; 128;</span><br><span class="line">        System.out.println(b2&#x3D;&#x3D;c2); &#x2F;&#x2F;false 因为Interger中的valueOf函数只会对int类型的取值范围内（-128～127）之间的数进行缓存。  </span><br><span class="line">        Interger b3 &#x3D; new Interger(127);</span><br><span class="line">        Interger c3 &#x3D; 127;</span><br><span class="line">        System.out.println(b3&#x3D;&#x3D;c3); &#x2F;&#x2F;false 无论如何Interger与new得到的Interger不会相等，</span><br><span class="line">        &#x2F;&#x2F;因为new得到的对象放在堆存储区里，非new得到的常量则放在常量池即方法区里，故不会经历拆箱，两地址也不同，故不会相等</span><br><span class="line">        Interger b4 &#x3D; new Interger(127);</span><br><span class="line">        Interger c4 &#x3D; new Interger(127);</span><br><span class="line">        System.out.println(b4&#x3D;&#x3D;c4); &#x2F;&#x2F;false 因为都是通过new得到的对象，所以地址不相同</span><br><span class="line">        Interger b5 &#x3D; 127;</span><br><span class="line">        Interger c5 &#x3D; 127;</span><br><span class="line">        System.out.println(b5.equals(c5)); &#x2F;&#x2F;true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译器特别支持的包装成为装箱，所以在内置类型要作为对象使用时，编译器就会将其装箱成为一个包装类，若是一个对象要作为内置数据类型使用时，编译器也会将其拆箱；  </p>
</blockquote>
<blockquote>
<h2 id="要注意在进行比较时-比较的是地址，equals-比较的是对象的内容，所以在Interger-valueOf-时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。"><a href="#要注意在进行比较时-比较的是地址，equals-比较的是对象的内容，所以在Interger-valueOf-时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。" class="headerlink" title="要注意在进行比较时 =比较的是地址，equals()比较的是对象的内容，所以在Interger.valueOf()时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。  "></a>要注意在进行比较时 =比较的是地址，equals()比较的是对象的内容，所以在Interger.valueOf()时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。  </h2><p><strong><em>String类</em></strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">    public static void main()&#123;</span><br><span class="line">        char[] array &#x3D; &#123;&quot;E&quot;, &quot;a&quot;, &quot;s&quot;, &quot;o&quot;, &quot;n&quot;&#125;;</span><br><span class="line">        String str &#x3D; new String(array);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        &#x2F;&#x2F;输出结果为Eason</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Java中，String字符串属于对象，String类有11中构造方法，这些方法提供不同的参数来初始化字符串，比如这段代码中提供一个字符数组来初始化一个字符串；  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">    public static void main()&#123;</span><br><span class="line">        String str &#x3D; &quot;Eason&quot;;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        &#x2F;&#x2F;输出Eason</span><br><span class="line">        str &#x3D; &quot;He&quot;;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        &#x2F;&#x2F;输出He</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>特别需要注意的是一旦String对象被创建那么它就无法被更改了，也就是说String是被final修饰的，但是这段代码中str在结果上看是改变了，但其实它并没有被更改，因为实例str只是一个String的对象引用，当执行str=”He”的时候它创建了一个新的String对象”He”,原来的”Eason”对象仍然存储在内存中；  </p>
</blockquote>
<blockquote>
<p>也就是说，如果需要对字符串做很多修改，那么应该选择使用<em>StringBuffer和StringBuilder</em>类。<br>    1.StringBuffer:字符串变量，Synchronized线程安全，如果想专成String类型，则可以使用toString()方法，Java.lang.StringBuffer可以通过某些特定的方法调用可以改变该序列的长度和内容，可以将字符串缓冲区安全的应用于多个线程；<br>    2.StringBuilder:字符串变量，非线程安全，在内部StringBuilder对象被当作是一个包含自负序列的变长数组；<br>    <strong><em>总结</em></strong>：<strong>-</strong> 如果操作少量的数据用String <strong>-</strong> 单线程操作大量数据用StringBuilder <strong>-</strong> 多线程操作大量数据用StringBuffer。<br>    ps：其实StringBuffer的线程安全也是很低能的也就是说它也只能保证jvm不抛出异常而向下运行而已，所以针对于StringBuilder的高效，所以<strong><em>在绝大部分情况下直接使用StringBuilder</em></strong>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; &quot;a&quot;+&quot;b&quot;+&quot;c&quot;;</span><br><span class="line">String s2 &#x3D; &quot;abc&quot;;</span><br><span class="line">System.out.println(s1&#x3D;&#x3D;s2);&#x2F;&#x2F;true</span><br><span class="line">System.out.println(s1.equals(s2));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是道面试经常会被问到的问题，在Java常量优化机制中，编译时s1已经成为”abc”在常量池中查找创建，故此时s2就不用再创建了；  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; &quot;a&quot;+&quot;b&quot;;</span><br><span class="line">String s2 &#x3D; &quot;abc&quot;;</span><br><span class="line">String s3 &#x3D; s1+&quot;c&quot;;</span><br><span class="line">System.out.println(s3&#x3D;&#x3D;s2);&#x2F;&#x2F;false</span><br><span class="line">System.out.println(s3.equals(s2));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这也是道面试经常会被问到的问题，在编译时，”ab”在常量池中被创建其地址为a1,”abc”接着被创建其地址为a2,对于s3，先创建一个StringBuilder或StringBuffer对象，通过append方法连接得到abc，再调用toString()转换为String得到的地址为a3，故==为false，equals比较对象的值为true。</p>
</blockquote>
<p><strong>另外</strong>：length(), length属性，size()之间的一些区别</p>
<ol>
<li>length()方法是针对字符串来说的，要求一个字符串的长度时就要用到这个方法；</li>
<li>length属性是针对Java中的数组来说的，要求数组的长度可以用length属性；</li>
<li>size()方法是针对泛型集合List来说的，如果想看一个泛型集合中有多少个元素就使用此方法；</li>
</ol>
<h2 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h2><p>-<br><strong>Arrays类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Demo&#123;</span><br><span class="line">    public static void main(String[], args)&#123;</span><br><span class="line">        int [] num &#x3D; new int[8];</span><br><span class="line">        int [] num1 &#x3D; &#123;7,3,6,2,8,5&#125;;</span><br><span class="line">        Arrays.fill(num, 6);&#x2F;&#x2F;此时num数组内的元素为66666666</span><br><span class="line">        Arrays.fill(num, 1,2,8);&#x2F;&#x2F;将num数组中第1，2个元素赋值为8</span><br><span class="line">        Arrays.sort(num1);&#x2F;&#x2F;对num1数组进行排序</span><br><span class="line">        Arrays.equals(num, num1);&#x2F;&#x2F;比较两数组元素是否相等</span><br><span class="line">        Arrays.binarySearch(num1, 2);&#x2F;&#x2F;查找元素3在数组中的位置，如果不存在就返回负数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java.util.Arrays类能够很方便的处理数组，它提供的所有方法都是静态的，它的部分功能：<br>    1. 通过fill()方法给数组赋值；<br>    2. 通过sort()方法按升序排序；<br>    3. 通过equals()方法判断数组中的元素是否相等；<br>    4. 通过binarySearch()方法能对排好序的数组进行二分法查找等等。</p>
</blockquote>
<h2 id="关于正则表达式"><a href="#关于正则表达式" class="headerlink" title="关于正则表达式"></a>关于正则表达式</h2><p>-<br><strong>Pattern与Matcher类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.regex.Pattern;</span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line"></span><br><span class="line">public class Demo&#123;</span><br><span class="line">    public static void main(String[], args)&#123;</span><br><span class="line">        String str &#x3D; &quot;My number is 56? Yes!&quot;;</span><br><span class="line">        String regex &#x3D; &quot;(\\d+)(\\D*)(.*)&quot;;</span><br><span class="line">        Pattern p &#x3D; Pattern.compile(regex);&#x2F;&#x2F;创建Pattern对象</span><br><span class="line">        Matcher m &#x3D; p.matcher(str);&#x2F;&#x2F;创建Matcher(适配器)对象</span><br><span class="line">        if(m.find())&#123;</span><br><span class="line">            System.out.println(m.group(0));&#x2F;&#x2F;输出：My number is 56? Yes!</span><br><span class="line">            System.out.println(m.group(1));&#x2F;&#x2F;输出：56</span><br><span class="line">            System.out.println(m.group(2));&#x2F;&#x2F;输出：My number is Yes</span><br><span class="line">            System.out.println(m.group(3));&#x2F;&#x2F;输出：? Yes!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本段代码中group()方法为捕获组，比如正则表达式中((A)(B(C)))这其中就有四个组((A)(B(C)))、(A)、(B(C))、(C),技巧是左边数第几个括号所对应的内容就是相应的第几组；  </p>
</blockquote>
<blockquote>
<p>Pattern与Matcher类都没有公共的构造方法，都是通过调用静态函数所得到的返回类型来创建类；</p>
</blockquote>
<blockquote>
<p>在其他语言的正则表达式中往往一个反斜杠\就具有转义作用，但是Java的正则表达式中两个反斜杠才能表示转义作用，比如\\d表示一位数字。</p>
</blockquote>
<blockquote>
<p>在Matcher类中有两个重要的方法就是start()和end()方法，start()方法返回由给定组所捕获的初始索引，end()方法是返回最后一个匹配字符的索引+1</p>
</blockquote>
<h2 id="关于Java方法"><a href="#关于Java方法" class="headerlink" title="关于Java方法"></a>关于Java方法</h2><p>-<br><strong>_出现在方法名称</strong></p>
<blockquote>
<h2 id="在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test-例如：textPop-emptyStack"><a href="#在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test-例如：textPop-emptyStack" class="headerlink" title="在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test 例如：textPop_emptyStack."></a>在方法的命名中，下划线<em>可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test<MethodUnderTest></em><state> 例如：textPop_emptyStack.</h2><p><strong>命令行参数的使用</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Demo()&#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;args.length;i++)&#123;</span><br><span class="line">            System.out.println(&quot;args[&quot;+i+&quot;] &#x3D; &quot;+args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行此程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ javac Demo.java</span><br><span class="line">$ java Demo This is a command line</span><br><span class="line">args[0] &#x3D; This</span><br><span class="line">args[1] &#x3D; is</span><br><span class="line">args[2] &#x3D; a</span><br><span class="line">args[3] &#x3D; command</span><br><span class="line">args[4] &#x3D; line</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息"><a href="#这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息" class="headerlink" title="这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息  "></a>这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息  </h2><p><strong>可变参数</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">    public static void main()&#123;</span><br><span class="line">        printMin(&#123;2, 1, 5, 0.6,&#125;);&#x2F;&#x2F;输出：The min value is : 0.6</span><br><span class="line">        printMin(new double[]&#123;3.2, 4, 9, 6.7&#125;)&#x2F;&#x2F;输出：The min value is : 3.2</span><br><span class="line">    &#125;</span><br><span class="line">    public void printMin(doulbe... num)&#123;</span><br><span class="line">        if(num.length&#x3D;&#x3D;0)&#123;</span><br><span class="line">            System.out.println(&quot;No agument passed&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        double result &#x3D; num[0]</span><br><span class="line">        for(int i&#x3D;1;i&lt;num.length;i++)&#123;</span><br><span class="line">            if(num[i]&lt;result)&#123;</span><br><span class="line">                result&#x3D;num[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;The min value is : &quot;+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个函数中最多只能有一个可变参数，并且要放在参数列表的最后，代码在执行时，编译器会将可变参数编译为一个数组，所以在函数的内部，参数名可以看作是数组名； </p>
</blockquote>
<blockquote>
<h2 id="由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法"><a href="#由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法" class="headerlink" title="由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法"></a>由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法</h2><p><strong>finalize()方法</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class FinalizationDemo&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cola cola1 &#x3D; new Cola(1);</span><br><span class="line">        Cola cola2 &#x3D; new Cola(2);</span><br><span class="line">        Cola cola3 &#x3D; new Cola(3);</span><br><span class="line">        cola2 &#x3D; cola3 &#x3D; null;&#x2F;&#x2F;将两对象作废，接下来会被回收</span><br><span class="line">        System.gc();&#x2F;&#x2F;调用Java垃圾收容器</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cola extends Object&#123;</span><br><span class="line">    private int i;</span><br><span class="line">    public Cola(int i)&#123;</span><br><span class="line">        this.i&#x3D;i;</span><br><span class="line">        System.out.println(&quot;Cola object &quot;+i+&quot; is created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    protected void finalize() throws java.lang.Throwable&#123;</span><br><span class="line">        System.out.println(&quot;Cola object &quot;+i+&quot; is disposed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;结果：</span><br><span class="line">&#x2F;&#x2F;Cola object 1 is created</span><br><span class="line">&#x2F;&#x2F;Cola object 2 is created</span><br><span class="line">&#x2F;&#x2F;Cola object 3 is created</span><br><span class="line">&#x2F;&#x2F;Cola object 2 is disposed</span><br><span class="line">&#x2F;&#x2F;Cola object 3 is disposed</span><br></pre></td></tr></table></figure>
<blockquote>
<p>finalize()方法在对象被回收之前调用，它用来清除回收对象，可以用这个方法来确保一个对象打开的文件被关闭，并且该方法需要protected限定其余类不可调用此方法，当然JVM自动完成内存的回收，也可以通过这个方法来手动操作  </p>
</blockquote>
<h2 id="关于文件的Stream-流-与File-文件"><a href="#关于文件的Stream-流-与File-文件" class="headerlink" title="关于文件的Stream(流)与File(文件)"></a>关于文件的Stream(流)与File(文件)</h2><p>-</p>
<p><strong>乱码问题</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            byte[] bWrite &#x3D; &#123;1, 3, 5, 7, 9&#125;;&#x2F;&#x2F;写入的数据为byte类型</span><br><span class="line">            Outputstream os &#x3D; new FileOutputStream(&quot;test.txt&quot;);</span><br><span class="line">            for(int i&#x3D;0;i&lt;bWrite.length;i++)&#123;</span><br><span class="line">                os.write(bWtite[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            os.close();</span><br><span class="line">        </span><br><span class="line">            InputStream is &#x3D; new FileInputStream(&quot;test.txt&quot;);</span><br><span class="line">            int size &#x3D; is.available();</span><br><span class="line">            for(int i&#x3D;0;i&lt;size;i++)&#123;</span><br><span class="line">                System.out.println((byte)is.read());&#x2F;&#x2F;最终要的要将读取数据强制转换成同类型才能避免乱码</span><br><span class="line">            &#125;</span><br><span class="line">            is.close();</span><br><span class="line">            &#125;catch(IOException e)&#123;</span><br><span class="line">                System.out.println(&quot;Exception&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FileOutputStream读写文件中容易出现乱码问题，这跟字符集编码无关，主要是要保证读写的类型一致，当然如果不一致也可以通过OutputStramWriter与InputStreamReader来规定相同的编码  </p>
</blockquote>
<h2 id="关于scanner类"><a href="#关于scanner类" class="headerlink" title="关于scanner类"></a>关于scanner类</h2><p>-</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        scanner scan &#x3D; new Scanner(System.in)&#x2F;&#x2F;控制台输入</span><br><span class="line">        &#x2F;&#x2F;scanner scanf &#x3D; new Scanner(new File(test.text));从文件中读取</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    if(scan.hasNext())&#123;</span><br><span class="line">        String str &#x3D; scan.next();&#x2F;&#x2F;单个字符返回，若是空字符则退出</span><br><span class="line">        &#x2F;&#x2F;String str1 &#x3D; scan.nextLine(); 每次读取一行，包含空字符，这时的判断应为scan.hasNextLine()</span><br><span class="line">        &#x2F;&#x2F;int i &#x3D; scan.nextInt();如果要接收数据，则为next***() 相应的判断语句也更改</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>scanner类在输入时的字符都是可见的，所以带来了一定的安全问题，故可以使用Console类来实现输入密码的目的，即：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Console cns &#x3D; System.console();</span><br><span class="line">String userame &#x3D; cns.readLine(&quot;User name: &quot;);</span><br><span class="line">char[] password &#x3D; cns.readPassword(&quot;Password: &quot;);</span><br></pre></td></tr></table></figure>
<h2 id="关于Java异常处理"><a href="#关于Java异常处理" class="headerlink" title="关于Java异常处理"></a>关于Java异常处理</h2><p>-<br><strong>异常分类</strong></p>
<blockquote>
<p>1、error–错误: 是指程序无法处理的错误，表示应用程序运行时出现的重大错误。例如jvm运行时出现的OutOfMemoryError以及Socket编程时出现的端口占用等程序无法处理的错误。<br>2、Exception-异常 ：异常可分为运行时异常跟编译异常<br>    -<em>运行时异常</em>：即RuntimeException及其之类的异常。这类异常在代码编写的时候不会被编译器所检测出来，是可以不需要被捕获，但是程序员也可以根据需要进行捕获抛出。常见的RUNtimeException有：NullpointException（空指针异常），ClassCastException（类型转换异常），IndexOutOfBoundsException（数组越界异常）等。<br>    -<em>编译异常</em>：RuntimeException以外的异常。这类异常在编译时编译器会提示需要捕获，如果不进行捕获则编译错误。常见编译异常有：IOException（流传输异常），SQLException（数据库操作异常）等。<br>-<br><strong>语句块执行问题</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            &#x2F;&#x2F;函数语句</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            System.out.println(&quot;catch is begin&quot;);</span><br><span class="line">            return 1;&#x2F;&#x2F;不被执行</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            System.out.println(&quot;finally is begin&quot;);&#x2F;&#x2F;被执行</span><br><span class="line">            return 0;&#x2F;&#x2F;被执行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了"><a href="#这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了" class="headerlink" title="这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了"></a>这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了</h2><p><strong>throw和throws的区别</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void Demo() throws Exception&#123;</span><br><span class="line">    throw new Exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>throws经常会被用在方法声明后，方法体之前，表明方法可能跑出一个异常，throw经常被用在方法体内，表示此时抛出一个已定义的异常。</p>
</blockquote>
<h2 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h2><p>-<br><strong>构造器(构造方法或构造函数)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Father&#123;</span><br><span class="line">    father()&#123;</span><br><span class="line">        &#x2F;&#x2F;方法体</span><br><span class="line">    &#125;</span><br><span class="line">    public father(int i)&#123;</span><br><span class="line">        &#x2F;&#x2F;方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Son extends father&#123;</span><br><span class="line">    Son()&#123;</span><br><span class="line">        &#x2F;&#x2F;super() 自动调用父类的无参构造器</span><br><span class="line">        &#x2F;&#x2F;方法体</span><br><span class="line">    &#125;</span><br><span class="line">    public Son(int i)&#123;</span><br><span class="line">        super(3)&#x2F;&#x2F;主动调用父类的有参构造器，就不再默认调用父类的无参构造器</span><br><span class="line">        &#x2F;&#x2F;方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="在Son-继承Father-后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器-主动调用，如果有的话-，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器-但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super-参数-否则系统报错"><a href="#在Son-继承Father-后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器-主动调用，如果有的话-，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器-但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super-参数-否则系统报错" class="headerlink" title="在Son()继承Father()后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器(主动调用，如果有的话)，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器,但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super(参数),否则系统报错"></a>在Son()继承Father()后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器(主动调用，如果有的话)，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器,但是<strong><em>如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super(参数),否则系统报错</em></strong></h2><p><strong>重写(覆盖)中的调用问题</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Father&#123;</span><br><span class="line">    public void demo()&#123;</span><br><span class="line">        System.out.println(&quot;Father&#39;s demo()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Son extends Father&#123;</span><br><span class="line">    public void demo()&#123;</span><br><span class="line">        super.demo();&#x2F;&#x2F;此时输出Father&#39;s demo()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用"><a href="#如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用" class="headerlink" title="如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用"></a>如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用</h2><p><strong>转型问题</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Father f1 &#x3D; new Son();&#x2F;&#x2F;upcasting(向上转型)f1引用指向Son对象</span><br><span class="line">Son s1 &#x3D; (Son)f1;&#x2F;&#x2F;downcasting(向下转型)f1引用仍然指向Son对象</span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line"></span><br><span class="line">Father f2 &#x3D; new Father();</span><br><span class="line">Son s2 &#x3D; (Son)f2;&#x2F;&#x2F;错误，子类引用不能指向父类对象</span><br></pre></td></tr></table></figure>
<blockquote>
<p>向上转型：子类对象直接赋给父类引用，不用强制转换<br>向下转型：把指向子类对象的父类赋给了子类，需要强制转换</p>
</blockquote>
<h2 id="关于Java重写-Override-与重载-Overload"><a href="#关于Java重写-Override-与重载-Overload" class="headerlink" title="关于Java重写(Override)与重载(Overload)"></a>关于Java重写(Override)与重载(Overload)</h2><p>-<br><strong>向上转型带来的问题</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    public void move()&#123;</span><br><span class="line">        &#x2F;&#x2F;Animal方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Cat extends Animal&#123;</span><br><span class="line">    public void move()&#123;</span><br><span class="line">        &#x2F;&#x2F;Cat重写方法体</span><br><span class="line">    &#125;</span><br><span class="line">    public void jump()&#123;</span><br><span class="line">        &#x2F;&#x2F;Cat特有方法体</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Animal a &#x3D; new Animal();</span><br><span class="line">        Animal a1 &#x3D; new Cat();&#x2F;&#x2F;向上转型</span><br><span class="line">        a.move();&#x2F;&#x2F;调用Animal自己的move()</span><br><span class="line">        a1.move();&#x2F;&#x2F;调用Cat重写过的move()</span><br><span class="line">        a1.jump();&#x2F;&#x2F;error 因为a1的引用类型Animal中没有jump()方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码中由于Animal中没有jump()方法导致编译失败，但是可以通过强制转型(UP)来访问引用父类中没有但是子类中有的方法或成员变量  </p>
</blockquote>
<blockquote>
<p>方法重写规则中需要注意的几点：<br>    1. 返回类型可以与被重写方法的返回类型不同，但是得是父类返回值的派生类；<br>    2. 访问权限不能比父类被重写方法的访问权限更低，比如父类方法的访问权限为public，子类重写方法后不能为protected或更低；<br>    4. 重写方法不能抛出更更广泛的强制性异常；  </p>
</blockquote>
<h2 id="关于Java多态"><a href="#关于Java多态" class="headerlink" title="关于Java多态"></a>关于Java多态</h2><p>-<br><strong>静态方法重写问题</strong></p>
<blockquote>
<p>父类的静态方法被子类重写后，调用问题应该看指向子类对象的是父类引用还是子类引用，如果是父类引用指向子类对象则会调用父类的静态方法，如果是子类引用指向子类对象，则会调用子类的静态方法</p>
</blockquote>
<h2 id="关于Java接口"><a href="#关于Java接口" class="headerlink" title="关于Java接口"></a>关于Java接口</h2><p>-<br><strong>接口的一些特性</strong></p>
<blockquote>
<p>-接口的方法都是且只能是public abstract；<br>-接口的成员变量都是且只能是public static final;<br>-Java不支持多继承，但是一个接口可以继承多个接口；<br>-类继承接口必须要实现接口里的全部方法，除非类为抽象类；<br>-如果基本功能在不断改变那么要使用抽象类，因为如果要用接口那么功能改变要更改所有继承这个接口的实体内的方法，<strong><em>这也可以理解abstract表示的是”is-a”的一种关系，interface表示的是”has-a”的一种关系</em></strong>；<br>-JDK1.8以后接口中开始允许出现静态方法和方法体； </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">    interface demo&#123;</span><br><span class="line">        default void test()&#123;</span><br><span class="line">            System.out.println(&quot;这里是interface里的默认实现方法&quot;)；</span><br><span class="line">        &#125;</span><br><span class="line">        static void test1()&#123;</span><br><span class="line">            System.out.println(&quot;这里是interface里的静态方法&quot;)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F;接口中只允许这两种非抽象方法实现</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用"><a href="#如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用" class="headerlink" title="如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用"></a>如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用</h2><p><strong>标记接口</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import java.util;</span><br><span class="line">public interface EventListener&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个接口就是监听接口，类似于MouseListener类就继承了这个接口。<br>标记接口存在的目的：<br>1.向一个类添加数据类型，因为不需要实现该类的方法(因为本身就没有方法)；<br>2.建立一个公共的父接口，正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口，它可以使得使用instanceof进行类型查询。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/29/Java%E5%90%8E%E7%9F%A5%E5%90%8E%E8%A7%89/" data-id="ck9l3jqhl0002xfugctbe4xcs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%80%E4%BA%9BJava%E4%B8%AD%E9%87%8D%E8%A6%81%E8%80%8C%E5%8F%88%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E4%B8%9C%E8%A5%BF/" rel="tag">一些Java中重要而又容易忽略的东西</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/04/29/1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">1</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%80%E4%BA%9BJava%E4%B8%AD%E9%87%8D%E8%A6%81%E8%80%8C%E5%8F%88%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E4%B8%9C%E8%A5%BF/" rel="tag">一些Java中重要而又容易忽略的东西</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E4%B8%80%E4%BA%9BJava%E4%B8%AD%E9%87%8D%E8%A6%81%E8%80%8C%E5%8F%88%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E4%B8%9C%E8%A5%BF/" style="font-size: 10px;">一些Java中重要而又容易忽略的东西</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/29/Java%E5%90%8E%E7%9F%A5%E5%90%8E%E8%A7%89/">Java后知后觉</a>
          </li>
        
          <li>
            <a href="/2020/04/29/1/">1</a>
          </li>
        
          <li>
            <a href="/2020/04/29/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
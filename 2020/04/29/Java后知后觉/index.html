<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/head.gif">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/head.gif">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"easonhe.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="那些Java中你可能不知道的一些事&lt;(▰˘◡˘▰)&gt;">
<meta property="og:type" content="article">
<meta property="og:title" content="【Java】Java后知后觉(初阶)">
<meta property="og:url" content="http://easonhe.top/2020/04/29/Java%E5%90%8E%E7%9F%A5%E5%90%8E%E8%A7%89/index.html">
<meta property="og:site_name" content="小贺のBLOG">
<meta property="og:description" content="那些Java中你可能不知道的一些事&lt;(▰˘◡˘▰)&gt;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/06/20/Rix9mJo7VXUFkDM.jpg">
<meta property="article:published_time" content="2020-04-29T08:30:57.000Z">
<meta property="article:modified_time" content="2020-07-01T12:20:39.235Z">
<meta property="article:author" content="Eason He">
<meta property="article:tag" content="学习区">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/06/20/Rix9mJo7VXUFkDM.jpg">

<link rel="canonical" href="http://easonhe.top/2020/04/29/Java%E5%90%8E%E7%9F%A5%E5%90%8E%E8%A7%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【Java】Java后知后觉(初阶) | 小贺のBLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">小贺のBLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">2</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">17</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    

  <a href="https://github.com/Eason459" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://easonhe.top/2020/04/29/Java%E5%90%8E%E7%9F%A5%E5%90%8E%E8%A7%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.JPG">
      <meta itemprop="name" content="Eason He">
      <meta itemprop="description" content="你当像鸟飞往你的山">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小贺のBLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【Java】Java后知后觉(初阶)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-29 16:30:57" itemprop="dateCreated datePublished" datetime="2020-04-29T16:30:57+08:00">2020-04-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E5%8C%BA/" itemprop="url" rel="index"><span itemprop="name">学习区</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>那些Java中你可能不知道的一些事&lt;(▰˘◡˘▰)&gt;</strong></p>
 <a id="more"></a>
<p><img src="https://i.loli.net/2020/06/20/Rix9mJo7VXUFkDM.jpg" alt="IMG_6579.jpg"></p>
<ol>
<li><h2 id="关于命令"><a href="#关于命令" class="headerlink" title="关于命令"></a>关于命令</h2></li>
</ol>
<ul>
<li><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">javac </span>HelloWorld.<span class="keyword">java </span> </span><br><span class="line">$ <span class="keyword">java </span>HelloWorld  </span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>相信这是大家刚刚接触Java时接触到的第一个程序</strong><br><strong>在这个命令行终端中我们用到了两个命令javac和java</strong></p>
<ul>
<li>javac后跟着的是一个典型的java文件，javac此时所做的事就是<em>将java源文件编译成字节码文件</em>此时如果编译成功的话是会生成一个名为HelloWorld.class的文件，此时就是成功编译为字节码文件；</li>
<li>java后跟的是Java文件中的类名，比如这里的HelloWorld但是不要加.class后缀。</li>
</ul>
<ol start="2">
<li><h2 id="关于修饰符"><a href="#关于修饰符" class="headerlink" title="关于修饰符"></a>关于修饰符</h2></li>
</ol>
<p>-</p>
<h3 id="synchronized修饰符"><a href="#synchronized修饰符" class="headerlink" title="synchronized修饰符"></a>synchronized修饰符</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">easonHe</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<strong>synchronized</strong>修饰符是在多线程的程序编码中常会用到的修饰符，<em>synchronized</em>修饰符旨在<em>确保方法在同一时间只能被一个线程访问</em>。同时<strong>synchronized</strong>可以用于四个访问修饰符。  </p>
<p>-</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> active;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        active = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(active)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        active = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>volatile</em>修饰词也是常用于多线程中，每当线程准备访问<em>volatile</em>所修饰的成员变量时，必须要从共享内存中重新读取该成员变量的值，另外，如果遇到该成员变量的值发生改变时，线程也必须将该成员变量的值写入到共享内存中更新，这样以来，多线程中每个线程所看到的都是成员变量的同一个值。  </p>
</blockquote>
<blockquote>
<p>这个成程序中，若是一个线程调用run()方法，此时另一线程调用stop()方法时，如果线程已经进入while的缓冲区，那么即使stop()方法中的active=false线程也不会停止，但是由于这个线程中的active是被<em>volatile</em>修饰符所修饰，所以这个循环会停止。</p>
</blockquote>
<p>-</p>
<h3 id="transient修饰符"><a href="#transient修饰符" class="headerlink" title="transient修饰符"></a>transient修饰符</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> transient <span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> b;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>transient</em>修饰符用来定义变量时，其作用是用来预处理类与变量的数据类型，也就是说，如果序列化的对象包含别<em>transient</em>修饰的实例变量，那么JVM将会跳过此特定的变量。</p>
</blockquote>
<h2 id="关于运算符"><a href="#关于运算符" class="headerlink" title="关于运算符"></a>关于运算符</h2><p>-</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">0101</span> <span class="number">1100</span></span><br><span class="line">B = <span class="number">0010</span> <span class="number">0101</span>  </span><br><span class="line">---------------</span><br><span class="line">A&amp;B = <span class="number">0000</span> <span class="number">0100</span></span><br><span class="line">A|B = <span class="number">0111</span> <span class="number">1101</span></span><br><span class="line">A^B = <span class="number">0111</span> <span class="number">1001</span></span><br><span class="line">~A = <span class="number">1010</span> <span class="number">0011</span></span><br><span class="line">B&lt;&lt;<span class="number">2</span> = <span class="number">1001</span> <span class="number">0100</span></span><br><span class="line">B&gt;&gt;<span class="number">2</span> = <span class="number">1001</span></span><br><span class="line">B&gt;&gt;&gt;<span class="number">2</span> = <span class="number">0000</span> <span class="number">1001</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><em>^如果对应位值相等则为0不等则为1</em>；</li>
<li><em>～按位取反运算符</em>；</li>
<li>*&lt;&lt;按位左移运算符，左操作数按位左移右操作数指定的位数*;  </li>
<li><em>&gt;&gt;按位右移运算符，左操作数按位右移右操作数指定的位数</em>；</li>
<li><em>&gt;&gt;&gt;按位右移补零运算符，在按位右移的情况下将最高位的空位用零填充</em></li>
</ol>
</blockquote>
<p>但是其实我们真正用到它的时候并非如此使用，而是下面这种情况：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(<span class="keyword">String</span>[], args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">13</span>; <span class="comment">//即 a=0000 1101</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">28</span>; <span class="comment">//即 b=0001 1100</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        c = a &amp; b;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"a &amp; b = "</span>+c) <span class="comment">//此时c的值为12 即0000 1100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说我们平时使用的往往并非二进制编码，而是对应的十进制编码，但有时我们也会为了满足某种需求而使用到十进制编码进行位操作符的运算。  </p>
<p>-</p>
<h3 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[], args)&#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">6</span>;</span><br><span class="line">        <span class="built_in">bool</span>ean result = (a&lt;<span class="number">2</span>&amp;&amp;++a&lt;<span class="number">8</span>) <span class="comment">//a=6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码中，result结果为false，因为a&lt;2已经是false了所以结果必定是false，所以说第二个操作判断就不被执行了，也就是++a不被执行，所以此时a仍然为6.</p>
</blockquote>
<p>-</p>
<h3 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"watermelon"</span>;</span><br><span class="line"><span class="built_in">boolean</span> isReal = <span class="built_in">str</span> <span class="keyword">instanceof</span> <span class="keyword">String</span>;</span><br><span class="line"><span class="comment">// is Real = true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>instanceof运算符用于操作一个对象的实例，若为此特定类类型或接口类型则为真，否则为假，即如果运算符左侧所指的对象是右侧类或者接口的一个对象则结果为真。  </p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cola</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Pepsi</span> <span class="keyword">extends</span> <span class="title">Cola</span></span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[], args)&#123;</span><br><span class="line">        <span class="type">Cola</span> cola = <span class="keyword">new</span> <span class="type">Pepsi</span>();</span><br><span class="line">        boolean result = cola instanceof <span class="type">Pepsi</span>;</span><br><span class="line">        <span class="comment">//此时result=true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用instanceof操作符如果被比较的对象兼容于右侧的类型，则同样成立。这里应该注意<strong><em>判断一个实例引用的类型时，使用的是实际类型，而不是声明的类型，如上代码中cola是Pepsi类型而不是Cola类型，并且，子类的实例可以声明为父类，但是父类的实例不可以声明为子类</em></strong>。</p>
</blockquote>
<h2 id="关于循环"><a href="#关于循环" class="headerlink" title="关于循环"></a>关于循环</h2><p>-</p>
<h3 id="加强型for循环-For-Each"><a href="#加强型for循环-For-Each" class="headerlink" title="加强型for循环(For-Each)"></a>加强型for循环(For-Each)</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[], args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] num = &#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : num)&#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(i+<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//此时将会打印出2 6 9 30</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">String</span> [] drinks = &#123;<span class="string">"cola"</span>, <span class="string">"coffee"</span>, <span class="string">"tea"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> name : drinks)&#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(name+<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//此时将会打印出cola coffee tea </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种情况是Java引入的为了用于数组形式的增强版for循环。</p>
</blockquote>
<p><strong>ps:在循环或者条件以及选择语句中需要注意的几点：</strong>  </p>
<ol>
<li>在循环操作语句中，如果遇到break语句被执行，那么将会直接跳出最内层的一个循环体，如果遇到continue语句被执行，那么接下来的语句将不会被执行，而是直接进入新一轮的循环，这种用法往往用来选择性退出或者是去刻意忽略某次循环体内的语句；</li>
<li>在选择操作语句中，如switch语句，如果case没有与变量类型相匹配的，那么将会执行default语句（如果有的话），如果匹配的case语句没有break，那么将会顺序输出以下的语句，直到遇到break或全部输出。  </li>
</ol>
<h2 id="关于Java类"><a href="#关于Java类" class="headerlink" title="关于Java类"></a>关于Java类</h2><p>-</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>由于java属于面向对象的编程语言，所以我们难免会遇到使用数据时需要使用对象而不是内置数据类型的情形，针对于此，java提供了包装类：Double,Float, Long, Integer, Short, Byte.</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">IntergerTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[], args)&#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">128</span>;</span><br><span class="line">        Interger b = <span class="number">128</span>;</span><br><span class="line">        Interger c = new Interger(<span class="number">128</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(a==b); <span class="comment">//true 因为与内置数据类型比较，所以Interger会自动拆箱比较  </span></span><br><span class="line">        <span class="comment">// a==c 与 a==b情况相同</span></span><br><span class="line">        Interger b1 = <span class="number">127</span>;</span><br><span class="line">        Interger c1 = <span class="number">127</span>; <span class="comment">//此时经编译时为Interger b2 = Interger.valueOf(127)  </span></span><br><span class="line">        System.<span class="keyword">out</span>.println(b1==c1); <span class="comment">//true</span></span><br><span class="line">        Interger b2 = <span class="number">128</span>;</span><br><span class="line">        Interger c2 = <span class="number">128</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(b2==c2); <span class="comment">//false 因为Interger中的valueOf函数只会对int类型的取值范围内（-128～127）之间的数进行缓存。  </span></span><br><span class="line">        Interger b3 = new Interger(<span class="number">127</span>);</span><br><span class="line">        Interger c3 = <span class="number">127</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(b3==c3); <span class="comment">//false 无论如何Interger与new得到的Interger不会相等，</span></span><br><span class="line">        <span class="comment">//因为new得到的对象放在堆存储区里，非new得到的常量则放在常量池即方法区里，故不会经历拆箱，两地址也不同，故不会相等</span></span><br><span class="line">        Interger b4 = new Interger(<span class="number">127</span>);</span><br><span class="line">        Interger c4 = new Interger(<span class="number">127</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(b4==c4); <span class="comment">//false 因为都是通过new得到的对象，所以地址不相同</span></span><br><span class="line">        Interger b5 = <span class="number">127</span>;</span><br><span class="line">        Interger c5 = <span class="number">127</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(b5.equals(c5)); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译器特别支持的包装成为装箱，所以在内置类型要作为对象使用时，编译器就会将其装箱成为一个包装类，若是一个对象要作为内置数据类型使用时，编译器也会将其拆箱；  </p>
</blockquote>
<blockquote>
<h2 id="要注意在进行比较时-比较的是地址，equals-比较的是对象的内容，所以在Interger-valueOf-时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。"><a href="#要注意在进行比较时-比较的是地址，equals-比较的是对象的内容，所以在Interger-valueOf-时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。" class="headerlink" title="要注意在进行比较时 =比较的是地址，equals()比较的是对象的内容，所以在Interger.valueOf()时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。  "></a>要注意在进行比较时 =比较的是地址，equals()比较的是对象的内容，所以在Interger.valueOf()时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。  </h2></blockquote>
<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] <span class="built_in">array</span> = &#123;<span class="string">"E"</span>, <span class="string">"a"</span>, <span class="string">"s"</span>, <span class="string">"o"</span>, <span class="string">"n"</span>&#125;;</span><br><span class="line">        <span class="keyword">String</span> str = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="built_in">array</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(str);</span><br><span class="line">        <span class="comment">//输出结果为Eason</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Java中，String字符串属于对象，String类有11中构造方法，这些方法提供不同的参数来初始化字符串，比如这段代码中提供一个字符数组来初始化一个字符串；  </p>
</blockquote>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Demo&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main()&#123;</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"Eason"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">        <span class="comment">//输出Eason</span></span><br><span class="line">        <span class="built_in">str</span> = <span class="string">"He"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">        <span class="comment">//输出He</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>特别需要注意的是一旦String对象被创建那么它就无法被更改了，也就是说String是被final修饰的，但是这段代码中str在结果上看是改变了，但其实它并没有被更改，因为实例str只是一个String的对象引用，当执行str=”He”的时候它创建了一个新的String对象”He”,原来的”Eason”对象仍然存储在内存中；  </p>
</blockquote>
<blockquote>
<p>也就是说，如果需要对字符串做很多修改，那么应该选择使用<em>StringBuffer和StringBuilder</em>类。<br>    1.StringBuffer:字符串变量，Synchronized线程安全，如果想专成String类型，则可以使用toString()方法，Java.lang.StringBuffer可以通过某些特定的方法调用可以改变该序列的长度和内容，可以将字符串缓冲区安全的应用于多个线程；<br>    2.StringBuilder:字符串变量，非线程安全，在内部StringBuilder对象被当作是一个包含自负序列的变长数组；<br>    <strong><em>总结</em></strong>：<strong>-</strong> 如果操作少量的数据用String <strong>-</strong> 单线程操作大量数据用StringBuilder <strong>-</strong> 多线程操作大量数据用StringBuffer。<br>    ps：其实StringBuffer的线程安全也是很低能的也就是说它也只能保证jvm不抛出异常而向下运行而已，所以针对于StringBuilder的高效，所以<strong><em>在绝大部分情况下直接使用StringBuilder</em></strong>。</p>
</blockquote>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String <span class="built_in">s1</span> = <span class="string">"a"</span>+<span class="string">"b"</span>+<span class="string">"c"</span>;</span><br><span class="line">String <span class="built_in">s2</span> = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(<span class="built_in">s1</span>==<span class="built_in">s2</span>)<span class="comment">;//true</span></span><br><span class="line">System.out.println(<span class="built_in">s1</span>.equals(<span class="built_in">s2</span>))<span class="comment">;//true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是道面试经常会被问到的问题，在Java常量优化机制中，编译时s1已经成为”abc”在常量池中查找创建，故此时s2就不用再创建了；  </p>
</blockquote>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="built_in">s1</span> = <span class="string">"a"</span>+<span class="string">"b"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="built_in">s2</span> = <span class="string">"abc"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="built_in">s3</span> = <span class="built_in">s1</span>+<span class="string">"c"</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">System.out.println</span>(<span class="built_in">s3</span>=<span class="symbol">=s2</span>)<span class="comment">;//false</span></span><br><span class="line"><span class="symbol">System.out.println</span>(<span class="built_in">s3</span>.equals(<span class="built_in">s2</span>))<span class="comment">;//true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这也是道面试经常会被问到的问题，在编译时，”ab”在常量池中被创建其地址为a1,”abc”接着被创建其地址为a2,对于s3，先创建一个StringBuilder或StringBuffer对象，通过append方法连接得到abc，再调用toString()转换为String得到的地址为a3，故==为false，equals比较对象的值为true。</p>
</blockquote>
<p><strong>另外</strong>：length(), length属性，size()之间的一些区别</p>
<ol>
<li>length()方法是针对字符串来说的，要求一个字符串的长度时就要用到这个方法；</li>
<li>length属性是针对Java中的数组来说的，要求数组的长度可以用length属性；</li>
<li>size()方法是针对泛型集合List来说的，如果想看一个泛型集合中有多少个元素就使用此方法；</li>
</ol>
<h2 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h2><p>-</p>
<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[], args)&#123;</span><br><span class="line">        <span class="built_in">int</span> [] num = new <span class="built_in">int</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="built_in">int</span> [] num1 = &#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Arrays.fill(num, <span class="number">6</span>);<span class="comment">//此时num数组内的元素为66666666</span></span><br><span class="line">        Arrays.fill(num, <span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>);<span class="comment">//将num数组中第1，2个元素赋值为8</span></span><br><span class="line">        Arrays.sort(num1);<span class="comment">//对num1数组进行排序</span></span><br><span class="line">        Arrays.equals(num, num1);<span class="comment">//比较两数组元素是否相等</span></span><br><span class="line">        Arrays.binarySearch(num1, <span class="number">2</span>);<span class="comment">//查找元素3在数组中的位置，如果不存在就返回负数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java.util.Arrays类能够很方便的处理数组，它提供的所有方法都是静态的，它的部分功能：<br>    1. 通过fill()方法给数组赋值；<br>    2. 通过sort()方法按升序排序；<br>    3. 通过equals()方法判断数组中的元素是否相等；<br>    4. 通过binarySearch()方法能对排好序的数组进行二分法查找等等。</p>
</blockquote>
<h2 id="关于正则表达式"><a href="#关于正则表达式" class="headerlink" title="关于正则表达式"></a>关于正则表达式</h2><p>-</p>
<h3 id="Pattern与Matcher类"><a href="#Pattern与Matcher类" class="headerlink" title="Pattern与Matcher类"></a>Pattern与Matcher类</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[], args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">String</span> str = <span class="string">"My number is 56? Yes!"</span>;</span><br><span class="line">        <span class="keyword">String</span> regex = <span class="string">"(\\d+)(\\D*)(.*)"</span>;</span><br><span class="line">        Pattern p = Pattern.compile(regex);<span class="comment">//创建Pattern对象</span></span><br><span class="line">        Matcher m = p.matcher(str);<span class="comment">//创建Matcher(适配器)对象</span></span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">find</span>())&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(m.group(<span class="number">0</span>));<span class="comment">//输出：My number is 56? Yes!</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(m.group(<span class="number">1</span>));<span class="comment">//输出：56</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(m.group(<span class="number">2</span>));<span class="comment">//输出：My number is Yes</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(m.group(<span class="number">3</span>));<span class="comment">//输出：? Yes!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本段代码中group()方法为捕获组，比如正则表达式中((A)(B(C)))这其中就有四个组((A)(B(C)))、(A)、(B(C))、(C),技巧是左边数第几个括号所对应的内容就是相应的第几组；  </p>
</blockquote>
<blockquote>
<p>Pattern与Matcher类都没有公共的构造方法，都是通过调用静态函数所得到的返回类型来创建类；</p>
</blockquote>
<blockquote>
<p>在其他语言的正则表达式中往往一个反斜杠\就具有转义作用，但是Java的正则表达式中两个反斜杠才能表示转义作用，比如\\d表示一位数字。</p>
</blockquote>
<blockquote>
<p>在Matcher类中有两个重要的方法就是start()和end()方法，start()方法返回由给定组所捕获的初始索引，end()方法是返回最后一个匹配字符的索引+1</p>
</blockquote>
<h2 id="关于Java方法"><a href="#关于Java方法" class="headerlink" title="关于Java方法"></a>关于Java方法</h2><p>-</p>
<h3 id="出现在方法名称"><a href="#出现在方法名称" class="headerlink" title="_出现在方法名称"></a>_出现在方法名称</h3><blockquote>
<h2 id="在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test-例如：textPop-emptyStack"><a href="#在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test-例如：textPop-emptyStack" class="headerlink" title="在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test 例如：textPop_emptyStack."></a>在方法的命名中，下划线<em>可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test<MethodUnderTest></em><state> 例如：textPop_emptyStack.</h2></blockquote>
<h3 id="命令行参数的使用"><a href="#命令行参数的使用" class="headerlink" title="命令行参数的使用"></a>命令行参数的使用</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"args["</span>+i+<span class="string">"] = "</span>+args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行此程序：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ javac Demo.java</span><br><span class="line">$ java Demo This <span class="keyword">is</span> <span class="keyword">a</span> <span class="keyword">command</span> <span class="built_in">line</span></span><br><span class="line"><span class="keyword">args</span>[<span class="number">0</span>] = This</span><br><span class="line"><span class="keyword">args</span>[<span class="number">1</span>] = <span class="keyword">is</span></span><br><span class="line"><span class="keyword">args</span>[<span class="number">2</span>] = <span class="keyword">a</span></span><br><span class="line"><span class="keyword">args</span>[<span class="number">3</span>] = <span class="keyword">command</span></span><br><span class="line"><span class="keyword">args</span>[<span class="number">4</span>] = <span class="built_in">line</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息"><a href="#这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息" class="headerlink" title="这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息  "></a>这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息  </h2></blockquote>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main()&#123;</span><br><span class="line">        printMin(&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0.6</span>,&#125;);<span class="comment">//输出：The min value is : 0.6</span></span><br><span class="line">        printMin(new <span class="built_in">double</span>[]&#123;<span class="number">3.2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6.7</span>&#125;)<span class="comment">//输出：The min value is : 3.2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> printMin(doulbe... num)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.length==<span class="number">0</span>)&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"No agument passed"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">double</span> result = num[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]&lt;result)&#123;</span><br><span class="line">                result=num[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"The min value is : "</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个函数中最多只能有一个可变参数，并且要放在参数列表的最后，代码在执行时，编译器会将可变参数编译为一个数组，所以在函数的内部，参数名可以看作是数组名； </p>
</blockquote>
<blockquote>
<h2 id="由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法"><a href="#由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法" class="headerlink" title="由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法"></a>由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法</h2></blockquote>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizationDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Cola cola1 = <span class="keyword">new</span> Cola(<span class="number">1</span>);</span><br><span class="line">        Cola cola2 = <span class="keyword">new</span> Cola(<span class="number">2</span>);</span><br><span class="line">        Cola cola3 = <span class="keyword">new</span> Cola(<span class="number">3</span>);</span><br><span class="line">        cola2 = cola3 = <span class="keyword">null</span>;<span class="comment">//将两对象作废，接下来会被回收</span></span><br><span class="line">        System.gc();<span class="comment">//调用Java垃圾收容器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cola</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cola</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i=i;</span><br><span class="line">        System.out.println(<span class="string">"Cola object "</span>+i+<span class="string">" is created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cola object "</span>+i+<span class="string">" is disposed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//Cola object 1 is created</span></span><br><span class="line"><span class="comment">//Cola object 2 is created</span></span><br><span class="line"><span class="comment">//Cola object 3 is created</span></span><br><span class="line"><span class="comment">//Cola object 2 is disposed</span></span><br><span class="line"><span class="comment">//Cola object 3 is disposed</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>finalize()方法在对象被回收之前调用，它用来清除回收对象，可以用这个方法来确保一个对象打开的文件被关闭，并且该方法需要protected限定其余类不可调用此方法，当然JVM自动完成内存的回收，也可以通过这个方法来手动操作  </p>
</blockquote>
<h2 id="关于文件的Stream-流-与File-文件"><a href="#关于文件的Stream-流-与File-文件" class="headerlink" title="关于文件的Stream(流)与File(文件)"></a>关于文件的Stream(流)与File(文件)</h2><p>-</p>
<h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bWrite = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;<span class="comment">//写入的数据为byte类型</span></span><br><span class="line">            Outputstream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bWrite.length;i++)&#123;</span><br><span class="line">                os.<span class="built_in">write</span>(bWtite[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            os.<span class="built_in">close</span>();</span><br><span class="line">        </span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = is.<span class="built_in">available</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)&#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>((<span class="keyword">byte</span>)is.<span class="built_in">read</span>());<span class="comment">//最终要的要将读取数据强制转换成同类型才能避免乱码</span></span><br><span class="line">            &#125;</span><br><span class="line">            is.<span class="built_in">close</span>();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">"Exception"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FileOutputStream读写文件中容易出现乱码问题，这跟字符集编码无关，主要是要保证读写的类型一致，当然如果不一致也可以通过OutputStramWriter与InputStreamReader来规定相同的编码  </p>
</blockquote>
<h2 id="关于scanner类"><a href="#关于scanner类" class="headerlink" title="关于scanner类"></a>关于scanner类</h2><p>-</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        scanner scan = <span class="keyword">new</span> Scanner(System.in)<span class="comment">//控制台输入</span></span><br><span class="line">        <span class="comment">//scanner scanf = new Scanner(new File(test.text));从文件中读取</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(scan.hasNext())&#123;</span><br><span class="line">        <span class="keyword">String</span> str = scan.next();<span class="comment">//单个字符返回，若是空字符则退出</span></span><br><span class="line">        <span class="comment">//String str1 = scan.nextLine(); 每次读取一行，包含空字符，这时的判断应为scan.hasNextLine()</span></span><br><span class="line">        <span class="comment">//int i = scan.nextInt();如果要接收数据，则为next***() 相应的判断语句也更改</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>scanner类在输入时的字符都是可见的，所以带来了一定的安全问题，故可以使用Console类来实现输入密码的目的，即：</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Console cns = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>console<span class="literal">()</span>;</span><br><span class="line">String userame = cns.read<span class="constructor">Line(<span class="string">"User name: "</span>)</span>;</span><br><span class="line"><span class="built_in">char</span><span class="literal">[]</span> password = cns.read<span class="constructor">Password(<span class="string">"Password: "</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="关于Java异常处理"><a href="#关于Java异常处理" class="headerlink" title="关于Java异常处理"></a>关于Java异常处理</h2><p>-</p>
<h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><blockquote>
<p>1、error–错误: 是指程序无法处理的错误，表示应用程序运行时出现的重大错误。例如jvm运行时出现的OutOfMemoryError以及Socket编程时出现的端口占用等程序无法处理的错误。<br>2、Exception-异常 ：异常可分为运行时异常跟编译异常<br>    -<em>运行时异常</em>：即RuntimeException及其之类的异常。这类异常在代码编写的时候不会被编译器所检测出来，是可以不需要被捕获，但是程序员也可以根据需要进行捕获抛出。常见的RUNtimeException有：NullpointException（空指针异常），ClassCastException（类型转换异常），IndexOutOfBoundsException（数组越界异常）等。<br>    -<em>编译异常</em>：RuntimeException以外的异常。这类异常在编译时编译器会提示需要捕获，如果不进行捕获则编译错误。常见编译异常有：IOException（流传输异常），SQLException（数据库操作异常）等。<br>-</p>
</blockquote>
<h3 id="语句块执行问题"><a href="#语句块执行问题" class="headerlink" title="语句块执行问题"></a>语句块执行问题</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//函数语句</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"catch is begin"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//不被执行</span></span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"finally is begin"</span>);<span class="comment">//被执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//被执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了"><a href="#这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了" class="headerlink" title="这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了"></a>这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了</h2></blockquote>
<h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">Demo</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>throws经常会被用在方法声明后，方法体之前，表明方法可能跑出一个异常，throw经常被用在方法体内，表示此时抛出一个已定义的异常。</p>
</blockquote>
<h2 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h2><p>-</p>
<h3 id="构造器-构造方法或构造函数"><a href="#构造器-构造方法或构造函数" class="headerlink" title="构造器(构造方法或构造函数)"></a>构造器(构造方法或构造函数)</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    father()&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    public father(int i)&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="type">Son</span>()&#123;</span><br><span class="line">        <span class="comment">//super() 自动调用父类的无参构造器</span></span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="type">Son</span>(int i)&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">3</span>)<span class="comment">//主动调用父类的有参构造器，就不再默认调用父类的无参构造器</span></span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="在Son-继承Father-后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器-主动调用，如果有的话-，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器-但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super-参数-否则系统报错"><a href="#在Son-继承Father-后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器-主动调用，如果有的话-，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器-但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super-参数-否则系统报错" class="headerlink" title="在Son()继承Father()后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器(主动调用，如果有的话)，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器,但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super(参数),否则系统报错"></a>在Son()继承Father()后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器(主动调用，如果有的话)，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器,但是<strong><em>如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super(参数),否则系统报错</em></strong></h2></blockquote>
<h3 id="重写-覆盖-中的调用问题"><a href="#重写-覆盖-中的调用问题" class="headerlink" title="重写(覆盖)中的调用问题"></a>重写(覆盖)中的调用问题</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    public void demo()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Father's demo()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    public void demo()&#123;</span><br><span class="line">        <span class="keyword">super</span>.demo();<span class="comment">//此时输出Father's demo()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用"><a href="#如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用" class="headerlink" title="如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用"></a>如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用</h2></blockquote>
<h3 id="转型问题"><a href="#转型问题" class="headerlink" title="转型问题"></a>转型问题</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Father f1 = <span class="keyword">new</span> <span class="type">Son</span>();<span class="comment">//upcasting(向上转型)f1引用指向Son对象</span></span><br><span class="line">Son s1 = (Son)f1;<span class="comment">//downcasting(向下转型)f1引用仍然指向Son对象</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line"></span><br><span class="line">Father f2 = <span class="keyword">new</span> <span class="type">Father</span>();</span><br><span class="line">Son s2 = (Son)f2;<span class="comment">//错误，子类引用不能指向父类对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>向上转型：子类对象直接赋给父类引用，不用强制转换<br>向下转型：把指向子类对象的父类赋给了子类，需要强制转换</p>
</blockquote>
<h2 id="关于Java重写-Override-与重载-Overload"><a href="#关于Java重写-Override-与重载-Overload" class="headerlink" title="关于Java重写(Override)与重载(Overload)"></a>关于Java重写(Override)与重载(Overload)</h2><p>-</p>
<h3 id="向上转型带来的问题"><a href="#向上转型带来的问题" class="headerlink" title="向上转型带来的问题"></a>向上转型带来的问题</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Animal方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="title">extends</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Cat重写方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Cat特有方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal a1 = <span class="keyword">new</span> Cat();<span class="comment">//向上转型</span></span><br><span class="line">        a.<span class="built_in">move</span>();<span class="comment">//调用Animal自己的move()</span></span><br><span class="line">        a1.<span class="built_in">move</span>();<span class="comment">//调用Cat重写过的move()</span></span><br><span class="line">        a1.jump();<span class="comment">//error 因为a1的引用类型Animal中没有jump()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码中由于Animal中没有jump()方法导致编译失败，但是可以通过强制转型(UP)来访问引用父类中没有但是子类中有的方法或成员变量  </p>
</blockquote>
<blockquote>
<p>方法重写规则中需要注意的几点：<br>    1. 返回类型可以与被重写方法的返回类型不同，但是得是父类返回值的派生类；<br>    2. 访问权限不能比父类被重写方法的访问权限更低，比如父类方法的访问权限为public，子类重写方法后不能为protected或更低；<br>    4. 重写方法不能抛出更更广泛的强制性异常；  </p>
</blockquote>
<h2 id="关于Java多态"><a href="#关于Java多态" class="headerlink" title="关于Java多态"></a>关于Java多态</h2><p>-</p>
<h3 id="静态方法重写问题"><a href="#静态方法重写问题" class="headerlink" title="静态方法重写问题"></a>静态方法重写问题</h3><blockquote>
<p>父类的静态方法被子类重写后，调用问题应该看指向子类对象的是父类引用还是子类引用，如果是父类引用指向子类对象则会调用父类的静态方法，如果是子类引用指向子类对象，则会调用子类的静态方法</p>
</blockquote>
<h2 id="关于Java接口"><a href="#关于Java接口" class="headerlink" title="关于Java接口"></a>关于Java接口</h2><p>-</p>
<h3 id="接口的一些特性"><a href="#接口的一些特性" class="headerlink" title="接口的一些特性"></a>接口的一些特性</h3><blockquote>
<p>-接口的方法都是且只能是public abstract；<br>-接口的成员变量都是且只能是public static final;<br>-Java不支持多继承，但是一个接口可以继承多个接口；<br>-类继承接口必须要实现接口里的全部方法，除非类为抽象类；<br>-如果基本功能在不断改变那么要使用抽象类，因为如果要用接口那么功能改变要更改所有继承这个接口的实体内的方法，<strong><em>这也可以理解abstract表示的是”is-a”的一种关系，interface表示的是”has-a”的一种关系</em></strong>；<br>-JDK1.8以后接口中开始允许出现静态方法和方法体； </p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title">demo</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"这里是interface里的默认实现方法"</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"这里是interface里的静态方法"</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//接口中只允许这两种非抽象方法实现</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用"><a href="#如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用" class="headerlink" title="如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用"></a>如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用</h2></blockquote>
<h3 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import java.util;</span><br><span class="line">public<span class="built_in"> interface </span>EventListener&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个接口就是监听接口，类似于MouseListener类就继承了这个接口。<br>标记接口存在的目的：<br>1.向一个类添加数据类型，因为不需要实现该类的方法(因为本身就没有方法)；<br>2.建立一个公共的父接口，正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口，它可以使得使用instanceof进行类型查询。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>
</blockquote>

    </div>

    
    
    
        <div class="reward-container">
  <div>如果觉得还不错的话，把它分享给朋友们吧(ง •̀_•́)ง</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Eason He
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://easonhe.top/2020/04/29/Java%E5%90%8E%E7%9F%A5%E5%90%8E%E8%A7%89/" title="【Java】Java后知后觉(初阶)">http://easonhe.top/2020/04/29/Java后知后觉/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E5%8C%BA/" rel="tag"><i class="fa fa-tag"></i> 学习区</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/05/27/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="next" title="【设计模式】Java设计模式(记忆点)">
      【设计模式】Java设计模式(记忆点) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于命令"><span class="nav-number">1.</span> <span class="nav-text">关于命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于修饰符"><span class="nav-number">2.</span> <span class="nav-text">关于修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized修饰符"><span class="nav-number">2.1.</span> <span class="nav-text">synchronized修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transient修饰符"><span class="nav-number">2.2.</span> <span class="nav-text">transient修饰符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于运算符"><span class="nav-number">3.</span> <span class="nav-text">关于运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#位运算符"><span class="nav-number">3.1.</span> <span class="nav-text">位运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#短路逻辑运算符"><span class="nav-number">3.2.</span> <span class="nav-text">短路逻辑运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof运算符"><span class="nav-number">3.3.</span> <span class="nav-text">instanceof运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于循环"><span class="nav-number">4.</span> <span class="nav-text">关于循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加强型for循环-For-Each"><span class="nav-number">4.1.</span> <span class="nav-text">加强型for循环(For-Each)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于Java类"><span class="nav-number">5.</span> <span class="nav-text">关于Java类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#包装类"><span class="nav-number">5.1.</span> <span class="nav-text">包装类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#要注意在进行比较时-比较的是地址，equals-比较的是对象的内容，所以在Interger-valueOf-时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。"><span class="nav-number">6.</span> <span class="nav-text">要注意在进行比较时 &#x3D;比较的是地址，equals()比较的是对象的内容，所以在Interger.valueOf()时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。  </span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String类"><span class="nav-number">6.1.</span> <span class="nav-text">String类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于数组"><span class="nav-number">7.</span> <span class="nav-text">关于数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays类"><span class="nav-number">7.1.</span> <span class="nav-text">Arrays类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于正则表达式"><span class="nav-number">8.</span> <span class="nav-text">关于正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Pattern与Matcher类"><span class="nav-number">8.1.</span> <span class="nav-text">Pattern与Matcher类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于Java方法"><span class="nav-number">9.</span> <span class="nav-text">关于Java方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#出现在方法名称"><span class="nav-number">9.1.</span> <span class="nav-text">_出现在方法名称</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test-例如：textPop-emptyStack"><span class="nav-number">10.</span> <span class="nav-text">在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test 例如：textPop_emptyStack.</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#命令行参数的使用"><span class="nav-number">10.1.</span> <span class="nav-text">命令行参数的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息"><span class="nav-number">11.</span> <span class="nav-text">这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息  </span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可变参数"><span class="nav-number">11.1.</span> <span class="nav-text">可变参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法"><span class="nav-number">12.</span> <span class="nav-text">由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#finalize-方法"><span class="nav-number">12.1.</span> <span class="nav-text">finalize()方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于文件的Stream-流-与File-文件"><span class="nav-number">13.</span> <span class="nav-text">关于文件的Stream(流)与File(文件)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#乱码问题"><span class="nav-number">13.1.</span> <span class="nav-text">乱码问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于scanner类"><span class="nav-number">14.</span> <span class="nav-text">关于scanner类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于Java异常处理"><span class="nav-number">15.</span> <span class="nav-text">关于Java异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#异常分类"><span class="nav-number">15.1.</span> <span class="nav-text">异常分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语句块执行问题"><span class="nav-number">15.2.</span> <span class="nav-text">语句块执行问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了"><span class="nav-number">16.</span> <span class="nav-text">这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#throw和throws的区别"><span class="nav-number">16.1.</span> <span class="nav-text">throw和throws的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于继承"><span class="nav-number">17.</span> <span class="nav-text">关于继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造器-构造方法或构造函数"><span class="nav-number">17.1.</span> <span class="nav-text">构造器(构造方法或构造函数)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在Son-继承Father-后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器-主动调用，如果有的话-，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器-但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super-参数-否则系统报错"><span class="nav-number">18.</span> <span class="nav-text">在Son()继承Father()后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器(主动调用，如果有的话)，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器,但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super(参数),否则系统报错</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重写-覆盖-中的调用问题"><span class="nav-number">18.1.</span> <span class="nav-text">重写(覆盖)中的调用问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用"><span class="nav-number">19.</span> <span class="nav-text">如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#转型问题"><span class="nav-number">19.1.</span> <span class="nav-text">转型问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于Java重写-Override-与重载-Overload"><span class="nav-number">20.</span> <span class="nav-text">关于Java重写(Override)与重载(Overload)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#向上转型带来的问题"><span class="nav-number">20.1.</span> <span class="nav-text">向上转型带来的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于Java多态"><span class="nav-number">21.</span> <span class="nav-text">关于Java多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态方法重写问题"><span class="nav-number">21.1.</span> <span class="nav-text">静态方法重写问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于Java接口"><span class="nav-number">22.</span> <span class="nav-text">关于Java接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#接口的一些特性"><span class="nav-number">22.1.</span> <span class="nav-text">接口的一些特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用"><span class="nav-number">23.</span> <span class="nav-text">如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标记接口"><span class="nav-number">23.1.</span> <span class="nav-text">标记接口</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Eason He"
      src="/images/header.JPG">
  <p class="site-author-name" itemprop="name">Eason He</p>
  <div class="site-description" itemprop="description">你当像鸟飞往你的山</div>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Eason459" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Eason459" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

      <div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=5392945&auto=0&height=66">
    </iframe>
</div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">贺俊耀</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">94k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:26</span>
</div>
<!--添加网站的运行时间-->
<span id="sitetime"> <br></span>
<script language="javascript">
	function siteTime(){
		window.setTimeout("siteTime()", 1000);
		var seconds = 1000
		var minutes = seconds * 60
		var hours = minutes * 60
		var days = hours * 24
		var years = days * 365

		var today = new Date()
		var todayYear = today.getFullYear()
		var todayMonth = today.getMonth()
		var todayDate = today.getDate()
		var todayHour = today.getHours()
		var todayMinute = today.getMinutes()
		var todaySecond = today.getSeconds()
		var t1 = Date.UTC(2020,3,12,11,00,00)
		var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond)
		var diff = t2-t1

		var diffYears = Math.floor(diff/years)
		var diffDays = Math.floor((diff/days)-diffYears*365)
		var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours)
		var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes)
		var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds)
		document.getElementById("sitetime").innerHTML=" 本站已运行"+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒<br>"
	}
	siteTime()
</script>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
  <span class="site-uv" title="总访客量">
    你是我的第<span id="busuanzi_value_site_uv"></span>位访客, 
  </span>

  <span class="site-pv" title="总访问量">
    经过<span id="busuanzi_value_site_pv"></span>次回眸才得以与你相遇
  </span>
</div>







      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

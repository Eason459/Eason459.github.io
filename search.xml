<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Java】Java后知后觉(初阶)</title>
    <url>/2020/04/29/Java%E5%90%8E%E7%9F%A5%E5%90%8E%E8%A7%89/</url>
    <content><![CDATA[<p><strong>那些Java中你可能不知道的一些事&lt;(▰˘◡˘▰)&gt;</strong></p>
 <a id="more"></a>
<p><img src="https://i.loli.net/2020/06/20/Rix9mJo7VXUFkDM.jpg" alt="IMG_6579.jpg"></p>
<ol>
<li><h2 id="关于命令"><a href="#关于命令" class="headerlink" title="关于命令"></a>关于命令</h2></li>
</ol>
<ul>
<li><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">javac </span>HelloWorld.<span class="keyword">java </span> </span><br><span class="line">$ <span class="keyword">java </span>HelloWorld  </span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>相信这是大家刚刚接触Java时接触到的第一个程序</strong><br><strong>在这个命令行终端中我们用到了两个命令javac和java</strong></p>
<ul>
<li>javac后跟着的是一个典型的java文件，javac此时所做的事就是<em>将java源文件编译成字节码文件</em>此时如果编译成功的话是会生成一个名为HelloWorld.class的文件，此时就是成功编译为字节码文件；</li>
<li>java后跟的是Java文件中的类名，比如这里的HelloWorld但是不要加.class后缀。</li>
</ul>
<ol start="2">
<li><h2 id="关于修饰符"><a href="#关于修饰符" class="headerlink" title="关于修饰符"></a>关于修饰符</h2></li>
</ol>
<p>-</p>
<h3 id="synchronized修饰符"><a href="#synchronized修饰符" class="headerlink" title="synchronized修饰符"></a>synchronized修饰符</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">easonHe</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<strong>synchronized</strong>修饰符是在多线程的程序编码中常会用到的修饰符，<em>synchronized</em>修饰符旨在<em>确保方法在同一时间只能被一个线程访问</em>。同时<strong>synchronized</strong>可以用于四个访问修饰符。  </p>
<p>-</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> active;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        active = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(active)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        active = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>volatile</em>修饰词也是常用于多线程中，每当线程准备访问<em>volatile</em>所修饰的成员变量时，必须要从共享内存中重新读取该成员变量的值，另外，如果遇到该成员变量的值发生改变时，线程也必须将该成员变量的值写入到共享内存中更新，这样以来，多线程中每个线程所看到的都是成员变量的同一个值。  </p>
</blockquote>
<blockquote>
<p>这个成程序中，若是一个线程调用run()方法，此时另一线程调用stop()方法时，如果线程已经进入while的缓冲区，那么即使stop()方法中的active=false线程也不会停止，但是由于这个线程中的active是被<em>volatile</em>修饰符所修饰，所以这个循环会停止。</p>
</blockquote>
<p>-</p>
<h3 id="transient修饰符"><a href="#transient修饰符" class="headerlink" title="transient修饰符"></a>transient修饰符</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> transient <span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> b;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>transient</em>修饰符用来定义变量时，其作用是用来预处理类与变量的数据类型，也就是说，如果序列化的对象包含别<em>transient</em>修饰的实例变量，那么JVM将会跳过此特定的变量。</p>
</blockquote>
<h2 id="关于运算符"><a href="#关于运算符" class="headerlink" title="关于运算符"></a>关于运算符</h2><p>-</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">A = <span class="number">0101</span> <span class="number">1100</span></span><br><span class="line">B = <span class="number">0010</span> <span class="number">0101</span>  </span><br><span class="line">---------------</span><br><span class="line">A&amp;B = <span class="number">0000</span> <span class="number">0100</span></span><br><span class="line">A|B = <span class="number">0111</span> <span class="number">1101</span></span><br><span class="line">A^B = <span class="number">0111</span> <span class="number">1001</span></span><br><span class="line">~A = <span class="number">1010</span> <span class="number">0011</span></span><br><span class="line">B&lt;&lt;<span class="number">2</span> = <span class="number">1001</span> <span class="number">0100</span></span><br><span class="line">B&gt;&gt;<span class="number">2</span> = <span class="number">1001</span></span><br><span class="line">B&gt;&gt;&gt;<span class="number">2</span> = <span class="number">0000</span> <span class="number">1001</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><em>^如果对应位值相等则为0不等则为1</em>；</li>
<li><em>～按位取反运算符</em>；</li>
<li>*&lt;&lt;按位左移运算符，左操作数按位左移右操作数指定的位数*;  </li>
<li><em>&gt;&gt;按位右移运算符，左操作数按位右移右操作数指定的位数</em>；</li>
<li><em>&gt;&gt;&gt;按位右移补零运算符，在按位右移的情况下将最高位的空位用零填充</em></li>
</ol>
</blockquote>
<p>但是其实我们真正用到它的时候并非如此使用，而是下面这种情况：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(<span class="keyword">String</span>[], args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">13</span>; <span class="comment">//即 a=0000 1101</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">28</span>; <span class="comment">//即 b=0001 1100</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        c = a &amp; b;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"a &amp; b = "</span>+c) <span class="comment">//此时c的值为12 即0000 1100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说我们平时使用的往往并非二进制编码，而是对应的十进制编码，但有时我们也会为了满足某种需求而使用到十进制编码进行位操作符的运算。  </p>
<p>-</p>
<h3 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[], args)&#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">6</span>;</span><br><span class="line">        <span class="built_in">bool</span>ean result = (a&lt;<span class="number">2</span>&amp;&amp;++a&lt;<span class="number">8</span>) <span class="comment">//a=6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码中，result结果为false，因为a&lt;2已经是false了所以结果必定是false，所以说第二个操作判断就不被执行了，也就是++a不被执行，所以此时a仍然为6.</p>
</blockquote>
<p>-</p>
<h3 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"watermelon"</span>;</span><br><span class="line"><span class="built_in">boolean</span> isReal = <span class="built_in">str</span> <span class="keyword">instanceof</span> <span class="keyword">String</span>;</span><br><span class="line"><span class="comment">// is Real = true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>instanceof运算符用于操作一个对象的实例，若为此特定类类型或接口类型则为真，否则为假，即如果运算符左侧所指的对象是右侧类或者接口的一个对象则结果为真。  </p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cola</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Pepsi</span> <span class="keyword">extends</span> <span class="title">Cola</span></span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[], args)&#123;</span><br><span class="line">        <span class="type">Cola</span> cola = <span class="keyword">new</span> <span class="type">Pepsi</span>();</span><br><span class="line">        boolean result = cola instanceof <span class="type">Pepsi</span>;</span><br><span class="line">        <span class="comment">//此时result=true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用instanceof操作符如果被比较的对象兼容于右侧的类型，则同样成立。这里应该注意<strong><em>判断一个实例引用的类型时，使用的是实际类型，而不是声明的类型，如上代码中cola是Pepsi类型而不是Cola类型，并且，子类的实例可以声明为父类，但是父类的实例不可以声明为子类</em></strong>。</p>
</blockquote>
<h2 id="关于循环"><a href="#关于循环" class="headerlink" title="关于循环"></a>关于循环</h2><p>-</p>
<h3 id="加强型for循环-For-Each"><a href="#加强型for循环-For-Each" class="headerlink" title="加强型for循环(For-Each)"></a>加强型for循环(For-Each)</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[], args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] num = &#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : num)&#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(i+<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//此时将会打印出2 6 9 30</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">String</span> [] drinks = &#123;<span class="string">"cola"</span>, <span class="string">"coffee"</span>, <span class="string">"tea"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> name : drinks)&#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(name+<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//此时将会打印出cola coffee tea </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种情况是Java引入的为了用于数组形式的增强版for循环。</p>
</blockquote>
<p><strong>ps:在循环或者条件以及选择语句中需要注意的几点：</strong>  </p>
<ol>
<li>在循环操作语句中，如果遇到break语句被执行，那么将会直接跳出最内层的一个循环体，如果遇到continue语句被执行，那么接下来的语句将不会被执行，而是直接进入新一轮的循环，这种用法往往用来选择性退出或者是去刻意忽略某次循环体内的语句；</li>
<li>在选择操作语句中，如switch语句，如果case没有与变量类型相匹配的，那么将会执行default语句（如果有的话），如果匹配的case语句没有break，那么将会顺序输出以下的语句，直到遇到break或全部输出。  </li>
</ol>
<h2 id="关于Java类"><a href="#关于Java类" class="headerlink" title="关于Java类"></a>关于Java类</h2><p>-</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>由于java属于面向对象的编程语言，所以我们难免会遇到使用数据时需要使用对象而不是内置数据类型的情形，针对于此，java提供了包装类：Double,Float, Long, Integer, Short, Byte.</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">IntergerTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[], args)&#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">128</span>;</span><br><span class="line">        Interger b = <span class="number">128</span>;</span><br><span class="line">        Interger c = new Interger(<span class="number">128</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(a==b); <span class="comment">//true 因为与内置数据类型比较，所以Interger会自动拆箱比较  </span></span><br><span class="line">        <span class="comment">// a==c 与 a==b情况相同</span></span><br><span class="line">        Interger b1 = <span class="number">127</span>;</span><br><span class="line">        Interger c1 = <span class="number">127</span>; <span class="comment">//此时经编译时为Interger b2 = Interger.valueOf(127)  </span></span><br><span class="line">        System.<span class="keyword">out</span>.println(b1==c1); <span class="comment">//true</span></span><br><span class="line">        Interger b2 = <span class="number">128</span>;</span><br><span class="line">        Interger c2 = <span class="number">128</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(b2==c2); <span class="comment">//false 因为Interger中的valueOf函数只会对int类型的取值范围内（-128～127）之间的数进行缓存。  </span></span><br><span class="line">        Interger b3 = new Interger(<span class="number">127</span>);</span><br><span class="line">        Interger c3 = <span class="number">127</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(b3==c3); <span class="comment">//false 无论如何Interger与new得到的Interger不会相等，</span></span><br><span class="line">        <span class="comment">//因为new得到的对象放在堆存储区里，非new得到的常量则放在常量池即方法区里，故不会经历拆箱，两地址也不同，故不会相等</span></span><br><span class="line">        Interger b4 = new Interger(<span class="number">127</span>);</span><br><span class="line">        Interger c4 = new Interger(<span class="number">127</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(b4==c4); <span class="comment">//false 因为都是通过new得到的对象，所以地址不相同</span></span><br><span class="line">        Interger b5 = <span class="number">127</span>;</span><br><span class="line">        Interger c5 = <span class="number">127</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(b5.equals(c5)); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译器特别支持的包装成为装箱，所以在内置类型要作为对象使用时，编译器就会将其装箱成为一个包装类，若是一个对象要作为内置数据类型使用时，编译器也会将其拆箱；  </p>
</blockquote>
<blockquote>
<h2 id="要注意在进行比较时-比较的是地址，equals-比较的是对象的内容，所以在Interger-valueOf-时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。"><a href="#要注意在进行比较时-比较的是地址，equals-比较的是对象的内容，所以在Interger-valueOf-时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。" class="headerlink" title="要注意在进行比较时 =比较的是地址，equals()比较的是对象的内容，所以在Interger.valueOf()时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。  "></a>要注意在进行比较时 =比较的是地址，equals()比较的是对象的内容，所以在Interger.valueOf()时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。  </h2></blockquote>
<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] <span class="built_in">array</span> = &#123;<span class="string">"E"</span>, <span class="string">"a"</span>, <span class="string">"s"</span>, <span class="string">"o"</span>, <span class="string">"n"</span>&#125;;</span><br><span class="line">        <span class="keyword">String</span> str = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="built_in">array</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(str);</span><br><span class="line">        <span class="comment">//输出结果为Eason</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Java中，String字符串属于对象，String类有11中构造方法，这些方法提供不同的参数来初始化字符串，比如这段代码中提供一个字符数组来初始化一个字符串；  </p>
</blockquote>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class Demo&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main()&#123;</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"Eason"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">        <span class="comment">//输出Eason</span></span><br><span class="line">        <span class="built_in">str</span> = <span class="string">"He"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">        <span class="comment">//输出He</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>特别需要注意的是一旦String对象被创建那么它就无法被更改了，也就是说String是被final修饰的，但是这段代码中str在结果上看是改变了，但其实它并没有被更改，因为实例str只是一个String的对象引用，当执行str=”He”的时候它创建了一个新的String对象”He”,原来的”Eason”对象仍然存储在内存中；  </p>
</blockquote>
<blockquote>
<p>也就是说，如果需要对字符串做很多修改，那么应该选择使用<em>StringBuffer和StringBuilder</em>类。<br>    1.StringBuffer:字符串变量，Synchronized线程安全，如果想专成String类型，则可以使用toString()方法，Java.lang.StringBuffer可以通过某些特定的方法调用可以改变该序列的长度和内容，可以将字符串缓冲区安全的应用于多个线程；<br>    2.StringBuilder:字符串变量，非线程安全，在内部StringBuilder对象被当作是一个包含自负序列的变长数组；<br>    <strong><em>总结</em></strong>：<strong>-</strong> 如果操作少量的数据用String <strong>-</strong> 单线程操作大量数据用StringBuilder <strong>-</strong> 多线程操作大量数据用StringBuffer。<br>    ps：其实StringBuffer的线程安全也是很低能的也就是说它也只能保证jvm不抛出异常而向下运行而已，所以针对于StringBuilder的高效，所以<strong><em>在绝大部分情况下直接使用StringBuilder</em></strong>。</p>
</blockquote>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">String <span class="built_in">s1</span> = <span class="string">"a"</span>+<span class="string">"b"</span>+<span class="string">"c"</span>;</span><br><span class="line">String <span class="built_in">s2</span> = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(<span class="built_in">s1</span>==<span class="built_in">s2</span>)<span class="comment">;//true</span></span><br><span class="line">System.out.println(<span class="built_in">s1</span>.equals(<span class="built_in">s2</span>))<span class="comment">;//true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是道面试经常会被问到的问题，在Java常量优化机制中，编译时s1已经成为”abc”在常量池中查找创建，故此时s2就不用再创建了；  </p>
</blockquote>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="built_in">s1</span> = <span class="string">"a"</span>+<span class="string">"b"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="built_in">s2</span> = <span class="string">"abc"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="built_in">s3</span> = <span class="built_in">s1</span>+<span class="string">"c"</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">System.out.println</span>(<span class="built_in">s3</span>=<span class="symbol">=s2</span>)<span class="comment">;//false</span></span><br><span class="line"><span class="symbol">System.out.println</span>(<span class="built_in">s3</span>.equals(<span class="built_in">s2</span>))<span class="comment">;//true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这也是道面试经常会被问到的问题，在编译时，”ab”在常量池中被创建其地址为a1,”abc”接着被创建其地址为a2,对于s3，先创建一个StringBuilder或StringBuffer对象，通过append方法连接得到abc，再调用toString()转换为String得到的地址为a3，故==为false，equals比较对象的值为true。</p>
</blockquote>
<p><strong>另外</strong>：length(), length属性，size()之间的一些区别</p>
<ol>
<li>length()方法是针对字符串来说的，要求一个字符串的长度时就要用到这个方法；</li>
<li>length属性是针对Java中的数组来说的，要求数组的长度可以用length属性；</li>
<li>size()方法是针对泛型集合List来说的，如果想看一个泛型集合中有多少个元素就使用此方法；</li>
</ol>
<h2 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h2><p>-</p>
<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[], args)&#123;</span><br><span class="line">        <span class="built_in">int</span> [] num = new <span class="built_in">int</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="built_in">int</span> [] num1 = &#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Arrays.fill(num, <span class="number">6</span>);<span class="comment">//此时num数组内的元素为66666666</span></span><br><span class="line">        Arrays.fill(num, <span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>);<span class="comment">//将num数组中第1，2个元素赋值为8</span></span><br><span class="line">        Arrays.sort(num1);<span class="comment">//对num1数组进行排序</span></span><br><span class="line">        Arrays.equals(num, num1);<span class="comment">//比较两数组元素是否相等</span></span><br><span class="line">        Arrays.binarySearch(num1, <span class="number">2</span>);<span class="comment">//查找元素3在数组中的位置，如果不存在就返回负数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java.util.Arrays类能够很方便的处理数组，它提供的所有方法都是静态的，它的部分功能：<br>    1. 通过fill()方法给数组赋值；<br>    2. 通过sort()方法按升序排序；<br>    3. 通过equals()方法判断数组中的元素是否相等；<br>    4. 通过binarySearch()方法能对排好序的数组进行二分法查找等等。</p>
</blockquote>
<h2 id="关于正则表达式"><a href="#关于正则表达式" class="headerlink" title="关于正则表达式"></a>关于正则表达式</h2><p>-</p>
<h3 id="Pattern与Matcher类"><a href="#Pattern与Matcher类" class="headerlink" title="Pattern与Matcher类"></a>Pattern与Matcher类</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[], args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">String</span> str = <span class="string">"My number is 56? Yes!"</span>;</span><br><span class="line">        <span class="keyword">String</span> regex = <span class="string">"(\\d+)(\\D*)(.*)"</span>;</span><br><span class="line">        Pattern p = Pattern.compile(regex);<span class="comment">//创建Pattern对象</span></span><br><span class="line">        Matcher m = p.matcher(str);<span class="comment">//创建Matcher(适配器)对象</span></span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">find</span>())&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(m.group(<span class="number">0</span>));<span class="comment">//输出：My number is 56? Yes!</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(m.group(<span class="number">1</span>));<span class="comment">//输出：56</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(m.group(<span class="number">2</span>));<span class="comment">//输出：My number is Yes</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(m.group(<span class="number">3</span>));<span class="comment">//输出：? Yes!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本段代码中group()方法为捕获组，比如正则表达式中((A)(B(C)))这其中就有四个组((A)(B(C)))、(A)、(B(C))、(C),技巧是左边数第几个括号所对应的内容就是相应的第几组；  </p>
</blockquote>
<blockquote>
<p>Pattern与Matcher类都没有公共的构造方法，都是通过调用静态函数所得到的返回类型来创建类；</p>
</blockquote>
<blockquote>
<p>在其他语言的正则表达式中往往一个反斜杠\就具有转义作用，但是Java的正则表达式中两个反斜杠才能表示转义作用，比如\\d表示一位数字。</p>
</blockquote>
<blockquote>
<p>在Matcher类中有两个重要的方法就是start()和end()方法，start()方法返回由给定组所捕获的初始索引，end()方法是返回最后一个匹配字符的索引+1</p>
</blockquote>
<h2 id="关于Java方法"><a href="#关于Java方法" class="headerlink" title="关于Java方法"></a>关于Java方法</h2><p>-</p>
<h3 id="出现在方法名称"><a href="#出现在方法名称" class="headerlink" title="_出现在方法名称"></a>_出现在方法名称</h3><blockquote>
<h2 id="在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test-例如：textPop-emptyStack"><a href="#在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test-例如：textPop-emptyStack" class="headerlink" title="在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test 例如：textPop_emptyStack."></a>在方法的命名中，下划线<em>可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test<MethodUnderTest></em><state> 例如：textPop_emptyStack.</h2></blockquote>
<h3 id="命令行参数的使用"><a href="#命令行参数的使用" class="headerlink" title="命令行参数的使用"></a>命令行参数的使用</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"args["</span>+i+<span class="string">"] = "</span>+args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行此程序：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ javac Demo.java</span><br><span class="line">$ java Demo This <span class="keyword">is</span> <span class="keyword">a</span> <span class="keyword">command</span> <span class="built_in">line</span></span><br><span class="line"><span class="keyword">args</span>[<span class="number">0</span>] = This</span><br><span class="line"><span class="keyword">args</span>[<span class="number">1</span>] = <span class="keyword">is</span></span><br><span class="line"><span class="keyword">args</span>[<span class="number">2</span>] = <span class="keyword">a</span></span><br><span class="line"><span class="keyword">args</span>[<span class="number">3</span>] = <span class="keyword">command</span></span><br><span class="line"><span class="keyword">args</span>[<span class="number">4</span>] = <span class="built_in">line</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息"><a href="#这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息" class="headerlink" title="这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息  "></a>这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息  </h2></blockquote>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main()&#123;</span><br><span class="line">        printMin(&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0.6</span>,&#125;);<span class="comment">//输出：The min value is : 0.6</span></span><br><span class="line">        printMin(new <span class="built_in">double</span>[]&#123;<span class="number">3.2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6.7</span>&#125;)<span class="comment">//输出：The min value is : 3.2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> printMin(doulbe... num)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.length==<span class="number">0</span>)&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"No agument passed"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">double</span> result = num[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]&lt;result)&#123;</span><br><span class="line">                result=num[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"The min value is : "</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个函数中最多只能有一个可变参数，并且要放在参数列表的最后，代码在执行时，编译器会将可变参数编译为一个数组，所以在函数的内部，参数名可以看作是数组名； </p>
</blockquote>
<blockquote>
<h2 id="由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法"><a href="#由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法" class="headerlink" title="由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法"></a>由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法</h2></blockquote>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizationDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Cola cola1 = <span class="keyword">new</span> Cola(<span class="number">1</span>);</span><br><span class="line">        Cola cola2 = <span class="keyword">new</span> Cola(<span class="number">2</span>);</span><br><span class="line">        Cola cola3 = <span class="keyword">new</span> Cola(<span class="number">3</span>);</span><br><span class="line">        cola2 = cola3 = <span class="keyword">null</span>;<span class="comment">//将两对象作废，接下来会被回收</span></span><br><span class="line">        System.gc();<span class="comment">//调用Java垃圾收容器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cola</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cola</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i=i;</span><br><span class="line">        System.out.println(<span class="string">"Cola object "</span>+i+<span class="string">" is created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cola object "</span>+i+<span class="string">" is disposed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//Cola object 1 is created</span></span><br><span class="line"><span class="comment">//Cola object 2 is created</span></span><br><span class="line"><span class="comment">//Cola object 3 is created</span></span><br><span class="line"><span class="comment">//Cola object 2 is disposed</span></span><br><span class="line"><span class="comment">//Cola object 3 is disposed</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>finalize()方法在对象被回收之前调用，它用来清除回收对象，可以用这个方法来确保一个对象打开的文件被关闭，并且该方法需要protected限定其余类不可调用此方法，当然JVM自动完成内存的回收，也可以通过这个方法来手动操作  </p>
</blockquote>
<h2 id="关于文件的Stream-流-与File-文件"><a href="#关于文件的Stream-流-与File-文件" class="headerlink" title="关于文件的Stream(流)与File(文件)"></a>关于文件的Stream(流)与File(文件)</h2><p>-</p>
<h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bWrite = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;<span class="comment">//写入的数据为byte类型</span></span><br><span class="line">            Outputstream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bWrite.length;i++)&#123;</span><br><span class="line">                os.<span class="built_in">write</span>(bWtite[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            os.<span class="built_in">close</span>();</span><br><span class="line">        </span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = is.<span class="built_in">available</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)&#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>((<span class="keyword">byte</span>)is.<span class="built_in">read</span>());<span class="comment">//最终要的要将读取数据强制转换成同类型才能避免乱码</span></span><br><span class="line">            &#125;</span><br><span class="line">            is.<span class="built_in">close</span>();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">"Exception"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FileOutputStream读写文件中容易出现乱码问题，这跟字符集编码无关，主要是要保证读写的类型一致，当然如果不一致也可以通过OutputStramWriter与InputStreamReader来规定相同的编码  </p>
</blockquote>
<h2 id="关于scanner类"><a href="#关于scanner类" class="headerlink" title="关于scanner类"></a>关于scanner类</h2><p>-</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        scanner scan = <span class="keyword">new</span> Scanner(System.in)<span class="comment">//控制台输入</span></span><br><span class="line">        <span class="comment">//scanner scanf = new Scanner(new File(test.text));从文件中读取</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(scan.hasNext())&#123;</span><br><span class="line">        <span class="keyword">String</span> str = scan.next();<span class="comment">//单个字符返回，若是空字符则退出</span></span><br><span class="line">        <span class="comment">//String str1 = scan.nextLine(); 每次读取一行，包含空字符，这时的判断应为scan.hasNextLine()</span></span><br><span class="line">        <span class="comment">//int i = scan.nextInt();如果要接收数据，则为next***() 相应的判断语句也更改</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>scanner类在输入时的字符都是可见的，所以带来了一定的安全问题，故可以使用Console类来实现输入密码的目的，即：</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Console cns = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>console<span class="literal">()</span>;</span><br><span class="line">String userame = cns.read<span class="constructor">Line(<span class="string">"User name: "</span>)</span>;</span><br><span class="line"><span class="built_in">char</span><span class="literal">[]</span> password = cns.read<span class="constructor">Password(<span class="string">"Password: "</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="关于Java异常处理"><a href="#关于Java异常处理" class="headerlink" title="关于Java异常处理"></a>关于Java异常处理</h2><p>-</p>
<h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><blockquote>
<p>1、error–错误: 是指程序无法处理的错误，表示应用程序运行时出现的重大错误。例如jvm运行时出现的OutOfMemoryError以及Socket编程时出现的端口占用等程序无法处理的错误。<br>2、Exception-异常 ：异常可分为运行时异常跟编译异常<br>    -<em>运行时异常</em>：即RuntimeException及其之类的异常。这类异常在代码编写的时候不会被编译器所检测出来，是可以不需要被捕获，但是程序员也可以根据需要进行捕获抛出。常见的RUNtimeException有：NullpointException（空指针异常），ClassCastException（类型转换异常），IndexOutOfBoundsException（数组越界异常）等。<br>    -<em>编译异常</em>：RuntimeException以外的异常。这类异常在编译时编译器会提示需要捕获，如果不进行捕获则编译错误。常见编译异常有：IOException（流传输异常），SQLException（数据库操作异常）等。<br>-</p>
</blockquote>
<h3 id="语句块执行问题"><a href="#语句块执行问题" class="headerlink" title="语句块执行问题"></a>语句块执行问题</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//函数语句</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"catch is begin"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//不被执行</span></span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"finally is begin"</span>);<span class="comment">//被执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//被执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了"><a href="#这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了" class="headerlink" title="这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了"></a>这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了</h2></blockquote>
<h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">Demo</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>throws经常会被用在方法声明后，方法体之前，表明方法可能跑出一个异常，throw经常被用在方法体内，表示此时抛出一个已定义的异常。</p>
</blockquote>
<h2 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h2><p>-</p>
<h3 id="构造器-构造方法或构造函数"><a href="#构造器-构造方法或构造函数" class="headerlink" title="构造器(构造方法或构造函数)"></a>构造器(构造方法或构造函数)</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    father()&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    public father(int i)&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="type">Son</span>()&#123;</span><br><span class="line">        <span class="comment">//super() 自动调用父类的无参构造器</span></span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="type">Son</span>(int i)&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">3</span>)<span class="comment">//主动调用父类的有参构造器，就不再默认调用父类的无参构造器</span></span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="在Son-继承Father-后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器-主动调用，如果有的话-，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器-但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super-参数-否则系统报错"><a href="#在Son-继承Father-后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器-主动调用，如果有的话-，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器-但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super-参数-否则系统报错" class="headerlink" title="在Son()继承Father()后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器(主动调用，如果有的话)，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器,但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super(参数),否则系统报错"></a>在Son()继承Father()后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器(主动调用，如果有的话)，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器,但是<strong><em>如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super(参数),否则系统报错</em></strong></h2></blockquote>
<h3 id="重写-覆盖-中的调用问题"><a href="#重写-覆盖-中的调用问题" class="headerlink" title="重写(覆盖)中的调用问题"></a>重写(覆盖)中的调用问题</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    public void demo()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Father's demo()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    public void demo()&#123;</span><br><span class="line">        <span class="keyword">super</span>.demo();<span class="comment">//此时输出Father's demo()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用"><a href="#如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用" class="headerlink" title="如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用"></a>如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用</h2></blockquote>
<h3 id="转型问题"><a href="#转型问题" class="headerlink" title="转型问题"></a>转型问题</h3><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">Father f1 = <span class="keyword">new</span> <span class="type">Son</span>();<span class="comment">//upcasting(向上转型)f1引用指向Son对象</span></span><br><span class="line">Son s1 = (Son)f1;<span class="comment">//downcasting(向下转型)f1引用仍然指向Son对象</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line"></span><br><span class="line">Father f2 = <span class="keyword">new</span> <span class="type">Father</span>();</span><br><span class="line">Son s2 = (Son)f2;<span class="comment">//错误，子类引用不能指向父类对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>向上转型：子类对象直接赋给父类引用，不用强制转换<br>向下转型：把指向子类对象的父类赋给了子类，需要强制转换</p>
</blockquote>
<h2 id="关于Java重写-Override-与重载-Overload"><a href="#关于Java重写-Override-与重载-Overload" class="headerlink" title="关于Java重写(Override)与重载(Overload)"></a>关于Java重写(Override)与重载(Overload)</h2><p>-</p>
<h3 id="向上转型带来的问题"><a href="#向上转型带来的问题" class="headerlink" title="向上转型带来的问题"></a>向上转型带来的问题</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Animal方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="title">extends</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Cat重写方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Cat特有方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal a1 = <span class="keyword">new</span> Cat();<span class="comment">//向上转型</span></span><br><span class="line">        a.<span class="built_in">move</span>();<span class="comment">//调用Animal自己的move()</span></span><br><span class="line">        a1.<span class="built_in">move</span>();<span class="comment">//调用Cat重写过的move()</span></span><br><span class="line">        a1.jump();<span class="comment">//error 因为a1的引用类型Animal中没有jump()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码中由于Animal中没有jump()方法导致编译失败，但是可以通过强制转型(UP)来访问引用父类中没有但是子类中有的方法或成员变量  </p>
</blockquote>
<blockquote>
<p>方法重写规则中需要注意的几点：<br>    1. 返回类型可以与被重写方法的返回类型不同，但是得是父类返回值的派生类；<br>    2. 访问权限不能比父类被重写方法的访问权限更低，比如父类方法的访问权限为public，子类重写方法后不能为protected或更低；<br>    4. 重写方法不能抛出更更广泛的强制性异常；  </p>
</blockquote>
<h2 id="关于Java多态"><a href="#关于Java多态" class="headerlink" title="关于Java多态"></a>关于Java多态</h2><p>-</p>
<h3 id="静态方法重写问题"><a href="#静态方法重写问题" class="headerlink" title="静态方法重写问题"></a>静态方法重写问题</h3><blockquote>
<p>父类的静态方法被子类重写后，调用问题应该看指向子类对象的是父类引用还是子类引用，如果是父类引用指向子类对象则会调用父类的静态方法，如果是子类引用指向子类对象，则会调用子类的静态方法</p>
</blockquote>
<h2 id="关于Java接口"><a href="#关于Java接口" class="headerlink" title="关于Java接口"></a>关于Java接口</h2><p>-</p>
<h3 id="接口的一些特性"><a href="#接口的一些特性" class="headerlink" title="接口的一些特性"></a>接口的一些特性</h3><blockquote>
<p>-接口的方法都是且只能是public abstract；<br>-接口的成员变量都是且只能是public static final;<br>-Java不支持多继承，但是一个接口可以继承多个接口；<br>-类继承接口必须要实现接口里的全部方法，除非类为抽象类；<br>-如果基本功能在不断改变那么要使用抽象类，因为如果要用接口那么功能改变要更改所有继承这个接口的实体内的方法，<strong><em>这也可以理解abstract表示的是”is-a”的一种关系，interface表示的是”has-a”的一种关系</em></strong>；<br>-JDK1.8以后接口中开始允许出现静态方法和方法体； </p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title">demo</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"这里是interface里的默认实现方法"</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"这里是interface里的静态方法"</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//接口中只允许这两种非抽象方法实现</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用"><a href="#如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用" class="headerlink" title="如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用"></a>如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用</h2></blockquote>
<h3 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">import java.util;</span><br><span class="line">public<span class="built_in"> interface </span>EventListener&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个接口就是监听接口，类似于MouseListener类就继承了这个接口。<br>标记接口存在的目的：<br>1.向一个类添加数据类型，因为不需要实现该类的方法(因为本身就没有方法)；<br>2.建立一个公共的父接口，正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口，它可以使得使用instanceof进行类型查询。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】Java设计模式(记忆点)</title>
    <url>/2020/05/27/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>这里是初读程杰老师的《大话设计模式》得到的一些对应模式应用场景的简单总结,后期深读时会继续更新设计模式系列的博文哒✪ω✪</strong></p>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/06/15/VUPQWpBE9hdLxl2.jpg" alt="IMG_7799.jpg"></p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote>
<p><strong><em>策略模式用来封装算法，当遇到不同时间使用不同时可以使用策略模式</em></strong>   </p>
</blockquote>
<blockquote>
<p>虽然当业务变更时仍需要改变Text里的switch语句中的判断条件，但是任何需求的变更都是需要成本的<br>—</p>
</blockquote>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><blockquote>
<p><strong><em>装饰模式就是为已有功能动态添加更多功能的一种方式，当代码需要新功能时不必向主类中添加代码从而增加主类的复杂度，可以使用修饰类来完成这个功能</em></strong></p>
</blockquote>
<hr>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote>
<p><strong><em>代理模式的应用场景：1.远程代理，即为一个对象在不同的地址空间提供局部代表，从而可以隐藏对象在不同地址空间的事实；2.虚拟代理，是根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象如HTML网页中的大量图片信息；3.安全代理，用来控制真实对象的访问权限；4.智能指引，指在调用真实的对象时代理处理另外一些事</em></strong></p>
</blockquote>
<hr>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote>
<p><strong><em>工厂方法定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂模式使一个类实例化延迟到了子类。相比于简单工厂的添加功能需要修改工厂的switch语句，这违背了开-闭原则，所以引入了工厂模式，它将修改的代码从普通类移动到了客户端</em></strong>   </p>
</blockquote>
<hr>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><blockquote>
<p><strong><em>原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。一般在初始化信息不变的的情况下，克隆是最好的方法，既隐藏了初始化的细节，又是对性能的极大提高</em></strong></p>
</blockquote>
<hr>
<h2 id="模版模式"><a href="#模版模式" class="headerlink" title="模版模式"></a>模版模式</h2><blockquote>
<p><strong><em>模版模式提供了一个代码复用的平台，通过模版模式将一些单一的行为整合到一个单一的地方，这样使子类摆脱了重复单一行为的纠缠</em></strong></p>
</blockquote>
<hr>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><blockquote>
<p><strong><em>迪米特法则指出如果两个类不必彼此直接通信，那么它们就不应该直接发生相互作用，如果其中一个类需要调用另一个类的方法的话，那么可以通过第三方转发这个调用</em></strong>   </p>
</blockquote>
<blockquote>
<p>迪米特法则根本思想其实强调了类之间的松耦合</p>
</blockquote>
<hr>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><blockquote>
<p><strong><em>外观模式为子系统的一组接口提供了一致的界面，此模式定义了一个高层接口，这个接口使得这个子系统更加容易使用</em></strong>   </p>
</blockquote>
<blockquote>
<p>外观模式用一个高层接口使得原本设计粗糙且复杂的遗留代码有了一个清晰的接口，这样让新的系统更加容易与其交互</p>
</blockquote>
<hr>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><blockquote>
<p><strong><em>建造者模式将一个复杂对象的构建与表示分离，这样使得同样的构建过程可以创建不同的表示</em></strong>   </p>
</blockquote>
<blockquote>
<p>建造者模式的Builder定义了抽象的建造过程，使得实例化的建造可以不遗漏建造过程（遗漏的话是不能通过编译的）,与此同时创建Director类可以用来创建具体的想要创建的对象</p>
</blockquote>
<hr>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote>
<p><strong><em>观察者模式一般使用在当一个对象改变同时需要改变其他对象时，并且并不知道具体有多少对象需要改变，观察者模式的工作其实就是在接触耦合，使得耦合双方依赖于抽象而非具体，从而使得各自的变化不回影响另一个的变化</em></strong></p>
</blockquote>
<hr>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><blockquote>
<p><strong><em>抽象工厂模式提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类</em></strong></p>
</blockquote>
<hr>
<h2 id="三种工厂模式对比"><a href="#三种工厂模式对比" class="headerlink" title="三种工厂模式对比"></a>三种工厂模式对比</h2><blockquote>
<p><strong>简单工厂模式</strong>:生产一个有多种款式的对象，对象通用抽象父类，用Switch决定实例化哪一种款式的对象；<br><strong>工厂模式</strong>：生产一个有多重款式的对象，对象通用抽象父类，每种款式有其特定的生产工厂，它们都继承一个工厂接口，在客户端种决定用哪一个特定工厂来实例化工厂，这将实例化延迟到了客户端；<br><strong>抽象工厂模式</strong>：生产多个有多种款式的对象3应其抽象父类，多个对象用多个特定工厂来连接工厂接口，接口里对应了每个款式对应的对象创建实例</p>
</blockquote>
<hr>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><blockquote>
<p><strong><em>状态模式:当一个对象的行为取决于它的状态，并且它必须在运行时刻根据自己的状态来改变自己的行为的时候可以考虑使用状态模式</em></strong>   </p>
</blockquote>
<blockquote>
<p>由于对于状态来判断行为会含有很长的判断语句，这将是long method其实就已经有了坏味道，这违反了单一职责和开-闭原则，状态模式说白了就是将很长的判断语句分离开来，以便后期修改与维护</p>
</blockquote>
<hr>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote>
<p><strong><em>适配器模式：适配器类继承适配目标的父类，被适配作为适配器的内部对象变量，在构造函数时将其实例化，然后将目标父类的函数内部调用被适配的对象的相对应的内方法</em></strong></p>
</blockquote>
<hr>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><blockquote>
<p><strong><em>备忘录模式：在需要进行存储备忘录的类里添加保存备忘录的方法，并将需要保存的属性加入，由于对备忘录的封装属性最好再加备忘录管理者类，通过管理者类来对备忘录进行存储和使用</em></strong></p>
</blockquote>
<hr>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote>
<p><strong><em>组合模式：将对象组合成树形结构，以表示它们之间的额“整体-部分”的层次结构，组合模式使得客户对单个对象和组合对象的使用具有一致性</em></strong>   </p>
</blockquote>
<blockquote>
<p>当发现需求中是整体与部分的结构层次时，并且客户可以忽略组合对象与单个对象之间的关系，从而统一的使用组合结构中的所有对象时就可以考虑使用组合模式了</p>
</blockquote>
<hr>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><blockquote>
<p><strong><em>迭代器模式：提供了一个方法可以顺序的访问某聚合类型里的各个元素，而又不暴露各个对象的内部表示</em></strong>   </p>
</blockquote>
<blockquote>
<p>很多语言中已经不再显式的使用迭代器模式而是已经把这个模式做到了语言当中例如foreach in循环或者枚举类型，但是迭代器模式还是拥有它本身的优点，比如可以自己定义一种循环方式，而不是简单的进行顺序遍历</p>
</blockquote>
<hr>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p><strong><em>单例模式：为了确保类被一次且只能被实例化一次，并且提供获取此实例的方法 一般来说不建议使用懒汉方式，一般使用饿汉方式，在明确要用lazy loading时会使用登记模式，如果涉及到反序列化创建对象时可以考虑使用枚举方式，如果有特殊需求可以使用双检锁方式</em></strong></p>
</blockquote>
<hr>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><blockquote>
<p><strong><em>桥接模式：由于大量的继承会导致更改影响大难以更新维护，违背了开-闭原则，所以也就是当多角度分类时，就可以将这些类分离出来，这种时候使用合成/聚合复用原则，尽量不使用继承</em></strong>   </p>
</blockquote>
<blockquote>
<p>可以这样想：猪八戒投胎，灵魂在河的一边，河对面有两个肉体，红猪和绿猪；灵魂需要过桥，选择红猪的肉体或者绿猪的肉体完成投胎。在上面的例子中，红猪和绿猪就是 HandsetGame 和 HandsetPhone，灵魂是 HandsetBand 类，而那座桥就是 HandsetBand 这个接口。</p>
</blockquote>
<hr>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><blockquote>
<p><strong><em>命令模式：把请求一个操作的对象与它怎么执行一个操作的对象分割开来，这样在程序中请求者和实现者分割开来，可以方便的加入一个新的命令，并且降低了系统的耦合度</em></strong></p>
</blockquote>
<hr>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><blockquote>
<p><strong><em>责任链模式有点类似于迭代器模式，一个对象管理对应的业务，超出范围则转入下一个对象管理，以此类推</em></strong></p>
</blockquote>
<hr>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><blockquote>
<p><strong><em>中介者模式是将很多实体之间的交互封装在一个特定的类当中，使得类之间松耦合，一般应用于一组定义良好但是复杂的方式进行通信的场合，但是由于中介者模式的特点使得中介者类很复杂难以维护</em></strong></p>
</blockquote>
<hr>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote>
<p><strong><em>享元模式是在一个程序需要创建大量的对象并且这些对象大多数的状态都可以是外部状态时就可以考虑使用享元模式，享元模式是通过对象生产工厂生产出来具有内部状态的对象，然后提供给不同用户赋予对象外部状态来使用，，这样避免了大量的创建对象而造成的占用大量的空间问题</em></strong></p>
</blockquote>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM】GC垃圾回收机制</title>
    <url>/2020/07/05/%E3%80%90JVM%E3%80%91GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><strong>说真的我要是不懂GC我都不好意思说自己懂Java（坏笑）探秘Java最能打能秀的GC=͟͟͞͞( •̀д•́)</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>GC垃圾回收机制简直要被HR问爆了，在哪都能刷到关于GC的问题，看来不懂是不行了。说到底<strong>GC的最终目的还是对Java程序的性能进行优化</strong>。Java和C++不同，C++是垃圾自动回收的，这使得一旦C++一旦搞丢的自己new的一个对象就会导致内存得不到释放而致使的内存泄露问题，看来垃圾自动回收还是不能打鸭，那就来看看Java的GC垃圾回收机制吧</p>
</blockquote>
<h2 id="关于GC的几个问题"><a href="#关于GC的几个问题" class="headerlink" title="关于GC的几个问题"></a>关于GC的几个问题</h2><h3 id="怎么判断一个对象是不是垃圾"><a href="#怎么判断一个对象是不是垃圾" class="headerlink" title="怎么判断一个对象是不是垃圾"></a>怎么判断一个对象是不是垃圾</h3><blockquote>
<p>在上篇JVM内存模型种讲到了GC垃圾回收，一个对象是不是垃圾简单的回答就是看这么<strong>对象有没有被引用</strong>，如果某个对象从始至终都没有被其他对象或直接引用，那么它就变成了垃圾对象。或者说<strong>作用域发生未捕获异常</strong>和<strong>程序在作用域正常执行完毕</strong>又或者<strong>程序执行了System.exit()</strong>以及<strong>程序发生意外终止（被杀线程等）</strong></p>
</blockquote>
<h3 id="GC的工作区域在哪"><a href="#GC的工作区域在哪" class="headerlink" title="GC的工作区域在哪"></a>GC的工作区域在哪</h3><blockquote>
<p>GC主要是在Java堆和方法区中工作的，因为堆内存放着所有对象的数据，<a href="http://www.easonhe.top/2020/07/03/%E3%80%90JVM%E3%80%91%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">如果不了解可快速飞机去了解堆</a>，所以对于内存中的栈来说，一旦存储的数据超出了作用域就将被JVM自动释放掉，所以GC并不管辖有关栈的区域。</p>
</blockquote>
<h3 id="GC什么时候会被执行"><a href="#GC什么时候会被执行" class="headerlink" title="GC什么时候会被执行"></a>GC什么时候会被执行</h3><blockquote>
<p>GC的触发主要是在新生代的Eden区满了的时候就会触发Minro GC，还有一个情况是当从新生代“升级”到老年代的数量要大于老年代剩余容量的时候会触发Full GC（调优主要需要控制的对象），为了减少Full GC的触发次数我们可以通过NewRatio控制新生代转老年代的比例，也可以通过控制年龄阀值的方式限制。</p>
</blockquote>
<h3 id="GC的主要任务都是什么"><a href="#GC的主要任务都是什么" class="headerlink" title="GC的主要任务都是什么"></a>GC的主要任务都是什么</h3><blockquote>
<ul>
<li>分配内存；   </li>
<li>确保被引用对象的内存不被错误的回收；</li>
<li>回收不再被引用的对象的内存空间.</li>
</ul>
</blockquote>
<h2 id="按代GC的垃圾回收机制"><a href="#按代GC的垃圾回收机制" class="headerlink" title="按代GC的垃圾回收机制"></a>按代GC的垃圾回收机制</h2><h3 id="关于新生代老年代问题的补充"><a href="#关于新生代老年代问题的补充" class="headerlink" title="关于新生代老年代问题的补充"></a>关于新生代老年代问题的补充</h3><blockquote>
<ul>
<li>默认的新生代与老年代所占空间比例为 1 : 2 ；</li>
<li>默认新生代空间的分配：Eden : Fron : To = 8 : 1 : 1;</li>
<li>年龄阀值设定，默认15</li>
<li>对于一些比较大的对象（需要分配一块比较大的连续内存空间）则直接进入到老年代。一般在Survivor 空间不足的情况下发生</li>
<li>Full GC（Major GC）发生的次数不会有Minor GC 那么频繁，并且做一次Major GC 的时间比Minor GC 要更长（约10倍）。</li>
</ul>
</blockquote>
<h3 id="各个代出发GC的条件"><a href="#各个代出发GC的条件" class="headerlink" title="各个代出发GC的条件"></a>各个代出发GC的条件</h3><blockquote>
<p>我们了解了新生代与老年代的垃圾回收条件及机制了（内存模型章节），作为“持久代“的方法区怎样进行GC呢？方法区内存储的并不是从老年代中存活下来的对象数据，而是那些类的常量以及字符串常量等数据，但是根据存储的对象来看这个区域要被GC的概率是不高的，所以说这个区域GC的条件十分苛刻，<strong>必须符合下列三个条件后才能被回收</strong>：</p>
<ul>
<li>所有的实例都被回收了</li>
<li>加载该类的类加载器被回收了</li>
<li>class对象已经无法通过任何包括反射的途径访问了</li>
</ul>
</blockquote>
<h3 id="一个性能问题的解决"><a href="#一个性能问题的解决" class="headerlink" title="一个性能问题的解决"></a>一个性能问题的解决</h3><blockquote>
<p>在老年代中存在着一个card table，它是一个512byte大小的块。所有老年代的对象指向新生代对象的引用都会被记录在这个表中。当针对新生代执行GC的时候，只需要查询 card table 来决定是否可以被回收，而不用查询整个老年代。这个 card table 由一个write barrier 来管理。write barrier给GC带来了很大的性能提升，虽然由此可能带来一些开销，但完全是值得的。</p>
</blockquote>
<h2 id="GC判断算法"><a href="#GC判断算法" class="headerlink" title="GC判断算法"></a>GC判断算法</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><blockquote>
<p>当某个对象被引用时那么计数器就会+1，当这个对象的引用失效时计数器就会-1，当某个对象的计数值为0的时候就说明这个对象不可能再被引用的，是可被回收的对象。但是根据调用System.gc()情况来看，这种算法不能解决对象之间相互循环引用问题</p>
</blockquote>
<h3 id="可达性分析法（主流判断法）"><a href="#可达性分析法（主流判断法）" class="headerlink" title="可达性分析法（主流判断法）"></a>可达性分析法（主流判断法）</h3><p><img src="https://wx1.sbimg.cn/2020/07/05/2yRU2.png" alt="2yRU2.png"></p>
<blockquote>
<p> 根搜索算法是按照离散数学中的图演化而来的，也就是将一个结点看成GC Root，然后从Root结点出发搜寻它对应的引用结点，找到后再搜索引用它的结点的引用结点，一直搜索下去，然后将所有未被标记的对象即为可回收对象。</p>
</blockquote>
<blockquote>
<p>可以当作GC Root结点的有：</p>
<ul>
<li>虚拟机栈中线帧所包含的本地变量表中引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量所引用的对象</li>
<li>本地方法栈中所引用的Native对象</li>
</ul>
</blockquote>
<h2 id="GC回收算法"><a href="#GC回收算法" class="headerlink" title="GC回收算法"></a>GC回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p><img src="https://wx2.sbimg.cn/2020/07/05/2yesV.png" alt="2yesV.png"></p>
<blockquote>
<p>标记清除算法   </p>
<ul>
<li>第一步：从根集合开始对对象进行扫描，被引用的即存活的就会被标记</li>
<li>第二步：将未被标记的对象进行GC回收<br>从图中可以看到，我们不需要对存活的对象进行移动，这样的情况下如果存活的对象非常多的话，那么这个方法的效率会比较高，但是<strong>缺点是这会造成很多不连续性的内存碎片</strong>，比如图中第二步中将中间结点回收的例子</li>
</ul>
</blockquote>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="https://wx1.sbimg.cn/2020/07/05/2ytU7.png" alt="2ytU7.png"></p>
<blockquote>
<ul>
<li>第一步：将内存均等分为两份：空间A与空间B，并且所有动态分配的对象都只在其中的一个空间（图中空间A）另一个空间为空（图中空间B）</li>
<li>第二步：将从根集合出发扫描对象并将引用的对象（存活的对象）复制到为空的空间内（图中空间B）</li>
<li>第三步：将原本的活动空间（空间A）对象全部回收，此时活动空间就变成了空闲空间，原本的空闲空间（空间B）变成了活动空间</li>
</ul>
</blockquote>
<blockquote>
<p>很明显，这种算法堆对于对象存活率低的情况比较高效，但是也很明显的是在动态分配内存中我们必须要牺牲一半的空间充当空闲区，所以我们得克服一半内存的浪费</p>
</blockquote>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p><img src="https://wx2.sbimg.cn/2020/07/05/2yHKe.png" alt="2yHKe.png"></p>
<blockquote>
<p>标记-整理算法的前两步与标记-清理的方法相同，前两步图参考标记-清理算法，它完整的步骤为：</p>
<ul>
<li>第一步：从根集合开始对对象进行扫描，被引用的即存活的就会被标记</li>
<li>第二步：将未被标记的对象进行GC回收    </li>
<li>第三步：将存活的对象进行统一向左移动</li>
</ul>
</blockquote>
<blockquote>
<p>很明显，添加第三步这样的做法是避免了标记-清除算法中造成的大量内存碎片问题，但是这样需要再次更新对应结点的指针，这样做的成本也明显增高了</p>
</blockquote>
<h3 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h3><blockquote>
<p>JVM为了优化GC回收机制，使用了分代回收的方法，所以对应的不同代的区域也使用了不同的回收算法</p>
<ul>
<li>新生代内存的回收（Minor GC）：主要采用复制算法</li>
<li>老年代的内存回收（Major GC）：主要采用标记-整理算法</li>
</ul>
</blockquote>
<h2 id="垃圾收集器（GC）"><a href="#垃圾收集器（GC）" class="headerlink" title="垃圾收集器（GC）"></a>垃圾收集器（GC）</h2><h3 id="相关参数的定义"><a href="#相关参数的定义" class="headerlink" title="相关参数的定义"></a>相关参数的定义</h3><blockquote>
<p>停顿时间：垃圾收集器进行垃圾回收工作时需要暂停应用程序的时间，这个由参数 -XX:MaxGCPauseMillis决定</p>
</blockquote>
<blockquote>
<p>吞吐量：在垃圾收集上的耗时与在应用上的耗时的占比。由参数-XX:GCTimeRatio=<n>决定，比如设置n为10，那么垃圾收集的时间的比重为 1/ (10+1)=1/11</p>
</blockquote>
<blockquote>
<p>stop-the-world:它会在任何一种GC算法中发生。stop-the-world 意味着JVM因为需要执行GC而停止了应用程序的执行。当stop-the-world 发生时，除GC所需的线程外，所有的线程都进入等待状态，直到GC任务完成。GC优化很多时候就是减少stop-the-world 的发生。<strong>对这两个参数的调整就是JVM优化经常要做的工作</strong></p>
</blockquote>
<h3 id="串行垃圾收集器（Serial）（-XX-UseSerialGC）"><a href="#串行垃圾收集器（Serial）（-XX-UseSerialGC）" class="headerlink" title="串行垃圾收集器（Serial）（-XX:+UseSerialGC）"></a>串行垃圾收集器（Serial）（-XX:+UseSerialGC）</h3><blockquote>
<p><strong>单线程一个GC</strong>，当JVM发现我们的内存不够时就会<strong>暂停应用程序的执行</strong>，然后开启一个垃圾回收线程来回收垃圾，这种一般只适用于很小的嵌入式设备。 </p>
</blockquote>
<blockquote>
<p>Java虚拟机中最基本、历史最悠久的收集器，在JDK1.3之前是Java虚拟机新生代收集器的唯一选择。目前也是ClientVM下ServerVM 4核4GB以下机器默认垃圾回收器。Serial收集器虽然是最老的，但是它对于限定单个CPU的环境来说，由于没有线程交互的开销，专心做垃圾收集，所以它在这种情况下是相对于其他收集器中最高效的。</p>
</blockquote>
<blockquote>
<p>-XX:+UseSerialGC Young（新生代）选择使用串行垃圾收集器<br>-XX:+UseSerialOldGC Old（老年代）选择使用串行垃圾收集器，开启前面那个参数，该参数会默认开启，所以若想用串行垃圾收集器开启前面的参数即可,这个收集器目前主要用于Client模式下使用。如果在Server模式下，它主要还有两大用途：一个是在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，如果CMS出现Concurrent Mode Failure，则SerialOld将作为后备收集器。注意web应用场景基本不使用串行垃圾收集器   </p>
</blockquote>
<h3 id="并行垃圾收集器（ParNew）（-XX-UseParNewGC）"><a href="#并行垃圾收集器（ParNew）（-XX-UseParNewGC）" class="headerlink" title="并行垃圾收集器（ParNew）（-XX:+UseParNewGC）"></a>并行垃圾收集器（ParNew）（-XX:+UseParNewGC）</h3><blockquote>
<p>并行并不是说垃圾收集线程和用户程序并行，而是说<strong>多个垃圾收集线程的并行</strong>，也就是说当内存不足的时候<strong>仍然需要暂停的用户线程</strong>来启动多个垃圾收集线程进行垃圾收集工作，也就是多线程版本的Serial，<strong>*使用复制算法</strong>，除了Serial收集器外，只有它能与CMS收集器配合工作。ParNew是许多运行在Server模式下的JVM首选的新生代收集器。但是在单CPU的情况下，它的效率远远低于Serial收集器，所以一定要注意使用场景。</p>
</blockquote>
<h3 id="吞吐量优先收集器-ParallelScavenge-XX-UseParallelGC"><a href="#吞吐量优先收集器-ParallelScavenge-XX-UseParallelGC" class="headerlink" title="吞吐量优先收集器(ParallelScavenge)(-XX:+UseParallelGC)"></a>吞吐量优先收集器(ParallelScavenge)(-XX:+UseParallelGC)</h3><blockquote>
<p>和ParNew一样，ParalleScavenge也是<strong>一个新生代收集器</strong>使用<strong>复制算法</strong>，ParallelScavenge收集器的目标是达到一个可控件的吞吐量。</p>
</blockquote>
<blockquote>
<p>ParallelOld（-XX:+UseParallelOldGC）<br>ParallelOld是一个<strong>老年代收集器</strong>，是老年代吞吐量优先收集器，它使用<strong>标记-整理算法</strong>。这个收集器在JDK1.6之后才开始提供的，在此之前，ParallelScavenge只能选择SerialOld来作为其老年代的收集器，这严重拖累了ParallelScavenge整体的速度。而ParallelOld的出现后，才证明了吞吐量优先收集器的大名。</p>
</blockquote>
<blockquote>
<p>在注重吞吐量与CPU数量大于1的情况下，都可以优先考虑ParallelScavenge + ParalleloOld收集器。</p>
</blockquote>
<h3 id="CMS-Concurrent-Mark-Sweep-Collector-XX-UseConcMarkSweepGC"><a href="#CMS-Concurrent-Mark-Sweep-Collector-XX-UseConcMarkSweepGC" class="headerlink" title="CMS(Concurrent Mark-Sweep Collector)(-XX:+UseConcMarkSweepGC)"></a>CMS(Concurrent Mark-Sweep Collector)(-XX:+UseConcMarkSweepGC)</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote>
<p>一种老年代垃圾收集器，其特点是<strong>响应时间优先，低延迟，低停顿</strong>,是JDK1.4后期开始引用的新GC收集器，在JDK1.5、1.6中得到了进一步的改进。它是对于<strong>响应时间的重要性需求大于吞吐量要求</strong>的收集器。<strong>它用两次短暂的暂停来代替串行或并行标记整理算法时候的长暂停</strong>，使用<strong>标记-清理</strong>算法。对于要求服务器响应速度高的情况下，使用CMS非常合适。</p>
</blockquote>
<h4 id="CMS的垃圾回收过程（注意并发与并行的区别）："><a href="#CMS的垃圾回收过程（注意并发与并行的区别）：" class="headerlink" title="CMS的垃圾回收过程（注意并发与并行的区别）："></a>CMS的垃圾回收过程（<strong>注意并发与并行的区别</strong>）：</h4><blockquote>
<p>1.<strong>初始标记阶段*</strong>（<strong>有暂停</strong>）（STW initial mark）：在这个阶段，<strong>需要虚拟机停顿正在执行的应用线程</strong>，官方的叫法STW（Stop The World）。这个过程从根对象扫描直接关联的对象，并作标记，这个过程进行的非常快；<br>2.<strong>并发标记阶段</strong>（Concurrent marking）：这个阶段紧随初始标记阶段，在初始标记的基础上<strong>继续向下追溯标记</strong>。注意这里是<strong>并发标记</strong>，表示用户线程可以和GC线程一起并发执行，不需要暂停用户线程；<br>3.<strong>并发预清理阶段</strong>（Concurrent precleaning）：<br>JVM<strong>查找正在执行“并发标记”阶段时候进入老年代的对象</strong>。通过重新扫描，减少下一阶段的工作，提高了性能，因为下一阶段会STW影响用户进程；<br>4.<strong>重新标记阶段</strong>（<strong>有暂停</strong>）（STW remark）：这个阶段会再次暂停用户线程，重新从根对象开始查找并标记并发阶段结束后对象状态的更新导致遗漏的对象，并处理对象关联。这一次耗时会比“初始标记”更长，并且这个阶段可以并行标记；<br>5.<strong>并发清理阶段</strong>（Concurrent sweeping）：应用线程和GC清除线程可以一起并发执行；<br>6.<strong>并发重置阶段</strong>（Concurrent reset）：重置CMS收集器的数据结构，等待下一次垃圾回收。</p>
</blockquote>
<h4 id="CMS的缺陷"><a href="#CMS的缺陷" class="headerlink" title="CMS的缺陷"></a>CMS的缺陷</h4><blockquote>
<ul>
<li><strong>CPU敏感</strong>：在CMS的工作过程中大都是使用的并发方式，这样以来将会占用更多的CPU资源，也牺牲了一定的吞吐量；</li>
<li><strong>浮动垃圾</strong>：同样因为CMS的并发性，导致在进行垃圾回收的过程中仍然在进行着用户线程，同样需要不断的向堆中存入对象，这样也会出现新的垃圾，但是这样的垃圾只能等到下一次GC时才能清理，成为了浮动垃圾；</li>
<li><strong>内存碎片</strong>：由于CMS使用“标记-清理”算法，所以会有算法产生的缺陷就是内存碎片。不过CMS收集器做了一些小的优化，就是把未分配的空间汇总成一个列表，当有JVM需要分配内存空间的时候，会搜索这个列表找到符合条件的空间来存储这个对象。如果一个对象需要多块连续的空间来存储，但是因为内存碎片所以寻找不到这样的空间，就会导致Full GC，这样一来内存碎片的问题依然存在；</li>
<li><strong>堆空间要求更大</strong>：因为CMS是属于并发进行的，那么就会有堆空间继续分配的问题，为了保障CMS在回收堆空间之前还有空间分配给新加入的对象，<strong>必须预留一部分空间</strong>。CMS默认在老年代空间使用68%时候启动垃圾回收，可以通过-XX:CMSinitiatingOccupancyFraction=n来设置这个阀值。</li>
</ul>
</blockquote>
<h3 id="G1（Garbage-First）垃圾收集器"><a href="#G1（Garbage-First）垃圾收集器" class="headerlink" title="G1（Garbage-First）垃圾收集器"></a>G1（Garbage-First）垃圾收集器</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><blockquote>
<p>G1(Garbage First)垃圾收集器是当今垃圾回收技术最前沿的成果之一。早在JDK7就已加入JVM的收集器大家庭中，成为HotSpot重点发展的垃圾回收技术。同优秀的CMS垃圾回收器一样，G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。G1最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。</p>
</blockquote>
<h4 id="G1GC的相关术语"><a href="#G1GC的相关术语" class="headerlink" title="G1GC的相关术语"></a>G1GC的相关术语</h4><blockquote>
<ul>
<li>Region：G1垃圾收集器利用分而治之的思想将堆进行分区，划分为一个个的区域。每次收集的时候，只收集其中几个区域，以此来控制垃圾回收产生的STW,G1和其他GC算法最大的区别是<strong>弱化分代概念，引入分区思想</strong>，如果要另外选择分区的尺寸，可以通过命令行选项：-XX:G1HeapRegionSize=n中进行设置；<br><img src="https://wx1.sbimg.cn/2020/07/05/2V22Y.png" alt="2V22Y.png"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>RSet：G1垃圾收集器里每一个RSet对应的是一个Region中存活对象的指针。在标记存活对象的时候，G1使用RSet概念，将每个分区指向分区内的引用记录在该分区，<strong>避免对整个堆扫描</strong>，并行独立处理垃圾集合<br>老年代对年轻代的引用，维护老年代分区指向年轻代分区的指针<br>老年代对老年代的引用。在这里，老年代中不同分区的指针将被维护在老年代拥有分区的RSet中。<br><img src="https://wx1.sbimg.cn/2020/07/05/2VMVm.png" alt="2VMVm.png"><br>在图中，我们可以看到3各分区，x（年轻代分区）、y和z（老年代分区）。x有一个来自z的对内引用。这个引用记录在x的RSet中，分区z有2个对内引用，一个来自x一个来自y，因为年轻代分区作为一个整体回收的，所以只需记录来自y的对内引用，不用记录x的对内引用；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>CSet：Collection Set，简称CSet。在垃圾收集过程中收集的Region集合可以称为收集集合（CSet），也就是在垃圾收集暂停过程中被回收的目标。GC时在CSet中的所有存活数据都会被转移，分区释放回空闲分区队列。<br><img src="https://wx1.sbimg.cn/2020/07/05/2Vptd.png" alt="2Vptd.png"><br>如图所示，左边的年轻代收集CSet代表年轻代的一部分分区，右边的混合收集CSet代表年轻代的一部分区和老年代的多个分区；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>PLAB：Promotion Local Allocation Buffers，对象晋升到survivor分区或者老年代分区的过程是在GC线程的晋升本地分配缓冲区（PLAB）进行的，每个线程有独立的PLAB。作用是避免多线程竞争相同数据。和下面介绍的TLAB思想是一致的；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>TLAB：Thread Local Allocation Buffers，线程本地分配缓存。JVM使用了TLAB这种线程专属的区间来避免多线程冲突（无锁方式），提高对象分配效率。TLAB本身占用了Eden空间，即JVM会为每一个线程都分配一块TLAB空间；<br><img src="https://wx2.sbimg.cn/2020/07/05/2Vkl4.png" alt="2Vkl4.png"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>IHOP：InitiatingHeapOccupancyPercent，简称IHOP。缺省情况是Java堆内存的45%。当老年代的空间超过45%，G1会启动一次混合周期收集。这也是G1和CMS之间较大的区别，G1的百分比是相对于整个Java堆而言的，CMS（CMSInitiatingOccupancyFraction）仅仅是针对老年代空间的占比。这样设计的原因是因为G1没有固定物理上分割一块内存作为老年代，而是用了Region的思想，这些Region可能是eden，survivor、老年代或者巨型分区，所以获取针对老年代本身的占用百分比没有意义；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>巨型分区：巨型对象会以连续分区的形式来存放，这种就叫巨型分区。巨型对象无法利用年轻代里的TLAB和PLAB。在JDK 8u40之前，它只能在并发收集周期的清除阶段回收，但是在JDK 8u40之后，巨型分区可以在年轻代收集中和full GC被回收。</li>
</ul>
</blockquote>
<h4 id="G1的设计"><a href="#G1的设计" class="headerlink" title="G1的设计"></a>G1的设计</h4><blockquote>
<p>之所以会有G1是因为并发、并行和CMS垃圾收集器都有2个共同的问题：老年代收集器大部分操作都必须扫描整个老年代空间（标记，清除和压缩）。这就导致了GC随着Java堆空间而线性增加或减少年轻代和老年代是独立的连续内存块，所以要先决定年轻代和年老代放在虚拟地址空间的位置。</p>
</blockquote>
<p><strong>设计目标</strong></p>
<blockquote>
<p>G1的设计目标就是把必要的调整限定在以下2个：</p>
<ul>
<li>设置最大的Java堆空间</li>
<li>设置指定GC暂停时间   </li>
</ul>
</blockquote>
<blockquote>
<p>G1会通过调整Java堆尺寸大小来满足设定的暂停时间目标，暂停时间目标越短，年轻代空间越小，老年代空间相对越大.</p>
</blockquote>
<p><strong>使用场景</strong>　　</p>
<blockquote>
<p>G1 GC切分堆内存为多个区间（Region），从而避免很多GC操作在整个Java堆或者整个年轻代进行。G1 GC只关注你有没有存货对象，都会被回收并放入可用的Region队列。G1 GC是基于Region的GC，适用于大内存机器。即使内存很大，Region扫描，性能还是很高的。<strong>如果现在采用的收集器没有问题，就不要选择G1，如果追求低停顿，那么G1已经是一个可尝试的选择，如果追求吞吐量，就不要选G1了</strong></p>
</blockquote>
<h4 id="G1垃圾收集机制"><a href="#G1垃圾收集机制" class="headerlink" title="G1垃圾收集机制"></a>G1垃圾收集机制</h4><blockquote>
<p>G1的垃圾收集周期主要有4种类型：年轻代收集周期、多级并发标记周期、混合收集周期和full GC（转移失败的安全保护机制），这节以应用启动的时间顺序来讲，可以参照G1垃圾收集活动时序图：<br><img src="https://wx2.sbimg.cn/2020/07/05/2VCLA.png" alt="2VCLA.png"></p>
</blockquote>
<h5 id="年轻代收集"><a href="#年轻代收集" class="headerlink" title="年轻代收集"></a>年轻代收集</h5><blockquote>
<p>应用刚启动，慢慢流量进来，开始生成对象。G1会选一个分区并指定他为eden分区，当这块分区用满了之后，G1会选一个新的分区作为eden分区，这个操作会一直进行下去直到达到eden分区上限，也就是说<strong>eden分区已经被占满，那么会触发一次年轻代收集</strong>。年轻代收集首先做的就是迁移存活对象，它使用单eden，双survivor进行复制算法，它将存活的对象从eden分区转移到survivor分区，survivor分区内的某些对象达到了任期阈值之后，会晋升到老年代分区中。原有的年轻代分区会被整个回收掉。同时，年轻代收集还负责维护对象年龄，存活对象经历过年轻代收集总次数等信息。G1将晋升对象的尺寸总和和它们的年龄信息维护到年龄表中，结合年龄表、survivor占比（–XX:TargetSurvivorRatio 缺省50%）、最大任期阈值（–XX:MaxTenuringThreshold 缺省为15）来计算出一个合适的任期阈值。<strong>调优</strong>：我们可以通过–XX:MaxGCPauseMillis，调优年轻代收集，缩小暂停时间。</p>
</blockquote>
<h5 id="并发标记周期"><a href="#并发标记周期" class="headerlink" title="并发标记周期"></a>并发标记周期</h5><blockquote>
<p>随着时间推移，越来越多的对象晋升到老年代中，当老年代占比（相对于Java总堆而言）达到IHOP参数（上图的IHOP Trigger）之后，那么G1首先会触发并发标记周期（上图的Concurrent Marking Cycle），当完成后才会开始下一小节的混合垃圾收集周期<br>G1的并发标记循环分5个阶段：</p>
<ul>
<li>第一阶段：初始标记（上图Young Collection with Initial Mark），收集所有GC根（对象的起源指针，根引用），STW，在年轻代完成</li>
<li>第二阶段：根区间扫描，标记所有幸存者区间的对象引用</li>
<li>第三阶段：并发标记（上图Concurrent Marking），标记存活对象</li>
<li>第四阶段：重新标记（上图Remark），是最后一个标记阶段，STW，很短，完成所有标记工作</li>
<li>第五阶段：清除（上图Clean），回收没有存活对象的Region并加入可用Region队列</li>
</ul>
</blockquote>
<blockquote>
<p>调优：我们可以通过–XX:InitiatingHeapOccupancyPercent，配置适合应用的IHOP值（过大会可能转移失败，过小可能过早引起并发标记周期)。我们也可以通过–XX:ConcGCThreads，增加并发线程数</p>
</blockquote>
<h5 id="混合收集周期"><a href="#混合收集周期" class="headerlink" title="混合收集周期"></a>混合收集周期</h5><blockquote>
<p>当达到IHOP参数并完成上一小节的并发标记周期之后，混合收集周期就启动了，一个周期里的单次STW的混合收集和年轻代收集是类似的，唯一区别就是在混合收集过程中会包含一部分老年分区，所以也叫混合收集<br>看上图的Mixed Collection Cycle，中间有好几段Mixed Collection，说明混合收集周期包含多次收集次数。那么什么影响收集次数呢？是固定的？还是？有两个参数比较重要：</p>
<ul>
<li>XX:G1MixedGCCountTarget：缺省值为8，意思是能启动混合收集的数目设定一个物理限制。G1根据将回收的老年分区除以该参数值得到每次混合收集的老年代CSet最小数量</li>
<li>XX:G1HeapWastePercent：缺省值为5%，每次混合收集暂停，G1算出废物百分比，根据堆废物百分比，当收集达到参数时，不再启动新的混合收集</li>
</ul>
</blockquote>
<blockquote>
<p>调优：当暂停时间和运行时间呈现指数级增长，可以通过-XX:G1HeapWastePercent，调高该参数会有所帮助，但这也导致更多碎片化</p>
</blockquote>
<h5 id="full-GC"><a href="#full-GC" class="headerlink" title="full GC"></a>full GC</h5><blockquote>
<p>有2个条件同时满足则会触发full GC</p>
<ul>
<li>拷贝存活对象晋升（promotion）失败，无法找到可用的空闲分区，GC日志记录为to-space exhausted。或分配巨型对象无法在老年代找到连续足够的分区</li>
<li>当发生第一个条件后，G1会尝试增加堆使用量，如果扩展失败，那么会触发安全措施机制同时发生full GC<br><img src="https://wx1.sbimg.cn/2020/07/05/2VDiV.png" alt="2VDiV.png"><br>full GC中，单个线程会对整个堆的所有代中所有分区做标记、清除以及压缩动作！！非常非常昂贵的操作！</li>
</ul>
</blockquote>
<h2 id="整理总结"><a href="#整理总结" class="headerlink" title="整理总结"></a>整理总结</h2><blockquote>
<p>新生代收集器：</p>
<ul>
<li>Serial （-XX:+UseSerialGC）</li>
<li>ParNew（-XX:+UseParNewGC）</li>
<li>ParallelScavenge（-XX:+UseParallelGC）</li>
<li>G1 收集器</li>
</ul>
</blockquote>
<blockquote>
<p>老年代收集器：</p>
<ul>
<li>SerialOld（-XX:+UseSerialOldGC）</li>
<li>ParallelOld（-XX:+UseParallelOldGC）</li>
<li>CMS（-XX:+UseConcMarkSweepGC）</li>
<li>G1 收集器</li>
</ul>
</blockquote>
<blockquote>
<p>G1是一款非常优秀的垃圾收集器，不仅适合堆内存大的应用，同时也简化了调优的工作。通过主要的参数初始和最大堆空间、以及最大容忍的GC暂停目标，就能得到不错的性能；同时，我们也看到G1对内存空间的浪费较高，但通过<strong>首先收集尽可能多的垃圾(Garbage First)</strong>的设计原则，可以及时发现过期对象，从而让内存占用处于合理的水平。</p>
</blockquote>
<p>参考：<br><a href="https://zhuanlan.zhihu.com/p/25539690" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25539690</a><br><a href="https://blog.csdn.net/qq_36652619/article/details/90645422" target="_blank" rel="noopener">https://blog.csdn.net/qq_36652619/article/details/90645422</a><br><a href="https://www.cnblogs.com/GrimMjx/p/12234564.html" target="_blank" rel="noopener">https://www.cnblogs.com/GrimMjx/p/12234564.html</a> （G1垃圾收集器）<br><a href="https://blog.csdn.net/coderlius/article/details/79272773" target="_blank" rel="noopener">https://blog.csdn.net/coderlius/article/details/79272773</a></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM】内存模型</title>
    <url>/2020/07/03/%E3%80%90JVM%E3%80%91%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>JVM内存模型是JVM高效运行的基础，也是JVM核心部分，同样也是面试官手里的香饽饽，盘它不要犹豫(●･̆⍛･̆●)</strong></p>
<a id="more"></a>
<hr>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><blockquote>
<p>内存作为重要的系统资源，为硬盘和CPU的握手做了桥梁，JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行，不同的JVM对于内存的划分方式和管理机制存在着部分差异。为了直观感受，先上经典JVM内存模型的<strong>结构组成图</strong>。</p>
</blockquote>
<p><img src="https://wx1.sbimg.cn/2020/07/03/2UAF1.png" alt="2UAF1.png"></p>
<h2 id="区域解释"><a href="#区域解释" class="headerlink" title="区域解释"></a>区域解释</h2><h3 id="程序计数器（PC）"><a href="#程序计数器（PC）" class="headerlink" title="程序计数器（PC）"></a>程序计数器（PC）</h3><blockquote>
<p>便于记忆的说，PC就是一块内存区域，<strong>里面存放着下一条要执行的指令的地址，也就是当前所执行的字节码的行号指示区</strong>，它会告诉字节码解释器下一条要解释的字节码的行号，起到了一个定位作用，其中类似于分支、循环、跳转、异常处理、线程恢复等功能都是依赖于PC来完成的。由于PC是线程隔离的，所以它<strong>不仅可以实现代码的流程控制，而且在多线程的情况下，它还可以记录下当前线程的执行位置，以便于再次切换到线程时能够继续顺序执行</strong>。</p>
</blockquote>
<p>需要注意的是：程序计数器是唯不会出现 OutOfMemoryError 的内存区域，因为它的生命周期与线程保持同步，随着线程的创建而创建，随着线程的结束而死亡。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><blockquote>
<p>我们在JVM字节码执行机制中详细的讲述了关于线帧的内容，它包括了局部变量表、操作数栈、动态链接、方法出口信息的内容，这里虚拟机栈就是线帧作为组成成分的栈结构，所以在方法执行中，虚拟机栈就是运用压栈出栈的方式对方法的执行进行控制，对于具体的操作流程这里不再赘述，不清楚这一块内容的小伙伴可以看往期blog《【JVM】字节码执行机制》或直接点击<a href="http://www.easonhe.top/2020/07/02/%E3%80%90JVM%E3%80%91%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<blockquote>
<p>虚拟机栈是JVM内存模型中非常重要的一个角色，关于它我们还需要注意的是虚拟机栈会出现的两种异常问题：</p>
<ol>
<li>StackOverFlowError:如果虚拟机栈的大小不允许动态扩展，那么如果当前线程请求超过了虚拟机栈的最大深度，那么将会抛出此异常；   </li>
<li>OutOfMemeoryError:如果虚拟机栈的大小允许动态扩展，那么如果当前线程请求栈时内存已经用尽，那么将会抛出此异常。</li>
</ol>
</blockquote>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote>
<p>本地方法栈不仅在名字上与虚拟机栈相似，他们的作用也非常的相似，<strong>本地方法栈与虚拟机栈的运作方式基本相同</strong>，包括可能抛出的两种异常。<strong>虚拟机栈主要是为了虚拟机执行字节码服务，而本地方法栈服务的是虚拟机使用native方法</strong>，在<a href="https://blog.csdn.net/tianshuhao/article/details/89819214" target="_blank" rel="noopener">HotSpot虚拟机</a>中与Java虚拟机相融合.</p>
</blockquote>
<p>关于native方法：</p>
<blockquote>
<p>简单来说native方法就是一个不是使用Java代码编写的但是Java需要使用的这么一个方法，这个方法的接口并非Java代码的接口，也就是说<strong>native是用作Java和其他语言协作时使用到的方法</strong>。这个特性在很多种语言中都支持，这种是Java底层的机制，实际上Java的平台无关性很大程度上就是在不同的平台上调用不同的native方法实现对操作系统的访问的。正是因为非Java接口所以<strong>native方法是由操作系统实现的</strong>，Java虚拟机只进行调用就可以了。</p>
</blockquote>
<h3 id="Java堆（heap）"><a href="#Java堆（heap）" class="headerlink" title="Java堆（heap）"></a>Java堆（heap）</h3><blockquote>
<ol>
<li>Java堆作为线程共享的数据区，所以它作为JVM所管理的最大的最大的一块内存，它可以供几乎所有类实例对象与数组对象分配内存，但是如果无节制的大量创建对象，那么将会消耗完内存空间，所以Java堆也是OOM异常出现的主要发源地;   </li>
<li>由于Java堆的特点，Java堆也是垃圾收集器主要管理的区域，所以也被成错Garbage Collected Heap（GC堆）;   </li>
<li>堆内存既可以固定大小也可以动态调整，但是通常情况下，在服务器运行的过程中，堆内存不断的进行扩容或收缩形成了不必要的系统压力，所以一般在线上生产环境中会给堆内存设置固定大小，避免了在GC后调整堆内存大小所带来的不必要的压力</li>
<li>从GC的角度来说，现在的垃圾收集器一般均采用分代垃圾收集算法，所以java堆又分成了新生代和老年代的空间。</li>
</ol>
</blockquote>
<p>在Java堆中新生代和老年代之间的运作关系很有意思，这里着重的说一下：</p>
<blockquote>
<p>新生代：<strong>1个Eden(伊甸园）区+2个Survivor（幸存者）区；其中绝大部分的对象的生成是在Eden区，当Eden区已满后将会触发GC垃圾回收机制，经过GC垃圾回收后只有少量对象可以存活（被引用的对象）然后被复制到其中的一个Survivor区，每次GC的时候，将存活的对象复制到未使用的那块Survivor空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态，如果YGC要移送的对象大于Survivor区容量上限，则直接移交给老年代。并且重要的是对象是不可以在两个Survuvir区一直交换的，因为每进行一次交换就要将对象的1个计数器的值+1，也就是“年龄”+1，当年龄到达某个阀值的时候就会自动进入老年代</strong></p>
</blockquote>
<blockquote>
<p>老年代：在新生代经历了多次GC回收后仍然存活的对象都放在了此区域，这个区域存放的对象存活率非常高，所以对于老年代的GC机制又被称为Major GC（老年代的垃圾回收），<strong>MGC通常使用的算法是“标记-清理”或者“标记-整理”的算法</strong>，其中整堆回收的机制也被成为Full GC（包括新生代）</p>
</blockquote>
<blockquote>
<p>永久代（Perm区）：故名思议这里主要存放的是例如Class、Method的元信息，由于GC主要回收的是Java对象所以这里相对于Young Generation和Old Generation来说受GC影响是很小的（<strong>JDK 1.8之后此区域已经被替换成了物理内存中的元空间区域</strong>）</p>
</blockquote>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote>
<p>方法区用于<strong>存放已经被虚拟机加载的类的信息、常量、静态变量、JIT编译后的代码等等</strong>，虽然它在逻辑上也是堆的一部分，但是方法区还有一个别名叫做Non-Heap（非堆），目的就是为了与堆区分开来。对于它存放的这些数据的特点简单的虚拟机实现<strong>可以不在这个区域进行垃圾收集</strong>，方法区和堆一样在实际内存中的存储可以是不连续的，这个区域存放的数据一般都<strong>长期存在</strong>，在这个区域垃圾回收主要也就是对于常量池的回收和类型的卸载，也同堆一样可以根据需求动态扩充和收缩内存大小也可以固定大小，如果内存不足也将抛出OutOfMemory异常。</p>
</blockquote>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><blockquote>
<p>虽然直接内存并不是实际JVM运行时内存区的一部分，他是利用了本地方法在Java堆之外申请的内存区域，但是这部分内存也将会被频繁的使用并且也会抛出OOM异常，JVM通过一个存储在Java堆中的 DirectByteBuffer对象作为这块内存的引用并进行操作，这样一来，就可以<strong>避免在Java堆和Native堆之间频繁的复制数据</strong>，就能在一些场景中显著提高性能。</p>
</blockquote>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><blockquote>
<p>运行时常量池是JVM内存模型方法区中的一部分，java文件被编译之后生成的class文件中除了包含：类的版本、字段、方法、接口等信息外，还有一项就是常量池，在类和接口被加载到虚拟机中之后对应的运行时常量池也就被创建了出来，Class文件中除了有类的版本、字段、方法、接口等描述信息外,还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入运行时常量池中存放。运行期间也可能将新的常量放入池中。当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用，那么就需要垃圾收集器回收。它也有可能抛出OOM异常。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM】字节码执行机制</title>
    <url>/2020/07/02/%E3%80%90JVM%E3%80%91%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><strong>本篇字节码执行机制将深入了解JVM字节码执行引擎在运行中怎么做( ∙̆ .̯ ∙̆ )</strong></p>
<a id="more"></a>
<h2 id="JVM字节码执行引擎概念"><a href="#JVM字节码执行引擎概念" class="headerlink" title="JVM字节码执行引擎概念"></a>JVM字节码执行引擎概念</h2><blockquote>
<p>作为JVM最为核心的组成部分，JVM执行引擎的工作方式本身就非常类似于真正物理机的编译以及汇编语言的执行机理，JVM执行引擎可以自己制定指令集和执行结构体系，很多不能被硬件所直接支持的指令集在执行引擎里也能够执行，这都是执行引擎自己所实现的，一般看来，<strong>所有的Java虚拟机的执行引擎都是将输入的字节码文件经过字节码解析过程从而得到执行结果的过程</strong>。<strong>字节码作为JVM的指令集，它需要JVM执行引擎去执行，达到从本地机器码到字节码的编译结果</strong>，这看似只是存储格式的转变，但这却深深的影响了编程语言。</p>
</blockquote>
<h2 id="线帧"><a href="#线帧" class="headerlink" title="线帧"></a>线帧</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>线帧（Stack Frame）是一种用于支持虚拟机进行方法调用和方法执行的数据结构，<strong>它是虚拟机运行时数据区中虚拟机栈的栈元素</strong>线帧作为栈元素并且能支持虚拟机对方法的相关操作自然包含了很多数据元素，也就是说，每一个方法的被调用到结束都对应着一个线帧从入栈到出栈的过程。</p>
</blockquote>
<p>在方法调用到结束的过程中还有一些相关概念</p>
<blockquote>
<p><strong>一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的</strong>,每当一个线程启动时，JVM都会为它分配一个栈，栈的单位是帧，并且它负责保存当前线程的运行状态，其中某个线程正在执行的方法就称为<strong>当前方法</strong>，当前方法所用到的帧称为<strong>当前帧</strong>，这个方法所属的类就被称作<strong>当前类</strong>，当前所用到的常量池成为<strong>当前常量池</strong>，所以在一个线程执行方法时就会追踪当前常量池。线帧作为当前方法所分配的一个帧，于是也就成了当前帧，这个帧就被用来存储当前方法的相关数据流被压入虚拟机栈中。</p>
</blockquote>
<p>概括的说</p>
<blockquote>
<p>栈是用来保存当前线程的运行状态的，而帧是用来保存当前方法的运行状态的，也就是线程中依次运行不同方法对应着帧的入栈和出栈   </p>
</blockquote>
<h3 id="组成成分"><a href="#组成成分" class="headerlink" title="组成成分"></a>组成成分</h3><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>相关概念：</p>
<blockquote>
<p>局部变量表的容量是<strong>容量槽slot</strong>为最小单位，一个slot大小为32bit，所以在<strong>64位的虚拟机</strong>中需要使用<strong>对齐补白</strong>的手段来使得使得容量槽slot在外观上看起来和32位的虚拟机保持一致，所以说对于<strong>64位的数据如long，double都需要使用两个容量槽slot去存储</strong>，并且在任何时候都不允许<strong>单独访问</strong>其中的一个。局部变量表的大小是在编译期间可以查询到的，因为它是作为方法的对应属性里的数据max_local数据项中存储的，也就是编译class文件的过程中，这个最大的需要分配变量的局部变量表的最大存储容量就已经确定了。</p>
</blockquote>
<p>局部变量表的顺序：</p>
<blockquote>
<p>变量表的索引从0开始，首先是方法所属的对象的引用（静态方法无）-&gt;其次是方法的参数变量（按照声明的顺序）-&gt;再者是方法的内部的局部变量（按照声明的顺序）。并且对于byte char short这三种数据类型需要转化为int类型存储在局部变量表中</p>
</blockquote>
<p>其他性质：</p>
<blockquote>
<p>在类被JVM加载时会为类变量赋初值，但是局部变量若声明了但却未赋初值是会出现编译错误的并且slot对于局部变量中没有覆盖整个方法的作用域的变量是可重用的。对于可重用的slot，如果后面没有在定义变量对这个slot进行覆盖，即使这个变量已经无效，那么这个变量在方法体内也不会被回收，除非解释执行的时候显示的赋值为null，但是在JIT编译器优化后赋值为null的操作就会被消除掉，这时候将变量设置为null就没有意义了。</p>
</blockquote>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>一些操作性质：</p>
<blockquote>
<p>操作数栈和局部变量表一样都是编译期间，操作数栈的最大深度在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的元素不明确Java的数据类型，也就是说在所有Java数据类型中，32位数据容量为1,64位数据容量为2，   </p>
</blockquote>
<p>其他性质：</p>
<blockquote>
<p>在概念模型中，一个县城的两个栈帧是相互独立的，但是在虚拟机实现中都会做一些优化处理，让两个栈帧出现一部分重叠，也就是让下面栈帧的部分操作数栈与上面的栈帧的部分局部变量表互相重重叠，这样在进行方法调用时就会公用一部分数据，无需进行额外的参数复制，达到了一定的优化效果。java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中栈指的就是操作数栈。</p>
</blockquote>
<h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><blockquote>
<p>栈帧包含了一个指向运行时常量池中该栈帧所属方法的引用，这个引用是为了支持方法调用过程中的<strong>动态连接</strong>。常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用有些会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外的符号引用将在每一次<strong>运行期间</strong>转化为直接引用，这部分称为<strong>动态解析</strong>。</p>
</blockquote>
<h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><blockquote>
<p>无论是正常完成退出方法还是异常完成退出方法，都需要返回到方法被调用的位置，才能将程序正常进行下去，方法正常退出时，PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值；方法异常退出时，要通过异常处理器表来确定返回的地址，栈帧中一般不会保存这部分信息。方法退出相当于把当前栈帧出栈，所以方法退出时可能执行恢复上层方法的局部变量表和操作数栈的操作和把返回值（如果存在）压入调用者栈帧的操作数栈中的操作以及调整PC计数器的值以指向方法调用指令后面的一条指令的操作。</p>
</blockquote>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p><img src="https://wx2.sbimg.cn/2020/07/02/2YjyJ.png" alt="2YjyJ.png"></p>
<h3 id="解析调用"><a href="#解析调用" class="headerlink" title="解析调用"></a>解析调用</h3><blockquote>
<p>我们知道，在类加载过程中有解析阶段，在这个阶段中，类文件的一部分符号引用会转化为直接引用，这么做主要是因为<strong>方法在真正的执行前就已经有了一个可确定的调用版本，并且这个版本在运行期间是不可变的</strong>，这类方法的调用就称作解析调用。并且满足条件的这类方法叫做<strong>非虚方法</strong>主要有静态方法、私有方法、父类方法、final类方法、实例构造器方法，其他的不满足这样过程的条件都称为<strong>虚方法</strong></p>
</blockquote>
<h2 id="分派与多态"><a href="#分派与多态" class="headerlink" title="分派与多态"></a>分派与多态</h2><h3 id="静态分派与重载"><a href="#静态分派与重载" class="headerlink" title="静态分派与重载"></a>静态分派与重载</h3><blockquote>
<p>重载是指方法名是相同的但是方法签名不同的情况，调用时使用<strong>方法签名</strong>来判断调用哪个具体方法，<strong>JVM在重载时是通过静态类型作为判断依据</strong>，所以javac编译器会根据参数的静态类型来决定选择哪个版本的方法，<strong>静态分派发生在编译阶段</strong>，因此确定静态分派的动作实际上不是有虚拟机来执行的。</p>
</blockquote>
<p>Java静态类型与实际类型的相关解释可以参考上一篇博客或直接点击<a href="http://www.easonhe.top/2020/07/02/%E3%80%90Java%E3%80%91%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">传送门</a></p>
<h4 id="方法签名的解释"><a href="#方法签名的解释" class="headerlink" title="方法签名的解释"></a>方法签名的解释</h4><blockquote>
<p><strong>方法头指定修饰符、返回值类型、方法名、和形式参数</strong>。方法头中定义的变量称为形参 ，形参如同占位符。当方法被调用时，传递一个值给形参，此值称为实参，形参列表指的是形参的类型、顺序和形参的数目。<strong>方法签名就是方法名和形参列表共同组成的</strong>。</p>
</blockquote>
<h3 id="动态分配与重写"><a href="#动态分配与重写" class="headerlink" title="动态分配与重写"></a>动态分配与重写</h3><blockquote>
<p>重写是指方法名和方法签名都相同的子类重写父类的方法，但是需要注意的是静态方法可以重载但是重写是无效的，因为在调用的过程中<strong>通过子类的实例对象调用就是调用子类的静态方法，通过父类的实例对象调用则调用父类的静态方法</strong></p>
</blockquote>
<blockquote>
<p>动态分派和多态重写的本质与<strong>字节码指令invokevirtual的多态查找过程</strong>相关：1.找到栈顶元素所指向的对象的实际类型，记为C；2. 在类型C中找到与常量池中的描述符与简单名称都相符的方法，然后进行访问权限检查，如果通过则返回这个方法的直接引用，查找结束；如果不通过，则返回java.lang.IllegalAccessError异常。3.否则，按照继承关系，继续重复2中搜索和验证过程。4.如果始终没有找到，则抛出java.lang.AbstractMethodError异常。这里注意，<strong>重写的本质其实就是invokevirtual指令把常量池中的符号引用解析到了不同的实际类型的直接引用上</strong></p>
</blockquote>
<p>用代码实例验证一下动态分配与静态方法重写问题：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"><span class="comment">//动态分配与静态方法重写的测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text1</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Father say Hi"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Father static"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="title">extends</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Son say Hi"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Son static"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Daughter</span> <span class="title">extends</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Daughter say Hi"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Daughter static"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"动态分配测试"</span>);</span><br><span class="line">		Father s = <span class="keyword">new</span> Son();</span><br><span class="line">		Father d = <span class="keyword">new</span> Daughter();</span><br><span class="line">		s.sayHi();</span><br><span class="line">		d.sayHi();</span><br><span class="line">		s = <span class="keyword">new</span> Daughter();</span><br><span class="line">		s.sayHi();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"静态方法重写测试"</span>);</span><br><span class="line">		s.testStatic();</span><br><span class="line">		d.testStatic();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>动态分配测试<br>Son say Hi<br>Daughter say Hi<br>Daughter say Hi<br>静态方法重写测试<br>Father static<br>Father static   </p>
</blockquote>
<p>这里需要注意的是：</p>
<blockquote>
<p>分派与解析并不是说只能选一个的问题，只是它们在不同的阶段不同层次上筛选和确定目标的过程，就比如静态方法在类加载过程的解析中就进行了解析，但若静态方法含有重载的版本那么这将在静态分派中完成选择问题。</p>
</blockquote>
<h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><blockquote>
<p>动态分派时为了避免频繁的搜索，会为类在方法区建立一个虚方法表，利用索引来代替元数据查找从而提高性能。<strong>虚方法表中存放着各个方法的实际入口地址</strong>。如果某个方法在子类中没有重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口，如果子类中重写了这个方法，那么子类对应的方法的地址将会替代指向父类方法的入口地址。具有相同方法签名的父类、子类的方法在父类和子类的虚方法表中具有相同的索引序号，这样当类型变换时，仅需要变更查找的方法表。</p>
</blockquote>
<h2 id="解释执行与直接执行"><a href="#解释执行与直接执行" class="headerlink" title="解释执行与直接执行"></a>解释执行与直接执行</h2><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><blockquote>
<p>解释器是将平台无关的字节码（原本由javac将java文件编译为class文件，并将源代码编译成了与平台无关的字节码）解释称对应平台的机器码解释执行</p>
</blockquote>
<h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><blockquote>
<p>（即时编译器）是一个把Java的字节码（包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序。JVM对这个函数就不再解释而是直接执行</p>
</blockquote>
<h3 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h3><blockquote>
<p>用户模式下:解释执行的。<br>server模式下：先解释执行，然后JVM统计函数执行热点，将这些热点代码仔细优化编译成本地机器码(默认为调用10000次以上)，即使用JIT编译器，当这个热点不再是热点的时候，重新解释执行。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM】类文件结构</title>
    <url>/2020/06/29/%E3%80%90JVM%E3%80%91%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><strong>学习JVM居然能忽略类文件结构？不存在的！类文件结构作为理解JVM入门级的垫脚石，你不能不清楚它的存在及意义 °(°ˊДˋ°) °</strong></p>
<a id="more"></a>
<hr>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>如今的计算机仍然只能识别0和1，但将我们编写的程序编译成二进制本地机器码已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、 平台中立的格式作为程序编译后的存储格式。各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石，而且语言无关性正越来越被开发者所重视。Java虚拟机不和包括Java在内的任何语言绑定，它只与Class文件这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。</p>
<hr>
<h2 id="类文件结构的相关概念与属性"><a href="#类文件结构的相关概念与属性" class="headerlink" title="类文件结构的相关概念与属性"></a>类文件结构的相关概念与属性</h2><h3 id="类文件定义"><a href="#类文件定义" class="headerlink" title="类文件定义"></a>类文件定义</h3><blockquote>
<p>Class文件是一组以8位字节为基础单位的二进制流，各项数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，如果是超过8位字节以上空间的数据项，则会按照高位在前的方式（Big-Endian）分割成若干个8位字节进行存储。    </p>
</blockquote>
<p>来看一个类文件二进制流实例：</p>
<p><img src="https://wx2.sbimg.cn/2020/06/29/2jo44.png" alt="2jo44.png"><br><strong>其中一个字节为2位16进制数，图中的‘cafe’就是为两个字节</strong>   </p>
<h3 id="魔数与文件版本"><a href="#魔数与文件版本" class="headerlink" title="魔数与文件版本"></a>魔数与文件版本</h3><blockquote>
<p><strong>魔数</strong>是每个class文件的4个字节组成的数，如图中的‘cafe babe’就是魔数，魔数的唯一作用就是用来判断此class文件是否是能被虚拟机接受的文件。很多种文件都是用到了魔数进行文件类别的识别，如：.gif, .jpeg等   </p>
</blockquote>
<blockquote>
<p><strong>文件版本</strong>号就是紧跟在魔数后的四个字节，其中，第5 6个字节表示的是次版本号，第7 8个字节表示的是主版本号。如图中的0000为次版本号，0034为主版本号，Java的版本号是从45开始的，JDK1.1之后每个JDK大版本发布，其主版本号就向上加1，这就让高版本的JDK能向下兼容低版本的class文件，但是不能向上兼容高版本的class文件，因为<em>虚拟机是拒绝执行超过它版本号的class文件</em>。</p>
</blockquote>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><blockquote>
<p>常量池的入口紧跟在主次版本号之后，<strong>向后的两个字节为常量池的个数，再向后就是从常量1….到常量n</strong>,常量池是class文件的数据仓库，也是占用class文件空间最大的数据项目之一，它是与class文件的其他项目关联最多的数据类型。<br>常量池中主要存放着<strong><em>两大元素</em></strong>：    </p>
<ol>
<li><strong>字面量</strong>：类似于常量概念，如final修饰的常量值等等   </li>
<li><strong>符号引用</strong>：包含类和进口的全限定名、字段的名称和描述符、方法的名称和描述符这三种常量，属于编译方面的概念。</li>
</ol>
</blockquote>
<p>当JVM运行时，需要从常量池中获取对应的符号引用，然后在类创建或运行时进行解析，得到真正的内存地址。</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><blockquote>
<p>访问标志是在常量池继续向后的两个字节，这个标志（access-flags）表示一些类或接口的访问信息，比如，这个Class是一个类呢还是一个接口呢，它是被什么限定符所修饰的？public？abstract？final？这些都在访问标志中被标明。</p>
</blockquote>
<h3 id="类索引-父索引-接口索引"><a href="#类索引-父索引-接口索引" class="headerlink" title="类索引-父索引-接口索引"></a>类索引-父索引-接口索引</h3><blockquote>
<p>类索引（this_class）与父索引（super_class）都是一个两个字节的数据集合，因为Java的单一继承所以让类索引和父索引只能有一个，以此类推，接口索引就不再只是一个两个字节的数据集合了，而是一组两个字节的数据集合，前两个字节代表着接口索引的个数，后面的字节分别就代表了接口1….接口n，其中<strong><em>类索引是用来确定这个类的全限定名，父所以与接口索引用来确定这个类的继承连接关系</em></strong>，接口索引的顺序是按照implements（或extends）后的顺序以此展开的。</p>
</blockquote>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><blockquote>
<p>字段表中存放用于描述类或接口中声明的变量信息，也是由一个两个字节的数据表示字段个数后面字节代表字段1….字段n，其中包括类级和实例级变量（static修饰符来区分）但是其中<strong>不包括局部变量也不包括从超类或父类中继承来的字段</strong>，还有一些是有着特殊含义的字段，如内部类通常会添加指向外部类的字段用来保持对外部类的访问性。其中<strong>字段的通常信息</strong>包括：   </p>
<ol>
<li>字段的作用域（public protected private default修饰符区分）；   </li>
<li>变量的级别（类级变量或实例级变量）；   </li>
<li>可变性（final修饰符区分）；   </li>
<li>并发可见性（volatile修饰符）；   </li>
<li>可否序列化（reansient修饰符）；   </li>
<li>字段的数据类型（int char double float等修饰符）；    </li>
<li>字段的名称等等。</li>
</ol>
</blockquote>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><blockquote>
<p>与字段表一致的是方法集合在class文件中采用了相同的存储方式，也是由一个两个字节的数据表示方法个数后面字节代表方法1….方法n，其中方法表的集合的信息通常包含：</p>
<ol>
<li>访问标志（access_flags）；   </li>
<li>名称索引（name_index）；   </li>
<li>描述符索引（descriptor_index）；   </li>
<li>属性表集合（attributes）这个里面包含的是类文件方法里的Java代码经过虚拟机编译后的<strong>字节码指令</strong>，这些指令都被放在了一个叫属性表的集合里面的“code”属性里。</li>
</ol>
</blockquote>
<p>解释一下字节码指令：字节码指令是指JVM的指令由一个字节长度的、代表着某种特定操作含义的数字（操作码，Opcode）以及跟随其后的0至多个爱表此操作所需参数（操作数，Operands）构成。字节码指令集是一种具有鲜明特点、优劣势都很突出的指令集架构，由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不可能超过256 条；又由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构。</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><blockquote>
<p>在class 文件、字段表、方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息，它也是由一个两个字节的数据表示属性个数后面字节代表属性1….方属性n。其中的属性包括：</p>
<ol>
<li><strong>code属性</strong>：这个在方法表集合中提到过，类文件方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。但是要注意，抽象类和接口的方法是没有code属性的；</li>
<li><strong>Exception属性</strong>：这个应该是很常见的，这个是一个异常类的统称，Exception属性就是用来列举出方法中可能抛出的（thorows关键字后的）受检查异常；</li>
<li><strong>LineNumberTable属性</strong>：用于描述 Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，但默认会生成到 Class 文件之中，可以在 javac 中分别使用 -g:none 或 -g:lines选项来取消或要求生成这项信息。如果选择不生成LineNumberTable 属性，对程序运行产生的最主要的影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。</li>
<li><strong>LocalVariableTable属性</strong>:用于描述栈帧中局部变量表中的变量与 Java 源码中定义的变量之间的关系,它也不是运行时必需的属性，但默认会生成到 Class 文件之中，可以在 Javac 中分别使用 -g:none 或 -g:vars 选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，IDE 将会使用诸如 arg0、arg1 之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不变，而且在调试期间无法根据参数名称从上下文获得参数值。</li>
<li><strong>SourceFile属性</strong>:用于记录生成这个 Class 文件的源码文件名称。这个属性也是可选的，可以分别使用 javac 的 -g:none 或 -g:source 选项来关闭或要求生成这项信息。在 Java 中，对于大多数的类来说，类名和文件名是一致的，但是又一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。</li>
<li><strong>ConstantValue属性</strong>:作用是通知虚拟机自动为静态变量赋值。只有被 static 关键字修饰的变量（类变量）才可以使用这项属性。类似 “int x = 1” 和 “static int x = 1” 这样的变量定义在 Java 程序中是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。对于非 static 类型的变量（也就是实例变量）的赋值是在实例构造器 <init> 方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器 <clinit> 方法中或者使用 ConstantValue 属性。目前 Sun Javac 编译器的选择是：如果同时使用 final 和 static 来修饰一个变量（按照习惯，这里称 “常量” 更贴切），并且这个变量的数据类型是基本类型或者 java.lang.String 的话，就生成 ConstantValue 属性来进行初始化，如果这个变量没有被 final 修饰，或者并非基本类型及字符串，则将会选择在 <clinit> 方法中进行初始化。</li>
<li><strong>InnerClass属性</strong>:用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成 InnerClass 属性。</li>
<li><strong>Deprecated和Synthetic属性</strong>：Deprecated 和 Synthetic 两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。Deprecated 属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过在代码中使用 @deprecated 注释进行设置。<br>Synthetic 属性代表此字段或者方法并不是由 Java 源码直接产生的，而是由编译器自行添加的，在 JDK 1.5 之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的 ACC_SYNTHETIC 标志位，其中最典型的例子就是 Bridge Method。所有由非用户代码产生的类、方法及字段都应当至少设置 Synthetic 属性和 ACC_SYNTHETIC 标志位中的一项，唯一的例外是实例构造器 “<init>” 方法和类构造器 “<clinit>” 方法。</li>
<li><strong>StackMapTable属性</strong>:在 JDK 1.6 发布后增加到了 Class 文件规范中，它是一个复杂的变长属性，位于 Code 属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</li>
<li><strong>Signature属性</strong>:在 JDK 1.5 发布后增加到了 Class 文件规范之中，它是一个可选的定长属性，可以出现于类、属性表和方法表结构的属性表中。在 JDK 1.5 中大幅增强了 Java 语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则 Signature 属性会为它记录泛型签名信息。之所以要专门使用这样一个属性去记录泛型类型，是因为 Java 语言的泛型采用的是擦除法实现的伪泛型，在字节码（Code 属性）中，泛型信息编译（类型变量、参数化类型）之后都通通被擦除掉。使用擦除法的好处是实现简单（主要修改 Javac 编译器，虚拟机内部只做了很少的改动）、非常容易实现 backport，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像 C# 等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得泛型信息。Signature 属性就是为了弥补这个缺陷而增设的，现在 Java 的反射 API 能够获取泛型类型，最终的数据来源也就是这个属性。</li>
<li><strong>BootstrapMethods属性</strong>:在 JDK 1.7 发布后增加到了 Class 文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存 invokedynamic 指令引用的引导方法限定符。</li>
</ol>
</blockquote>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Java类文件结构是java技术体系的重要基础之一，类文件是JVM对于编译首先要识别的入口，这是个数据和指令的开端，所以想要深入理解Java虚拟机，就不能不对class文件结构进行一个详细的认知。</p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM】类加载机制</title>
    <url>/2020/06/30/%E3%80%90JVM%E3%80%91%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><strong>类加载机制作为Java虚拟机最基础的部分，在学习Java语言是不容忽略的一部分，懂得类加载机制才是深入理解JVM的敲门砖，加油ヽ(.◕ฺˇд ˇ◕ฺ;)ﾉ</strong></p>
<a id="more"></a>
<hr>
<h2 id="什么是类加载机制"><a href="#什么是类加载机制" class="headerlink" title="什么是类加载机制"></a>什么是类加载机制</h2><blockquote>
<p>类加载机制是指将类的.class文件的二进制数据读取到运行时的<strong>数据区的方法区</strong>内,然后在<strong>堆区</strong>内创建一个java.lang.Class对象,用来封装类在方法区内的数据结构,类的加载的最终产品就是位于堆中的Class对象,对象向用户提供了访问方法区内的数据结构的接口。</p>
</blockquote>
<hr>
<h2 id="类加载机制的过程"><a href="#类加载机制的过程" class="headerlink" title="类加载机制的过程"></a>类加载机制的过程</h2><p><img src="https://wx2.sbimg.cn/2020/06/28/2d57R.png" alt="2d57R.png"></p>
<p>类的加载过程分为了五个过程：加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化，其中(验证准备和解析)三个阶段也被成为连接阶段,<strong>这几个阶段是按顺序开始，而并不是按顺序完成，往往这些阶段会交叉的混合运行，一般在某个阶段运行过程中去调用激活另一个阶段</strong>，这里需要注意的是这五个阶段中有四个阶段的发生顺序是确定的（加载-&gt;验证-&gt;准备-&gt;初始化）,但是解析并非一定在顺序中,它有时会在初始化过程之后,这样的目的是为了支持Java语言的动态绑定。接下来我们分别来看一个类加载过程中的每个阶段的内容：</p>
<h3 id="加载（查找并获取字节流）"><a href="#加载（查找并获取字节流）" class="headerlink" title="加载（查找并获取字节流）"></a>加载（<strong><em>查找并获取字节流</em></strong>）</h3><blockquote>
<ol>
<li>通过类的全限定名来获取其定义的二进制字节流；    </li>
<li>将这个字节流所代表的静态存储结构转为方法的运行时的数据结构；</li>
<li>在Java堆中生成一个代表这个类的Java.lang.Class对象，作为方法区中这些数据的访问入口。   </li>
</ol>
</blockquote>
<p>这几个步骤是JVM需要在这个阶段完成的三件事情，相比于其他几个阶段来说，<strong>加载阶段（准确的说应该是加载获取类的二进制字节流的动作）是可控性最强的阶段</strong>，因为在这个阶段，开发人员可以利用系统提供的类加载器来加载，也可以使用自己定义的类加载器进行加载。<strong>加载阶段完成后JVM外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，并且创建了一个对应的java.lang.Class对象，用来访问这些数据</strong>。加载的具体方式和类加载器在后面的模块中解释。   </p>
<h3 id="验证（确保类加载的正确性）"><a href="#验证（确保类加载的正确性）" class="headerlink" title="验证（确保类加载的正确性）"></a>验证（<strong><em>确保类加载的正确性</em></strong>）</h3><blockquote>
<ol>
<li>文件格式验证：验证字节流是否符合文件的规范；   </li>
<li>元数据验证：对字节码的描述的信息进行语义分析，以保证其描述的信息符合语言规范的要求；</li>
<li>字节码验证：通过数据流和控制流分析，保证程序的语义合法逻辑；</li>
<li>符号引用验证：确保解析动作能够正确执行。   </li>
</ol>
</blockquote>
<p><strong>验证是连接阶段的第一步，这一步是为了确认Class文件字节流符合当前JVM的需求，并且不会危害到JVM本身的安全</strong>，所以进行了如上四个方面的验证动作，值得注意的是，<em>验证并不是必需的阶段，它不会影响到程序的运行，所以如果类进行了反复的验证，那么完全可以通过参数Xverifynone来关闭大部分的验证措施，从而缩短虚拟机加载类的时长。</em></p>
<h3 id="准备（为静态变量分配内存和初始化）"><a href="#准备（为静态变量分配内存和初始化）" class="headerlink" title="准备（为静态变量分配内存和初始化）"></a>准备（<strong><em>为静态变量分配内存和初始化</em></strong>）</h3><p><strong>准备阶段是为类的静态变量分配内存，并将其初始化为默认值</strong>，但是要注意：</p>
<blockquote>
<ol>
<li><em>这里分配内存仅是为类的静态变量，并不包括类中的实例变量，这个将在以后的对象实例化中分配到堆中</em>；</li>
<li><em>这里所说的初始化为默认值是指将对应的变量类型赋予对应的0值，如0、null、false等，而不是初始化为用户设置的变量值，将变量赋值为用户定义数值是在初始化阶段才做的工作</em>;  </li>
<li>全局变量如果没有显示的对其赋值，那么在使用时将会用到准备阶段为其赋予的0值，当然局部变量必须显示的赋值，否则编译是不通过的；</li>
<li>对于引用类型来说，如数组的引用或对象的引用，如果都没有对其进行显示的赋值而使用，那么都将用到系统为其赋予的0值null；</li>
<li>同时被static与final修饰的值将在此阶段就被赋予显示的初始值，也就是在编译期间就已经将其结果放到了调用它的类的常量池中了。</li>
</ol>
</blockquote>
<h3 id="解析（符号引用转为直接引用）"><a href="#解析（符号引用转为直接引用）" class="headerlink" title="解析（符号引用转为直接引用）"></a>解析（<strong><em>符号引用转为直接引用</em></strong>）</h3><p>解析阶段是虚拟机将常量池中的符号引用（<em>主要是类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符7种</em>）转化为直接引用的过程。其中直接引用就是一个直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p>
<h3 id="初始化（为类的静态变量赋予真正的初始值）"><a href="#初始化（为类的静态变量赋予真正的初始值）" class="headerlink" title="初始化（为类的静态变量赋予真正的初始值）"></a>初始化（<strong><em>为类的静态变量赋予真正的初始值</em></strong>）</h3><p>JVM对静态变量初始化的两种方式：</p>
<blockquote>
<ol>
<li>声明类变量是指定初始值；</li>
<li>使用静态代码块为类变量指定初始值。   </li>
</ol>
</blockquote>
<p>JVM初始化的步骤为：</p>
<blockquote>
<ol>
<li>若初始化的这个类还没有进行加载和连接，那么先将类进行加载和连接；</li>
<li>若初始化的这个类的父类还没有进行初始化，则先去初始化父类；</li>
<li>若初始化的这个类中有初始化语句，则系统依次执行这些初始化语句。</li>
</ol>
</blockquote>
<p>类初始化的时机：(对类进行主动调用的时候)</p>
<blockquote>
<ol>
<li>创建类的实例，及new一个对象；</li>
<li>访问某个类或接口的静态变量或对静态变量进行赋值时；</li>
<li>调用某个类的静态方法时；</li>
<li>某个类的子类被初始化时;</li>
<li>使用反射方式强制创建某个类或接口对应的java.lang.Class对象；</li>
<li>JVM启动时被标明为启动类的类；</li>
</ol>
</blockquote>
<p>初始化总结：   </p>
<blockquote>
<p>初始化是类加载机制的最后一个阶段，本阶段才真正意义上执行了class内部代码，但是其实这也只是执行类构造器<clinit>()方法，所以说，执行代码也只是一个开端。</p>
</blockquote>
<hr>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="定义及一些分类与关系"><a href="#定义及一些分类与关系" class="headerlink" title="定义及一些分类与关系"></a>定义及一些分类与关系</h3><p>提到类加载机制就不得不提到类加载器，，它是用在类加载机制的第一个阶段-加载，一个类在JVM中的唯一性依赖于类与其类加载器，即使两个类来源于同一个class文件，但是由于类加载器的不同也让两个类在JVM中是两个不同的存在。并且在加载阶段类加载器获取二进制字节流并非只在Class文件中，还可以从jar包中以及网络和其他文件生成。其种类可分为如下：</p>
<blockquote>
<p><em>以虚拟机的角度</em>：   </p>
<ol>
<li><strong>启动类加载器</strong>:它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分。</li>
<li><strong>所有其他的类加载器</strong>：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。   </li>
</ol>
</blockquote>
<blockquote>
<p><em>以开发人员的角度</em>:</p>
<ol>
<li><strong>启动类加载器</strong>：Bootstrap-ClassLoader，跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap-ClassLoader加载）,并且启动类加载器是无法被Java程序直接引用的。</li>
<li><strong>扩展类加载器</strong>：Extension-ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li>
<li><strong>应用程序类加载器</strong>：Application-ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ol>
</blockquote>
<p>一般应用程序的加载都是由这三种类加载器互相协作完成的，<em>当然也可以加入自定义的ClassLoader，因为JVM自带的ClassLoader只是在本地文件系统加载标准的java class文件</em>。其实在使用Applet时就用到了自定义的ClassLoader，因为它需要加载网络上的Java class文件，并且可以做到:   </p>
<ol>
<li>在执行非置信代码之前，自动验证数字签名。</li>
<li>动态地创建符合用户特定需要的定制化构建类。</li>
<li>从特定的场所取得java class，例如数据库中和网络中。   </li>
</ol>
<p>这样可以检验相关的安全信息，应用服务器也大都使用了自定义ClassLoader技术。</p>
<h3 id="几种类加载器的层级关系"><a href="#几种类加载器的层级关系" class="headerlink" title="几种类加载器的层级关系"></a>几种类加载器的层级关系</h3><p><a href="https://sbimg.cn/image/2smPO" target="_blank" rel="noopener"><img src="https://wx2.sbimg.cn/2020/06/28/2smPO.png" alt="2smPO.png"></a><br>这种层级关系称为<strong>双亲委派模型</strong>，每一层类加载器的上一层为其父加载器，但是，它们的这种关系不是通过继承实现的，而是通过组合关系来复用父加载器中的代码的。这就不得不提到JVM类加载的3种机制了：</p>
<blockquote>
<ol>
<li>父类委托：当收到类加载请求时，先让父类进行加载，也就是一直到顶层的启动类加载器向下，只有当父类无法加载时，子类类加载器才会尝试从自己的类路径中加载；</li>
<li>全盘负责：当一个类加载器负责加载某个类时，该类的所依赖和引用的其他类也将由该类加载器全权负责，除非显示的使用另一个类加载器；</li>
<li>缓存机制：该机制会保证所有加载过的类都会被缓存，当需要加载某个类时，类加载器会先从缓存区中寻找是否有该类，若无，系统才会加载该类并放入缓存区。这也解释了为什么修改了类之后需要重新启动JVM新的类才会生效。   </li>
</ol>
</blockquote>
<h3 id="双亲委派机制："><a href="#双亲委派机制：" class="headerlink" title="双亲委派机制："></a>双亲委派机制：</h3><blockquote>
<p>1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。<br>2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。<br>3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；<br>4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</p>
</blockquote>
<p>这里给出<strong><em>双亲委派机制的源码</em></strong>以便于更好的理解双亲委派机制的作用原理：   </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public Class&lt;?&gt; load<span class="constructor">Class(String <span class="params">name</span>)</span>throws ClassNotFoundException &#123;</span><br><span class="line">            return load<span class="constructor">Class(<span class="params">name</span>, <span class="params">false</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected synchronized Class&lt;?&gt; load<span class="constructor">Class(String <span class="params">name</span>, <span class="params">boolean</span> <span class="params">resolve</span>)</span>throws ClassNotFoundException &#123;</span><br><span class="line">            Class c = find<span class="constructor">LoadedClass(<span class="params">name</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (c<span class="operator"> == </span>null) &#123;  <span class="comment">//判断类是否已经被加载</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != null) &#123;<span class="comment">//如果该加载器有父类，则传递给父类加载器加载</span></span><br><span class="line">                        c = parent.load<span class="constructor">Class(<span class="params">name</span>, <span class="params">false</span>)</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span></span><br><span class="line">                        c = find<span class="constructor">BootstrapClass0(<span class="params">name</span>)</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;<span class="comment">// 如果无父类加载器并且启动类加载器都不能加载，则调用自身的加载功能</span></span><br><span class="line">                    c = find<span class="constructor">Class(<span class="params">name</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolve<span class="constructor">Class(<span class="params">c</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里给出几个ClassLoader加载的Demo：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package First;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> Demo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String<span class="literal">[]</span> args) throws ClassNotFoundException &#123;</span><br><span class="line">		ClassLoader loader = <span class="module-access"><span class="module"><span class="identifier">HelloWorld</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ClassLoader()</span>;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(loader);</span><br><span class="line">		loader.load<span class="constructor">Class(<span class="string">"First.Text"</span>)</span>;  <span class="comment">//loader.loadClass()的方式加载类 默认不执行初始化块</span></span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"First.Text"</span>)</span>;  <span class="comment">//Class.forNmae()的方式加载类 默认执行初始化块</span></span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"First.Text"</span>, <span class="params">false</span>, <span class="params">loader</span>)</span>;  <span class="comment">//Class.forNmae()指定类加载器的方式 默认不执行初始化块(false)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package First;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"执行静态代码块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">jdk.<span class="built_in">int</span>ernal.loader.ClassLoaders$<span class="symbol">AppClassLoader@</span><span class="number">3</span>a71f4dd</span><br><span class="line">执行静态代码块</span><br></pre></td></tr></table></figure>
<h3 id="这里记录一个坑"><a href="#这里记录一个坑" class="headerlink" title="这里记录一个坑"></a>这里记录一个坑</h3><p>在普通的使用loader.loadClass(ClassNmae)或Class.forName(ClassName)或指定加载器的加载类时若ClassName只填写类名称将抛出ClassNotFoundException异常。<br><strong>解决方法</strong>:同一个包中的类虽然可以直接引用但是由于类名前的包名已由编译器加载上去了，所以在通过这几个方法加载类时，如果不加包名则会默认在default中寻找，自然也就找不到了，所以在ClassName前应该加上包名，问题就解决了。   </p>
<blockquote>
<p><strong>三种类加载方式的不同</strong>：<br>1 . ClassLoader.loadClass(ClassName)方式默认只是将其加载到JVM中而不会去加载类的静态代码块，只有等到new Instance时才会去执行；<br>2 . Class.forName(ClassName)方法是将类的.class文件加载到JVM中并对类进行解释，执行类的静态代码块；<br>3 . Class.forNmae(ClassName, Initialize, Loader)这种类加载方式是使用指定的类加载器进行加载类，并且可以指定是否执行类的静态代码块。   </p>
</blockquote>
<hr>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本篇对于类加载机制通过累加载机制的过程将5个阶段的任务以及相关的机制原理以及所用到的一些外部实体做了解释，我们可以看到，在整个类加载机制的过程中，只有类加载阶段可以由用户控制，即使用指定的类加载器进行加载，其余的阶段都是由JVM所控制的，并且类加载机制的结束仅仅是代码运行的一个开端，所以说，类加载机制也仅仅是将类文件加载到JVM的内存中，只有在类加载结束后，才真正的开始执行字节码的操作。</p>
<p>参考：<br>《深入理解JAVA虚拟机》<br><a href="https://www.cnblogs.com/ityouknow/p/5603287.html" target="_blank" rel="noopener">https://www.cnblogs.com/ityouknow/p/5603287.html</a></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java】静态类型与实际类型</title>
    <url>/2020/07/02/%E3%80%90Java%E3%80%91%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>Java的静态类型与实际类型的相关问题，同时有助于理解Java中的转型问题 (๑´ڡ`๑)</strong></p>
<a id="more"></a>
<h2 id="代码观察"><a href="#代码观察" class="headerlink" title="代码观察"></a>代码观察</h2><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Father do it"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="title">extends</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Son do it"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(Father father)</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"Father say Hi"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(Son son)</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"Son say Hi"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		Text t = <span class="keyword">new</span> Text();</span><br><span class="line">		Father f = <span class="keyword">new</span> Son();</span><br><span class="line">		f.doIt();</span><br><span class="line">		t.sayHi(f);</span><br><span class="line">		System.out.<span class="built_in">println</span>(f.getClass());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><blockquote>
<p>Son do it<br>Father say Hi<br>class Second.Text$Son</p>
</blockquote>
<h2 id="相关解释"><a href="#相关解释" class="headerlink" title="相关解释"></a>相关解释</h2><blockquote>
<p>在本段代码中Father f = new Son()实例化时<strong>Father为静态类型，Son为实际类型</strong>，并且<strong>静态类型在编译期间就是可知的，而实际类型要等到运行期间才可知</strong>，Son（）中的doIt（）方法重写了父类中的此方法，而最后执行结果是调用的子类的方法，这说明方法的<strong>重写是动态的</strong>，以此类推当f作为参数传入时是作为father这个静态类型传入的，因为结果调用的father的方法，这也说明了<strong>重载是静态的的</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】Executor框架</title>
    <url>/2020/07/15/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91Executor%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(九）Executor框架含简介/ThreadPoolExecutor详解/ScheduledThreadPoolExecutor详解/FutureTask详解</strong></p>
<a id="more"></a>
<h2 id="Executor框架简介"><a href="#Executor框架简介" class="headerlink" title="Executor框架简介"></a>Executor框架简介</h2><h3 id="Executor框架的两级调度模型"><a href="#Executor框架的两级调度模型" class="headerlink" title="Executor框架的两级调度模型"></a>Executor框架的两级调度模型</h3><p><img src="https://wx1.sbimg.cn/2020/07/14/CKcoU.png" alt="CKcoU.png"></p>
<p>在HotSpot VM的线程模型中，<strong>Java线程（java.lang.Thread）被一对一映射为本地操作系统线程</strong>。<strong>Java线程启动时会创建一个本地操作系统线程；当该Java线程终止时，这个操作系统线程 也会被回收</strong>。操作系统会调度所有线程并将它们分配给可用的CPU。<strong>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器 （Executor框架）将这些任务映射为固定数量的线程</strong>；<strong>在底层，操作系统内核将这些线程映射到硬件处理器上</strong>。从图中可以看出，应用程序通过Executor框架控制上层的调度；而下层的调度由操作系统内核控制，<strong>下层的调度不受应用程序的控制</strong>。</p>
<h3 id="Executor框架结构与成员"><a href="#Executor框架结构与成员" class="headerlink" title="Executor框架结构与成员"></a>Executor框架结构与成员</h3><h4 id="Executor框架结构"><a href="#Executor框架结构" class="headerlink" title="Executor框架结构"></a>Executor框架结构</h4><p><img src="https://wx2.sbimg.cn/2020/07/14/CKdqd.png" alt="CKdqd.png"></p>
<p>如图所示Executor框架主要由3大部分组成如下：</p>
<ul>
<li>任务：包括被执行任务需要实现的接口：Runnable接口或Callable接口。 </li>
<li>任务的执行：包括任务执行机制的核心接口Executor，以及继承自Executor的 ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口 （ThreadPoolExecutor和ScheduledThreadPoolExecutor）。</li>
<li>异步计算的结果。包括接口Future和实现Future接口的FutureTask类。Executor框架包含的主要的类与接口如图所示。下面是这些类和接口的简介：<blockquote>
<ul>
<li>Executor是一个接口，<strong>它是Executor框架的基础，它将任务的提交与任务的执行分离开</strong>。</li>
<li><strong>ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务</strong>。</li>
<li>ScheduledThreadPoolExecutor是一个实现类，<strong>可以在给定的延迟后运行命令，或者定期执行命令</strong>。ScheduledThreadPoolExecutor比Timer更灵活，功能更强大。</li>
<li>Future接口和实现Future接口的FutureTask类，<strong>代表异步计算的结果</strong>。</li>
<li>Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或Scheduled-ThreadPoolExecutor执行。</li>
</ul>
</blockquote>
</li>
</ul>
<p>如图所示Executor框架的使用示意图：</p>
<p><img src="https://wx1.sbimg.cn/2020/07/14/CKgN4.png" alt="CKgN4.png"></p>
<p><strong>主线程首先要创建实现Runnable或者Callable接口的任务对象</strong>。工具类Executors可以把一个Runnable对象封装为一个Callable对象（Executors.callable（Runnable task）或 Executors.callable（Runnable task，Object resule））。然后可以把Runnable对象直接交给ExecutorService执行（ExecutorService.execute（Runnable command））；或者也可以把Runnable对象或Callable对象提交给ExecutorService执行（Executor- Service.submit（Runnable task）或ExecutorService.submit（Callable<T>task））。 如果执行ExecutorService.submit（…），ExecutorService将返回一个实现Future接口的对象（到目前为止的JDK中，返回的是FutureTask对象）。由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</p>
<h4 id="Executor框架成员"><a href="#Executor框架成员" class="headerlink" title="Executor框架成员"></a>Executor框架成员</h4><p>Executor框架的主要成员：</p>
<ul>
<li>ThreadPoolExecutor</li>
<li>ScheduledThreadPoolExecutor </li>
<li>Future接口</li>
<li>Runnable接口</li>
<li>Callable接口</li>
<li>Executors。 </li>
</ul>
<h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><blockquote>
<p>ThreadPoolExecutor通常使用工厂类Executors来创建。<strong>Executors可以创建3种类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool和CachedThreadPool</strong>:</p>
<ul>
<li>FixedThreadPool:下面是Executors提供的，创建使用固定线程数的FixedThreadPool的 API:</li>
</ul>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads, ThreadFactorythreadFactory)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>FixedThreadPool适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器</strong>。</p>
<ul>
<li>SingleThreadExecutor。下面是Executors提供的，创建使用单个线程的SingleThread- Executor的API: </li>
</ul>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>(ThreadFactory threadFactory)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>SingleThreadExecutor适用于需要保证顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景</strong>。</p>
<ul>
<li>CachedThreadPool。下面是Executors提供的，创建一个会根据需要创建新线程的 CachedThreadPool的API:</li>
</ul>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>(ThreadFactory threadFactory)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>CachedThreadPool是大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器</strong>。</p>
</blockquote>
<h5 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h5><blockquote>
<p>ScheduledThreadPoolExecutor通常使用工厂类Executors来创建。Executors可以创建2种类型的ScheduledThreadPoolExecutor<br><strong>·ScheduledThreadPoolExecutor。包含若干个线程的ScheduledThreadPoolExecutor</strong>。<br><strong>·SingleThreadScheduledExecutor。只包含一个线程的ScheduledThreadPoolExecutor</strong>。 </p>
</blockquote>
<p>下面分别介绍这两种ScheduledThreadPoolExecutor：</p>
<blockquote>
<ul>
<li>下面是工厂类Executors提供的，创建固定个数线程的ScheduledThreadPoolExecutor的API:</li>
</ul>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static ScheduledExecutorService <span class="keyword">new</span><span class="constructor">ScheduledThreadPool(<span class="params">int</span> <span class="params">corePoolSize</span>)</span> </span><br><span class="line">public static ScheduledExecutorService <span class="keyword">new</span><span class="constructor">ScheduledThreadPool(<span class="params">int</span> <span class="params">corePoolSize</span>,ThreadFactory <span class="params">threadFactory</span>)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>ScheduledThreadPoolExecutor适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景</strong>。</p>
<ul>
<li>下面是Executors提供的，创建单个线程的SingleThreadScheduledExecutor的API：</li>
</ul>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="keyword">new</span><span class="type">SingleThreadScheduledExecutor</span>() </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="keyword">new</span><span class="type">SingleThreadScheduledExecutor</span> (ThreadFactory threadFactory)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>SingleThreadScheduledExecutor适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景</strong>。</p>
</blockquote>
<h5 id="future接口"><a href="#future接口" class="headerlink" title="future接口"></a>future接口</h5><p>Future接口和实现Future接口的FutureTask类用来表示异步计算的结果。当我们把Runnable接口或Callable接口的实现类提交（submit）给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduledThreadPoolExecutor会向我们返回一个FutureTask对象。下面是对应的API：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">T</span>&gt;</span> Future<span class="tag">&lt;<span class="name">T</span>&gt;</span> submit(Callable<span class="tag">&lt;<span class="name">T</span>&gt;</span> task) </span><br><span class="line"><span class="tag">&lt;<span class="name">T</span>&gt;</span> Future<span class="tag">&lt;<span class="name">T</span>&gt;</span> submit(Runnable task, T result) </span><br><span class="line">Future<span class="tag">&lt;&gt;</span> submit(Runnable task)</span><br></pre></td></tr></table></figure>

<h5 id="Runnable接口与Callable接口"><a href="#Runnable接口与Callable接口" class="headerlink" title="Runnable接口与Callable接口"></a>Runnable接口与Callable接口</h5><blockquote>
<p>Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或Scheduled- ThreadPoolExecutor执行。它们之间的<strong>区别是Runnable不会返回结果，而Callable可以返回结果</strong>。除了可以自己创建实现Callable接口的对象外，还可以使用工厂类Executors来把一个 Runnable包装成一个Callable。 下面是Executors提供的，把一个Runnable包装成一个Callable的API:</p>
</blockquote>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;<span class="keyword">Object</span>&gt; callable(Runnable task) </span><br><span class="line"><span class="comment">// 假设返回对象Callable1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>下面是Executors提供的，把一个Runnable和一个待返回的结果包装成一个Callable的API:</p>
</blockquote>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; callable(Runnable <span class="keyword">task</span>, T result) <span class="comment">// 假设返回对象Callable2</span></span><br></pre></td></tr></table></figure>

<p>当我们把一个Callable对象（比如上面的Callable1或Callable2）提交给 ThreadPoolExecutor或ScheduledThreadPoolExecutor执行时，submit（…）会向我们返回一个FutureTask对象。我们可以执行FutureTask.get()方法来等待任务执行完成。当任务成功完成后FutureTask.get()将返回该任务的结果。<strong>如果提交的是对象Callable1，FutureTask.get()方法将返回null；如果提交的是对象Callable2，FutureTask.get()方法将返回result对象</strong>。</p>
<h2 id="ThreadPoolExecutor详解"><a href="#ThreadPoolExecutor详解" class="headerlink" title="ThreadPoolExecutor详解"></a>ThreadPoolExecutor详解</h2><p>Executor框架最核心的类是ThreadPoolExecutor，它是线程池的实现类，主要由下列4个组件构成</p>
<ul>
<li>corePool：核心线程池的大小。</li>
<li>maximumPool：最大线程池的大小。</li>
<li>BlockingQueue：用来暂时保存任务的工作队列。</li>
<li>RejectedExecutionHandler：当ThreadPoolExecutor已经关闭或ThreadPoolExecutor已经饱和时（达到了最大线程池大小且工作队列已满），execute()方法将要调用Handler。 </li>
</ul>
<p>通过Executor框架的工具类Executors，可以创建3种类型的ThreadPoolExecutor：</p>
<ul>
<li>FixedThreadPool。</li>
<li>SingleThreadExecutor。</li>
<li>CachedThreadPool。</li>
</ul>
<h3 id="FixedThreadPool详解"><a href="#FixedThreadPool详解" class="headerlink" title="FixedThreadPool详解"></a>FixedThreadPool详解</h3><p><strong>FixedThreadPool被称为可重用固定线程数的线程池</strong>。下面是FixedThreadPool的源代码实现：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="number">0</span>L, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。*<em>当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止。这里把keepAliveTime设置为0L，意味着多余 *</em>。 </p>
<p>FixedThreadPool的execute()方法的运行示意图如图所示:</p>
<p><img src="https://wx2.sbimg.cn/2020/07/14/CKK0k.png" alt="CKK0k.png"></p>
<ul>
<li>如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。 &gt;- 在线程池完成预热之后（当前运行的线程数等于corePoolSize），将任务加入LinkedBlockingQueue。</li>
<li>线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行。<strong>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）</strong>。<strong>使用无界队列作为工作队列会对线程池带来如下影响</strong>:<blockquote>
<ul>
<li>当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。</li>
<li>由于1，使用无界队列时maximumPoolSize将是一个无效参数。</li>
<li>由于1和2，使用无界队列时keepAliveTime将是一个无效参数。</li>
<li>由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown()或shutdownNow()）不会拒绝任务（不会调用RejectedExecutionHandler.rejectedExecution方法）。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="SingleThreadExecutor详解"><a href="#SingleThreadExecutor详解" class="headerlink" title="SingleThreadExecutor详解"></a>SingleThreadExecutor详解</h3><p><strong>SingleThreadExecutor是使用单个worker线程的Executor</strong>。下面是SingleThreadExecutor的源代码实现： </p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span> (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>L, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SingleThreadExecutor的corePoolSize和maximumPoolSize被设置为1。其他参数与FixedThreadPool相同。<strong>SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。SingleThreadExecutor使用无界队列作为工作队列</strong>对线程池带来的影响与FixedThreadPool相同。</p>
<p>SingleThreadExecutor的运行示意图如图所示:<br><img src="https://wx1.sbimg.cn/2020/07/14/CKWsn.png" alt="CKWsn.png"></p>
<ul>
<li>如果当前运行的线程数少于corePoolSize（即线程池中无运行的线程），则创建一个新线程来执行任务。</li>
<li>在线程池完成预热之后（当前线程池中有一个运行的线程），将任务加入Linked-BlockingQueue。</li>
<li>线程执行完1中的任务后，会在一个无限循环中反复从LinkedBlockingQueue获取任务来执行。</li>
</ul>
<h3 id="CachedThreadPool详解"><a href="#CachedThreadPool详解" class="headerlink" title="CachedThreadPool详解"></a>CachedThreadPool详解</h3><p><strong>CachedThreadPool是一个会根据需要创建新线程的线程池</strong>。下面是创建CachedThread-Pool的源代码：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>L, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CachedThreadPool的corePoolSize被设置为0，即corePool为空；maximumPoolSize被设置为Integer.MAX_VALUE，即maximumPool是无界的。这里把keepAliveTime设置为60L，意味着CachedThreadPool中的空闲线程等待新任务的最长时间为60秒，空闲线程超过60秒后将会被终止。<strong>FixedThreadPool和SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的 工作队列</strong>。<strong>CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列</strong>，但CachedThreadPool的maximumPool是无界的。这意味着，如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU和内存资源。</p>
</blockquote>
<p>CachedThreadPool的execute()方法的执行示意图如图所示：<br><img src="https://wx2.sbimg.cn/2020/07/14/CKiTI.png" alt="CKiTI.png"></p>
<blockquote>
<ul>
<li>首先执行SynchronousQueue.offer（Runnable task）。如果当前maximumPool中有空闲线程正在执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS），那么主线程执行offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行，execute()方 法执行完成；否则执行下一步骤。</li>
<li>当初始maximumPool为空，或者maximumPool中当前没有空闲线程时，将没有线程执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS）。这种情况下，上一步骤将失败。此时CachedThreadPool会创建一个新线程执行任务，execute()方法执行完成。</li>
<li>在上一步骤中新创建的线程将任务执行完后，会执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS）。这个poll操作会让空闲线<br>程最多在SynchronousQueue中等待60秒钟。如果60秒钟内主线程提交了一个新任务（主线程执行步骤1）），那么这个空闲线程将执行主线程提交的新任务；否则，这个空闲线程将终止。由于空闲60秒的空闲线程会被终止，因此长时间保持空闲的CachedThreadPool不会使用任何资源。 </li>
</ul>
</blockquote>
<p><strong>SynchronousQueue是一个没有容量的阻塞队列。每个插入操作必须等待另一 个线程的对应移除操作，反之亦然</strong>。CachedThreadPool使用SynchronousQueue，把主线程提交的任务传递给空闲线程执行。CachedThreadPool中任务传递的示意图如图所示：<br><img src="https://wx1.sbimg.cn/2020/07/14/CKx3K.png" alt="CKx3K.png"></p>
<h2 id="ScheduledThreadPoolExecutor详解"><a href="#ScheduledThreadPoolExecutor详解" class="headerlink" title="ScheduledThreadPoolExecutor详解"></a>ScheduledThreadPoolExecutor详解</h2><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。<strong>它主要用来在给定的延迟之后运行任务，或者定期执行任务</strong>。ScheduledThreadPoolExecutor的功能与Timer类似，但ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而<strong>ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数</strong>。</p>
<h3 id="ScheduledThreadPoolExecutor运行机制"><a href="#ScheduledThreadPoolExecutor运行机制" class="headerlink" title="ScheduledThreadPoolExecutor运行机制"></a>ScheduledThreadPoolExecutor运行机制</h3><p>ScheduledThreadPoolExecutor的执行示意图（基于JDK 6）如图所示：</p>
<p><img src="https://wx1.sbimg.cn/2020/07/14/CWJlG.png" alt="CWJlG.png"></p>
<p>DelayQueue是一个无界队列，所以ThreadPoolExecutor的maximumPoolSize在Scheduled-ThreadPoolExecutor中没有什么意义。 </p>
<p>ScheduledThreadPoolExecutor的执行主要分为两大部分： </p>
<ul>
<li>当调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()方法或者scheduleWith-FixedDelay()方法时，会向ScheduledThreadPoolExecutor的DelayQueue添加一个实现了RunnableScheduledFutur接口的ScheduledFutureTask。</li>
<li>线程池中的线程从DelayQueue中获取ScheduledFutureTask，然后执行任务。</li>
</ul>
<p>ScheduledThreadPoolExecutor为了实现周期性的执行任务，对ThreadPoolExecutor做了如下的修改。</p>
<ul>
<li>使用DelayQueue作为任务队列。</li>
<li>获取任务的方式不同（见后文）。</li>
<li>执行周期任务后，增加了额外的处理（见后文）。</li>
</ul>
<h3 id="ScheduledThreadPoolExecutor的实现"><a href="#ScheduledThreadPoolExecutor的实现" class="headerlink" title="ScheduledThreadPoolExecutor的实现"></a>ScheduledThreadPoolExecutor的实现</h3><p>ScheduledThreadPoolExecutor会把待调度的任务（ScheduledFutureTask） 放到一个DelayQueue中。<strong>ScheduledFutureTask主要包含3个成员变量</strong>：</p>
<ul>
<li>long型成员变量time，表示这个任务将要被执行的具体时间。</li>
<li>long型成员变量sequenceNumber，表示这个任务被添加到ScheduledThreadPoolExecutor中的序号。</li>
<li>long型成员变量period，表示任务执行的间隔周期。 </li>
</ul>
<blockquote>
<p><strong>这个PriorityQueue会对队列中的Scheduled-FutureTask进行排序。排序时，time小的排在前面（时间早的任务将被先执行）。如果两个ScheduledFutureTask的time相同，就比较sequenceNumber，sequenceNumber小的排在前面</strong>首先，让我们看看ScheduledThreadPoolExecutor中的线程执行周期任务的过程。</p>
</blockquote>
<p>图是ScheduledThreadPoolExecutor中的线程1执行某个周期任务的4个步骤:<br><img src="https://wx2.sbimg.cn/2020/07/15/CZgNG.png" alt="CZgNG.png"></p>
<ul>
<li>线程1从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。到期任务是指ScheduledFutureTask的time大于等于当前时间。 </li>
<li>线程1执行这个ScheduledFutureTask。 </li>
<li>线程1修改ScheduledFutureTask的time变量为下次将要被执行的时间。 </li>
<li>线程1把这个修改time之后的ScheduledFutureTask放回DelayQueue中（Delay- Queue.add()）。 </li>
</ul>
<p>步骤1获取任务的过程。是DelayQueue.take()方法的源代码实现：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> throws InterruptedException </span>&#123; </span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 1 </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">            E first = q.<span class="built_in">peek</span>(); </span><br><span class="line">            <span class="keyword">if</span> (first == null) &#123; </span><br><span class="line">                <span class="built_in">available</span>.await(); <span class="comment">// 2.1 </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">long</span> <span class="built_in">delay</span> = first.getDelay(TimeUnit.NANOSECONDS); <span class="keyword">if</span> (<span class="built_in">delay</span> &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                    <span class="keyword">long</span> tl = <span class="built_in">available</span>.awaitNanos(<span class="built_in">delay</span>); <span class="comment">// 2.2 </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                    E x = q.poll(); <span class="comment">// 2.3.1 </span></span><br><span class="line">                    assert x != null; </span><br><span class="line">                    <span class="keyword">if</span> (q.<span class="built_in">size</span>() != <span class="number">0</span>) </span><br><span class="line">                        <span class="built_in">available</span>.signalAll(); <span class="comment">// 2.3.2 </span></span><br><span class="line">                        <span class="keyword">return</span> x; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">    &#125; finally &#123; </span><br><span class="line">        lock.unlock(); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://wx2.sbimg.cn/2020/07/15/CZJsw.png" alt="CZJsw.png"></p>
<p>步骤：</p>
<ul>
<li>获取Lock。 </li>
<li>获取周期任务。 <blockquote>
<ul>
<li>如果PriorityQueue为空，当前线程到Condition中等待；否则执行下面的2.2。 </li>
<li>如果PriorityQueue的头元素的time时间比当前时间大，到Condition中等待到time时间；否则执行下面的2.3。</li>
<li>获取PriorityQueue的头元素（2.3.1）；如果PriorityQueue不为空，则唤醒在Condition中等待的所有线程（2.3.2）。 </li>
</ul>
</blockquote>
</li>
<li>释放Lock。 ScheduledThreadPoolExecutor在一个循环中执行步骤2，直到线程从PriorityQueue获取到一个元素之后（执行2.3.1之后），才会退出无限循环（结束步骤2）。</li>
</ul>
<p>DelayQueue.add()的源代码实现:</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">offer</span>(<span class="params">E e</span>)</span> &#123; </span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>; </span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>(); <span class="comment">// 1 </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E first = q.peek();</span><br><span class="line">        q.offer(e); <span class="comment">// 2.1 </span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span> || e.compareTo(first) &lt; <span class="number">0</span>)</span><br><span class="line">            available.signalAll(); <span class="comment">// 2.2 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        ock.unlock(); <span class="comment">// 3 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://wx2.sbimg.cn/2020/07/15/CawYh.png" alt="CawYh.png"></p>
<p>步骤：</p>
<ul>
<li>获取Lock。 </li>
<li>添加任务。 <blockquote>
<ul>
<li>向PriorityQueue添加任务。</li>
<li>如果在上面2.1中添加的任务是PriorityQueue的头元素，唤醒在Condition中等待的所有线程。 </li>
</ul>
</blockquote>
</li>
<li>释放Lock。</li>
</ul>
<h2 id="FutureTask详解"><a href="#FutureTask详解" class="headerlink" title="FutureTask详解"></a>FutureTask详解</h2><p>Future接口和实现Future接口的FutureTask类，代表异步计算的结果。</p>
<h3 id="FutureTask简介"><a href="#FutureTask简介" class="headerlink" title="FutureTask简介"></a>FutureTask简介</h3><p>FutureTask除了实现Future接口外，还实现了Runnable接口。因此，<strong>FutureTask可以交给Executor执行，也可以由调用线程直接执行（FutureTask.run()）</strong>。根据FutureTask.run()方法被执行的时机，FutureTask可以处于下面3种状态：</p>
<ul>
<li>未启动。FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态。当创建一 个FutureTask，且没有执行FutureTask.run()方法之前，这个FutureTask处于未启动状态。</li>
<li>已启动。FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态。 </li>
<li>已完成。FutureTask.run()方法执行完后正常结束，或被取消（FutureTask.cancel（…）），或执行FutureTask.run()方法时抛出异常而异常结束，FutureTask处于已完成状态。</li>
</ul>
<p>FutureTask的状态迁移的示意图：<br><img src="https://wx1.sbimg.cn/2020/07/15/CazFM.png" alt="CazFM.png"></p>
<ul>
<li>当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞；</li>
<li>当FutureTask处于已完成状态时，执行FutureTask.get()方法将导致调用线程立即返回结果或抛出异常。执行FutureTask.cancel（…）方法将返回false </li>
<li>当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会被执行；</li>
<li>当FutureTask处于已启动状态时，执行FutureTask.cancel（true）方法将以中断执行此任务线程的方式来试图停止任务；执行FutureTask.cancel（false）方法将不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）； </li>
</ul>
<p>get方法和cancel方法的执行示意图：</p>
<h3 id="FutureTask的使用"><a href="#FutureTask的使用" class="headerlink" title="FutureTask的使用"></a>FutureTask的使用</h3><p>可以把FutureTask交给Executor执行；也可以通过ExecutorService.submit（…）方法返回一个FutureTask，然后执行FutureTask.get()方法或FutureTask.cancel（…）方法。除此以外，还可以单独使用FutureTask。<strong>当一个线程需要等待另一个线程把某个任务执行完后它才能继续执行，此时可以使用FutureTask。假设有多个线程执行若干任务，每个任务最多只能被执行一次。当多个线程试图 同时执行同一个任务时，只允许一个线程执行任务，其他线程需要等待这个任务执行完后才能继续执行</strong>。</p>
<p>对应的示例代码:</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;<span class="keyword">Object</span>, Future&lt;<span class="keyword">String</span>&gt;&gt; taskCache = <span class="keyword">new</span> ConcurrentHashMap&lt;<span class="keyword">Object</span>, Future&lt;<span class="keyword">String</span>&gt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">String</span> executionTask(<span class="keyword">final</span> <span class="keyword">String</span> taskName) <span class="keyword">throws</span> ExecutionException, InterruptedException &#123; </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">        Future&lt;<span class="keyword">String</span>&gt; future = taskCache.<span class="built_in">get</span>(taskName); <span class="comment">// 1.1,2.1 if (future == null) &#123; </span></span><br><span class="line">            Callable&lt;<span class="keyword">String</span>&gt; task = <span class="keyword">new</span> Callable&lt;<span class="keyword">String</span>&gt;() &#123; </span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">String</span> call() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">                    <span class="keyword">return</span> taskName; &#125; &#125;; <span class="comment">// 1.2创建任务</span></span><br><span class="line">                    FutureTask&lt;<span class="keyword">String</span>&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;<span class="keyword">String</span>&gt;(task); </span><br><span class="line">                    future = taskCache.putIfAbsent(taskName, futureTask); <span class="comment">// 1.3 </span></span><br><span class="line">                    <span class="keyword">if</span> (future == <span class="keyword">null</span>) &#123; </span><br><span class="line">                        future = futureTask; </span><br><span class="line">                        futureTask.run(); <span class="comment">// 1.4执行任务 </span></span><br><span class="line">                    &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> future.<span class="built_in">get</span>(); <span class="comment">// 1.5,2.2线程在此等待任务执行完成</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">        taskCache.remove(taskName, future); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示意图：<br><img src="https://wx2.sbimg.cn/2020/07/15/CaH9a.png" alt="CaH9a.png"></p>
<p>当两个线程试图同时执行同一个任务时，如果Thread 1执行1.3后Thread 2执行2.1，那么接下来Thread2将在2.2等待，直到Thread1执行完1.4后Thread 2才能从2.2（FutureTask.get()）返回。</p>
<h3 id="FutureTask的实现"><a href="#FutureTask的实现" class="headerlink" title="FutureTask的实现"></a>FutureTask的实现</h3><p>FutureTask的实现基于AbstractQueuedSynchronizer（AQS）。java.util.concurrent中的很多可阻塞类（比如ReentrantLock）都是基于AQS来实现的。AQS是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及维护被阻塞线程的队列。JDK6中AQS被广泛使用，基于AQS实现的同步器包括：ReentrantLock、Semaphore、ReentrantReadWriteLock、 CountDownLatch和FutureTask。每一个基于AQS实现的同步器都会包含两种类型的操作，如下：</p>
<ul>
<li><strong>至少一个acquire操作。这个操作阻塞调用线程，除非/直到AQS的状态允许这个线程继续执行。FutureTask的acquire操作为get()/get（long timeout，TimeUnit unit）方法调用</strong>。</li>
<li><strong>至少一个release操作。这个操作改变AQS的状态，改变后的状态可允许一个或多个阻塞 线程被解除阻塞。FutureTask的release操作包括run()方法和cancel（…）方法。</strong> </li>
</ul>
<p>基于“复合优先于继承”的原则，FutureTask声明了一个内部私有的继承于AQS的子类 Sync，对FutureTask所有公有方法的调用都会委托给这个内部子类。 AQS被作为“模板方法模式”的基础类提供给FutureTask的内部子类Sync，这个内部子类只 需要实现状态检查和状态更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具体来说，Sync实现了AQS的tryAcquireShared（int）方法和tryReleaseShared（int）方法，Sync通过这两个方法来检查和更新同步状态。<br>FutureTask的设计示意图如图所示：<br><img src="https://wx2.sbimg.cn/2020/07/15/CalrJ.png" alt="CalrJ.png"></p>
<p>如图所示，<strong>Sync是FutureTask的内部私有类，它继承自AQS</strong>。创建FutureTask时会创建内部私有的成员对象Sync，FutureTask所有的的公有方法都直接委托给了内部私有的Sync。FutureTask.get()方法会调用AQS.acquireSharedInterruptibly（int arg）方法，这个方法的执行过程如下：</p>
<ul>
<li>调用AQS.acquireSharedInterruptibly（int arg）方法，这个方法首先会回调在子类Sync中实现的tryAcquireShared()方法来判断acquire操作是否可以成功。acquire操作可以成功的条件为： state为执行完成状态RAN或已取消状态CANCELLED，且runner不为null。</li>
<li>如果成功则get()方法立即返回。如果失败则到线程等待队列中去等待其他线程执行release操作。</li>
<li>当其他线程执行release操作（比如FutureTask.run()或FutureTask.cancel（…））唤醒当前线程后，当前线程再次执行tryAcquireShared()将返回正值1，当前线程将离开线程等待队列并唤醒它的后继线程（这里会产生级联唤醒的效果）。</li>
<li>最后返回计算的结果或抛出异常。 </li>
</ul>
<p>FutureTask.run()的执行过程如下:</p>
<ul>
<li>执行在构造函数中指定的任务（Callable.call()）。</li>
<li>以原子方式来更新同步状态（调用AQS.compareAndSetState（int expect，int update），设置state为执行完成状态RAN）。如果这个原子操作成功，就设置代表计算结果的变量result的值为Callable.call()的返回值，然后调用AQS.releaseShared（int arg）。 </li>
<li>AQS.releaseShared（int arg）首先会回调在子类Sync中实现的tryReleaseShared（arg）来执行release操作（设置运行任务的线程runner为null，然会返回true）；AQS.releaseShared（int arg），然后唤醒线程等待队列中的第一个线程。</li>
<li>调用FutureTask.done()。 当执行FutureTask.get()方法时，如果FutureTask不是处于执行完成状态RAN或已取消状态 CANCELLED，当前执行线程将到AQS的线程等待队列中等待（见下图的线程A、B、C和D）。当某个线程执行FutureTask.run()方法或FutureTask.cancel（…）方法时，会唤醒线程等待队列的第一个线程（见图所示的线程E唤醒线程A）。</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/15/CaODm.png" alt="CaODm.png"></p>
<p>假设开始时FutureTask处于未启动状态或已启动状态，等待队列中已经有3个线程（A、B和 C）在等待。此时，线程D执行get()方法将导致线程D也到等待队列中去等待。 当线程E执行run()方法时，会唤醒队列中的第一个线程A。线程A被唤醒后，首先把自己从队列中删除，然后唤醒它的后继线程B，最后线程A从get()方法返回。线程B、C和D重复A线程的处理流程。最终，在队列中等待的所有线程都被级联唤醒并从get()方法返回。</p>
<p>参考：<br><strong>《Java并发编程的艺术》</strong></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】Java内存模型（上）</title>
    <url>/2020/07/06/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(一）内存模型（上）含Java内存模型基础/重排序/顺序一致性/volatile内存语义/锁的内存语义</strong></p>
<a id="more"></a>

<h2 id="内存模型基础"><a href="#内存模型基础" class="headerlink" title="内存模型基础"></a>内存模型基础</h2><h3 id="并发编程模型的两个关键问题"><a href="#并发编程模型的两个关键问题" class="headerlink" title="并发编程模型的两个关键问题"></a>并发编程模型的两个关键问题</h3><ol>
<li>线程之间如何通信？<blockquote>
<p>通信是指线程之间以何种机制来交换信息。在命令式编程 中，线程之间有两种通信机制：共享内存和消息传递   </p>
<ul>
<li>共享内存的并发模型：线程之间共享程序的公共状态，通过写-读内存中的公共状态进行<strong>隐式通信</strong>；</li>
<li>消息传递的并发模型：线程之间没有公共状态，线程之间必须通过发送消 息来进行<strong>显式通信</strong>。</li>
</ul>
</blockquote>
</li>
<li>线程之间如何同步？<blockquote>
<p>同步是指程序中用于控制不同线程间操作发生相对顺序的机制</p>
<ul>
<li>共享内存的并发模型：<strong>同步是显式进行</strong>的，程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行；</li>
<li>消息传递的并发模型：由于消息的发送必须在消息的接收之前，因此<strong>同步是隐式进行</strong>的。</li>
</ul>
</blockquote>
</li>
</ol>
<p>3.Java并发采用的机制</p>
<blockquote>
<p><strong>Java的并发</strong>采用的是<strong>共享内存模型</strong>，Java线程之间的通信总是隐式进行，<strong>整个通信过程对 程序员完全透明</strong>。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
</blockquote>
<h3 id="Java内存模型（JMM）的抽象结构"><a href="#Java内存模型（JMM）的抽象结构" class="headerlink" title="Java内存模型（JMM）的抽象结构"></a>Java内存模型（JMM）的抽象结构</h3><h4 id="1-JMM涵盖的范围"><a href="#1-JMM涵盖的范围" class="headerlink" title="1. JMM涵盖的范围"></a>1. JMM涵盖的范围</h4><blockquote>
<p>在Java中，所有实例域、静态域和数组元素（总体称之为共享元素）都存储在堆内存中，堆内存在线程之间共享。局部变量），方法定义参数和异常处理器参数不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
</blockquote>
<h4 id="2-JMM的描述"><a href="#2-JMM的描述" class="headerlink" title="2. JMM的描述"></a>2. JMM的描述</h4><blockquote>
<p>Java线程之间的通信由JMM控制，<strong>JMM决定一个线程对共享变量的写入何时对另一个线程可见</strong>。从抽象的角度来看，JMM定义了线程和主内存之间的<strong>抽象关系</strong>：线程之间的共享变量存储在主内存中，<strong>每个线程都有一个私有的本地内存</strong>，本地内存中存储了该线程以读/写共享变量的<strong>副本</strong>。本地内存是JMM的一个<strong>抽象概念</strong>，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。<br><img src="https://wx2.sbimg.cn/2020/07/06/C4hPK.png" alt="C4hPK.png"></p>
</blockquote>
<h4 id="3-线程间的通信过程"><a href="#3-线程间的通信过程" class="headerlink" title="3.线程间的通信过程"></a>3.线程间的通信过程</h4><p><img src="https://wx1.sbimg.cn/2020/07/06/C4s1G.png" alt="C4s1G.png"><br>由图可知线程<strong>AB之间的通信过程</strong>为：   </p>
<blockquote>
<ul>
<li>本地内存A和本地内存B由主内存中共享变量x的副本(默认为0）；   </li>
<li>线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1；   </li>
<li>当线程A和线程B需要通信时，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。     </li>
</ul>
<p><strong>总体来说就是线程A与线程B通过主内存来进行通信，而JMM就是通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证的。</strong></p>
</blockquote>
<h3 id="从源代码到指令序列的重排序"><a href="#从源代码到指令序列的重排序" class="headerlink" title="从源代码到指令序列的重排序"></a>从源代码到指令序列的重排序</h3><blockquote>
<p>在执行程序时，为了提高性能，编译器和处理器常常会对源代码指令做重排序。重排序分3种类型（<strong>实际中会分别按以下顺序进行从源代码到最终执行的指令序列做重排序</strong>）。</p>
</blockquote>
<ol>
<li><strong>编译器优化的重排序</strong>：编译器在不改变单线程程序语义的前提下，可以重新安排语句 的执行顺序；</li>
<li><strong>指令级并行的重排序</strong>：现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序；</li>
<li><strong>内存系统的重排序</strong>：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上 去可能是在乱序执行。<blockquote>
<p>上述的<strong>1属于编译器重排序</strong>，<strong>2和3属于处理器重排序</strong>。这些重排序可能会<strong>导致多线程程序出现内存可见性问题</strong>。对于编译器，JMM的编译器重排序规则会<strong>禁止特定类型的编译器重排序</strong>（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为 Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。 <strong>JMM属于语言级的内存模型</strong>，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
</blockquote>
</li>
</ol>
<h3 id="重排序所带来的问题与解决方案"><a href="#重排序所带来的问题与解决方案" class="headerlink" title="重排序所带来的问题与解决方案"></a>重排序所带来的问题与解决方案</h3><p><img src="https://wx1.sbimg.cn/2020/07/06/C41al.png" alt="C41al.png"></p>
<blockquote>
<p>在这个小程序的运行中，很可能结果会为a=b=0(因为拿处理器A来说，它执行的步骤为A1-&gt;A2-&gt;A3)。虽然处理器A执行内存操作的顺序为：A1→A2，但内存操作实际发生的顺序却是A2→A1。此时，处理器A的内存操作顺序被重排序了，这里的关键是，由于<strong>写缓冲区仅对自己的处理器可见</strong>，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此<strong>现代的处理器都会允许对写-读操作进行重排序</strong>。</p>
</blockquote>
<blockquote>
<p>为了<strong>保证内存可见性</strong>，Java编译器在<strong>生成指令序列的适当位置会插入内存屏障指令</strong>来<strong>禁止特定类型的处理器重排序</strong>。JMM把内存屏障指令分为4类:<br><img src="https://wx2.sbimg.cn/2020/07/06/C4w78.png" alt="C4w78.png"><br>其中StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他3个屏障的效果。现代的多处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（Buffer Fully Flush）。</p>
</blockquote>
<h3 id="happens-before简介"><a href="#happens-before简介" class="headerlink" title="happens-before简介"></a>happens-before简介</h3><blockquote>
<p>。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p>
</blockquote>
<p>一些有关happens-before的规则</p>
<blockquote>
<ul>
<li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before<strong>于</strong>该线程中的<strong>任意后续操作</strong>。</li>
<li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before<strong>于</strong>随后对这个锁的<strong>加锁</strong>。 </li>
<li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 </li>
<li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
</ul>
</blockquote>
<p><strong>注意</strong>：</p>
<blockquote>
<p> 两个操作之间具有happens-before关系，<strong>并不意味着前一个操作必须要在后一个操作之前执行</strong>！happens-before<strong>仅仅要求前一个操作（执行的结果）对后一个操作可见</strong>，<strong>且前一个操作按顺序排在第二个操作之前</strong>的定义很微妙，后文会具体说明happens-before为什么要这么定义。，一个happens-before规则对应于一个或多个编译器和处理器重排序规则。对 于Java程序员来说，happens-before规则简单易懂，它避免Java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法。</p>
</blockquote>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
</blockquote>
<h4 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><blockquote>
<p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间 就存在数据依赖性。<br><a href="https://sbimg.cn/image/CM2CD" target="_blank" rel="noopener"><img src="https://wx1.sbimg.cn/2020/07/06/CM2CD.png" alt="CM2CD.png"></a><br>这三种情况只要重新排序两个操作的执行顺序，执行结果就会发生改变<br>前编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器<strong>不会改变单个处理器中执行的指令序列和单个线程中执行的操作中存在数据依赖关系的两个操作的执行顺序不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑</strong></p>
</blockquote>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><blockquote>
<p>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义，也就是说存在数据依赖的操作的执行顺序不会被改变，但是不存在数据依赖的操作的执行顺序可能会被改变，如 1.int a=1;  2.int b=1; 3.int c = a+b;在这个情况中，1和2依赖3所以3不会在1 2之前执行，但是1和2并不一定顺序执行。由于结果是一样的，但是要注意<strong>单线程程序并不一定是按照程序的顺序执行的！</strong>as-if-serial把单线程程序保护了起来，使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
</blockquote>
<h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><blockquote>
<p>上面举例中的操作1的执行结果不需要对操作2可见；而且重排序操作1和操作1后的执行结果，与操作1和操作2按happens-before顺序执行的结果一致。在这种情况下，JMM会认为<strong>这种重排序并不非法</strong>，JMM允许这种重排，所以说在计算机中，软件技术和硬件技术有一个共同的目标：<strong>在不改变程序执行结果的前提下，尽可能提高并行度</strong>。编译器和处理器遵从这一目标，从happens-before的定义我们可以看出，JMM同样遵从这一目标。</p>
</blockquote>
<h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><blockquote>
<p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
</blockquote>
<h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><blockquote>
<p>顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语 言的内存模型都会以顺序一致性内存模型作为参照。</p>
</blockquote>
<h3 id="数据竞争与顺序一致性"><a href="#数据竞争与顺序一致性" class="headerlink" title="数据竞争与顺序一致性"></a>数据竞争与顺序一致性</h3><blockquote>
<p>当程序未正确同步时，就可能会存在数据竞争。Java内存模型规范对数据竞争的定义：在一个线程中写一个变量，在另一个线程读同一个变量，而且写和读<strong>没有通过同步来排序</strong>。当代码中包含数据竞争时，程序的执行往往产生错误结果。如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。JMM对正确同步的多线程程序的内存一致性做了如下保证: 如果程序是正确同步的，程序的执行将具有<strong>顺序一致性</strong>即<strong>程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同</strong>。马上我们就会看到，这对于程序员来说是一个极强的保证。这里的同步是指广义上的同步，包括对常用同步原语 （synchronized、volatile和final）的正确使用。</p>
</blockquote>
<h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p><img src="https://wx2.sbimg.cn/2020/07/06/CMBlI.png" alt="CMBlI.png"></p>
<blockquote>
<p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员<strong>提供了极强的内存可见性保证</strong>。当多个线程并发 执行时，图中的开关装置能把所有线程的所有内存读/写操作串行化（即在<strong>顺序一致性模型中，所有操作之间具有全序关系</strong>）。顺序一致性内存模型有两大特性:   </p>
<ul>
<li><strong>一个线程中的所有操作必须按照程序的顺序来执行</strong>。   </li>
<li><strong>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序</strong>,在顺序一致性内存模型中，<strong>每个操作都必须原子执行且立刻对所有线程可见</strong>。<br><img src="https://wx2.sbimg.cn/2020/07/06/CMdjG.png" alt="CMdjG.png"><br><img src="https://wx2.sbimg.cn/2020/07/06/CMsXw.png" alt="CMsXw.png"><br>但是，<strong>在JMM中就没有这个保证</strong>。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本没有被当前线程执行。只有当前线程把本地内存中写过的数据刷 新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其他线程看到的操作执行顺序将不一致。</li>
</ul>
</blockquote>
<h3 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h3><blockquote>
<p>对程序ReorderExample用锁来同步，看看正确同步的程序如何具有顺序 一致性。<br><img src="https://wx2.sbimg.cn/2020/07/06/CM1G2.png" alt="CM1G2.png"><br><img src="https://wx1.sbimg.cn/2020/07/06/CMqw8.png" alt="CMqw8.png"><br>从这里我们可以看到，JMM在具体实现上的基本方针为：<strong>在不改变（正确同步的）程序执行结果的前提下，尽可能地为编译器和处理器的优化打开方便之门。</strong></p>
</blockquote>
<h3 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h3><blockquote>
<p>未同步程序在JMM中的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有如下几个差异:</p>
<ul>
<li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行;</li>
<li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。</li>
<li>JMM不保证对64位的long型和double型变量的写操作具有原子性（因为32位处理器可能在总线执行机制中被拆分的两个事务其间穿插其他事务），而顺序一致性模型保证对所有的内存读/写操作都具有原子性。但从JDK5开始，仅仅只允许把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行，任意的读操作都必须具有原子性（即任意读操作必须要在单个读事务中执行）。</li>
</ul>
</blockquote>
<p>数据总线的执行机制：   </p>
<blockquote>
<p><img src="https://wx1.sbimg.cn/2020/07/06/CMWdY.png" alt="CMWdY.png"><br>在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步<br>骤称之为总线事务。总线事务包括读事务和写事务。每个事务会 读/写内存中一个或多个物理上连续的字。这里的关键是，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其他的处理器和I/O设备执行内存的读/写。假设处理器A，B和C同时向总线发起总线事务，这时总线仲裁（Bus Arbitration）会对竞争做出裁决。总线的这些工作机制可以把<strong>所有处理器对内存的访问以串行化的方式来执行</strong>。在任意时间点，最多只能有一个处理器可以访问内存。这个特性确保了单个总线事务之中的内存读/写 操作具有原子性。</p>
</blockquote>
<h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><h3 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h3><blockquote>
<ul>
<li>可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</li>
</ul>
</blockquote>
<h3 id="volatile写-读建立的happens-before关系"><a href="#volatile写-读建立的happens-before关系" class="headerlink" title="volatile写-读建立的happens-before关系"></a>volatile写-读建立的happens-before关系</h3><blockquote>
<p><strong>volatile变量的写-读可以实现线程之间的通信。从内存语义的角度来说，volatile的写-读与锁的释放-获取有相同的语义效果</strong>，例子：<br><img src="https://wx1.sbimg.cn/2020/07/06/CMVOR.png" alt="CMVOR.png"><br>1.根据程序次序规则，1happens-before2;3happens-before4。<br>2.根据volatile规则，2happens-before3。<br>3.根据happens-before的传递性规则，1 happens-before 4。<br>这里A线程写一个volatile变量后，B线程读同一个volatile变量。A线程在写volatile变量之前所有可见的共享变量，在B线程读同一个volatile变量后，将立即变得对B线程可见。</p>
</blockquote>
<h3 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h3><ul>
<li><strong>volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存</strong>。</li>
<li><strong>volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主 内存中读取共享变量。</strong>   </li>
</ul>
<p>也就是说：</p>
<ul>
<li>线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程 发出了（其对共享变量所做修改的）消息。</li>
<li>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile 变量之前对共享变量所做修改的）消息。</li>
<li>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
<h3 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h3><p>根据JMM针对编译器制定的bolatile重排序的规则表：<br><img src="https://wx2.sbimg.cn/2020/07/06/CXxH1.png" alt="CXxH1.png"></p>
<blockquote>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中<strong>插入内存屏障</strong>来禁止特定类型的处理器重排序,它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义：</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
</blockquote>
<blockquote>
<p>volatile写-读内存语义的常见使用模式是：一个 写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时， 选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里可以看到JMM 在实现上的一个特点：<strong>首先确保正确性，然后再去追求执行效率</strong>。</p>
</blockquote>
<p>一个例子：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">text</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> a;</span><br><span class="line">    volatile <span class="built_in">int</span> i;</span><br><span class="line">    volatile <span class="built_in">int</span> j;</span><br><span class="line">    <span class="built_in">void</span> readAndWrite()&#123;</span><br><span class="line">        <span class="built_in">int</span> v1 = i;    <span class="comment">//第一个volatile读</span></span><br><span class="line">        <span class="built_in">int</span> v2 = j;    <span class="comment">//第二个volatile读</span></span><br><span class="line">        a = v1 + v2;   <span class="comment">//第一个普通写</span></span><br><span class="line">        i = v1+<span class="number">1</span>;      <span class="comment">//第一个volatile写</span></span><br><span class="line">        j = v2+<span class="number">1</span>;      <span class="comment">//第二个volatile写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中对于readAndWrite，编译器在生成字节码时会做如下的优化：</p>
<blockquote>
<p><img src="https://wx1.sbimg.cn/2020/07/06/CXlNm.png" alt="CXlNm.png"><br>注意，<strong>最后的StoreLoad屏障不能省略。因为第二个volatile写之后，方法立即return</strong></p>
</blockquote>
<p>继续优化：</p>
<blockquote>
<p>上面的优化针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以X86处理器为例，<strong>除了最后的StoreLoad屏障外，其他的屏障都会被省略</strong>。因为X86处理器仅会对写-读操作做重排序。X86不会对读-读、读-写和写-写操作做重排序，因此在X86处理器中会省略掉这3种操作类型对应的内存屏障。在X86中，JMM仅需在volatile写后面插入一个StoreLoad屏障即可正确实现volatile写-读的内存语义。这意味着在X86处理器中，volatile写的开销比volatile读的开销会大很多（因为执行StoreLoad屏障开销会比较大）。<br><img src="https://wx1.sbimg.cn/2020/07/06/CXSsd.png" alt="CXSsd.png"></p>
</blockquote>
<h3 id="volatile小总结"><a href="#volatile小总结" class="headerlink" title="volatile小总结"></a>volatile小总结</h3><blockquote>
<p>由于volatile<strong>仅仅保证对单个volatile变量的读/写具有原子性</strong>，而<strong>锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性</strong>。<strong>在功能上，锁比volatile更强大</strong>；<strong>在可伸缩性和执行性能上，volatile更有优势</strong>。如果读者想在程序中用volatile代替锁，请一定谨慎，具体详情请参阅Brian Goetz的文章《Java理论与实践：正确使用Volatile变量》。</p>
</blockquote>
<h2 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h2><blockquote>
<p>众所周知，锁可以让临界区互斥执行。这里将介绍锁的另一个同样重要，但常常被忽视的功能：锁的内存语义。</p>
</blockquote>
<h3 id="锁的释放-获取建立的happens-before关系"><a href="#锁的释放-获取建立的happens-before关系" class="headerlink" title="锁的释放-获取建立的happens-before关系"></a>锁的释放-获取建立的happens-before关系</h3><blockquote>
<p>锁是Java并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。来看一个锁释放-获取的例子：</p>
</blockquote>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">clss text&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123; <span class="comment">//1</span></span><br><span class="line">        a++;                          <span class="comment">//2</span></span><br><span class="line">    &#125;                                 <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;  <span class="comment">//4</span></span><br><span class="line">        <span class="keyword">int</span> i = a;                    <span class="comment">//5</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;                                 <span class="comment">//6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类的代码中包含着三类happens-before关系：</p>
<blockquote>
<ul>
<li>程序次序规则：1 happens-before 2，2 happens-before 3;4 happens-before 5,5 happens- before 6。</li>
<li>监视器锁规则：3happens-before4</li>
<li>happens-before传递性：2 happens-before 5</li>
</ul>
</blockquote>
<p>综合来看：<br><img src="https://wx2.sbimg.cn/2020/07/06/CmDBn.png" alt="CmDBn.png"></p>
<blockquote>
<p>每一个箭头链接的两个节点，代表了一个happens-before关系。黑色箭头表示 程序顺序规则；橙色箭头表示监视器锁规则；蓝色箭头表示组合这些规则后提供的happens- before保证。<br><strong>图表示在线程A释放了锁之后，随后线程B获取同一个锁。在上图中，2 happens-before 5。因此，线程A在释放锁之前所有可见的共享变量，在线程B获取同一个锁之后，将立刻变得对B线程可见</strong>。</p>
</blockquote>
<h3 id="锁的释放和获取的内存语义"><a href="#锁的释放和获取的内存语义" class="headerlink" title="锁的释放和获取的内存语义"></a>锁的释放和获取的内存语义</h3><blockquote>
<ul>
<li><strong>线程释放锁</strong>时：JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。以上面的程序为例，A线程释放锁后，共享数据的状态就被刷新了；</li>
<li><strong>线程获取锁</strong>时：<strong>JMM会把该线程对应的本地内存置为无效</strong>。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。相当于线程A向线程B发送了消息</li>
</ul>
</blockquote>
<p>总结：</p>
<blockquote>
<ul>
<li>锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。 </li>
<li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</li>
<li>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。</li>
<li>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
</blockquote>
<h3 id="锁内存语义的实现"><a href="#锁内存语义的实现" class="headerlink" title="锁内存语义的实现"></a>锁内存语义的实现</h3><p>示例代码：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> &#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>; </span><br><span class="line">    ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>(); <span class="comment">// 获取锁 </span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a++; </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123; </span><br><span class="line">            <span class="keyword">lock</span>.unlock(); <span class="comment">// 释放锁 </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span> (<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>(); <span class="comment">// 获取锁 </span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = a; </span><br><span class="line">            …… </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">            <span class="keyword">lock</span>.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125; </span><br><span class="line">            </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在ReentrantLock中，调用lock()方法获取锁；调用unlock()方法释放锁。 ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronizer（简称之为AQS）。AQS使用一个整型的volatile变量（命名为state）来维护同步状态，这个volatile变量是ReentrantLock内存语义实现的关键。<br><img src="https://wx2.sbimg.cn/2020/07/06/CmbVh.png" alt="CmbVh.png"><br>ReentrantLock分为公平锁和非公平锁，逐一分析：</p>
</blockquote>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>使用公平锁时，<strong>加锁方法lock()调用轨迹如下</strong>：<br>1.ReentrantLock:lock()；<br>2.FairSync:lock()。<br>3.AbstractQueuedSynchronizer:acquire(int arg)。<br>4.ReentrantLock:tryAcquire(int acquires)。<br><strong>在第4步真正开始加锁</strong>，下面是该方法的源代码。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected final boolean <span class="keyword">try</span><span class="constructor">Acquire(<span class="params">int</span> <span class="params">acquires</span>)</span> &#123; </span><br><span class="line">    final Thread current = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>; </span><br><span class="line">    <span class="built_in">int</span> c = get<span class="constructor">State()</span>; <span class="comment">// 获取锁的开始，首先读volatile变量state if (c == 0) &#123; </span></span><br><span class="line">        <span class="keyword">if</span> (is<span class="constructor">First(<span class="params">current</span>)</span><span class="operator"> &amp;&amp; </span>compare<span class="constructor">AndSetState(0, <span class="params">acquires</span>)</span>)&#123;</span><br><span class="line">            set<span class="constructor">ExclusiveOwnerThread(<span class="params">current</span>)</span>; </span><br><span class="line">            return <span class="literal">true</span>; </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (current<span class="operator"> == </span>get<span class="constructor">ExclusiveOwnerThread()</span>) &#123; </span><br><span class="line">        <span class="built_in">int</span> nextc = c + acquires; </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) throw <span class="keyword">new</span> <span class="constructor">Error(<span class="string">"Maximum lock count exceeded"</span>)</span>; </span><br><span class="line">        set<span class="constructor">State(<span class="params">nextc</span>)</span>; </span><br><span class="line">        return <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面源代码中我们可以看出，加锁方法首先读volatile变量state。</p>
</blockquote>
<p>在使用公平锁时，<strong>解锁方法unlock()调用轨迹</strong>如下<br>1.ReentrantLock:unlock()。<br>2.AbstractQueuedSynchronizer:release(int arg)。<br>3.Sync:tryRelease(int releases)。<br>在<strong>第3步真正开始释放锁</strong>，下面是该方法的源代码:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected final boolean <span class="keyword">try</span><span class="constructor">Release(<span class="params">int</span> <span class="params">releases</span>)</span> &#123; </span><br><span class="line">    <span class="built_in">int</span> c = get<span class="constructor">State()</span> - releases; </span><br><span class="line">    <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span> != get<span class="constructor">ExclusiveOwnerThread()</span>)</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">IllegalMonitorStateException()</span>; </span><br><span class="line">    boolean free = <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">if</span> (c<span class="operator"> == </span><span class="number">0</span>) &#123; </span><br><span class="line">    free = <span class="literal">true</span>; </span><br><span class="line">    set<span class="constructor">ExclusiveOwnerThread(<span class="params">null</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    set<span class="constructor">State(<span class="params">c</span>)</span>; <span class="comment">// 释放锁的最后，写volatile变量state </span></span><br><span class="line">    return free; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面的源代码可以看出，在释放锁的最后写volatile变量state。 公平锁在释放锁的最后写volatile变量state，在获取锁时首先读这个volatile变量。根据 volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。</p>
</blockquote>
<h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>非公平锁的释放和公平锁完全一样，所以这里仅仅分析非公平锁的获取。使用非公平锁时，加锁方法lock()调用轨迹如下：<br>1.ReentrantLock:lock()。<br>2.NonfairSync:lock()。<br>3.AbstractQueuedSynchronizer:compareAndSetState(int expect,int update)。<br>在第3步真正开始加锁，下面是该方法的源代码。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected final boolean compare<span class="constructor">AndSetState(<span class="params">int</span> <span class="params">expect</span>, <span class="params">int</span> <span class="params">update</span>)</span> &#123; </span><br><span class="line">    return unsafe.compare<span class="constructor">AndSwapInt(<span class="params">this</span>, <span class="params">stateOffset</span>, <span class="params">expect</span>, <span class="params">update</span>)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该方法以原子操作的方式更新state变量，本文把Java的compareAndSet()方法调用简称为 CAS。JDK文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有volatile读和写的内存语义。</p>
</blockquote>
<h4 id="在常见的intel-X86处理器中，CAS是如何同时具有volatile读和volatile写的内存语义的"><a href="#在常见的intel-X86处理器中，CAS是如何同时具有volatile读和volatile写的内存语义的" class="headerlink" title="在常见的intel X86处理器中，CAS是如何同时具有volatile读和volatile写的内存语义的?"></a>在常见的intel X86处理器中，CAS是如何同时具有volatile读和volatile写的内存语义的?</h4><p>下面是sun.misc.Unsafe类的compareAndSwapInt()方法的源代码。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="built_in">boolean</span> compareAndSwapInt(<span class="keyword">Object</span> o, <span class="keyword">long</span> offset, <span class="built_in">int</span> expected)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到，这是一个本地方法调用。这个本地方法在openjdk中依次调用的c++代码为： unsafe.cpp，atomic.cpp和atomic_windows_x86.inline.hpp。这个本地方法的最终实现在openjdk的如下位置：openjdk-7-fcs-src-b147- 27_jun_2011\openjdk\hotspot\src\os_cpu\windows_x86\vm\atomic_windows_x86.inline.hpp（对应于Windows操作系统，X86处理器）。</p>
</blockquote>
<p>下面是对应于intel X86处理器的源代码的片段:</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">inlinej <span class="keyword">int</span> Atomic::<span class="keyword">cmpxchg</span> (jint exchange_value, volatile jint* dest, jint compare_value) </span><br><span class="line">&#123; // alternative for InterlockedCompareExchange </span><br><span class="line">    <span class="keyword">int</span> mp = os::is_MP()<span class="comment">;</span></span><br><span class="line">    __asm &#123; <span class="keyword">mov</span> <span class="built_in">edx</span>, dest <span class="keyword">mov</span> <span class="built_in">ecx</span>, exchange_value <span class="keyword">mov</span> <span class="built_in">eax</span>, compare_value LOCK_IF_MP(mp) <span class="keyword">cmpxchg</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>], <span class="built_in">ecx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如上面源代码所示，程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前 缀。如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（Lock Cmpxchg）。反之，如果程序是在单处理器上运行，就省略lock前缀（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障效果）。</p>
</blockquote>
<h4 id="intel的手册对lock前缀的说明"><a href="#intel的手册对lock前缀的说明" class="headerlink" title="intel的手册对lock前缀的说明"></a>intel的手册对lock前缀的说明</h4><ul>
<li>1.确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium4、Intel Xeon及P6处理器开始，Intel使用缓存锁定（Cache Locking） 来保证指令执行的原子性。缓存锁定将大大降低lock前缀指令的执行开销。     </li>
<li>2.禁止该指令，与之前和之后的读和写指令重排序。   </li>
<li>3.把写缓冲区中的所有数据刷新到内存中。</li>
</ul>
<p>上面的第2点和第3点所具有的内存屏障效果，足以同时实现volatile读和volatile写的内存语义。</p>
<h4 id="公平锁和非公平锁的内存语义总结"><a href="#公平锁和非公平锁的内存语义总结" class="headerlink" title="公平锁和非公平锁的内存语义总结"></a>公平锁和非公平锁的内存语义总结</h4><ul>
<li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。</li>
<li>公平锁获取时，首先会去读volatile变量。</li>
<li>非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile 写的内存语义。    </li>
</ul>
<p>从本文对ReentrantLock的分析可以看出，锁释放-获取的内存语义的实现至少有下面两种方式:</p>
<ul>
<li>1.利用volatile变量的写-读所具有的内存语义。</li>
<li>2.利用CAS所附带的volatile读和volatile写的内存语义。</li>
</ul>
<h3 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h3><p>由于Java的CAS同时具有volatile读和volatile写的内存语义，因此Java线程之间的通信现 在有了下面4种方式。</p>
<ul>
<li>1.A线程写volatile变量，随后B线程读这个volatile变量。</li>
<li>2.A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>3.A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。 </li>
<li>4.A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。 <blockquote>
<p>Java的CAS会使用现代处理器上提供的高效机器级别的原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式。首先，声明共享变量为volatile。 然后，使用CAS的原子条件更新来实现线程之间的同步。同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的 通信。AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。</p>
</blockquote>
</li>
</ul>
<p>从整体来看，concurrent包的实现示意图:<br><a href="https://sbimg.cn/image/Cp4cw" target="_blank" rel="noopener"><img src="https://wx1.sbimg.cn/2020/07/06/Cp4cw.png" alt="Cp4cw.png"></a></p>
<p>参考：<br>《Java并发编程的艺术》</p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】Java内存模型（下）</title>
    <url>/2020/07/07/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(二）内存模型（下）含final域的内存定义/happens-before/双重检查锁定与延迟初始化/Java内存模型综述</strong></p>
<a id="more"></a>
<h2 id="final域的内存定义"><a href="#final域的内存定义" class="headerlink" title="final域的内存定义"></a>final域的内存定义</h2><p>与前面介绍的锁和volatile相比，对final域的读和写更像是普通的变量访问。</p>
<h3 id="final域的重排序规则"><a href="#final域的重排序规则" class="headerlink" title="final域的重排序规则"></a>final域的重排序规则</h3><blockquote>
<ul>
<li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li>
</ul>
</blockquote>
<p>下面给出一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;                  <span class="comment">//普通变量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j;            <span class="comment">//final变量</span></span><br><span class="line">    <span class="keyword">static</span> FinalExample obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalExaple</span><span class="params">()</span></span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.i = <span class="number">1</span>;         <span class="comment">//写普通域</span></span><br><span class="line">        <span class="keyword">this</span>.j = <span class="number">2</span>;         <span class="comment">//写final域</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;    <span class="comment">//写方法 线程A执行</span></span><br><span class="line">        obj = <span class="keyword">new</span> FinalExample();<span class="comment">//写对象引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;     <span class="comment">//读方法 线程B执行</span></span><br><span class="line">        FinalExample object = obj;<span class="comment">//读对象引用</span></span><br><span class="line">        <span class="keyword">int</span> a = obj.i;      <span class="comment">//读普通变量</span></span><br><span class="line">        <span class="keyword">int</span> b = obj.j;      <span class="comment">//读final变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h3><blockquote>
<p>写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含下面2个方面:</p>
<ul>
<li>JMM禁止编译器把final域的写重排序到构造函数之外。</li>
<li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障 禁止处理器把final域的写重排序到构造函数之外   </li>
</ul>
</blockquote>
<blockquote>
<p>写普通域的操作被编译器重排序到了构造函数之外，读线程B错误地读取了普通变量i初始化之前的值。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确地读取了final变量初始化之后的值。 写final域的重排序规则可以确保：<strong>在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障</strong>。</p>
</blockquote>
<h3 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h3><blockquote>
<p>读final域的重排序规则是：在一个线程中，<strong>初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作</strong>（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。 初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器的。 </p>
</blockquote>
<blockquote>
<p>在时序图中读对象的普通域的操作被处理器重排序到读对象引用之前。<strong>读普通域时，该域还没有被写线程A写入</strong>，这是一个错误的读取操作。而读final域的重排序规则会把读对象final域的操作“限定”在读对象引用之后，此时该final域已经被A线程初始化过了，这是一个正确的读取操作。<br>读final域的重排序规则可以确保：<strong>在读一个对象的final域之前，一定会先读包含这个final域的对象的引用</strong>。</p>
</blockquote>
<h3 id="final域为引用类型"><a href="#final域为引用类型" class="headerlink" title="final域为引用类型"></a>final域为引用类型</h3><p>上面我们看到的final域是基础数据类型，如果final域是引用类型，将会有什么效果？示例代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">FinalReferenceExample</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span>[] <span class="built_in">array</span>int;              <span class="comment">//饮用类型的final</span></span><br><span class="line">    static FinalReferenceExample obj;</span><br><span class="line">    <span class="keyword">public</span> FinalReferenceExample()&#123;</span><br><span class="line">        <span class="built_in">array</span>int = new <span class="built_in">int</span>[<span class="number">1</span>];         <span class="comment">//1</span></span><br><span class="line">        <span class="built_in">array</span>int[<span class="number">0</span>] = <span class="number">1</span>;               <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> writeOne()&#123;            <span class="comment">//A执行的写操作</span></span><br><span class="line">        obj = new FinalReferenceExample();<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> writeTwo()&#123;            <span class="comment">//B执行的写操作</span></span><br><span class="line">        obj.<span class="built_in">array</span>int[<span class="number">0</span>] = <span class="number">2</span>;           <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> read()&#123;                <span class="comment">//C执行的读操作</span></span><br><span class="line">        <span class="keyword">if</span>(obj!=<span class="literal">null</span>)&#123;                 <span class="comment">//5</span></span><br><span class="line">            <span class="built_in">int</span> temp = obj.<span class="built_in">array</span>int[<span class="number">0</span>];<span class="comment">//6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本例final域为一个引用类型，它引用一个int型的数组对象。对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：<strong>在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序</strong>。 对上面的示例程序，1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。<br>JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写 入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看得到，也可能看不到。<strong>JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知</strong>。 <strong>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性</strong>。</p>
</blockquote>
<h3 id="为什么final引用不能从构造函数内“溢出”"><a href="#为什么final引用不能从构造函数内“溢出”" class="headerlink" title="为什么final引用不能从构造函数内“溢出”\"></a>为什么final引用不能从构造函数内“溢出”\</h3><blockquote>
<p>写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该 引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实，要得到这个效果，还需要一个保证：<strong>在构造函数内部，不能让这个被构造对象的引用为其他线程所见</strong>，也就是对象引用不能在构造函数中“溢出”。示例代码:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> i;</span><br><span class="line">    FinalReferenceExcapeExample obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceExcapeExample</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i = <span class="number">1</span>;                    <span class="comment">//1写final域</span></span><br><span class="line">        obj = <span class="keyword">this</span>                <span class="comment">//2this在此溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FinalReferenceExcapeExample();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj!=<span class="keyword">null</span>)&#123;            <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> temp = obj.i;     <span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的时序图可能将1放到最后</p>
<blockquote>
<p>假设一个线程A执行writer()方法，另一个线程B执行reader()方法。这里的操作2使得对象还未完成构造前就为线程B可见。即使这里的操作2是构造函数的最后一步，且在程序中操作2排在操作1后面，执行reader()方法的线程仍然可能无法看到final域被初始化后的值，因为<strong>这里的操作1和操作2之间可能被重排序</strong>。所以在构造函数返回前，被构造对象的引用不能为其他线程所见，<strong>因为此时的final域可能还没有被初始化</strong>。在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。</p>
</blockquote>
<h3 id="final语义在处理器中的实现"><a href="#final语义在处理器中的实现" class="headerlink" title="final语义在处理器中的实现"></a>final语义在处理器中的实现</h3><blockquote>
<p>写final域的重排序规则会要求编译器在final域的写之后，构造函数return之前插入一个StoreStore障屏。读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障。由于<strong>X86处理器不会对写-写操作做重排序</strong>，所以在X86处理器中，写final域需要的StoreStore障屏会被省略掉。同样，由于<strong>X86处理器不会对存在间接依赖关系的操作做重排序</strong>， 所以在X86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说，在X86处理器中，final域的读/写不会插入任何内存屏障</p>
</blockquote>
<h3 id="JSR-133为什么要增强final的语义"><a href="#JSR-133为什么要增强final的语义" class="headerlink" title="JSR-133为什么要增强final的语义"></a>JSR-133为什么要增强final的语义</h3><blockquote>
<p>在旧的Java内存模型中，一个最严重的缺陷就是线程可能看到final域的值会改变。比如， 一个线程当前看到一个整型final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为1（被某个线程初始化之后的值）。最常见的例子就是在旧的Java内存模型中，String的值可能会改变。为了修补这个漏洞，JSR-133专家组增强了final的语义。<strong>通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证</strong>：<strong>只要对象是正确构造的（被构造对象的引用在 构造函数中没有“溢出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</strong></p>
</blockquote>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>happens-before是JMM最核心的概念。对应Java程序员来说，理解happens-before是理解JMM的关键。</p>
<h3 id="JMM的设计"><a href="#JMM的设计" class="headerlink" title="JMM的设计"></a>JMM的设计</h3><blockquote>
<p>从JMM设计者的角度，在设计JMM时，需要考虑两个关键因素。 </p>
<ul>
<li>程序员对内存模型的使用。程序员希望内存模型易于理解、易于编程。<strong>程序员希望基于一个强内存模型来编写代码</strong>。</li>
<li>编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。<strong>编译器和处理器希望实现一个弱内存模型</strong>。</li>
</ul>
</blockquote>
<blockquote>
<p>由于这两个因素互相矛盾，所以JSR-133专家组在设计JMM时的核心目标就是找到一个好的平衡点：一方面，要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能地放松。我们来看JSR-133是如何实现这一目标的</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> pi = <span class="number">3.14</span>; <span class="comment">// A </span></span><br><span class="line"><span class="built_in">double</span> r = <span class="number">1.0</span>; <span class="comment">// B </span></span><br><span class="line"><span class="built_in">double</span> area = pi * r * r; <span class="comment">// C</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面计算圆的面积的示例代码存在3个happens-before关系，如下:</p>
<ul>
<li>A happens-before B;</li>
<li>B happens-before C;</li>
<li>A happens-before C。 </li>
</ul>
</blockquote>
<p>在3个happens-before关系中，2和3是必需的，但1是不必要的。因此，JMM把happens-before要求禁止的重排序分为了下面两类：</p>
<blockquote>
<ul>
<li>会改变程序执行结果的重排序;</li>
<li>不会改变程序执行结果的重排序。 </li>
</ul>
</blockquote>
<p>JMM对这两种不同性质的重排序，采取了不同的策略，如下：</p>
<blockquote>
<ul>
<li>对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。</li>
<li>对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种重排序）<br><img src="https://wx2.sbimg.cn/2020/07/07/C0RiD.png" alt="C0RiD.png"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>JMM向程序员提供的happens-before规则能满足程序员的需求。JMM的happens-before规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的A happens-before B;</li>
<li>JMM对编译器和处理器的束缚已经尽可能少。从上面的分析可以看出，JMM其实是在遵循一个基本原则：<strong>只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行</strong>。例如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个volatile变量只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li>
</ul>
</blockquote>
<h3 id="happens-before的定义"><a href="#happens-before的定义" class="headerlink" title="happens-before的定义"></a>happens-before的定义</h3><blockquote>
<ul>
<li>1.如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前;</li>
<li>2.两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>1.是JMM对程序员的承诺。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。注意，这只是Java内存模型向程序员做出的保证！</li>
<li>2.是JMM对编译器和处理器重排序的约束原则。正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。</li>
</ul>
</blockquote>
<p>happens-before关系本质上和as-if-serial语义是一回事。</p>
<blockquote>
<ul>
<li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</li>
<li>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。 </li>
</ul>
</blockquote>
<p>as-if-serial语义和happens-before这么做的目的，都是<strong>为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度</strong>。</p>
<h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><blockquote>
<ul>
<li>1.程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li>2.监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>3.volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 </li>
<li>4.传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li>5.start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的 ThreadB.start()操作happens-before于线程B中的任意操作。</li>
<li>6.join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before于线程A从ThreadB.join()操作成功返回。</li>
</ul>
</blockquote>
<p>这里的规则1、2、3和4前面都说过，这里再做个总结。由于2和3情况类似，这里只以1、3和4为例来说明。</p>
<p>volatile写-读建立的happens-before：<br><img src="https://wx2.sbimg.cn/2020/07/07/C0gRj.png" alt="C0gRj.png"></p>
<blockquote>
<ul>
<li>1 happens-before 2和3 happens-before 4由程序顺序规则产生。由于编译器和处理器都要遵守as-if-serial语义，也就是说，as-if-serial语义保证了程序顺序规则。因此，可以把程序顺序 规则看成是对as-if-serial语义的“封装”。</li>
<li>2 happens-before 3是由volatile规则产生。前面提到过，对一个volatile变量的读，总是能看到（任意线程）之前对这个volatile变量最后的写入。因此，volatile的这个特性可以保证实现 volatile规则。 </li>
<li>1 happens-before 4是由传递性规则产生的。这里的传递性是由volatile的内存屏障插入策略和volatile的编译器重排序规则共同来保证的。 </li>
</ul>
</blockquote>
<p>下面我们来看start()规则。假设线程A在执行的过程中，通过执行ThreadB.start()来启动线程B；同时，假设线程A在执行ThreadB.start()之前修改了一些共享变量，线程B在开始执行后会 读这些共享变量。该程序对应的happens-before关系图为：<br><img src="https://wx1.sbimg.cn/2020/07/07/C0hWk.png" alt="C0hWk.png"></p>
<blockquote>
<ul>
<li>1 happens-before 2由程序顺序规则产生，2 happens-before 4由start()规则产生。根据传递性，将有1 happens-before 4。这实意味着，线程A在执行ThreadB.start()之前对共享变量所做的修改，接下来在线程B开始执行后都将确保对线程B可见。 </li>
</ul>
</blockquote>
<p>下面我们来看join()规则。假设线程A在执行的过程中，通过执行ThreadB.join()来等待线 程B终止；同时，假设线程B在终止之前修改了一些共享变量，线程A从ThreadB.join()返回后会读这些共享变量。该程序对应的happens-before关系图为：<br><img src="https://wx2.sbimg.cn/2020/07/07/C0syn.png" alt="C0syn.png"></p>
<blockquote>
<ul>
<li>2 happens-before 4由join()规则产生；4 happens-before 5由程序顺序规则产生。 根据传递性规则，将有2 happens-before 5。这意味着，线程A执行操作ThreadB.join()并成功返回后，线程B中的任意操作都将对线程A可见。</li>
</ul>
</blockquote>
<h3 id="双重检查锁定与延迟初始化"><a href="#双重检查锁定与延迟初始化" class="headerlink" title="双重检查锁定与延迟初始化"></a>双重检查锁定与延迟初始化</h3><blockquote>
<p>在Java程序中，有时候可能<strong>需要推迟一些高开销的对象初始化操作</strong>，并且只有在<strong>使用这些对象时才进行初始化</strong>。此时，程序员可能会采用延迟初始化。但要正确实现线程安全的延迟初始化需要一些技巧，否则很容易出现问题。</p>
</blockquote>
<h4 id="双重检查锁定的由来"><a href="#双重检查锁定的由来" class="headerlink" title="双重检查锁定的由来"></a>双重检查锁定的由来</h4><p>下面是非线程安全的延迟初始化对象的示例代码</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public class UnsafeLazyInitialization&#123;</span><br><span class="line">    private static<span class="built_in"> Instance </span>instance;</span><br><span class="line">    public static<span class="built_in"> Instance </span>getInstance()&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="built_in"> instance </span>= new Instance();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双重检查锁定：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public class SafeLacyInitialization&#123;</span><br><span class="line">    private static<span class="built_in"> Instance </span>instance;</span><br><span class="line">    public static<span class="built_in"> Instance </span>getInstance()&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            synchronized (DoubleCheckedLoacking.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                   <span class="built_in"> instance </span>= new Instance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>双重检查锁定看起来似乎很完美，但这是一个错误的优化！在线程执行到第4行，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p>
</blockquote>
<h4 id="问题的根源"><a href="#问题的根源" class="headerlink" title="问题的根源"></a>问题的根源</h4><p>双重检查锁定示例代码的第7行（instance=new Singleton();）创建了一个对象。这一行代码可以分解为如下的3行伪代码。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">memory = allocata() //为对象分配内存区域</span><br><span class="line">ctorInstance(memory) //对象初始化</span><br><span class="line">instance = memory //设置instance指向刚分配的内存区域</span><br></pre></td></tr></table></figure>
<p>上面3行伪代码中的2和3之间，可能会被重排序<br><img src="https://wx2.sbimg.cn/2020/07/07/C0Zt1.png" alt="C0Zt1.png"></p>
<blockquote>
<p>这里A2和A3虽然重排序了，但Java内存模型的intra-thread semantics将确保A2一定会排在A4前面执行。因此，线程A的intra-thread semantics没有改变，但A2和A3的重排序，将导致线程B在B1处判断出instance不为空，线程B接下来将访问instance引用的对象。此时，线程B将会访 问到一个还未初始化的对象。在知晓了问题发生的根源之后，我们可以想出两个办法来实现线程安全的延迟初始化:</p>
<ul>
<li>不允许2和3重排序。</li>
<li>允许2和3重排序，但不允许其他线程“看到”这个重排序。</li>
</ul>
</blockquote>
<h4 id="基于volatile的解决方案"><a href="#基于volatile的解决方案" class="headerlink" title="基于volatile的解决方案"></a>基于volatile的解决方案</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public class SafeLazyInitilization&#123;</span><br><span class="line">    private volatile static<span class="built_in"> Instance </span>instance;</span><br><span class="line">    public static<span class="built_in"> Instance </span>getInstance()&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            synchronized(DoubleCheckedLocking.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                   <span class="built_in"> instance </span>= new Instance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当声明对象的引用为volatile后，3行伪代码中的2和3之间的重排序，在多线程环境中将会被禁止，保证了线程安全的延迟初始化。</p>
<h2 id="Java内存模型综述"><a href="#Java内存模型综述" class="headerlink" title="Java内存模型综述"></a>Java内存模型综述</h2><p>###处理器的内存模型<br>顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会以顺序一致性内存模型为<strong>参照</strong>。在设计时，JMM和处理器内存模型会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。根据对不同类型的读/写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为如下几种类型：</p>
<blockquote>
<ul>
<li>放松程序中写-读操作的顺序，由此产生了Total Store Ordering内存模型（简称为TSO）;</li>
<li>在上面的基础上，继续放松程序中写-写操作的顺序，由此产生了Partial Store Order内存模型（简称为PSO）;</li>
<li>在前面两条的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了Relaxed Memory Order内存模型（简称为RMO）和PowerPC内存模型。 </li>
</ul>
</blockquote>
<p>注意：这里处理器对读/写操作的放松，是<strong>以两个操作之间不存在数据依赖性为前提</strong>的（因为处理器要遵守as-if-serial语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。   </p>
<p>常见处理器内存模型的细节特征如下：<br><a href="https://sbimg.cn/image/C2LZd" target="_blank" rel="noopener"><img src="https://wx1.sbimg.cn/2020/07/07/C2LZd.png" alt="C2LZd.png"></a></p>
<blockquote>
<p><strong>所有处理器内存模型都允许写-读重排序</strong>，因为它们都使用了写缓存区。写缓存区可能导致写-读操作重排序。同时，我们可以看到这些处 理器内存模型都允许更早读到当前处理器的写，原因同样是因为写缓存区。由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己写缓存区中的写。</p>
</blockquote>
<p>表中的各种处理器内存模型，从上到下，<strong>模型由强变弱</strong>。越是追求性能的处理器，内存模型设计得会越弱。因为这些处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。由于常见的处理器内存模型比JMM要弱，Java编译器在生成字节码时，<strong>会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序</strong>。同时，由于各种处理器内存模型的强弱不同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不相同。   </p>
<p>图展示了JMM在不同处理器内存模型中需要插入的内存屏障的示意图。 JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。<br><img src="https://wx2.sbimg.cn/2020/07/07/C2jI4.png" alt="C2jI4.png"></p>
<h3 id="各种内存模型之间的关系"><a href="#各种内存模型之间的关系" class="headerlink" title="各种内存模型之间的关系"></a>各种内存模型之间的关系</h3><p><strong>JMM是一个语言级的内存模型</strong>，<strong>处理器内存模型是硬件级的内存模型</strong>，顺序一致性内存模型是一个理论参考模型。<strong>常见的4种处理器内存模型比常用的3中语言内存模型要弱</strong>，<strong>处理器内存模型和语言内存模型都比顺序一致性内存模型要弱</strong>。<strong>同处理器内存模型一样，越是追求执行性能的语言，内存模型设计得会越弱</strong>。<br><img src="https://wx2.sbimg.cn/2020/07/07/C2qzA.png" alt="C2qzA.png"></p>
<h3 id="JMM的内存可见性保证"><a href="#JMM的内存可见性保证" class="headerlink" title="JMM的内存可见性保证"></a>JMM的内存可见性保证</h3><p>按程序类型，Java程序的内存可见性保证可以分为下列3类。</p>
<blockquote>
<ul>
<li>单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li>
<li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li>
<li>未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）</li>
</ul>
</blockquote>
<p>注意:</p>
<blockquote>
<p>最小安全性保障与64位数据的非原子性写并不矛盾。它们是两个不同的概念，它们“发生”的时间点也不同。最小安全性保证对象默认初始化之后（设置成员域为0、null或false），才会被任意线程使用。最小安全性“发生”在对象被任意线程使用之前。64位数据的非原子性写“发生”在对象被多个线程使用的过程中（写共享变量）。当发生问题时（处理器B看到 仅仅被处理器A“写了一半”的无效值），这里虽然处理器B读取到一个被写了一半的无效值，但这个值仍然是处理器A写入的，只不过是处理器A还没有写完而已。最小安全性保证<strong>线程读取到的值，要么是之前某个线程写入的值，要么是默认值</strong>（0、null、false）。但<strong>最小安全性并不保证 线程读取到的值，一定是某个线程写完后的值</strong>。最小安全性保证线程读取到的值不会无中生有的冒出来，但并不保证线程读取到的值一定是正确的。 图展示了这3类程序在JMM中与在顺序一致性内存模型中的执行结果的异同。 只要多线程程序是正确同步的，JMM保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。<br><img src="https://wx2.sbimg.cn/2020/07/07/C2wD7.png" alt="C2wD7.png"></p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><strong>对于Java内存模型的解读比较全面。对Java内存模型的了解也比较深入同时，当然这也有助于解决在Java并发编程中经常遇到的各种内存可见性问题。</strong></p>
<p>参考：<br>《Java并发编程的艺术》</p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】原子操作类</title>
    <url>/2020/07/11/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(六）原子操作类含原子更新基本类类型/更新数组/更新引用类型/更新字段类</strong></p>
<a id="more"></a>
<h2 id="原子更新基本类类型"><a href="#原子更新基本类类型" class="headerlink" title="原子更新基本类类型"></a>原子更新基本类类型</h2><p>使用原子的方式更新基本类型，Atomic包提供了以下3个类：</p>
<blockquote>
<ul>
<li>AtomicBoolean：原子更新布尔类型。 </li>
<li>AtomicInteger：原子更新整型。 </li>
<li>AtomicLong：原子更新长整型。 </li>
</ul>
</blockquote>
<p>以上3个类提供的方法几乎一模一样，所以以AtomicInteger为例进行讲解， AtomicInteger的常用方法如下:</p>
<blockquote>
<ul>
<li>int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的 value）相加，并返回结果。 </li>
<li>boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方 式将该值设置为输入的值。 </li>
<li>int getAndIncrement()：以原子方式将当前值加1，注意，<strong>这里返回的是自增前的值</strong>。 </li>
<li>void lazySet（int newValue）：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</li>
<li>int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。</li>
</ul>
</blockquote>
<p>AtomicInteger示例代码如代码所示:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(ai.getAndIncrement());</span><br><span class="line">		System.out.<span class="built_in">println</span>(ai.<span class="built_in">get</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>getAndIncrement实现原子操作的源码代码:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> final <span class="type">int</span> getAndIncrement() &#123; </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        <span class="type">int</span> <span class="keyword">current</span> = <span class="keyword">get</span>(); </span><br><span class="line">        <span class="type">int</span> next = <span class="keyword">current</span> + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(<span class="keyword">current</span>, next)) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">current</span>;</span><br><span class="line">            &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">public</span> final <span class="type">boolean</span> compareAndSet(<span class="type">int</span> expect, <span class="type">int</span> <span class="keyword">update</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(this, valueOffset, expect, <span class="keyword">update</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码中for循环体的第一步先取得AtomicInteger里存储的数值<br>第二步对AtomicInteger的当前数值进行加1操作，<br>关键的第三步调用compareAndSet方法来进行原子更新操作,该方法先检查当前数值是否等于current，等于意味着AtomicInteger的值没有被其他线程修改过，则将 AtomicInteger的当前数值更新成next的值，如果不等compareAndSet方法会返回false，程序会进入for循环重新进行compareAndSet操作。 </p>
<p>Atomic包提供了3种基本类型的原子更新，但是Java的基本类型里还有char、float和double等。Atomic包里的类基本都是使用Unsafe实现的，Unsafe的源码代码:</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果当前数值是expected，则原子的将Java变量更新成x </span></span><br><span class="line"><span class="comment">    * @return 如果更新成功则返回true </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="built_in">boolean</span> compareAndSwapObject(<span class="keyword">Object</span> o, <span class="keyword">long</span> offset, <span class="keyword">Object</span> expected, <span class="keyword">Object</span> x); </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="built_in">boolean</span> compareAndSwapInt(<span class="keyword">Object</span> o, <span class="keyword">long</span> offset, <span class="built_in">int</span> expected, <span class="built_in">int</span> x); </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="built_in">boolean</span> compareAndSwapLong(<span class="keyword">Object</span> o, <span class="keyword">long</span> offset, <span class="keyword">long</span> expected, <span class="keyword">long</span> x);</span><br></pre></td></tr></table></figure>
<p>Unsafe只提供了3种CAS方法：</p>
<blockquote>
<ul>
<li>compareAndSwapObject</li>
<li>compare- AndSwapInt</li>
<li>compareAndSwapLong，</li>
</ul>
</blockquote>
<p>再看AtomicBoolean源码，发现它是<strong>先把Boolean转换成整型，再使用compareAndSwapInt进行CAS</strong>，所以<strong>原子更新char、float和double变量也可以用类似 的思路来实现</strong>。</p>
<h2 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h2><p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下4个类：</p>
<blockquote>
<ul>
<li>AtomicIntegerArray：原子更新整型数组里的元素。</li>
<li>AtomicLongArray：原子更新长整型数组里的元素。</li>
<li>AtomicReferenceArray：原子更新引用类型数组里的元素</li>
</ul>
</blockquote>
<p>AtomicIntegerArray类主要是提供原子的方式更新数组里的整型，其常用方法如下: </p>
<blockquote>
<ul>
<li>int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。 </li>
<li>boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。 </li>
</ul>
</blockquote>
<p>以上几个类提供的方法几乎一样，所以仅以AtomicIntegerArray为例, AtomicIntegerArray的使用实例代码:</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AtomicIntegerArrayTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>[] <span class="keyword">value</span> = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="keyword">static</span> AtomicIntegerArray aia = <span class="keyword">new</span> AtomicIntegerArray(<span class="keyword">value</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		aia.getAndSet(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">		System.<span class="keyword">out</span>.println(aia.<span class="keyword">get</span>(<span class="number">0</span>));</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="keyword">value</span>[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<strong>数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组</strong>。</p>
<h2 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h2><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类：</p>
<blockquote>
<ul>
<li>AtomicReference：原子更新引用类型。</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li>
<li>AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，boolean initialMark）。 </li>
</ul>
</blockquote>
<p>以上几个类提供的方法几乎一样，所以仅以AtomicReference为例, AtomicReference的使用示例代码如代码:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> AtomicReference&lt;User&gt;  ar= <span class="keyword">new</span> AtomicReference&lt;User&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		User user = <span class="keyword">new</span> User(<span class="string">"Easonhe"</span>, <span class="number">22</span>);</span><br><span class="line">		ar.<span class="built_in">set</span>(user);</span><br><span class="line">		User update = <span class="keyword">new</span> User(<span class="string">"老贺"</span>, <span class="number">28</span>);</span><br><span class="line">		ar.compareAndSet(user, update);</span><br><span class="line">		System.out.<span class="built_in">println</span>(ar.<span class="built_in">get</span>().getName()+<span class="string">" "</span>+ar.<span class="built_in">get</span>().getAge());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>&#123;</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">String</span> name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">			<span class="keyword">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">老贺 <span class="number">28</span></span><br></pre></td></tr></table></figure>

<h2 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h2><p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新：</p>
<blockquote>
<ul>
<li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。 </li>
</ul>
</blockquote>
<p>要想原子地更新字段类需要两步:</p>
<blockquote>
<ul>
<li>第一步:因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</li>
<li><strong>第二步:更新类的字段（属性）必须使用public volatile修饰符</strong>。</li>
</ul>
</blockquote>
<p>以上3个类提供的方法几乎一样，所以仅以AstomicIntegerFieldUpdater为例进行讲解，AstomicIntegerFieldUpdater的示例代码如代码所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; aifu = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">"age"</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		User easonhe = <span class="keyword">new</span> User(<span class="string">"easonhe"</span>, <span class="number">20</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(aifu.getAndIncrement(easonhe));</span><br><span class="line">		System.out.<span class="built_in">println</span>(aifu.<span class="built_in">get</span>(easonhe));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>&#123;</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">String</span> name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">			<span class="keyword">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是更新字段类的第二步！！！</p>
<p>参考：<br><strong>《Java并发编程艺术》</strong></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】并发容器与框架</title>
    <url>/2020/07/10/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B8%8E%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(五）并发容器与框架含ConcurrentHashMap/ConcurrentLinkedQueue/阻塞队列/Fork/Join框架</strong></p>
<a id="more"></a>
<h2 id="ConcurrentHashMap的实现原理与使用"><a href="#ConcurrentHashMap的实现原理与使用" class="headerlink" title="ConcurrentHashMap的实现原理与使用"></a>ConcurrentHashMap的实现原理与使用</h2><p>线程不安全的HashMap：</p>
<blockquote>
<p>HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表 形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p>
</blockquote>
<p>效率低下的HashTable:</p>
<blockquote>
<p>为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同 步方法时，会进入阻塞或轮询状态。</p>
</blockquote>
<p>ConcurrentHashMap的锁分段技术:</p>
<blockquote>
<p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的 线程都必须竞争同一把锁，假如<strong>容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率</strong>，这就是ConcurrentHashMap所使用的<strong>锁分段技术</strong>。<strong>首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</strong>。</p>
</blockquote>
<h3 id="ConcurrentHashMap的结构"><a href="#ConcurrentHashMap的结构" class="headerlink" title="ConcurrentHashMap的结构"></a>ConcurrentHashMap的结构</h3><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重 入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里<strong>包含一个Segment数组</strong>。Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里<strong>包含一个HashEntry数组</strong>，每个HashEntry是一个链表结构的元 素，每个Segment守护着一个HashEntry数组里的元素，<strong>当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁</strong>，</p>
<p>类图如图所示：<br><img src="https://wx1.sbimg.cn/2020/07/10/Cck4h.png" alt="Cck4h.png"><br>结构如图所示：<br><img src="https://wx1.sbimg.cn/2020/07/10/Cc2Ha.png" alt="Cc2Ha.png"></p>
<h3 id="ConcurrentHashMap的初始化"><a href="#ConcurrentHashMap的初始化" class="headerlink" title="ConcurrentHashMap的初始化"></a>ConcurrentHashMap的初始化</h3><p>ConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的 HashEntry数组来实现的。</p>
<h4 id="初始化segments数组"><a href="#初始化segments数组" class="headerlink" title="初始化segments数组"></a>初始化segments数组</h4><p>源码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS) </span><br><span class="line">    concurrencyLevel = MAX_SEGMENTS; </span><br><span class="line"><span class="built_in">int</span> sshift = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">int</span> ssize = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift; </span><br><span class="line">    size &lt;&lt;= <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">segmentShift = <span class="number">32</span> - sshift; </span><br><span class="line">segmentMask = ssize - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br></pre></td></tr></table></figure>
<p>由上面的代码可知，segments数组的长度ssize是通过concurrencyLevel计算得出的。为了能 通过按位与的散列算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方），所以必须计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。<strong>假如concurrencyLevel等于14、15或16，ssize都会等于16，即容器里锁的个数也是16。concurrencyLevel的最大值是65535，这意味着segments数组的长度最大为65536， 对应的二进制是16位。</strong></p>
<h4 id="初始化segmentShift和segmentMask"><a href="#初始化segmentShift和segmentMask" class="headerlink" title="初始化segmentShift和segmentMask"></a>初始化segmentShift和segmentMask</h4><p><strong>这两个全局变量需要在定位segment时的散列算法里使用</strong>，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。segmentShift用于定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是散列运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p>
<h4 id="初始化每个segment"><a href="#初始化每个segment" class="headerlink" title="初始化每个segment"></a>初始化每个segment</h4><p>输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个segment。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY; </span><br><span class="line"><span class="built_in">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity) </span><br><span class="line">    ++c; </span><br><span class="line"><span class="built_in">int</span> cap = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span> (cap &lt; c) </span><br><span class="line">    cap &lt;&lt;= <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i) </span><br><span class="line">    <span class="keyword">this</span>.segments[i] = new Segment&lt;K,V&gt;(cap, loadFactor);</span><br></pre></td></tr></table></figure>
<p>上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝（int）cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。</p>
<h3 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h3><p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，<strong>那么在插入和获取元素的时候，必须先通过散列算法定位到Segment</strong>。可以看到ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode进行一次再散列。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="built_in">int</span> hash(<span class="built_in">int</span> h) &#123; </span><br><span class="line">    h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>; </span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">6</span>); </span><br><span class="line">    h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>); </span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>之所以进行再散列，目的是减少散列冲突，使元素能够均匀地分布在不同的Segment上， 从而提高容器的存取效率</strong> <strong>如果不进行再散列，散列冲突会非 常严重，因为只要低位一样，无论高位是什么数，其散列值总是一样。</strong></p>
<p>ConcurrentHashMap通过以下散列算法定位segment:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下segmentShift为28，segmentMask为15，再散列后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到散列运算中，（hash&gt;&gt;&gt;segmentShift）&amp;segmentMask的运算结果分别是4、15、7和8，可以看到散列值没有发生冲突。</p>
<h3 id="ConcurrentHashMap的操作"><a href="#ConcurrentHashMap的操作" class="headerlink" title="ConcurrentHashMap的操作"></a>ConcurrentHashMap的操作</h3><h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><p>Segment的get操作实现非常简单和高效。<strong>先经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素</strong>，代码如下：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123; </span><br><span class="line">    <span class="built_in">int</span> hash = hash(<span class="built_in">key</span>.hashCode()); </span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).<span class="built_in">get</span>(<span class="built_in">key</span>, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空才会加锁重读。原因是它的get方法里将要使用的共享变量都定义成volatile类型</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">hash &gt;&gt;&gt; segmentShift) &amp; segmentMask </span><br><span class="line"><span class="comment">// 定位Segment所使用的hash算法 </span></span><br><span class="line"><span class="type">int</span> <span class="keyword">index</span> = hash &amp; (tab.<span class="built_in">length</span> - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//定位HashEntry所使用的hash算法</span></span><br></pre></td></tr></table></figure>
<p>在定位元素的代码里我们可以发现，定位HashEntry和定位Segment的散列算法虽然一样， 都与数组的长度减去1再相“与”，但是相“与”的值不一样，<strong>定位Segment使用的是元素的hashcode通过再散列后得到的值的高位</strong>，而定位HashEntry直接使用的是再散列后的值。其目的是避免两次散列后的值一样，虽然元素在Segment里散列开了，但是却没有在HashEntry里散列开。</p>
<h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必 须加锁。put方法首先定位到Segment，然后在Segment里进行插入操作。<strong>插入操作需要经历两个步骤</strong>:</p>
<blockquote>
<ul>
<li>第一步判断是否需要对Segment里的HashEntry数组进行扩容：在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阈值，则对数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。在扩容的时候，首先会创建一个容量是原来容量两倍的数组，然后将原数组里的元素进行再散列后插入到新的数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而只 对某个segment进行扩容。</li>
<li>第二步定位添加元素的位置，然后将其放在HashEntry数组里</li>
</ul>
</blockquote>
<h4 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h4><p>因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以 ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>在并发编程中，有时候需要使用线程安全的队列。如果要实现一个线程安全的队列有两种方式：</p>
<blockquote>
<ul>
<li>一种是使用阻塞算法，</li>
<li>另一种是使用非阻塞算法。</li>
</ul>
</blockquote>
<p><strong>使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。非阻塞的实现方式则可以使用循环CAS了“wait-free”算法的方式来实现。</strong></p>
<p><strong>类图结构：</strong><br><img src="https://wx1.sbimg.cn/2020/07/10/CdjwR.png" alt="CdjwR.png"></p>
<h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><h4 id="入队列过程"><a href="#入队列过程" class="headerlink" title="入队列过程"></a>入队列过程</h4><p>注意的：如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点</p>
<p>多个线程同时进行入队的情况就变得更加复杂了，因为可能会出现其他线程插队的情况。如果有一个线程正在入队，那么它必须先获取尾节点，然后设置尾节点的下一个节点为入队节点，但这时可能有另外一个线程插队了，那么队列的尾节点就会发生变化，这时当前线程要暂停入队操作，然后重新获取尾节点。整个入队过程主要做两件事情：第一是定位出尾节点；第二是使用 CAS算法将入队节点设置成尾节点的next节点，如不成功则重试。</p>
<h4 id="定位尾结点"><a href="#定位尾结点" class="headerlink" title="定位尾结点"></a>定位尾结点</h4><p>tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点。尾节点可能 是tail节点，也可能是tail节点的next节点。获取tail节点的next节点需要注意的是<strong>p节点等于p的next节点</strong>的情况，只有一种可能就是<strong>p节点和p的next节点都等于空</strong>，表示这个队列刚初始化，正准备添加节点，所以需要返回head节点。</p>
<h4 id="设置入队节点为尾节点"><a href="#设置入队节点为尾节点" class="headerlink" title="设置入队节点为尾节点"></a>设置入队节点为尾节点</h4><p>p.casNext（null，n）方法用于将入队节点设置为当前队列尾节点的next节点，如果p是null，表示p是当前队列的尾节点，如果不为null，表示有其他线程更新了尾节点，则需要重新获取当 前队列的尾节点。</p>
<h4 id="HOPS的设计意图"><a href="#HOPS的设计意图" class="headerlink" title="HOPS的设计意图"></a>HOPS的设计意图</h4><blockquote>
<p>用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将tail节点更新成尾节点，而是当tail节点和尾节点的距离大于等于常量 HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长，使用CAS更新tail节点的次数就会越少，但是<strong>距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来看它通过增加对volatile变量的读操作来减少对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升</strong>。<strong>入队方法永远返回true，所以不要通过返回值判断入队是否成功。</strong></p>
</blockquote>
<h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><p>并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点。这种做法也是通过hops变量来减少使用CAS更新head节点的消耗，从而提高出队效率。</p>
<h2 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h2><h3 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法：</p>
<blockquote>
<ul>
<li><strong>支持阻塞的插入方法</strong>：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>
<li><strong>支持阻塞的移除方法</strong>：意思是在队列为空时，获取元素的线程会等待队列变为非空。 </li>
</ul>
</blockquote>
<p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。在阻塞队列不可用时，这两个附加操作提供了4种处理方式，如表所示:<br><img src="https://wx2.sbimg.cn/2020/07/10/ChQUj.png" alt="ChQUj.png"></p>
<blockquote>
<ul>
<li>抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queue full”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</li>
<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。 </li>
<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</li>
<li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</li>
</ul>
</blockquote>
<p>这两个附加操作的4种处理方式不方便记忆，所以我找了一下这几个方法的规律。<strong>put和take分别尾首含有字母t，offer和poll都含有字母o</strong>。 <strong>注意如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且使用offer方法时，该方法永远返回true</strong>。</p>
<h3 id="Java里的阻塞队列"><a href="#Java里的阻塞队列" class="headerlink" title="Java里的阻塞队列"></a>Java里的阻塞队列</h3><p>JDK 7提供了7个阻塞队列，如下。</p>
<blockquote>
<ul>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列:是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列;</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列:一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列:一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列:一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列:一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。 它支持公平访问队列。默认情况下线程采用非公平性策略访问队列.</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列:一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列:一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、 addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双 端队列的最后一个元素。</li>
</ul>
</blockquote>
<h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><p>一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<p>运行流程如图所示:<br><img src="https://wx1.sbimg.cn/2020/07/10/Ch1UT.png" alt="Ch1UT.png"></p>
<h3 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h3><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行</p>
<p>工作窃取的运行流程如图所示：<br><img src="https://wx2.sbimg.cn/2020/07/10/ChwKl.png" alt="ChwKl.png"></p>
<blockquote>
<ul>
<li>工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。</li>
<li>工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</li>
</ul>
</blockquote>
<h3 id="Fork-Join框架的设计"><a href="#Fork-Join框架的设计" class="headerlink" title="Fork/Join框架的设计"></a>Fork/Join框架的设计</h3><blockquote>
<ul>
<li><strong>步骤1 分割任务</strong>:首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。 </li>
<li><strong>步骤2 执行任务并合并结果</strong>。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</li>
</ul>
</blockquote>
<p>Fork/Join使用两个类来完成以上两件事情:</p>
<blockquote>
<ul>
<li>ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制。通常情况下，我们不需要直接继承ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了以下两个子类。 ·RecursiveAction：用于没有返回结果的任务。 ·RecursiveTask：用于有返回结果的任务。</li>
<li>ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行。任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</li>
</ul>
</blockquote>
<h3 id="使用Fork-Join框架"><a href="#使用Fork-Join框架" class="headerlink" title="使用Fork/Join框架"></a>使用Fork/Join框架</h3><p>一个简单的需求来使用Fork/Join框架，需求是：计算1+2+3+4的结果。 使用Fork/Join框架首先要考虑到的是如何分割任务，如果希望每个子任务最多执行两个 数的相加，那么我们设置分割的阈值是2，由于是4个数字相加，所以Fork/Join框架会把这个任务fork成两个子任务，子任务一负责计算1+2，子任务二负责计算3+4，然后再join两个子任务的结果。因为是有结果的任务，所以必须继承RecursiveTask，实现代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="title">extends</span> <span class="title">RecursiveTask</span>&lt;Integer&gt; &#123;</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>; <span class="comment">// 阈值 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="built_in">end</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.start = start; </span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">end</span> = <span class="built_in">end</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 如果任务足够小就计算任务 </span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (<span class="built_in">end</span> - start) &lt;= THRESHOLD; </span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; i++) &#123; </span><br><span class="line">                sum += i;</span><br><span class="line">                &#125; </span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算 </span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle); CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, <span class="built_in">end</span>); <span class="comment">// 执行子任务 </span></span><br><span class="line">            leftTask.fork(); </span><br><span class="line">            rightTask.fork(); </span><br><span class="line">            <span class="comment">// 等待子任务执行完，并得到其结果 int leftResult=leftTask.join(); </span></span><br><span class="line">            <span class="keyword">int</span> rightResult=rightTask.join(); </span><br><span class="line">            <span class="comment">// 合并子任务 </span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    <span class="comment">// 生成一个计算任务，负责计算1+2+3+4 </span></span><br><span class="line">    CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>); </span><br><span class="line">    <span class="comment">// 执行一个任务 Future&lt;Integer&gt; result = forkJoinPool.submit(task); </span></span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        System.out.<span class="built_in">println</span>(result.<span class="built_in">get</span>()); </span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123; </span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fork-Join框架的异常处理"><a href="#Fork-Join框架的异常处理" class="headerlink" title="Fork/Join框架的异常处理"></a>Fork/Join框架的异常处理</h3><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(task.is<span class="constructor">CompletedAbnormally()</span>) &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(task.get<span class="constructor">Exception()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p>
<p>参考：<br><strong>《Java并发编程的艺术》</strong></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】并发工具类</title>
    <url>/2020/07/12/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(七）并发工具类含等待多线程完成的CountDownLatch/同步屏障CyclicBarrier/控制并发线程数的Semaphore/线程间交换数据的Exchanger</strong></p>
<a id="more"></a>

<p>在JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和 Semaphore工具类提供了一种并发流程控制的手段，Exchanger工具类则提供了在线程间交换数 据的一种手段。</p>
<h2 id="等待多线程完成的CountDownLatch"><a href="#等待多线程完成的CountDownLatch" class="headerlink" title="等待多线程完成的CountDownLatch"></a>等待多线程完成的CountDownLatch</h2><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JoinCountDownLatchTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">				System.<span class="keyword">out</span>.println(<span class="string">"thread1 finish"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">				System.<span class="keyword">out</span>.println(<span class="string">"thread2 finish"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		thread1.start();</span><br><span class="line">		thread2.start();</span><br><span class="line">		thread1.<span class="keyword">join</span>();</span><br><span class="line">		thread2.<span class="keyword">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">thread1</span> <span class="string">finish</span></span><br><span class="line"><span class="attr">thread2</span> <span class="string">finish</span></span><br></pre></td></tr></table></figure>
<p><strong>join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远等待</strong>。其中，wait（0）表示永远等待下去。直到join线程中止后，线程的this.notifyAll()方法会被调用，调用notifyAll()方法是在JVM里实现的，在JDK1.5之后的并发包中提供的CountDownLatch也可以实现join的功能，并且比join的功能更多，如代码所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> CountDownLatch cdl = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="number">1</span>);</span><br><span class="line">				cdl.countDown();</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="number">2</span>);</span><br><span class="line">				cdl.countDown();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		cdl.await();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>CountDownLatch的构造函数接收一个int类型的参数作为计数器，<strong>如果你想等待N个点完成，这里就传入N</strong>。<strong>当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零</strong>。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个 CountDownLatch的引用传递到线程里即可。如果有某个解析sheet的线程处理得比较慢，我们不可能让主线程一直等待，所以可以使用另外一个带指定时间的await方法——await（long time，TimeUnit unit），这个方法等待特定时 间后，就会不再阻塞当前线程。join也有类似的方法。<br><strong>CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值</strong>。一个线程调用countDown方法happen-before，另外一个线程调用await方法。</p>
<h2 id="同步屏障CyclicBarrier"><a href="#同步屏障CyclicBarrier" class="headerlink" title="同步屏障CyclicBarrier"></a>同步屏障CyclicBarrier</h2><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：<strong>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</strong></p>
<h3 id="CyclicBarrier简介"><a href="#CyclicBarrier简介" class="headerlink" title="CyclicBarrier简介"></a>CyclicBarrier简介</h3><p>CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。示例代码所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					c.await();</span><br><span class="line">				&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			c.await();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>还有可能输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>因为主线程和子线程的调度是由CPU决定的，两个线程都有可能先执行，所以会产生两种输出.如果把new CyclicBarrier(2)修改成new CyclicBarrier(3)，则<strong>主线程和子线程会永远等待，因为没有第三个线程执行await方法，即没有第三个线程到达屏障</strong>，<strong>所以之前到达屏障的两个 线程都不会继续执行</strong>。</p>
<p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrier-Action），用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景，如代码所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> A());</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					c.await();</span><br><span class="line">				&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			c.await();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="number">3</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>因为CyclicBarrier设置了拦截线程的数量是2，所以必须等代码中的第一个线程和线程A都执行完之后，才会继续执行主线程，然后输出2</strong></p>
<h3 id="CyclicBarrier的应用场景"><a href="#CyclicBarrier的应用场景" class="headerlink" title="CyclicBarrier的应用场景"></a>CyclicBarrier的应用场景</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankWaterService</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span> </span><br><span class="line"><span class="comment">//创建4个屏障，处理完之后执行当前类的run方法</span></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, <span class="keyword">this</span>); </span><br><span class="line">    <span class="comment">//假设只有4个sheet，所以只启动4个线程 </span></span><br><span class="line">    <span class="keyword">private</span> Executor executor = Executors.newFixedThreadPool(<span class="number">4</span>); <span class="comment">//保存每个sheet计算出的银流结果</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;<span class="keyword">String</span>, Integer&gt;sheetBankWaterCount = <span class="keyword">new</span> ConcurrentHashMap&lt;<span class="keyword">String</span>, Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (inti = <span class="number">0</span>; i&lt; <span class="number">4</span>; i++) &#123; </span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">                publicvoid <span class="built_in">run</span>() &#123; </span><br><span class="line">                <span class="comment">// 计算当前sheet的银流数据，计算代码省略 sheetBankWaterCount.put(Thread.currentThread().getName(), 1); </span></span><br><span class="line">                <span class="comment">// 银流计算完成，插入一个屏障 </span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await(); </span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;);</span><br><span class="line">            &#125; </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        intresult = <span class="number">0</span>; <span class="comment">// 汇总每个sheet计算出的结果</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;<span class="keyword">String</span>, Integer&gt;sheet : sheetBankWaterCount.entrySet()) &#123; </span><br><span class="line">            result += sheet.getValue(); </span><br><span class="line">        &#125;<span class="comment">// 将结果输出</span></span><br><span class="line">        sheetBankWaterCount.<span class="built_in">put</span>(<span class="string">"result"</span>, result); System.out.<span class="built_in">println</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line">    BankWaterService bankWaterCount = <span class="keyword">new</span> BankWaterService(); bankWaterCount.count(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>使用线程池创建4个线程，分别计算每个sheet里的数据，每个sheet计算结果是1，再由BankWaterService线程汇总4个sheet计算出的结果。</p>
<h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><p><strong>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。</strong>例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。代码执行完之后会返回true，其中isBroken的使用代码如代码所示：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">importjava.util.concurrent.BrokenBarrierException; importjava.util.concurrent.CyclicBarrier; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CyclicBarrierTest3</span> &#123; </span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException， BrokenBarrierException</span> &#123; </span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c.<span class="keyword">await</span>(); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">    thread.start(); </span><br><span class="line">    thread.interrupt(); </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">    c.<span class="keyword">await</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(c.isBroken());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="控制并发线程数的Semaphore"><a href="#控制并发线程数的Semaphore" class="headerlink" title="控制并发线程数的Semaphore"></a>控制并发线程数的Semaphore</h2><p><strong>Semaphore（信号量）是用来控制同时访问特定资源的线程数量</strong>，它通过协调各个线程，以保证合理的使用公共资源。</p>
<p>Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制，如代码所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> &#123;</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorServicethreadPool = Executors.newFixedThreadPool(THREAD_COUNT); </span><br><span class="line">    <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (inti = <span class="number">0</span>; i&lt; THREAD_COUNT; i++) &#123; threadPool.execute(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123; </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s.acquire();</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"save data"</span>); </span><br><span class="line">                    s.<span class="built_in">release</span>(); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">        &#125; </span><br><span class="line">        threadPool.<span class="built_in">shutdown</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore（10）表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p>
<h3 id="2-其他方法"><a href="#2-其他方法" class="headerlink" title="2.其他方法"></a>2.其他方法</h3><p>Semaphore还提供一些其他方法，具体如下:</p>
<ul>
<li>intavailablePermits()：返回此信号量中当前可用的许可证数。</li>
<li>intgetQueueLength()：返回正在等待获取许可证的线程数。</li>
<li>booleanhasQueuedThreads()：是否有线程正在等待获取许可证。 </li>
<li>void reducePermits（int reduction）：减少reduction个许可证，是个protected方法。 </li>
<li>Collection getQueuedThreads()：返回所有等待获取许可证的线程集合，是个protected方法。</li>
</ul>
<h2 id="线程间交换数据的Exchanger"><a href="#线程间交换数据的Exchanger" class="headerlink" title="线程间交换数据的Exchanger"></a>线程间交换数据的Exchanger</h2><p>Exchanger（交换者）是一个<strong>用于线程间协作的工具类</strong>。<strong>Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据</strong>。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产 出来的数据传递给对方。 下面来看一下Exchanger的应用场景:</p>
<p>Exchanger可以用于<strong>遗传算法</strong>，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致，如代码所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> &#123;</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;<span class="keyword">String</span>&gt;exgr = <span class="keyword">new</span> Exchanger&lt;<span class="keyword">String</span>&gt;(); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorServicethreadPool = Executors.newFixedThreadPool(<span class="number">2</span>); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123; </span><br><span class="line">                <span class="keyword">try</span> &#123; </span><br><span class="line">                    <span class="keyword">String</span> A = <span class="string">"银行流水A"</span>; <span class="comment">// A录入银行流水数据</span></span><br><span class="line">                    exgr.exchange(A);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;); </span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123; </span><br><span class="line">                <span class="keyword">try</span> &#123; </span><br><span class="line">                    <span class="keyword">String</span> B = <span class="string">"银行流水B"</span>; <span class="comment">// B录入银行流水数据</span></span><br><span class="line">                    <span class="keyword">String</span> A = exgr.exchange(<span class="string">"B"</span>); System.out.<span class="built_in">println</span>(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span></span><br><span class="line">+ A + <span class="string">"，B录入是："</span> + B); </span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">                &#125; </span><br><span class="line">        &#125;); </span><br><span class="line">        threadPool.<span class="built_in">shutdown</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="keyword">A</span>和B数据是否一致：false，<span class="keyword">A</span>录入的是：银行流水<span class="keyword">A</span>，B录入是：银行流水B</span><br></pre></td></tr></table></figure>
<p>如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长。</p>
<p>参考：<br><strong>《Java并发编程的艺术》</strong></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】并发编程基础</title>
    <url>/2020/07/08/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(三）Java并发编程基础含线程简介/启动与终止线程/线程间通信</strong></p>
<a id="more"></a>
<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><blockquote>
<p>现代操作系统在运行一个程序时，会为其创建一个<strong>进程</strong>。例如，启动一个Java程序，操作系统就会创建一个<strong>Java进程</strong>。<strong>现代操作系统调度的最小单元是线程</strong>，也叫<strong>轻量级进程</strong>，在<strong>一个进程里可以创建多个线程</strong>，这些<strong>线程都拥有各自的计数器、堆栈和局 部变量等属性</strong>，并且能够访问共享的内存变量。处理器在这些线程上<strong>高速切换</strong>，让使用者感觉到这些线程在同时执行。</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span>&#123;</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 获取Java线程管理MXBean </span></span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean(); </span><br><span class="line">        <span class="comment">// 不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息 </span></span><br><span class="line">        ThreadInfo[] threadInfos =     threadMXBean.dumpAllThreads(<span class="literal">false</span>, <span class="literal">false</span>); </span><br><span class="line">        <span class="comment">// 遍历线程信息，仅打印线程ID和线程名称信息</span></span><br><span class="line">        <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"["</span> + threadInfo.getThreadId() + <span class="string">"] "</span> + threadInfo. getThreadName()); </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[<span class="number">4</span>] Signal Dispatcher <span class="comment">// 分发处理发送给JVM信号的线程 </span></span><br><span class="line">[<span class="number">3</span>] Finalizer <span class="comment">// 调用对象finalize方法的线程 </span></span><br><span class="line">[<span class="number">2</span>] Reference Handler <span class="comment">// 清除Reference的线程 </span></span><br><span class="line">[<span class="number">1</span>] main <span class="comment">// main线程，用户程序入口</span></span><br></pre></td></tr></table></figure>
<p>可以看到，一个Java程序的运行不仅仅是main()方法的运行，而是main线程和多个其他线程的同时运行。</p>
<h3 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h3><ul>
<li>更多的处理器核心；</li>
<li>更快的响应时间；</li>
<li>更好的编程模型。</li>
</ul>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><blockquote>
<p>现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。</p>
</blockquote>
<blockquote>
<p>在Java线程中，通过一个<strong>整型成员变量priority</strong>来控制优先级，<strong>优先级的范围从1~10</strong>，在线程构建的时候<strong>可以通过setPriority(int)方法</strong>来修改优先级，<strong>默认优先级是5</strong>，优先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较 低的优先级，确保处理器不会被独占。在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定，如示例代码所示：</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Priority</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> notStart = <span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> notEnd = <span class="literal">true</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws Exception </span>&#123;</span><br><span class="line">        List&lt;Job&gt; jobs = <span class="keyword">new</span> ArrayList&lt;Job&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">            <span class="keyword">int</span> priority = i &lt; <span class="number">5</span> Thread.MIN_PRIORITY : Thread.MAX_PRIORITY; </span><br><span class="line">            Job job = <span class="keyword">new</span> Job(priority); </span><br><span class="line">            jobs.add(job); </span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(job, <span class="string">"Thread:"</span> + i); thread.setPriority(priority); </span><br><span class="line">            thread.start(); </span><br><span class="line">        &#125;</span><br><span class="line">        notStart = <span class="literal">false</span>; </span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>); </span><br><span class="line">        notEnd = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">for</span> (Job job : jobs) &#123; </span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"Job Priority : "</span> + job.priority + <span class="string">", Count : "</span> + job.jobCount);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span> </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> jobCount;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">this</span>.priority = priority; </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">while</span> (notStart) &#123; </span><br><span class="line">                Thread.<span class="built_in">yield</span>(); </span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">while</span> (notEnd) &#123; </span><br><span class="line">                Thread.<span class="built_in">yield</span>(); </span><br><span class="line">                jobCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Job Priority :</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1259592</span> </span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1260717</span> </span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1264510</span> </span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1251897</span> </span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1264060</span></span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">10</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1256938</span> </span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">10</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1267663</span> </span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">10</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1260637</span> </span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">10</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1261705</span> </span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">10</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1259967</span></span><br></pre></td></tr></table></figure>
<p><strong>从输出可以看到线程优先级没有生效，优先级1和优先级10的Job计数的结果非常相近，没有明显差距。这表示程序正确性不能依赖线程的优先级高低。</strong></p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>Java线程在运行的生命周期中的某个时刻处于其中的一个状态：<br><img src="https://wx1.sbimg.cn/2020/07/07/CCsqM.png" alt="CCsqM.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> TimeWaiting(), <span class="string">"TimeWaitingThread"</span>).start(); </span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Waiting(), <span class="string">"WaitingThread"</span>).start(); <span class="comment">// 使用两个Blocked线程，一个获取锁成功，另一个被阻塞 </span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-1"</span>).start(); </span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-2"</span>).start(); </span><br><span class="line">	&#125;<span class="comment">// 该线程不断地进行睡眠 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWaiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; <span class="meta">@Override</span> </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				SleepUtils.second(<span class="number">100</span>); </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;<span class="comment">// 该线程在Waiting.class实例上等待 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">			<span class="keyword">synchronized</span> (Waiting<span class="class">.<span class="keyword">class</span>) </span>&#123; </span><br><span class="line">				<span class="keyword">try</span> &#123;Waiting<span class="class">.<span class="keyword">class</span>.<span class="title">wait</span>()</span>; </span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace(); </span><br><span class="line">					&#125; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">&#125;<span class="comment">// 该线程在Blocked.class实例上加锁后，不会释放该锁 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Blocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (Blocked<span class="class">.<span class="keyword">class</span>) </span>&#123; </span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					SleepUtils.second(<span class="number">100</span>); </span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepUtils</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(<span class="keyword">long</span> seconds)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(seconds); </span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该示例，打开终端或者命令提示符，键入“jps”，输出如下:</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">611 </span></span><br><span class="line"><span class="symbol">935 </span>Jps </span><br><span class="line"><span class="symbol">929 </span>ThreadState </span><br><span class="line"><span class="number">270</span></span><br></pre></td></tr></table></figure>
<p>可以看到运行示例对应的进程ID是929，接着再键入“jstack 929”（这里的进程ID需要和读<br>者自己键入jps得出的ID一致），部分输出如下所示:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BlockedThread-2线程阻塞在获取Blocked.class示例的锁上</span></span><br><span class="line"><span class="string">"BlockedThread-2"</span> prio=<span class="number">5</span> tid=<span class="number">0</span>x00007feacb05d000 nid=<span class="number">0</span>x5d03 waiting <span class="keyword">for</span> monitor </span><br><span class="line">entry [<span class="number">0</span>x000000010fd58000] </span><br><span class="line">    java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: BLOCKED (on <span class="selector-tag">object</span> monitor) </span><br><span class="line"><span class="comment">// BlockedThread-1线程获取到了Blocked.class的锁 </span></span><br><span class="line"><span class="string">"BlockedThread-1"</span> prio=<span class="number">5</span> tid=<span class="number">0</span>x00007feacb05a000 nid=<span class="number">0</span>x5b03 waiting on condition </span><br><span class="line">[<span class="number">0</span>x000000010fc55000] </span><br><span class="line">    java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: TIMED_WAITING (sleeping) </span><br><span class="line"><span class="comment">// WaitingThread线程在Waiting实例上等待 </span></span><br><span class="line"><span class="string">"WaitingThread"</span> prio=<span class="number">5</span> tid=<span class="number">0</span>x00007feacb059800 nid=<span class="number">0</span>x5903 <span class="keyword">in</span> Object.wait() </span><br><span class="line">[<span class="number">0</span>x000000010fb52000] </span><br><span class="line">    java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: WAITING (on <span class="selector-tag">object</span> monitor) </span><br><span class="line"><span class="comment">// TimeWaitingThread线程处于超时等待 </span></span><br><span class="line"><span class="string">"TimeWaitingThread"</span> prio=<span class="number">5</span> tid=<span class="number">0</span>x00007feacb058800 nid=<span class="number">0</span>x5703 waiting on condition </span><br><span class="line">[<span class="number">0</span>x000000010fa4f000] </span><br><span class="line">    java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: TIMED_WAITING (sleeping)</span><br></pre></td></tr></table></figure>
<p>通过示例，我们了解到Java程序运行中线程状态的具体含义。线程在自身的生命周期中，并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变迁如图所示：</p>
<p><img src="https://wx2.sbimg.cn/2020/07/07/CCuhI.png" alt="CCuhI.png"></p>
<h3 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h3><p>Daemon线程是一种<strong>支持型线程</strong>，因为它<strong>主要被用作程序中后台调度以及支持性工作</strong>。这意味着，当一个Java虚拟机中<strong>不存在非Daemon线程的时候，Java虚拟机将会退出</strong>。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。注意Daemon属性需要在启动线程之前设置，不能在启动线程之后设置。 Daemon线程被用作完成支持性工作，<strong>但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行</strong>，示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daemon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonRunner(), <span class="string">"RaemonRunner"</span>);</span><br><span class="line">		thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				SleepUtils.second(<span class="number">10</span>);</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"DaemonRunner finally run"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果终端上没有任何输出。main线程在启动了线程DaemonRunner之后<strong>随着main方法执行完毕而终止</strong>，而此时Java虚拟机中已经没有非Daemon线程，虚拟机需要退出。Java虚拟机中的所有Daemon线程都需要立即终止，因此DaemonRunner立即终止，但是DaemonRunner中的finally块并没有执行。注意：<strong>在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑</strong>。</p>
<h2 id="启动和终止线程"><a href="#启动和终止线程" class="headerlink" title="启动和终止线程"></a>启动和终止线程</h2><h3 id="构造线程"><a href="#构造线程" class="headerlink" title="构造线程"></a>构造线程</h3><p>在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。代码摘自java.lang.Thread中对线程进行初始化的部分。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable <span class="keyword">target</span>, String name,<span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程就是该线程的父线程 </span></span><br><span class="line">    Thread parent = currentThread(); </span><br><span class="line">    <span class="keyword">this</span>.group = g; </span><br><span class="line">    <span class="comment">// 将daemon、priority属性设置为父线程的对应属性 this.daemon = parent.isDaemon(); </span></span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority(); </span><br><span class="line">    <span class="keyword">this</span>.name = name.toCharArray(); </span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>; setPriority(priority);</span><br><span class="line">    <span class="comment">//将父线程的InheritableThreadLocal复制过来 </span></span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>) <span class="keyword">this</span>.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent. inheritableThreadLocals); </span><br><span class="line">    <span class="comment">// 分配一个线程ID </span></span><br><span class="line">    tid = nextThreadID(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一个新构造的线程对象是由其parent线程来进行空间分配的</strong>，而<strong>child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal</strong>，同时<strong>还会分配一个唯一的ID来标识这个child线程</strong>。至此，一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。</p>
<h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><blockquote>
<p>线程对象在初始化完成之后，调用start()方法就可以启动这个线程。线程start()方法的含义是：<strong>当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程</strong>。注意:启动一个线程前，最好为这个线程设置线程名称，因为这样在使用jstack分析程 序或者进行问题排查时，就会给开发人员提供一些提示，自定义的线程最好能够起个名字。</p>
</blockquote>
<h3 id="理解中断"><a href="#理解中断" class="headerlink" title="理解中断"></a>理解中断</h3><p>中断可以理解为线程的一个<strong>标识位属性</strong>，它表示一个运行中的线程是否被其他线程进行了中断操作。其他线程通过调用该线程的interrupt() 方法对其进行中断操作。处于终结状态的线程，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。从Java的API中可以看到，许多声明抛出InterruptedException的方法（例如Thread.sleep(long millis)方法）这些方法在<strong>抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除</strong>，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。代码例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupted</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//不停进行休眠的线程</span></span><br><span class="line">		Thread sleepthread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SleepRunner(), <span class="string">"sleepthread"</span>);</span><br><span class="line">		sleepthread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">//不停进行工作的线程</span></span><br><span class="line">		Thread busythread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> BusyRunner(), <span class="string">"busythread"</span>);</span><br><span class="line">		busythread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		</span><br><span class="line">		sleepthread.start();</span><br><span class="line">		busythread.start();</span><br><span class="line">		<span class="comment">//休眠五秒，让两个线程充分运行</span></span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">		sleepthread.interrupt();</span><br><span class="line">		busythread.interrupt();</span><br><span class="line">		System.out.println(<span class="string">"SleepThread interrupted is: "</span>+sleepthread.isInterrupted());</span><br><span class="line">		System.out.println(<span class="string">"BusyThread interrupted is: "</span>+busythread.isInterrupted());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">				SleepUtils.second(<span class="number">10</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusyRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">SleepThread <span class="built_in">int</span>errupted <span class="keyword">is</span>: <span class="literal">false</span></span><br><span class="line">BusyThread <span class="built_in">int</span>errupted <span class="keyword">is</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>从结果可以看出，<strong>抛出InterruptedException的线程SleepThread，其中断标识位被清除了，而一直忙碌运作的线程BusyThread，中断标识位没有被清除。</strong></p>
<h3 id="过期的suspend-、resume-、stop"><a href="#过期的suspend-、resume-、stop" class="headerlink" title="过期的suspend()、resume()、stop()"></a>过期的suspend()、resume()、stop()</h3><p>暂停、恢复和停止操作对应在线程Thread的API就是suspend()、resume()和stop()。对应的实例</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line">import java.text.DateFormat;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> Delayed &#123;</span><br><span class="line">	public static void main(String<span class="literal">[]</span> args) throws InterruptedException &#123;</span><br><span class="line">	DateFormat format = <span class="keyword">new</span> <span class="constructor">SimpleDateFormat(<span class="string">"HH:MM:SS"</span>)</span>;</span><br><span class="line">	Thread thread = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">new</span> Runner()</span>, <span class="string">"PrintThread"</span>);</span><br><span class="line">	thread.set<span class="constructor">Daemon(<span class="params">true</span>)</span>;</span><br><span class="line">	thread.start<span class="literal">()</span>;</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">TimeUnit</span>.</span><span class="module"><span class="identifier">SECONDS</span>.</span></span>sleep(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//将Thread进行暂停，输出工作内容后停止</span></span><br><span class="line">	thread.suspend<span class="literal">()</span>;</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(thread.get<span class="constructor">Name()</span>+<span class="string">" run at "</span>+format.format(<span class="keyword">new</span> <span class="constructor">Date()</span>));</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">TimeUnit</span>.</span><span class="module"><span class="identifier">SECONDS</span>.</span></span>sleep(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//将Thread进行恢复，输出工作内容后恢复</span></span><br><span class="line">	thread.resume<span class="literal">()</span>;</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(thread.get<span class="constructor">Name()</span>+<span class="string">" resume at "</span>+format.format(<span class="keyword">new</span> <span class="constructor">Date()</span>));</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">TimeUnit</span>.</span><span class="module"><span class="identifier">SECONDS</span>.</span></span>sleep(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//将Thread进行停止，输出工作内容后停止</span></span><br><span class="line">	thread.stop<span class="literal">()</span>;</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(thread.get<span class="constructor">Name()</span>+<span class="string">" stop at "</span>+format.format(<span class="keyword">new</span> <span class="constructor">Date()</span>));</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">TimeUnit</span>.</span><span class="module"><span class="identifier">SECONDS</span>.</span></span>sleep(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	static <span class="keyword">class</span> Runner implements Runnable&#123;</span><br><span class="line">		public void run<span class="literal">()</span> &#123;</span><br><span class="line">			DateFormat format = <span class="keyword">new</span> <span class="constructor">SimpleDateFormat(<span class="string">"HH:MM:SS"</span>)</span>;</span><br><span class="line">			<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">" run at "</span>+format.format(<span class="keyword">new</span> <span class="constructor">Date()</span>));</span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">SleepUtils</span>.</span></span>second(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">PrintThread run at <span class="number">15</span>:<span class="number">07</span>:<span class="number">676</span></span><br><span class="line">PrintThread run at <span class="number">15</span>:<span class="number">07</span>:<span class="number">681</span></span><br><span class="line">PrintThread run at <span class="number">15</span>:<span class="number">07</span>:<span class="number">681</span></span><br><span class="line">PrintThread run at <span class="number">15</span>:<span class="number">07</span>:<span class="number">679</span></span><br><span class="line">PrintThread run at <span class="number">15</span>:<span class="number">07</span>:<span class="number">684</span></span><br><span class="line">PrintThread resume at <span class="number">15</span>:<span class="number">07</span>:<span class="number">684</span></span><br><span class="line">PrintThread run at <span class="number">15</span>:<span class="number">07</span>:<span class="number">689</span></span><br><span class="line">PrintThread run at <span class="number">15</span>:<span class="number">07</span>:<span class="number">693</span></span><br><span class="line">PrintThread stop at <span class="number">15</span>:<span class="number">07</span>:<span class="number">690</span></span><br></pre></td></tr></table></figure>
<p>在执行过程中，PrintThread运行了3秒，随后被暂停，3秒后恢复，最后经过3秒被终止。 通过示例的输出可以看到，suspend()、resume()和stop()方法完成了线程的暂停、恢复和终止工作，<strong>但是这些API是过期的，也就是不建议使用的</strong>。不建议使用的原因主要有：</p>
<ul>
<li>以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。</li>
<li>stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。 </li>
</ul>
<p>注意：正因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法，而<strong>暂停和恢复操作可以等待/通知机制来替代</strong>。</p>
<h3 id="安全地终止线程"><a href="#安全地终止线程" class="headerlink" title="安全地终止线程"></a>安全地终止线程</h3><p>中断状态是线程的一个标识位，而<strong>中断操作是一种简便的线程间交互方式</strong>，而这种交互方式最适合用来取消或停止任务。除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。实例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutDown</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Runner one = <span class="keyword">new</span> Runner();</span><br><span class="line">		Runner two = <span class="keyword">new</span> Runner();</span><br><span class="line">		Thread onethread = <span class="keyword">new</span> Thread(one, <span class="string">"onethread"</span>);</span><br><span class="line">		onethread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		onethread.start();</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		onethread.interrupt();</span><br><span class="line">		</span><br><span class="line">		Thread twothread = <span class="keyword">new</span> Thread(two, <span class="string">"twothread"</span>);</span><br><span class="line">		twothread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		twothread.start();</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		two.cancel();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"Count i = "</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			on = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Count i = <span class="number">466312256</span></span><br><span class="line">Count i = <span class="number">481484154</span></span><br></pre></td></tr></table></figure>
<p>示例在执行过程中，main线程通过中断操作和cancel()方法均可使thread得以终止。这种通过标识位或者中断操作的方式能够<strong>使线程在终止时有机会去清理资源，而不是武断地将线程停止</strong>，因此这种终止线程的做法显得更加安全。</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，这将会带来巨大的价值。</p>
<h3 id="volatile与synchronized关键字"><a href="#volatile与synchronized关键字" class="headerlink" title="volatile与synchronized关键字"></a>volatile与synchronized关键字</h3><p>Java支持多个线程同时访问一个对象或者对象的成员变量，由于每个线程可以拥有这个 变量的拷贝（虽然对象以及成员变量分配的内存是在共享内存中的，但是<strong>每个执行的线程还是可以拥有一份拷贝</strong>，这样做的目的是加速程序的执行，这是现代多核处理器的一个显著特性），所以程序在执行过程中，一个线程看到的变量并不一定是最新的。</p>
<ul>
<li>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。 </li>
</ul>
<p>举个例子：定义一个表示程序是否运行的成员变量boolean on=true，那么另一个线程可能对它执行关闭动作（on=false），这里涉及多个线程对变量的访问，因此需要将其定义成为 volatile boolean on＝true，这样其他线程对它进行改变时，可以让所有线程感知到变化，因为所有对on变量的访问和修改都需要以共享内存为准。但是，过多地使用volatile是不必要的，因为它会降低程序执行的效率。 </p>
<ul>
<li>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</li>
</ul>
<p>使用了同步块和同步方法，通过使用javap工具查看生成的class文件信息来分析synchronized关键字的实现细节，示例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronized</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//对synchronized加锁</span></span><br><span class="line">		<span class="keyword">synchronized</span> (Synchronized<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//同步静态方法，对该class的对象进行加锁</span></span><br><span class="line">		s();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Synchronized.class同级目录执行javap –v Synchronized.class，部分相关输出如下所示:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">1</span>                  <span class="comment">// class Second/Synchronized</span></span><br><span class="line">         <span class="number">2</span>: dup</span><br><span class="line">         <span class="number">3</span>: monitorenter</span><br><span class="line">         <span class="number">4</span>: monitorexit</span><br><span class="line">         <span class="number">5</span>: invokestatic  #<span class="number">16</span>                 <span class="comment">// Method s:()V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">5</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> static synchronized <span class="built_in">void</span> s();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0029</span>) ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>上面class信息中，对于同步块的实现使用了monitorenter和monitorexit指令，而同步方法则是依靠方法修饰符上的ACC_SYNCHRONIZED来完成的。无论采用哪种方式，其本质是<strong>对一个对象的监视器（monitor）进行获取</strong>，而这个获取过程是排他的，也就是<strong>同一时刻只能有一个线程获取到由synchronized所保护对象的监视器</strong>。任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器（执行该方法）的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED 状态。下图描述了对象、对象的监视器、同步队列和执行线程之间的关系：<br><img src="https://wx2.sbimg.cn/2020/07/08/C3tn2.png" alt="C3tn2.png"></p>
<h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h3><blockquote>
<p>一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程<strong>开始于一个线程，而最终执行又是另一个线程</strong>。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），在功能层面上实现了解耦体系结构上具备了良好的伸缩性，但是在Java语言中如何实现类似的功能呢？<br>等待/通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类java.lang.Object上，方法和描述如表所示：<br><a href="https://sbimg.cn/image/C3NYe" target="_blank" rel="noopener"><img src="https://wx2.sbimg.cn/2020/07/08/C3NYe.png" alt="C3NYe.png"></a></p>
</blockquote>
<p>等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同<strong>开关信号</strong>一样，用来完成等待方和通知方之间的交互工作。</p>
<p>实例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> WaitNotify &#123;</span><br><span class="line"></span><br><span class="line">	static boolean flag = <span class="literal">true</span>;</span><br><span class="line">	static Object lock = <span class="keyword">new</span> <span class="constructor">Object()</span>;</span><br><span class="line">	public static void main(String<span class="literal">[]</span> args) throws InterruptedException &#123;</span><br><span class="line">		Thread wait = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">new</span> Wait()</span>, <span class="string">"waitThread"</span>);</span><br><span class="line">		wait.start<span class="literal">()</span>;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">TimeUnit</span>.</span><span class="module"><span class="identifier">SECONDS</span>.</span></span>sleep(<span class="number">2</span>);</span><br><span class="line">		Thread Notify = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">new</span> Notify()</span>, <span class="string">"notifyThred"</span>);</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Notify</span>.</span></span>start<span class="literal">()</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	static <span class="keyword">class</span> Wait implements Runnable&#123;</span><br><span class="line">		public void run<span class="literal">()</span> &#123;</span><br><span class="line">			<span class="comment">//加锁的monitor</span></span><br><span class="line">			synchronized(lock) &#123;</span><br><span class="line">				<span class="comment">//条件不足时，继续wait 释放锁</span></span><br><span class="line">				<span class="keyword">while</span>(flag) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>+<span class="string">"flag is true, wait on "</span>+<span class="keyword">new</span> <span class="constructor">SimpleDateFormat(<span class="string">"HH:MM:SS"</span>)</span>.format(<span class="keyword">new</span> <span class="constructor">Date()</span>));</span><br><span class="line">						lock.wait<span class="literal">()</span>;</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//条件满足时完成任务</span></span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>+<span class="string">"flag is false, wait on "</span>+<span class="keyword">new</span> <span class="constructor">SimpleDateFormat(<span class="string">"HH:MM:SS"</span>)</span>.format(<span class="keyword">new</span> <span class="constructor">Date()</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	static <span class="keyword">class</span> Notify implements Runnable&#123;</span><br><span class="line">		public void run<span class="literal">()</span> &#123;</span><br><span class="line">			<span class="comment">//拥有加锁的monitor</span></span><br><span class="line">			synchronized(lock) &#123;</span><br><span class="line">				<span class="comment">//获取lock的锁然后进行通知，通知时不会释放lock的锁</span></span><br><span class="line">				<span class="comment">//知道线程释放了lock之后 Wait线程才能从wait方法中返回</span></span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>+<span class="string">"Hold lock notify "</span>+<span class="keyword">new</span> <span class="constructor">SimpleDateFormat(<span class="string">"HH:MM:SS"</span>)</span>.format(<span class="keyword">new</span> <span class="constructor">Date()</span>));</span><br><span class="line">				lock.notify<span class="constructor">All()</span>;</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">SleepUtils</span>.</span></span>second(<span class="number">5</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//再次加锁</span></span><br><span class="line">			synchronized(lock) &#123;</span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>+<span class="string">"Hold lock again and sleep"</span>+<span class="keyword">new</span> <span class="constructor">SimpleDateFormat(<span class="string">"HH:MM:SS"</span>)</span>.format(<span class="keyword">new</span> <span class="constructor">Date()</span>));</span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">SleepUtils</span>.</span></span>second(<span class="number">5</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行的结果如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Thread[waitThread,<span class="number">5</span>,main]flag <span class="keyword">is</span> <span class="literal">true</span>, wait on <span class="number">20</span>:<span class="number">07</span>::<span class="number">698</span></span><br><span class="line">Thread[notifyThred,<span class="number">5</span>,main]Hold lock notify <span class="number">20</span>:<span class="number">07</span>:<span class="number">596</span></span><br><span class="line">Thread[notifyThred,<span class="number">5</span>,main]Hold lock again <span class="keyword">and</span> sleep20:<span class="number">07</span>:<span class="number">601</span></span><br><span class="line">Thread[waitThread,<span class="number">5</span>,main]flag <span class="keyword">is</span> <span class="literal">false</span>, wait on <span class="number">20</span>:<span class="number">07</span>:<span class="number">605</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述第3行和第4行输出的顺序可能会互换，而上述例子主要说明了调用wait()、notify()以 及notifyAll()时需要注意的细节，如下:</p>
<ul>
<li>使用wait()、notify()和notifyAll()时需要先对调用对象加锁。</li>
<li>调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。</li>
<li>notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。</li>
<li>notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为获得了调用对象的锁。</li>
</ul>
</blockquote>
<blockquote>
<p>从上述细节中可以看到，等待/通知机制依托于同步机制，其目的就是确保等待线程从wait()方法返回时能够感知到通知线程对变量做出的修改。</p>
</blockquote>
<p>过程图：<br><a href="https://sbimg.cn/image/C9GsM" target="_blank" rel="noopener"><img src="https://wx1.sbimg.cn/2020/07/08/C9GsM.png" alt="C9GsM.png"></a><br>WaitThread首先获取了对象的锁，然后调用对象的wait()方法，从而放弃了锁并进入了对象的等待队列WaitQueue中，进入等待状态。由于WaitThread释放了对象的锁，NotifyThread随后获取了对象的锁，并调用对象的notify()方法，将WaitThread从WaitQueue移到SynchronizedQueue中，此时WaitThread的状态变为阻塞状态。NotifyThread释放了锁之后，WaitThread再次获取到锁并从wait()方法返回继续执行。</p>
<h3 id="等待-通知的基本范式"><a href="#等待-通知的基本范式" class="headerlink" title="等待/通知的基本范式"></a>等待/通知的基本范式</h3><p>等待/通知的经典范式，该范式分为两部分，分别针对等待方（消费者）和通知方（生产者）。<br><strong>等待方遵循如下原则：</strong>   </p>
<blockquote>
<ul>
<li>获取对象的锁;</li>
<li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</li>
<li>条件满足则执行对应的逻辑。 </li>
</ul>
</blockquote>
<p>对应的伪代码如下:</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">synchronized</span>(对象)&#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不满足)&#123;</span><br><span class="line">        对象.<span class="built_in">wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通知方遵循如下原则:</strong> </p>
<blockquote>
<ul>
<li>获得对象的锁。 </li>
<li>改变条件。 </li>
<li>通知所有等待在对象上的线程。</li>
</ul>
</blockquote>
<p>对应的伪代码如下:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">    改变条件<span class="comment">;</span></span><br><span class="line">    对象.notifyAll()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入/输出流"></a>管道输入/输出流</h3><p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它<strong>主要用于线程之间的数据传输，而传输的媒介为内存</strong>。管道输入/输出流主要包括了如下4种具体实现：<strong>PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter，前两种面向字节，而后两种面向字符</strong>。 </p>
<p>实例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">		PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">		PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">		<span class="comment">//将输入输出流进行连接，否则会抛出IOException</span></span><br><span class="line">		out.<span class="built_in">connect</span>(in);</span><br><span class="line">		Thread printthread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">"PrintThread"</span>);</span><br><span class="line">		printthread.start();</span><br><span class="line">		<span class="keyword">int</span> received = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span>((received = System.in.<span class="built_in">read</span>())!=<span class="number">-1</span>) &#123;</span><br><span class="line">				out.<span class="built_in">write</span>(received);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			out.<span class="built_in">close</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line">		PipedReader in;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.in = in;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> received = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">while</span>((received = in.<span class="built_in">read</span>())!=<span class="number">-1</span>) &#123;</span><br><span class="line">					System.out.<span class="built_in">print</span>((<span class="keyword">char</span>)received);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">catch</span>(IOException e) &#123;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Easonhe</span></span><br><span class="line"><span class="attribute">Easonhe</span></span><br></pre></td></tr></table></figure>
<p>例子中创建了printThread，它用来接受main线程的输入，任何main线程的输入均通过PipedWriter写入，而printThread在另一端通过PipedReader将内容读出并打印。对于Piped类型的流，<strong>必须先要进行绑定</strong>，也就是调用connect()方法，如果没有将输入/输出流绑定起来，对于该流的访问将会抛出异常。</p>
<h3 id="Thread-join-的使用"><a href="#Thread-join-的使用" class="headerlink" title="Thread.join()的使用"></a>Thread.join()的使用</h3><p>如果一个线程A执行了thread.join()语句，其含义是：<strong>当前线程A等待thread线程终止之后才从thread.join()返回</strong>。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。这两个超时方法表示，<strong>如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回</strong>。 </p>
<p>实例代码如下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="keyword">Join</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">	Thread <span class="keyword">previous</span> = Thread.currentThread();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">		Thread domino = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Domino(<span class="keyword">previous</span>), String.valueOf(i));</span><br><span class="line">		domino.start();</span><br><span class="line">		<span class="keyword">previous</span> = domino;			</span><br><span class="line">	&#125;</span><br><span class="line">	TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">	System.out.<span class="keyword">println</span>(Thread.currentThread().getName()+<span class="string">" terminate"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> Domino <span class="keyword">implements</span> Runnable&#123;</span><br><span class="line">	    <span class="comment">//每一个线程拥有前一个线程的引用，需要等待前一个线程的终止才能从wait中返回</span></span><br><span class="line">		Thread <span class="keyword">previous</span>;</span><br><span class="line">		<span class="keyword">public</span> Domino(Thread <span class="keyword">previous</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.<span class="keyword">previous</span> = <span class="keyword">previous</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">previous</span>.<span class="keyword">join</span>();</span><br><span class="line">			&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.<span class="keyword">println</span>(Thread.currentThread().getName()+<span class="string">" terminate"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果如下：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">main <span class="keyword">terminate</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">9</span> <span class="keyword">terminate</span></span><br></pre></td></tr></table></figure>
<p>从上述输出可以看到，每个线程终止的前提是前驱线程的终止，每个线程等待前驱线程终止后，才从join()方法返回，这里涉及了等待/通知机制（等待前驱线程结束，接收前驱线程结束通知）。</p>
<p>JDK中Thread.join()方法的源码（进行了部分调整）:</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁当前线程对象 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;     <span class="comment">// 条件不满足，继续等待 </span></span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123; </span><br><span class="line">        wait(<span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件符合，方法返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当线程终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程。可以看到join()方法的逻辑结构与等待/通知经典范式一致，即加锁、循环和处理逻辑3个步骤。</p>
<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>ThreadLocal，即<strong>线程变量</strong>，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p>
<p>实例代码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		TIME_THREADLOCAL.<span class="built_in">set</span>(System.currentTimeMillis());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.<span class="built_in">get</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;</span><br><span class="line">		Profiler.<span class="built_in">begin</span>();</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"cost : "</span>+Profiler.<span class="built_in">end</span>()+<span class="string">" mills."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cost :</span> <span class="number">1003</span> <span class="string">mills.</span></span><br></pre></td></tr></table></figure>
<p>Profiler可以被复用在方法调用耗时统计的功能上，在方法的入口前执行begin()方法，在方法调用后执行end()方法，好处是两个方法的调用不用在一个方法或者类中，比如在AOP（面向方面编程）中，可以在方法调用前的切入点执行begin()方法，而在方法调用后的切入点执行end()方法，这样依旧可以获得方法的执行耗时。</p>
<h2 id="线程应用实例"><a href="#线程应用实例" class="headerlink" title="线程应用实例"></a>线程应用实例</h2><h3 id="等待超时模式"><a href="#等待超时模式" class="headerlink" title="等待超时模式"></a>等待超时模式</h3><p><strong>经典问题</strong>：调用一个方法时等待一段时间（一般来说是给定一个时间段），如果该方法能够在给定的时间段之内得到结果，那么将结果立刻返回，反之，超时返回默认结果。前面的章节介绍了等待/通知的经典范式，即加锁、条件循环和处理逻辑3个步骤，而这种范式无法做到超时等待。，只需要对经典范式做出非常小的改动，就能实现超时等待的加入。</p>
<p><strong>改动内容</strong><br>假设超时时间段是T，那么可以推断出在当前时间now+T之后就会超时。定义如下变量：<strong>等待持续时间：REMAINING=T</strong>。<strong>超时时间：FUTURE=now+T</strong>。 <strong>这时仅需要wait(REMAINING)即可，在wait(REMAINING)返回之后会将执行： REMAINING=FUTURE–now。如果REMAINING小于等于0，表示已经超时，直接退出，否则将 继续执行wait(REMAINING)。</strong></p>
<p>等待超时模式的伪代码如下：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对当前对象加锁 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">Object</span> <span class="built_in">get</span>(<span class="keyword">long</span> mills) <span class="keyword">throws</span> InterruptedException &#123; </span><br><span class="line">    <span class="keyword">long</span> future = System.currentTimeMillis() + mills; </span><br><span class="line">    <span class="keyword">long</span> remaining = mills<span class="comment">//当超时大于0并且result返回值不满足要求</span></span><br><span class="line">    <span class="keyword">while</span> ((result == <span class="keyword">null</span>) &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wait(remaining);</span><br><span class="line">    remaining = future - System.currentTimeMillis(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，等待超时模式就是在等待/通知范式基础上增加了超时控制，这使得该模式相比原有范式更具有灵活性，因为即使方法执行时间过长，也不会“永久”阻塞调用者，而是会按照调用者的要求“按时”返回。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>多线程技术带来了好处有很多，并且讲述了如何启动和终止线程以及线程的状态，详细阐述了多线程之间进行通信的基本方式和等待/通知经典范式</strong>。</p>
<p><strong>参考</strong>：    </p>
<p>《Java并发编程的艺术》</p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】线程池</title>
    <url>/2020/07/14/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(八）线程池含线程池的原理及使用</strong></p>
<a id="more"></a>
<p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序 都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处：</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 </li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 </li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>
</ul>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p><img src="https://wx2.sbimg.cn/2020/07/14/CHV1j.png" alt="CHV1j.png"></p>
<p>从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下：</p>
<ul>
<li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作 线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li>
<li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这 个工作队列里。如果工作队列满了，则进入下个流程。 </li>
<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程 来执行任务。如果已经满了，则交给饱和策略来处理这个任务。 </li>
</ul>
<p>ThreadPoolExecutor执行execute()方法的示意图，如图所示：</p>
<p><img src="https://wx1.sbimg.cn/2020/07/14/CK5vM.png" alt="CK5vM.png"></p>
<ul>
<li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤 需要获取全局锁）。</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue</li>
<li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</li>
<li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用 RejectedExecutionHandler.rejectedExecution()方法。 </li>
</ul>
<p>ThreadPoolExecutor采取上述步骤的总体设计思路，是为了<strong>在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）</strong>。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p>
<p>通过源代码来看看是如何实现的，线程池执行任务的方法如下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">execute</span>(Runnable command) &#123; </span><br><span class="line">    <span class="selector-tag">if</span> (command == null) <span class="selector-tag">throw</span> <span class="selector-tag">new</span> <span class="selector-tag">NullPointerException</span>(); </span><br><span class="line">    <span class="comment">// 如果线程数小于基本线程数，则创建线程并执行当前任务</span></span><br><span class="line">    <span class="selector-tag">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123; </span><br><span class="line">    <span class="comment">// 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。</span></span><br><span class="line">    <span class="selector-tag">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123; </span><br><span class="line">        <span class="selector-tag">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">            <span class="selector-tag">ensureQueuedTaskHandled</span>(command); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量,则创建一个线程执行任务。 </span></span><br><span class="line">    <span class="selector-tag">else</span> <span class="selector-tag">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">    <span class="comment">// 抛出RejectedExecutionException异常 </span></span><br><span class="line">        <span class="selector-tag">reject</span>(command); <span class="comment">// is shutdown or saturated </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作线程</strong>：线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行。Worker类的run()方法:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Runnable <span class="keyword">task</span> = firstTask; </span><br><span class="line">        firstTask = <span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">task</span> != <span class="keyword">null</span> || (<span class="keyword">task</span> = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            runTask(<span class="keyword">task</span>);</span><br><span class="line">            <span class="keyword">task</span> = <span class="keyword">null</span>; </span><br><span class="line">            &#125; </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        workerDone(<span class="keyword">this</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadPoolExecutor执行任务的示意图：</p>
<p><img src="https://wx1.sbimg.cn/2020/07/14/CKmAR.png" alt="CKmAR.png"></p>
<p>线程池中的线程执行任务分两种情况：</p>
<ul>
<li>在execute()方法中创建一个线程时，会让这个线程执行当前任务。</li>
<li>这个线程执行完上图中1的任务后，会反复从BlockingQueue获取任务来执行。</li>
</ul>
<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>我们可以通过ThreadPoolExecutor来创建一个线程池</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">ThreadPoolExecutor(<span class="params">corePoolSize</span>, <span class="params">maximumPoolSize</span>, <span class="params">keepAliveTime</span>, <span class="params">milliseconds</span>,<span class="params">runnableTaskQueue</span>, <span class="params">handler</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>创建一个线程池时需要输入几个参数，如下:</p>
<ul>
<li>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</li>
<li>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列:<blockquote>
<ul>
<li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原 则对元素进行排序</li>
<li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通 常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用 移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li>
</ul>
</blockquote>
</li>
<li>maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。 </li>
<li>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线 程设置有意义的名字，代码如下:<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">ThreadFactoryBuilder</span>()<span class="selector-class">.setNameFormat</span>(<span class="string">"XX-task-%d"</span>)<span class="selector-class">.build</span>();</span><br></pre></td></tr></table></figure></li>
<li>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略<strong>默认情况下是AbortPolicy</strong>，表示无法处理新任务时抛出异常。在JDK1.5中Java线程池框架提供了以下4种策略：<blockquote>
<ul>
<li>AbortPolicy：直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
<li>也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。</li>
</ul>
</blockquote>
</li>
<li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</li>
<li>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟 （MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</li>
</ul>
<h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为<strong>execute()和submit()方法</strong>。 execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">threadPool.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功</strong>，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">Future&lt;Object&gt; <span class="built_in">future</span> = executor.submit(harReturnValuetask); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    Object s = <span class="built_in">future</span>.<span class="built_in">get</span>(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">    <span class="comment">// 处理中断异常 </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123; </span><br><span class="line">    <span class="comment">// 处理无法执行任务异常</span></span><br><span class="line">&#125; </span><br><span class="line">finally &#123; </span><br><span class="line">    <span class="comment">// 关闭线程池 </span></span><br><span class="line">    executor.<span class="built_in">shutdown</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是<strong>遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止</strong>。但是它们存在一定的区别：</p>
<ul>
<li>shutdownNow首先将线程池的状态设置成STOP，然后<strong>尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表</strong>；</li>
<li>shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程</li>
</ul>
<p>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。<strong>当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true</strong>。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，<strong>通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法</strong>。</p>
<h3 id="合理地配置线程池"><a href="#合理地配置线程池" class="headerlink" title="合理地配置线程池"></a>合理地配置线程池</h3><p>要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析：</p>
<ul>
<li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</li>
<li>任务的优先级：高、中和低。 ·任务的执行时间：长、中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。 </li>
</ul>
<p>性质不同的任务可以用不同规模的线程池分开处理。<strong>CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解</strong>，可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行。执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。<strong>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU</strong>。</p>
<p><strong>建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千</strong>。实例：我们系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然，我们的系统所有的任务是用单独的服务器部署的，我们使用不同规模的线程池完成不同类型的任务，但是出现这样问题时也会影响到其他任务。</p>
<h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性：</p>
<ul>
<li>taskCount：线程池需要执行的任务数量。 </li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li>
<li>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是 否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。 </li>
<li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</li>
<li>getActiveCount：获取活动的线程数。 </li>
</ul>
<p>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的 beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>参考：<br><strong>《Java并发编程的艺术》</strong></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】锁</title>
    <url>/2020/07/09/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E9%94%81/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(四）锁含Lock接口/队列同步器/重入锁/读写锁/LockSupport工具/Condition接口</strong></p>
<a id="more"></a>
<h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p><strong>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）</strong>。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了<strong>锁获取与释放的可操作性、可中断的获取锁以 及超时获取锁</strong>等多种synchronized关键字所不具备的同步特性。使用synchronized关键字将会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先 获取再释放。当然，这种方式简化了同步的管理，可是<strong>扩展性没有显示的锁获取和释放来的好</strong>。例如，针对一个场景，手把手进行锁获取和释放，先获得锁A，然后再获取锁B，当锁B获得后，释放锁A同时获取锁C，当锁C获得后，再释放B同时获取锁D，以此类推。这种场景下，synchronized关键字就不那么容易实现了，而使用Lock却容易许多。</p>
<p>实例代码：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Lock</span> <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock()<span class="comment">;</span></span><br><span class="line"><span class="keyword">lock</span>.<span class="keyword">lock</span>()<span class="comment">;</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    <span class="keyword">lock</span>.unlock()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放</strong>。 不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放**。</p>
<p>Lock接口提供的synchronized关键字所不具备的主要特性如表所示:<br><img src="https://wx2.sbimg.cn/2020/07/09/CB0in.png" alt="CB0in.png"></p>
<p>Lock是一个接口，它定义了锁获取和释放的基本操作，Lock的API如表所示:<br><img src="https://wx1.sbimg.cn/2020/07/09/CBCMh.png" alt="CBCMh.png"><br>Lock接口的实现基本都是通过聚合了一个同步器的子类来完成线程访问控制的。</p>
<h2 id="队列同步器"><a href="#队列同步器" class="headerlink" title="队列同步器"></a>队列同步器</h2><p>队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来<strong>构建锁或者其他同步组件的基础框架</strong>，<strong>它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作</strong>，并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。</p>
<p><strong>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态</strong>，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3 个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操 作，因为它们能够保证状态的改变是安全的。<strong>子类推荐被定义为自定义同步组件的静态内部类</strong>，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，<strong>同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态</strong>，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。 </p>
<p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，<strong>利用同步器实现锁的语义</strong>。可以这样理解二者之间的关系：</p>
<ul>
<li>锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；</li>
<li>同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</li>
</ul>
<h3 id="队列同步器的接口与示例"><a href="#队列同步器的接口与示例" class="headerlink" title="队列同步器的接口与示例"></a>队列同步器的接口与示例</h3><p>同步器的设计是<strong>基于模板方法模式</strong>的，也就是说，<strong>使用者需要继承同步器并重写指定的方法</strong>，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。重写同步器指定的方法时，<strong>需要使用同步器提供的如下3个方法来访问或修改同步状态</strong>。 </p>
<blockquote>
<p>1 .getState()：获取当前同步状态。<br>2 .setState(int newState)：设置当前同步状态。<br>3 .compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态 设置的原子性。 </p>
</blockquote>
<p>同步器可重写的方法与描述如表所示:<br><img src="https://wx2.sbimg.cn/2020/07/09/CBA2T.png" alt="CBA2T.png"><br><strong>实现自定义同步组件时，将会调用同步器提供的模板方法</strong>，这些（部分）模板方法与描述如表所示:<br><img src="https://wx2.sbimg.cn/2020/07/09/CBRno.png" alt="CBRno.png"><br>同步器提供的模板方法基本上分为3类：</p>
<ul>
<li>独占式获取与释放同步状态</li>
<li>共享式获取与释放</li>
<li>同步状态和查询同步队列中的等待线程情况</li>
</ul>
<p>自定义同步组件将使用同步器提供的模板方法来实现自己的同步语义。</p>
<p>实例代码展示独占锁：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 静态内部类，自定义同步器 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123; <span class="comment">// 是否处于占用状态 </span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当状态为0的时候获取锁 </span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread()); <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放锁，将状态设置为0 </span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(); setExclusiveOwnerThread(<span class="keyword">null</span>); </span><br><span class="line">            setState(<span class="number">0</span>); </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列 </span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 仅需要将操作代理到Sync上即可 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; sync.acquire(<span class="number">1</span>); &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123; <span class="function"><span class="keyword">return</span> sync.<span class="title">tryAcquire</span><span class="params">(<span class="number">1</span>)</span></span>; &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; sync.release(<span class="number">1</span>); &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="function"><span class="keyword">return</span> sync.<span class="title">newCondition</span><span class="params">()</span></span>; &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="function"><span class="keyword">return</span> sync.<span class="title">isHeldExclusively</span><span class="params">()</span></span>; &#125; <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; <span class="function"><span class="keyword">return</span> sync.<span class="title">hasQueuedThreads</span><span class="params">()</span></span>; &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; sync.acquireInterruptibly(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout)); &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述示例中，独占锁Mutex是一个自定义同步组件，它在<strong>同一时刻只允许一个线程占有锁</strong>。Mutex中定义了一个静态内部类，该内部类继承了同步器并实现了独占式获取和释放同步状态。在tryAcquire(int acquires)方法中，如果经过CAS设置成功（同步状态设置为1），则代表获 取了同步状态，而在tryRelease(int releases)方法中只是将同步状态重置为0。用户使用Mutex时并不会直接和内部同步器的实现打交道，而是调用Mutex提供的方法，在Mutex的实现中，以获取锁的lock()方法为例，只需要在方法实现中调用同步器的模板方法acquire(int args)即可，当前线程调用该方法获取同步状态失败后会被加入到同步队列中等待，这样就大大降低了实现一个可靠自定义同步组件的门槛。</p>
<h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对 资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。这里提到一个锁获取的公平性问题，<strong>如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的</strong>，反之，是不公平的。公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。事实上，公平的锁机制往往没有非公平的效率高，但是，并不是任何场景都是以TPS作为唯一的指标，公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。</p>
<h3 id="实现重进入"><a href="#实现重进入" class="headerlink" title="实现重进入"></a>实现重进入</h3><p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题：</p>
<ul>
<li>线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</li>
<li>锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。</li>
</ul>
<p><strong>锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。 ReentrantLock是通过组合自定义同步器来实现锁的获取与释放，以非公平性（默认的）实现为例</strong>，</p>
<p>获取同步状态的实例代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">final boolean nonfair<span class="constructor">TryAcquire(<span class="params">int</span> <span class="params">acquires</span>)</span> &#123; </span><br><span class="line">    final Thread current = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>; </span><br><span class="line">    <span class="built_in">int</span> c = get<span class="constructor">State()</span>; </span><br><span class="line">    <span class="keyword">if</span> (c<span class="operator"> == </span><span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> (compare<span class="constructor">AndSetState(0, <span class="params">acquires</span>)</span>) &#123;</span><br><span class="line">            set<span class="constructor">ExclusiveOwnerThread(<span class="params">current</span>)</span>; </span><br><span class="line">            return <span class="literal">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current<span class="operator"> == </span>get<span class="constructor">ExclusiveOwnerThread()</span>) &#123; </span><br><span class="line">        <span class="built_in">int</span> nextc = c + acquires; </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) throw <span class="keyword">new</span> <span class="constructor">Error(<span class="string">"Maximum lock count exceeded"</span>)</span>; </span><br><span class="line">            set<span class="constructor">State(<span class="params">nextc</span>)</span>; </span><br><span class="line">            return <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。</p>
</blockquote>
<p>成功获取锁的线程再次获取锁，只是增加了同步状态值，这也就要求ReentrantLock在释放同步状态时减少同步状态值，该方法的代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected final boolean <span class="keyword">try</span><span class="constructor">Release(<span class="params">int</span> <span class="params">releases</span>)</span> &#123; </span><br><span class="line">    <span class="built_in">int</span> c = get<span class="constructor">State()</span> - releases; </span><br><span class="line">    <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span> != get<span class="constructor">ExclusiveOwnerThread()</span>) throw <span class="keyword">new</span> <span class="constructor">IllegalMonitorStateException()</span>; </span><br><span class="line">    boolean free = <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">if</span> (c<span class="operator"> == </span><span class="number">0</span>) &#123; </span><br><span class="line">        free = <span class="literal">true</span>; </span><br><span class="line">        set<span class="constructor">ExclusiveOwnerThread(<span class="params">null</span>)</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    set<span class="constructor">State(<span class="params">c</span>)</span>; </span><br><span class="line">    return free; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。公平锁代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected final boolean <span class="keyword">try</span><span class="constructor">Acquire(<span class="params">int</span> <span class="params">acquires</span>)</span> &#123; </span><br><span class="line">    final Thread current = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>; </span><br><span class="line">    <span class="built_in">int</span> c = get<span class="constructor">State()</span>; </span><br><span class="line">    <span class="keyword">if</span> (c<span class="operator"> == </span><span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> (!has<span class="constructor">QueuedPredecessors()</span><span class="operator"> &amp;&amp; </span>compare<span class="constructor">AndSetState(0, <span class="params">acquires</span>)</span>) &#123; </span><br><span class="line">            set<span class="constructor">ExclusiveOwnerThread(<span class="params">current</span>)</span>;</span><br><span class="line">            return <span class="literal">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current<span class="operator"> == </span>get<span class="constructor">ExclusiveOwnerThread()</span>) &#123; </span><br><span class="line">        <span class="built_in">int</span> nextc = c + acquires; </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) throw <span class="keyword">new</span> <span class="constructor">Error(<span class="string">"Maximum lock count exceeded"</span>)</span>;</span><br><span class="line">        set<span class="constructor">State(<span class="params">nextc</span>)</span>; </span><br><span class="line">        return <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为<strong>判断条件多了 hasQueuedPredecessors()方法</strong>，即加入了同步队列中当前节点<strong>是否有前驱节点</strong>的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p>
<p>公平和非公平锁在获取锁时的区别的代码实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairAndUnfairTest</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock fairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">true</span>); <span class="keyword">private</span> <span class="keyword">static</span> Lock unfairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">false</span>); <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fair</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        testLock(fairLock); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfair</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        testLock(unfairLock); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">(Lock lock)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 启动5个Job（略） </span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">        <span class="keyword">private</span> Lock lock; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(Lock lock)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 连续2次打印当前的Thread和等待队列中的Thread（略） </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock2</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock2</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(fair);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        List&lt;Thread&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="keyword">super</span>. getQueuedThreads()); </span><br><span class="line">        Collections.reverse(arrayList); </span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：<br><img src="https://wx2.sbimg.cn/2020/07/10/CRQQ6.png" alt="CRQQ6.png"><br>在测试中公平性锁与非公平性锁相比，总耗时是其94.3倍，总切换次数是其133倍。可以 看出，公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>之前提到锁（如Mutex和ReentrantLock）基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而<strong>读写锁在同一时刻可以允许多个读线程访问</strong>，但是<strong>在写线程访问时，所有的读线程和其他写线程均被阻塞</strong>。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p>
<p>一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在<strong>读多于写的情况下</strong>，<strong>读写锁能够提供比排它锁更好的并发性和吞吐量</strong>。Java并发包提供读写锁的实现是ReentrantReadWriteLock，它提供的特性如表所示：<br><img src="https://wx1.sbimg.cn/2020/07/10/CRAzO.png" alt="CRAzO.png"></p>
<h3 id="读写锁的接口与示例"><a href="#读写锁的接口与示例" class="headerlink" title="读写锁的接口与示例"></a>读写锁的接口与示例</h3><p>ReadWriteLock仅定义了获取读锁和写锁的两个方法，即readLock()方法和writeLock()方 法，而其实现——ReentrantReadWriteLock，除了接口方法之外，还提供了一些便于外界监控其内部工作状态的方法，这些方法以及描述如表所示。<br><img src="https://wx2.sbimg.cn/2020/07/10/CRBOe.png" alt="CRBOe.png"><br>读写锁的实例代码：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.<span class="keyword">HashMap</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Cache &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span> , <span class="keyword">Object</span>&gt;();</span><br><span class="line">	<span class="keyword">static</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">	<span class="keyword">static</span> Lock r = lock.readLock();</span><br><span class="line">	<span class="keyword">static</span> Lock w = lock.writeLock();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span> <span class="built_in">get</span>(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">		r.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			r.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置key所对应的value并返回旧的value</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span> <span class="built_in">set</span>(<span class="keyword">String</span> <span class="built_in">key</span>, <span class="keyword">Object</span> obj) &#123;</span><br><span class="line">		w.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">map</span>.put(<span class="built_in">key</span>, obj);</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			w.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//清空所有内容</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="built_in">clear</span>() &#123;</span><br><span class="line">		w.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="built_in">map</span>.<span class="built_in">clear</span>();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			w.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述示例中，Cache组合一个非线程安全的HashMap作为缓存的实现，同时使用读写锁的读锁和写锁来保证Cache是线程安全的。<strong>Cache使用读写锁提升读操作的并发性，也保证每次写操作对所有的读写操作的可见性，同时简化了编程方式。</strong></p>
</blockquote>
<h2 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h2><p>当需要阻塞或唤醒一个线程的时候，都会使用LockSupport工具类来完成相应工作。LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。</p>
<p>LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread) 方法来唤醒一个被阻塞的线程。Park有停车的意思，假设线程为车辆，那么park方法代表着停车，而unpark方法则是指车辆启动离开，这些方法以及描述如表所示。<br><img src="https://wx2.sbimg.cn/2020/07/10/CRduN.png" alt="CRduN.png"></p>
<blockquote>
<p>LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos) 和parkUntil(Object blocker,long deadline)3个方法，用于实现阻塞当前线程的功能，其中参数blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和系统监控。 下面的示例中，将对比parkNanos(long nanos)方法和parkNanos(Object blocker,long nanos)方 法来展示阻塞对象blocker的用处，代码片段和线程dump（部分）如表5-11所示。 从表的线程dump结果可以看出，代码片段的内容都是阻塞当前线程10秒，但从线程 dump结果可以看出，有阻塞对象的parkNanos方法能够传递给开发人员更多的现场信息。这是 由于在Java 5之前，当线程阻塞（使用synchronized关键字）在一个对象上时，通过线程dump能够查看到该线程的阻塞对象，方便问题定位，而Java 5推出的Lock等并发工具时却遗漏了这一点，致使在线程dump时无法提供阻塞对象的信息。因此，在Java 6中，LockSupport新增了上述3个含有阻塞对象的park方法，用以替代原有的park方法。<br><img src="https://wx1.sbimg.cn/2020/07/10/CRg8j.png" alt="CRg8j.png"></p>
</blockquote>
<h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以<strong>实现等待/通知模式</strong>。Condition接口也提供了类似Object的监视器方法，与<strong>Lock配合可以实现等待/通知模式</strong>，但是这两者在使用方式以及功能特性上还是有差别的。通过对比Object的监视器方法和Condition接口，可以更详细地了解Condition的特性，对比项与结果如表所示:<br><img src="https://wx2.sbimg.cn/2020/07/10/CRspk.png" alt="CRspk.png"></p>
<h3 id="Condition接口与实例"><a href="#Condition接口与实例" class="headerlink" title="Condition接口与实例"></a>Condition接口与实例</h3><p>Condition的使用方式比较简单，需要注意在调用方法前获取锁，使用方式如代码所示：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line">Condition condition = <span class="keyword">lock</span>.newCondition(); </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionWait</span>(<span class="params"></span>) throws InterruptedException</span> &#123;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>(); </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        condition.<span class="keyword">await</span>(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="keyword">lock</span>.unlock(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span>(<span class="params"></span>) throws InterruptedException</span> &#123;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>(); </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        condition.signal(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如示例所示，一般都会将Condition对象作为成员变量。当调用await()方法后，当前线程会<strong>释放锁并在此等待</strong>，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p>
</blockquote>
<p>Condition定义的（部分）方法以及描述如表所示:<br><img src="https://wx1.sbimg.cn/2020/07/10/CRJgn.png" alt="CRJgn.png"><br>获取一个Condition必须通过Lock的newCondition()方法。下面通过一个有界队列的示例来深入了解Condition的使用方式:</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">public class BoundedQueue&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] <span class="built_in">items</span>; <span class="comment">//添加的下标，删除的下标和数组当前数量 </span></span><br><span class="line">    <span class="keyword">private</span> int addIndex, removeIndex, <span class="built_in">count</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">Lock</span> <span class="built_in">lock</span> = new ReentrantLock(); </span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = <span class="built_in">lock</span>.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition notFull = <span class="built_in">lock</span>.newCondition(); </span><br><span class="line">    public BoundedQueue(int <span class="built_in">size</span>) &#123; </span><br><span class="line">        <span class="built_in">items</span> = new Object[<span class="built_in">size</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加一个元素，如果数组满，则添加线程进入等待状态，直到有"空位" </span></span><br><span class="line">    public void add(T t) throws InterruptedException &#123;</span><br><span class="line">        <span class="built_in">lock</span>.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">count</span> == <span class="built_in">items</span>.length) </span><br><span class="line">            notFull.await(); </span><br><span class="line">        <span class="built_in">items</span>[addIndex] = t;</span><br><span class="line">        <span class="keyword">if</span> (++addIndex == <span class="built_in">items</span>.length)</span><br><span class="line">            addIndex = <span class="number">0</span>;</span><br><span class="line">        ++<span class="built_in">count</span>; </span><br><span class="line">        notEmpty.signal(); </span><br><span class="line">        &#125; finally &#123; </span><br><span class="line">            <span class="built_in">lock</span>.unlock(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素 </span></span><br><span class="line">    public T remove() throws InterruptedException &#123;</span><br><span class="line">        <span class="built_in">lock</span>.<span class="built_in">lock</span>(); </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">count</span> == <span class="number">0</span>) </span><br><span class="line">                    notEmpty.await(); </span><br><span class="line">                Object x = <span class="built_in">items</span>[removeIndex]; </span><br><span class="line">                <span class="keyword">if</span> (++removeIndex == <span class="built_in">items</span>.length) </span><br><span class="line">                    removeIndex = <span class="number">0</span>; </span><br><span class="line">                --<span class="built_in">count</span>; </span><br><span class="line">                notFull.signal(); </span><br><span class="line">                return (T) x; </span><br><span class="line">            &#125; finally &#123; </span><br><span class="line">                <span class="built_in">lock</span>.unlock(); </span><br><span class="line">            &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述示例中，BoundedQueue通过add(T t)方法添加一个元素，通过remove()方法移出一个 元素。以添加方法为例。首先需要获得锁，目的是确保数组修改的可见性和排他性。当数组数量等于数组长度时，表示数组已满，则调用notFull.await()，当前线程随之释放锁并进入等待状态。如果数组数量不等于数组长度，表示数组未满，则添加元素到数组中，同时通知等待在notEmpty上的线程，数 组中已经有新元素可以获取。在添加和删除方法中使用while循环而非if判断，目的是防止过早或意外的通知，只有条件符合才能够退出循环。回想之前提到的等待/通知的经典范式，二者是非常类似的。</p>
<p>参考：<br><strong>《Java并发编程的艺术》</strong></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【生活区】吐血安利数十款宝藏网站</title>
    <url>/2020/07/04/%E3%80%90%E7%94%9F%E6%B4%BB%E5%8C%BA%E3%80%91%E5%90%90%E8%A1%80%E5%AE%89%E5%88%A9%E6%95%B0%E5%8D%81%E6%AC%BE%E5%AE%9D%E8%97%8F%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p><strong>不会吧!不会吧!不会真的有人不知道这些网站吧？自从收藏夹里有了这些网站，上网幸福指数直线上升啊！(｡◕ˇ∀ˇ◕）</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>今儿个周六，按照计划今天是对前几天写的技术博客的回顾温习，所以今天搞完计划还剩很多时间，所以就突发奇想，把我Chrome里面私藏的宝贝给大家分享一下，也希望其中能有些能对你们有用。当今Web技术极度成熟了，所以很多的网址的内容做的相当棒，所以我这里按照网站类型对这些网址进行了分类，大家可以利用目录（手机用户通过点击文章里左下角的菜单按钮即可查看目录）直接定位自己感兴趣的类别，分为以下三类：</p>
</blockquote>
<ul>
<li>究极休闲类</li>
<li>办公学习类</li>
<li>程序猿私享   </li>
</ul>
<p><strong>废话不多说 Here we go~</strong></p>
<h2 id="究极休闲类"><a href="#究极休闲类" class="headerlink" title="究极休闲类"></a>究极休闲类</h2><h3 id="Pexels（免费相片影片库）"><a href="#Pexels（免费相片影片库）" class="headerlink" title="Pexels（免费相片影片库）"></a>Pexels（免费相片影片库）</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2S5WD.png" alt="2S5WD.png"></p>
<blockquote>
<p>超级强大的高分辨率图和影片的合辑网站，这面入驻有很多的专业摄影师和模特，不仅能白嫖下载当屏保还能当艺术品欣赏，在这里面浏览久了感觉自己艺术品位都提升了呢（手动狗头）<a href="https://www.pexels.com/zh-tw/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.pexels.com/zh-tw/" target="_blank" rel="noopener">https://www.pexels.com/zh-tw/</a>)</p>
</blockquote>
<h3 id="豆瓣读书"><a href="#豆瓣读书" class="headerlink" title="豆瓣读书"></a>豆瓣读书</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2S4Re.png" alt="2S4Re.png"></p>
<blockquote>
<p>有的时候想读一些非专业知识的好书就很苦于哪里寻找，豆瓣读书是我找书用的最多的一个来源了，页面很友好，还有年度榜单这种大众认可的好书，可以说省了很多的时间去挑书，而且还有配套的书店和电子书，这么好的资源都放在这了，你确定不盘几本品品？<a href="https://book.douban.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://book.douban.com/" target="_blank" rel="noopener">https://book.douban.com/</a>)</p>
</blockquote>
<h3 id="偶书"><a href="#偶书" class="headerlink" title="偶书"></a>偶书</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SMyN.png" alt="2SMyN.png"></p>
<blockquote>
<p>这个本身其实我不太想分享给你们的，这是一款很强的白嫖图书电子版的网站，你也可以在里面求书还可以找一找读一读那些热门推荐里面的书籍，之所以说本来不想推荐主要是因为里面有很多的资源都属于盗版，但是后来想想不读要比读盗版更可怕，答应我，如果书对你有帮助，即便你读完了也要去买本正版支持作者！让更多的好书得以问世<a href="https://obook.cc/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://obook.cc/" target="_blank" rel="noopener">https://obook.cc/</a>)</p>
</blockquote>
<h3 id="马可菠萝"><a href="#马可菠萝" class="headerlink" title="马可菠萝"></a>马可菠萝</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2Skbn.png" alt="2Skbn.png"></p>
<blockquote>
<p>这是一款可以下载于Mac上的App合集网站，鉴于Mac上的Store实在太过于鸡肋，所以想要好的软件体验还是少不了第三方的提供，这里有很多的精品软件包括游戏办公美化等等吧，大家自行探索<a href="https://www.macbl.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.macbl.com/" target="_blank" rel="noopener">https://www.macbl.com/</a>)</p>
</blockquote>
<h2 id="办公学习区"><a href="#办公学习区" class="headerlink" title="办公学习区"></a>办公学习区</h2><h3 id="必应"><a href="#必应" class="headerlink" title="必应"></a>必应</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2S22h.png" alt="2S22h.png"></p>
<blockquote>
<p>为什么推荐bing呢？主要是因为百度的这个广告是在是太多了，百度一下整个第一页搜索结果全是广告，这也导致搜索幸福指数直线下降，所以bing这清爽又艺术的页面就让人赏心悦目，最主要的是他广告少呀，这才是搜索引擎应该有的亚子！不得不说百度某些产品的开发表现实在是越来越令人失望了，不过作为国产搜索引擎之光还是要多努力啊<a href="https://cn.bing.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://cn.bing.com/" target="_blank" rel="noopener">https://cn.bing.com/</a>)</p>
</blockquote>
<h3 id="ProcessOn"><a href="#ProcessOn" class="headerlink" title="ProcessOn"></a>ProcessOn</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2SCLM.png" alt="2SCLM.png"></p>
<blockquote>
<p>作为一个免费的在线作图的软件，ProcessOn的表现真的是非常棒了，相较于visio它更加的易于操作，相较于某些疯狂打广告自称免费的作图app不知道要好上多少倍，虽然它在某些非常强的功能上可以付费，但是免费功能足够日常使用了，至少导出不用充会员（叹息），在我的博客里面作图我都是用的这个ProcessOn很好用很友好！<br><a href="https://www.processon.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.processon.com/" target="_blank" rel="noopener">https://www.processon.com/</a>)</p>
</blockquote>
<h3 id="简书"><a href="#简书" class="headerlink" title="简书"></a>简书</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SDia.png" alt="2SDia.png"></p>
<blockquote>
<p>简书真的是本百科全书，它的涉及领域十分广泛，我是通过专业问题摸到了这个上面来的，接触久了才发现这里面有很多不同领域的作者写了很多满满干货文章，有时候你会发现很多领域的问题都可以在这找到答案，有点文章版的知乎的意思，闲下来的时候这里面的文章也是够探索的，总之很舒服，很有意思！<br><a href="https://www.jianshu.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.jianshu.com/" target="_blank" rel="noopener">https://www.jianshu.com/</a>)</p>
</blockquote>
<h3 id="Converto（在线文件格式转换器）"><a href="#Converto（在线文件格式转换器）" class="headerlink" title="Converto（在线文件格式转换器）"></a>Converto（在线文件格式转换器）</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2SoMR.png" alt="2SoMR.png"></p>
<blockquote>
<p>可以看到页面十分简洁并且功能强大的在线文件格式转换器，不管是图片还是视频以及文档等等都是可以在这里找到转换格式列表，并且免费！唯一不足的地方是很大的文件格式转换速度比较慢，不过也可以接受，办公学习日常免不了文件格式转换，线上直换省时又省力<br><a href="https://convertio.co/zh/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://convertio.co/zh/" target="_blank" rel="noopener">https://convertio.co/zh/</a>)</p>
</blockquote>
<h3 id="慕课"><a href="#慕课" class="headerlink" title="慕课"></a>慕课</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2S3RI.png" alt="2S3RI.png"></p>
<blockquote>
<p>这个想必大家都不陌生，作为一个大学学习网站，MOOC做的真的是特别优秀了，不仅是很多名校的加入让Mooc课程内容含金量满满，而且多用才发现它真的是个很强的学习宝库，所以还是希望大家多多探索它，畅游在知识的海洋～<br><a href="https://www.icourse163.org/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.icourse163.org/" target="_blank" rel="noopener">https://www.icourse163.org/</a>)</p>
</blockquote>
<h3 id="江下科技在线应用"><a href="#江下科技在线应用" class="headerlink" title="江下科技在线应用"></a>江下科技在线应用</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2S9VG.png" alt="2S9VG.png"></p>
<blockquote>
<p>这个网站是我最近才发掘的，我是在一次需要图片压缩的时候意外找到的，使用后体验很不错，首先很重要的是它免费！并且它对于图片压缩的性能有着不俗的表现，不仅速度快而且下载也很快，总之是一款效率很高功能很强大的在线办公应用！<br><a href="https://www.onlinedo.cn/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.onlinedo.cn/" target="_blank" rel="noopener">https://www.onlinedo.cn/</a>)</p>
</blockquote>
<h3 id="盲打在线学习课程"><a href="#盲打在线学习课程" class="headerlink" title="盲打在线学习课程"></a>盲打在线学习课程</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SQ6T.png" alt="2SQ6T.png"></p>
<blockquote>
<p>我真的特别感谢这个网站，因为在刚寒假的时候就接触到了它，然后按照这个网站的的课程一步一步的让我充分掌握了盲打技术，自从学会了盲打，电脑学习工作的体验简直不要太爽～关于盲打我真的觉得大家都可以学一学，因为面不了电脑办公，掌握盲打肯定让你效率高涨，我只学了大概两周就已经掌握的不错了，大家学起来吧（首次加载有些慢，不要着急慢慢等待）<br><a href="https://www.typingstudy.com/zh/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.typingstudy.com/zh/" target="_blank" rel="noopener">https://www.typingstudy.com/zh/</a>)</p>
</blockquote>
<h3 id="Removebg（抠图）"><a href="#Removebg（抠图）" class="headerlink" title="Removebg（抠图）"></a>Removebg（抠图）</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SBlo.png" alt="2SBlo.png"></p>
<blockquote>
<p>一款在线图片背景消除工具，简单理解就是抠图，可能日常生活不太需要，但是偶尔还是很可能会用一用的，这款工具对于图片处理萌新来说操作十分友好，很简单很清爽，并且免费，收藏起来吧～<br><a href="https://www.remove.bg/zh" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.remove.bg/zh" target="_blank" rel="noopener">https://www.remove.bg/zh</a>)</p>
</blockquote>
<h3 id="我要自学网"><a href="#我要自学网" class="headerlink" title="我要自学网"></a>我要自学网</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2Sc2l.png" alt="2Sc2l.png"></p>
<blockquote>
<p>全能自学网站！这个网站自学的领域范围真的是令人赞赏，看图就可以感受到它究竟有多么强大了，即便你不知道你对什么技术有兴趣，在里面游览一番说不定也能找到你喜欢的课程从此踏上人间巅峰了呢（呲牙）我在这里学习的竟然就是简单的电脑维修技术，的确不错，很香～<br><a href="https://www.51zxw.net/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.51zxw.net/" target="_blank" rel="noopener">https://www.51zxw.net/</a>)</p>
</blockquote>
<h3 id="优品PPT"><a href="#优品PPT" class="headerlink" title="优品PPT"></a>优品PPT</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2Sgn2.png" alt="2Sgn2.png"></p>
<blockquote>
<p>免费的PPT模版下载网址，众所周知PPT自我制作的步骤还是十分繁琐的，并且要做出好的PPT还需要很多精细的操作，现在大多的PPT模版的下载网址大都收费，所以像这种种类繁多又免费的PPT网站的存在实属不易，作为办公老朋友的PPT模版还是白嫖模版比较香～<br><a href="http://www.ypppt.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="http://www.ypppt.com/" target="_blank" rel="noopener">http://www.ypppt.com/</a>)</p>
</blockquote>
<h3 id="adddog（网址导航）"><a href="#adddog（网址导航）" class="headerlink" title="adddog（网址导航）"></a>adddog（网址导航）</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SsM8.png" alt="2SsM8.png"></p>
<blockquote>
<p>有了它即使你没有之前安利的那么多网址也没关系，因为它为你准备了各种行业领域或技术领域可以使用的干活网站，相比于其他网址导航满满的广告，这个导航就良心太多了，网站摆酷快快进收藏夹吃土吧～<br><a href="https://www.addog.vip/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.addog.vip/" target="_blank" rel="noopener">https://www.addog.vip/</a>)</p>
</blockquote>
<h3 id="北京大学视频公开课"><a href="#北京大学视频公开课" class="headerlink" title="北京大学视频公开课"></a>北京大学视频公开课</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2SJcJ.png" alt="2SJcJ.png"></p>
<blockquote>
<p>这个网站标题看着就有内味了，我在这个上面看过一些计算机专业的相关课感觉还不错，名校教师真是名不虚传，很多疑难的点居然在课上就可以提出解决了，不足之处就是很多种类的课程年代比较老画质不咋滴，并且很多课程在这个上面找不到，不过也还好，以后更新了说不定就更齐全了～<br><a href="http://opencourse.pku.edu.cn/course/opencourse/index.html" target="_blank" rel="noopener">戳我直达</a>(<a href="http://opencourse.pku.edu.cn/course/opencourse/index.html" target="_blank" rel="noopener">http://opencourse.pku.edu.cn/course/opencourse/index.html</a>)</p>
</blockquote>
<h3 id="公益图床"><a href="#公益图床" class="headerlink" title="公益图床"></a>公益图床</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SLYm.png" alt="2SLYm.png"></p>
<blockquote>
<p>如果你和我一样也在写博客的话图床是肯定离不开的，当下在线图床工具不算少比如七牛云等等但是要么得冲币要么不稳定要么就是操作不友好，这个公益图床是我的blog一直在用的在线图床工具，用了一段时间感觉还不错，页面很美观很简洁，操作也很友好，但是作为免费用户只能上传2M以下的图，不过可以接受，这个图床工具我也不敢恭维它，小问题不断不过总体下来作为免费图床工具已经是很不错的了<br><a href="https://sbimg.cn/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://sbimg.cn/" target="_blank" rel="noopener">https://sbimg.cn/</a>)</p>
</blockquote>
<h2 id="程序猿私享"><a href="#程序猿私享" class="headerlink" title="程序猿私享"></a>程序猿私享</h2><h3 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2SjVU.png" alt="2SjVU.png"></p>
<blockquote>
<p>这个是我非常喜欢的一个在线学习网站，里面涵盖了几乎所有的计算机知识，并且对于基础知识来说更是非常的多，它最大的特点就是将某种知识区循序渐进的一步步的教授，让人学起来觉得非常的有趣非常的轻松，今天下午我还刚刚简单的学习完了前端开发的HTML CSS和JavaScript，总是特别棒特别香墙裂推荐～<br><a href="https://www.runoob.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com/</a>)</p>
</blockquote>
<h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2S19d.png" alt="2S19d.png"></p>
<blockquote>
<p>GitHub想必不用我多说，感觉程序员应该没有不用的，作为一个全球最大的开源项目集结地，GitHub在计算机专业的地位毋庸置疑，里面大量的开源项目分享简直就是程序员的宝库！<br><a href="https://github.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://github.com/)、" target="_blank" rel="noopener">https://github.com/)、</a></p>
</blockquote>
<h3 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2Sqw4.png" alt="2Sqw4.png"></p>
<blockquote>
<p>这个应该更不用我介绍了，CSDN是面向国内最大的程序员社区了，是国内标杆般的存在，我很多很多学习的计算机知识大都来自于CSDN，当然我也在CSDN建立了blog，希望能和大家一起加入CSDN～<br><a href="https://www.csdn.net/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.csdn.net/" target="_blank" rel="noopener">https://www.csdn.net/</a>)</p>
</blockquote>
<h3 id="Gitee码云"><a href="#Gitee码云" class="headerlink" title="Gitee码云"></a>Gitee码云</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SelY.png" alt="2SelY.png"></p>
<blockquote>
<p>Gitee码云虽然创立的较晚但是它做的功能真的是已经很棒了，完全可以成为国内版GitHub了，正是因为它位于国内，才让它对于GitHub来说有了加载速度快的绝对优势，想必大家都有从GitHub上好不容易找到了好的开源项目但是git clone到本地的时候速度简直不要太感人，很好的解决方式就是将GitHub上的仓库地址直接先导入Gitee上然后再git clone那速度，快到飞起～<br><a href="https://gitee.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a>)</p>
</blockquote>
<h3 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2SwCA.png" alt="2SwCA.png"></p>
<blockquote>
<p>牛客网真是个善后的存在，自从在牛客刷了些面试题后我才惊喜的发现我遗漏了哪些关键位置知识点，牛客本身的功能就很强大，我把它当作一个量足的题库，很多编程题目都可以在上面找到诸多解决思路，用起来啦～<br><a href="https://www.nowcoder.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a>)</p>
</blockquote>
<h3 id="简单教程"><a href="#简单教程" class="headerlink" title="简单教程"></a>简单教程</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SzLV.png" alt="2SzLV.png"></p>
<blockquote>
<p>类似于菜鸟教程，我在这个简单教程学了设计模式，感觉还不错，页面很清爽，讲解也很细致，节奏也比较慢，是个学开发的不可多得的在线学习网站<br><a href="https://www.twle.cn/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.twle.cn/" target="_blank" rel="noopener">https://www.twle.cn/</a>)</p>
</blockquote>
<h3 id="虫部落"><a href="#虫部落" class="headerlink" title="虫部落"></a>虫部落</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SZFD.png" alt="2SZFD.png"></p>
<blockquote>
<p>很强大万物集结地，这里边个个都是人才哈哈，这里有很多破解修改的软件或者脚本之类的有创意的资源，我在里面能泡一天～<br><a href="https://www.chongbuluo.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.chongbuluo.com/" target="_blank" rel="noopener">https://www.chongbuluo.com/</a>)</p>
</blockquote>
<h3 id="Java教程"><a href="#Java教程" class="headerlink" title="Java教程"></a>Java教程</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SywT.png" alt="2SywT.png"></p>
<blockquote>
<p>专注的Java教程网站，在这里学Java开发很有意思，它将很多的知识点以及知识区块都用游戏的方式呈现出来，并且有很多有意思小应用，对于Java语言的系统学习很有意思～<br><a href="https://how2j.cn/?p=61135" target="_blank" rel="noopener">戳我直达</a>(<a href="https://how2j.cn/?p=61135" target="_blank" rel="noopener">https://how2j.cn/?p=61135</a>)</p>
</blockquote>
<h3 id="OSCHINA"><a href="#OSCHINA" class="headerlink" title="OSCHINA"></a>OSCHINA</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2SVrw.png" alt="2SVrw.png"></p>
<blockquote>
<p>中国专注于开源项目的很不错的网站，相比于GitHub他对国内的程序员更加友好，虽然没有GiyHub那么丰富的资源，但是作为国内开源网站，集结的开源项目也是非常值得肯定的！<br><a href="https://www.oschina.net/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.oschina.net/" target="_blank" rel="noopener">https://www.oschina.net/</a>)</p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><strong>本以为这篇博客半小时就能写完，没想到写下来用了两个多小时（狂哭）当然如果这些安利里面有可以帮到你的我也算值了～本次大约安利了将近30款在线网址，不过究极休闲区安利的很少，因为我本身也很少去使用这类的网址，希望大家如果有什么好的在线网址也可以安利给我，我也会及时更新分享给大家哒～还是那句话，希望可以和大家一起成长，请立即加油喔</strong></p>
]]></content>
      <categories>
        <category>生活区</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>好物</tag>
      </tags>
  </entry>
  <entry>
    <title>【看法分享】浅谈考研</title>
    <url>/2020/06/30/%E3%80%90%E7%94%9F%E6%B4%BB%E5%8C%BA%E3%80%91%E6%9C%AC%E7%A7%91%E5%9C%A8%E8%AF%BB%E7%94%9F%E6%B5%85%E8%B0%88%E8%80%83%E7%A0%94/</url>
    <content><![CDATA[<p><strong>本科毕业考研一定是个不错的选择吗？我到底适不适合考研？大家都在互劝考研之时，本科在读生与你分享一些对考研的认知和建议，给你不一样的声音（●&gt;∀&lt;●）</strong></p>
<a id="more"></a>
<hr>
<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p><strong>最近恶补JVM的深入理解搞的有点头晕目眩，这会就偷懒一下写一点关于我对考研这条路的理解，希望能和大家一起交流，这仅仅代表我个人看法，不建议作为大家的决定参考。</strong></p>
<hr>
<h2 id="大家怎么说？"><a href="#大家怎么说？" class="headerlink" title="大家怎么说？"></a>大家怎么说？</h2><p>考研这个问题呢相信是在看这篇blog的你我都很关注的问题，我在很多很多场合和很多很多朋友都有交流过类似的问题，这些问题都有个通常的开头：你准备考研吗？我通常的回答：我大概率是不考研的。大家这时候往往开始用一些我们都听出茧的理由diss我，比如：<br><img src="https://wx1.sbimg.cn/2020/06/30/2tegO.png" alt="2tegO.png"><br>稍微做个总结把：</p>
<blockquote>
<ol>
<li>感觉不考研就找不到工作</li>
<li>感觉大家都考研了 不考就落下了</li>
<li>本科学的很鸡肋 需要考个研补一补</li>
<li>全村的希望 学历越高越牛X</li>
<li>想要找个好工作</li>
<li>靠 不知道本科毕了业能干什么<br>。。。   </li>
</ol>
</blockquote>
<p>所以针对这些普遍的疑问，就几个方面谈一谈我的理解吧</p>
<hr>
<h2 id="考研的目的"><a href="#考研的目的" class="headerlink" title="考研的目的"></a>考研的目的</h2><h3 id="研究生毕业真有那么香？"><a href="#研究生毕业真有那么香？" class="headerlink" title="研究生毕业真有那么香？"></a>研究生毕业真有那么香？</h3><p>暂且不谈论考研能否上岸问题，就考研的目的来讲只有很少数人是想从事科研方向才选择考研的，而大部分人是想利用研究生这个敲门砖走进自己理想工作的大门的，这个目的好吗？当然没错，没有人不想找到好工作，更没有人不想拿到更高的文凭。<br><strong>那么问题就来了！读研后真的能找到更好的工作？我拿一位已经毕业工作多年的华中科技大学的学长的经历跟大家分享一下：</strong></p>
<blockquote>
<p>这位学长自己导师手下毕业的小伙伴共5个，有两个去了某互联网厂做开发，有一个去了某通信厂的销服岗，另外一个也去了某通信厂，不过也是做开发，<strong>有且仅有一个</strong>小伙伴去了某算法研究院继续做图像相关的算法。   </p>
</blockquote>
<p>这段历程表面能看到的就是这样算下来，从事老本行图像相关算法研究的也只有一个，不严谨的计算也就是只有20%的比例。是的20%，并且唯一的20%是作为研究型人才的成神道路。也就是说每个人还是一样在IT基层做起了开发工作，<strong>并且比本科生要晚了3年</strong>。你能想象这三年本科生在这个技术岗上积累了多少东西了吗？面个试就盯你文凭？兄弟醒醒了</p>
<h3 id="鱼与熊掌整一套？"><a href="#鱼与熊掌整一套？" class="headerlink" title="鱼与熊掌整一套？"></a>鱼与熊掌整一套？</h3><p>我现在大二刚刚结业，也拿到了大三的课程信息，当我看见的第一眼便心里暗自发问：C#？What fuck？合着大一C++、大二Java、到了大三又拿起了C#？这是学校带着我们集体摸鱼？大四学什么？Python？学了一年的Java突然来了C语言版的数据结构？所以对于学校课程的安排我心里只能默念我<strong><strong>***</strong></strong>，没办法，学校有学校自己的理由，我们不得不去接受，所以按照学校的步伐我的简历可以怎么写呢：<br>1.了解C++；<br>2.了解Java；<br>3.了解C#；<br>4.了解Python；<br>所以，到底会干嘛？我甚至还没有校外培训班的同学们会的多？学这么多语言还都是了解级别的，我教大家初识变成语言？我不知道考上研之后的课程是怎样的我也不敢多想，所以我想说：<strong>文凭和技术真的不能兼得</strong>（我不否认神级别的大牛能做到，但是不抬杠，仅仅个人想法，Peace）但是作为计算机专业的人来讲，<strong>因为学校不会教你Git SVN Maven Gradle怎么用，不会教你什么是Spring开发框架 什么是Nginx Tomcat Jetty Undertow，什么是中间件缓存技术，什么是Rocket消息队列，什么是RPC框架，什么数据库的链接是Druid，ORM层数据库框架，什么是MyCat分库分表，什么是分布式/微服务熔断降级网关服务调用负载均衡分布式事务链路追踪和监控日志分析容器技术容器排版技术</strong>你说你研究生再学完？那我瑞斯拜！<br><strong>大家都知道，搞开发是一碗青春饭，这碗饭过了青春就某的吃了，中年危机不是危言耸听，大家可以去了解一下很多中年程序员的经历分享你就有答案了。更不容忽略的是，搞开发真的看文凭吗？根据众多领英的人才分享来看，开发真的重点看技术能力，而不是你是不是研究生的学历。</strong></p>
<hr>
<h2 id="考研的难度"><a href="#考研的难度" class="headerlink" title="考研的难度"></a>考研的难度</h2><h3 id="扩招了研究生好考了？"><a href="#扩招了研究生好考了？" class="headerlink" title="扩招了研究生好考了？"></a>扩招了研究生好考了？</h3><p>给数据：<br><img src="https://wx2.sbimg.cn/2020/06/30/2tO1l.jpg" alt="2tO1l.jpg"><br><img src="https://wx1.sbimg.cn/2020/06/30/2tSE1.jpg" alt="2tSE1.jpg"><br>官方数据及预测：</p>
<blockquote>
<p>2019年考研报名人数为290万人，报录比预计为3.6：1，较2018年有明显的提升。<br>2020年考研报名人数再次上涨，共计 341万，特殊原因大幅扩招，报录比为3.4：1，勉强和去年持平。<br>预测：根据今年情况，预测2021年研究生报考人数有望突破400w，但招生人数涨幅应该不会太大。在这一情况下，2021年的考研报录比很可能会飙升至4:1!将创历史新高！</p>
</blockquote>
<h3 id="我不怕？"><a href="#我不怕？" class="headerlink" title="我不怕？"></a>我不怕？</h3><p><strong>你想，你仔细想，你以为你好好肝个一年就能肝考上清北考上华科考上复旦同济了？现在数据流通这么强，很多很多的同学越来越早的准备考研了，甚至于大一就开始了一门心思的考研，所以说这个竞争力一点点都不亚于高考。越早准备读研你就越早将你的赌注放到了这个上面，如果失利，你失去的要比你看到的多得多。具体参考上一章节鱼与熊掌来一套。</strong></p>
<h3 id="二战？三战？"><a href="#二战？三战？" class="headerlink" title="二战？三战？"></a>二战？三战？</h3><p><strong>赌注挺大，直接赌上了一切了，你要考不上清北感觉完全亏了昂，这个时间成本要是会算账的话自己心里悄悄算一下就知道亏了多少了，对于这种情况我只能Good luck！</strong></p>
<h3 id="祝福"><a href="#祝福" class="headerlink" title="祝福"></a>祝福</h3><p><strong>这里也希望正在考研或者准备考研的同学顺利上岸！！</strong><br><img src="https://wx2.sbimg.cn/2020/06/30/2wmoY.jpg" alt="2wmoY.jpg"></p>
<hr>
<h2 id="我到底适不适合读研"><a href="#我到底适不适合读研" class="headerlink" title="我到底适不适合读研"></a>我到底适不适合读研</h2><h3 id="什么样的人适合读研"><a href="#什么样的人适合读研" class="headerlink" title="什么样的人适合读研"></a>什么样的人适合读研</h3><p><strong>首先</strong></p>
<blockquote>
<p>我认为最适合读研的就是热衷于科技研究有着把自己专业深挖创新突破的人，这也是我很尊重的一类人，乐于把精力奉献在科研工作的人都很值得敬仰。</p>
</blockquote>
<p><strong>其次</strong></p>
<blockquote>
<p>你的大学文凭真的阻挡住了你进入理想工作大门的人，比如很多企业要求要985 211 双一流毕业的学生，如果真的是这样好好读个研也是个不错的选择，因为这样你才能跨过门槛离理想更进一步不是？</p>
</blockquote>
<p><strong>再者</strong></p>
<blockquote>
<p>你对更好的院校充满向往，你的生活中心并非在就业，而是期望得到更牛X的文凭，这种也适合继续考研，而且加油吧哈哈</p>
</blockquote>
<p><strong>还有</strong></p>
<blockquote>
<p>你的专业非常需要更高的文凭，比如要硕士博士以上，例如我知道的医学哈哈那么也别犹豫了 继续考吧加油</p>
</blockquote>
<p><strong>最后</strong></p>
<blockquote>
<p>看完本篇blog或者无论是看过怎样的踩坑经验都仍然觉得考研才能找到好工作的，那我就拜拜，加油考</p>
</blockquote>
<h3 id="什么样的人不适合读研"><a href="#什么样的人不适合读研" class="headerlink" title="什么样的人不适合读研"></a>什么样的人不适合读研</h3><p><strong><em>首先要说我绝不会因为考研非易而鼓励大家不去考研！！！</em></strong>   </p>
<p><strong>首先</strong></p>
<blockquote>
<p>我认为厌学的人就最不适合读研了，厌学还要苦苦的逼着自己考研，到头来考个一般院校研究生，或者二战三战的真的没有必要兄弟，尽早的进入社会说不定能找到你热爱的事业</p>
</blockquote>
<p><strong>其次</strong></p>
<blockquote>
<p>如果你和我一样是一个热衷于技术的人那么你是否考研也要三思了，花多年的时间专心搞技术结果不是更好吗</p>
</blockquote>
<p><strong>再者</strong></p>
<blockquote>
<p>如果你和我专业计算机性质一样，都是技术至上的专业，那么我也劝不读研，何必赌这一把呢</p>
</blockquote>
<p><strong>最后</strong></p>
<blockquote>
<p>如果你的家庭真的不太能支撑你读研究生，你的工作能为家庭作出卓越贡献，这样我也劝不读研，读研真的不一定能带给你什么</p>
</blockquote>
<hr>
<h2 id="写在结尾"><a href="#写在结尾" class="headerlink" title="写在结尾"></a>写在结尾</h2><p><strong>本篇blog我也基本阐明了我对于考研的一些浅薄的看法，希望能对大家纠结的问题提供一些解答的思路，我始终觉得，任何决定都是应该三思而后行的，不要被身边的言论所左右，不要被眼前的一些趋势一些现象蒙蔽了双眼，多看一看外面的世界是怎样的，你周围之外的言论又是什么样的？</strong></p>
<blockquote>
<p>再次声明本篇blog仅代表个人看法不希望作为决定标准，还有期间言论如有得罪还望海涵，希望能与你一起成长！瑞斯拜！<br><img src="https://wx2.sbimg.cn/2020/06/30/2wkEV.jpg" alt="2wkEV.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>生活区</category>
      </categories>
      <tags>
        <tag>生活区</tag>
      </tags>
  </entry>
  <entry>
    <title>【置顶】和我的Blog认识一下吧</title>
    <url>/2022/07/03/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E5%92%8C%E6%88%91%E7%9A%84Blog%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%8B%E5%90%A7/</url>
    <content><![CDATA[<p><strong>Hi～欢迎来到小贺同学的blog，如果你不知道怎么来了解它的话先来康康我吧 o‿≖✧</strong></p>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>做这个blog的初心呢是想记录着自己在技术所做出的努力所带来的一些成果，也想用它来激励自己，还有就是想和你们交流啦，自从开始做撸码肥宅之后感觉真的是越来越和大家脱轨了，很多很多的想法想跟你们讲却又苦于如何开口，所以我就把它们都写在了这，希望能与你们共勉。（大家一定要来找我玩  (;´༎ຶД༎ຶ`)  ）还有就是因为我目前对于前端开发语言和框架不太熟悉，所以blog是建立在了前人开发的基础上做起来的，所以很遗憾很多想要实现的功能和想要更换的布置还没办法去完成，在后端开发学习进度不错的情况下将会将会对前端开发进行学习，如果有什么大家希望博客改进/改错的地方或者想要看那些方面的blog内容分享还烦请跟我联系喔～总之希望和大家一起成长～</p>
</blockquote>
<hr>
<h2 id="Blog导航"><a href="#Blog导航" class="headerlink" title="Blog导航"></a>Blog导航</h2><h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><p><img src="https://wx1.sbimg.cn/2020/07/03/2nWck.png" alt="2nWck.png"></p>
<blockquote>
<p>这里是通过索引和分区快速找到你感兴趣的blog的地方，它们的作用是这样</p>
<ol>
<li>首页：如果你不知道现在在哪那就一键首页吧，带你回到最初的这个样子；</li>
<li>分类：这里我目前把学习与生活分成了两个分区，你可以只挑你感兴趣的分区浏览喔；</li>
<li>归档：以时间轴为线整合了所有文章的地方；</li>
<li>搜索：通过关键字快速寻找文章（目前踩坑还未出坑）</li>
</ol>
</blockquote>
<h3 id="信息栏"><a href="#信息栏" class="headerlink" title="信息栏"></a>信息栏</h3><p><img src="https://wx1.sbimg.cn/2020/07/03/2nZVh.png" alt="2nZVh.png"></p>
<blockquote>
<p>点击左下角的菜单小图标将会显示Blog的信息栏，在这里你可以选择从哪里联系我（这个方面还比较鸡肋，后期会更新）还可以听一下我为Blog设定的BGM音乐并且还可以点击最下方的小箭头直接回到网页头部</p>
</blockquote>
<h2 id="分类导航"><a href="#分类导航" class="headerlink" title="分类导航"></a>分类导航</h2><blockquote>
<p>学习区：当然是博客的重头戏啦，我将按照我的Java开发路线进行不断前进，所以写技术博客就是对自己最好的督促了，我希望大家有兴趣的话可以跟着我的路线共勉，另外，大多数博客都是作为我在书籍或者网络上学习后写下来的学习笔记，所以若有不足或者错误之处还请不吝赐教，我也更希望大家可以跟我一起交流相关的开发知识，一起前进啦QAQ</p>
</blockquote>
<blockquote>
<p>生活区：喜欢的影音作品、好的App和实物的安利、对于某些作品及事物的观点看法、觉得不错的书籍推荐等等等等包罗万象的生活区将会是我更新日常的主阵地啦，还请大家多多联系我找我玩哦~。</p>
</blockquote>
<h2 id="文章导航"><a href="#文章导航" class="headerlink" title="文章导航"></a>文章导航</h2><blockquote>
<p>在更新的所有文章中我均设立了对应的目录结构，所以我在文章中对于各级标题都做了严格的梳理，所以既可以完整的阅读文章也可以通过目录结构直接定位到要阅读的部分～</p>
</blockquote>
<h2 id="更新计划"><a href="#更新计划" class="headerlink" title="更新计划"></a>更新计划</h2><p>更新原则（我要日更！！！）   </p>
<blockquote>
<ol>
<li>学习区：是将会在周日-周五每天更新至少一篇学习区的博客文章以督促自己的学习进度，周六将会着重复习和消化本周及之前的文章内容所以将不更新学习区的博客文章；</li>
<li>生活区：这个作为不定时更新的博客栏目所以会在有想分享或者想和大家交流以及当天目标完成比较早的时候（偷懒的时候）更新，更新的形式与篇幅均不确定。</li>
</ol>
</blockquote>
<h2 id="更新预告"><a href="#更新预告" class="headerlink" title="更新预告"></a>更新预告</h2><blockquote>
<p>由于小贺还是个技术萌新，所以Java的开发路线先按照编程基础进行：</p>
</blockquote>
<ul>
<li>目前继续更新JVM的相关内容</li>
<li>接着是并发以及多线程的相关知识</li>
<li>之后是完善数据结构与算法的相关内容</li>
<li>计算机网络这个大块的内容</li>
<li>…(完成后将更新此块内容)</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>【数据结构】(链表的Java实现与经典应用)</title>
    <url>/2020/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(Java%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0)/</url>
    <content><![CDATA[<p><strong>链表作为数据结构的基石,它的出现给很多的方法提供了优化措施,链表是最重要的数据结构之一,在我心里,链表就是数据结构的灵魂，本篇利用数组和内部类两种方式实现了链表的定义和基本方法的实现,当然我最爱内部类的实现形式( `)3’)▃▃▃▅▆▇▉</strong></p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://i.loli.net/2020/06/15/wJlYTC5oxUXtSZM.jpg" alt="IMG_7967.jpg"></p>
<blockquote>
<p>对于Java实现链表将Node作为内部类是个很好的选择，所以这里给出两个Java实现链表的版本，个人比较认同第二种。因为在链表的添加顺序是由右向左，先添加的节点对下一节点的引用可以为空，并且引用是引用下一节点而不是下一节点的对象，因为具有连续引用使得头节点可以操作所有节点，所以需要一个头节点和视情况而定的若干临时节点</p>
</blockquote>
<h2 id="链表的Java实现"><a href="#链表的Java实现" class="headerlink" title="链表的Java实现"></a>链表的Java实现</h2><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">package SqueneList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Sqlist</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span> MAXSIZE;</span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span>[] sqlist;</span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span> length;</span><br><span class="line">	<span class="comment">//用最大数组长度来初始化顺序表</span></span><br><span class="line">	<span class="keyword">public</span> Sqlist(<span class="built_in">int</span> MAXSIZE)&#123;</span><br><span class="line">		<span class="keyword">this</span>.sqlist = new <span class="built_in">int</span>[MAXSIZE];</span><br><span class="line">		<span class="keyword">this</span>.MAXSIZE=MAXSIZE;</span><br><span class="line">		<span class="keyword">this</span>.length=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//用数组来初始化顺序表</span></span><br><span class="line">	<span class="keyword">public</span> Sqlist(<span class="built_in">int</span>[] arr) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">			sqlist[i] = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.length = arr.length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对由数组实现的顺序表进行扩充</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> expandList()&#123;</span><br><span class="line">	    <span class="built_in">int</span>[] newarr = new <span class="built_in">int</span>[arr.length*<span class="number">2</span>]</span><br><span class="line">	    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">	        newarr[i]=arr[i]</span><br><span class="line">	    &#125;</span><br><span class="line">	    arr = newarr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//向顺序表指定位置插入元素</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> listInsert(<span class="built_in">int</span> i, <span class="built_in">int</span> e) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>) &#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"非法插入位置"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.length == <span class="keyword">this</span>.MAXSIZE) &#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"顺序表已满"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> k=length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--) &#123;</span><br><span class="line">			sqlist[k+<span class="number">1</span>]=sqlist[k];  <span class="comment">//数组中插入位置及其后的元素均向后移动一位</span></span><br><span class="line">		&#125;</span><br><span class="line">		sqlist[i<span class="number">-1</span>]=e;  <span class="comment">//将制定元素插入此位置</span></span><br><span class="line">		<span class="keyword">this</span>.length++;  <span class="comment">//插入后的顺序表长度+1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//清空顺序表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> listClear() &#123;</span><br><span class="line">		<span class="keyword">this</span>.length = <span class="number">0</span>;  <span class="comment">//仅用来判断是否为空，直接将长度设置为0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断顺序表是否为空</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">bool</span>ean isEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.length==<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取指定位置的顺序表元素</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">int</span> getElem(<span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;length)</span><br><span class="line">		&#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"获取位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sqlist[i<span class="number">-1</span>];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取制定元素的位置信息</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> getIndex(<span class="built_in">int</span> e, <span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;=length<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(sqlist[j]==e) &#123;</span><br><span class="line">				i=j++;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"顺序表中无对应元素"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印顺序表</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">void</span> printList() &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;=length<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">int</span> t=i+<span class="number">1</span>;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"第"</span>+t+<span class="string">"个元素为"</span>+sqlist[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除顺序表指定位置的元素</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">int</span> listDelete(<span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;length)</span><br><span class="line">		&#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"删除位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=i;j&lt;=length<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sqlist[j<span class="number">-1</span>]=sqlist[j];</span><br><span class="line">		&#125;</span><br><span class="line">		length--;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">		Sqlist sqlist = new Sqlist(<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			sqlist.listInsert(i, i);</span><br><span class="line">		&#125;</span><br><span class="line">		printList();</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"第3个元素为"</span>+getElem(<span class="number">3</span>));</span><br><span class="line">		listDelete(<span class="number">2</span>);</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"删除第二个元素后的顺序表的内容为："</span>);</span><br><span class="line">		printList();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> SqueneList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Linklist &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> Node head = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//使用内部类来作为普通结点，这样就只有头结点可以操作其他节点</span></span><br><span class="line">	<span class="keyword">class</span> Node&#123;</span><br><span class="line">		Node <span class="keyword">next</span>=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">int</span> data;</span><br><span class="line">		<span class="keyword">public</span> Node(<span class="keyword">int</span> data) &#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取单链表的长度</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> getLength() &#123;</span><br><span class="line">		<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">		Node temp = head;</span><br><span class="line">		<span class="keyword">while</span>(temp.<span class="keyword">next</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			length++;</span><br><span class="line">			temp = temp.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//单链表的增加</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> addNode(<span class="keyword">int</span> d) &#123;</span><br><span class="line">		Node newnode = <span class="keyword">new</span> Node(d);</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			head = newnode;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node temp = head;  <span class="comment">//临时结点</span></span><br><span class="line">		<span class="keyword">while</span>(temp.<span class="keyword">next</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">			temp = temp.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp.<span class="keyword">next</span> = newnode;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">//删除指定位置的结点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> deleteNode(<span class="keyword">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;getLength()) &#123;</span><br><span class="line">			System.out.<span class="keyword">println</span>(<span class="string">"删除位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) &#123;</span><br><span class="line">			head = head.<span class="keyword">next</span>;  <span class="comment">//若删除第一个结点则直接删去头结点即可</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">1</span>;</span><br><span class="line">		Node pre = head;  <span class="comment">//定义两个临时结点分别为前驱结点与后继结点</span></span><br><span class="line">		Node cur = pre.<span class="keyword">next</span>;</span><br><span class="line">		<span class="keyword">while</span>(cur!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(index == i-<span class="number">1</span>) &#123;</span><br><span class="line">				pre.<span class="keyword">next</span> = cur.<span class="keyword">next</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			pre = cur;</span><br><span class="line">			cur = cur.<span class="keyword">next</span>;</span><br><span class="line">			index++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印单链表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> printLinkList() &#123;</span><br><span class="line">		Node temp = head;</span><br><span class="line">		<span class="keyword">while</span>(temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.<span class="keyword">println</span>(temp.data);</span><br><span class="line">			temp = temp.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表的经典应用1:反转</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node reverseList(Node head) &#123;</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">		Node pre = head;</span><br><span class="line">		Node cur = head.<span class="keyword">next</span>;</span><br><span class="line">		Node tmp;</span><br><span class="line">		<span class="keyword">while</span>(cur!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			tmp = cur.<span class="keyword">next</span>;</span><br><span class="line">			cur.<span class="keyword">next</span> = pre;</span><br><span class="line">			pre = cur;</span><br><span class="line">			cur = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		head.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">return</span> pre;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表的经典应用2:查找单链表的中间节点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> searchMid() &#123;  <span class="comment">//这里对单链表中间位置查找使用的是快慢指针法</span></span><br><span class="line">		Node f = head;               <span class="comment">//即：快的指针一次走两个慢的指针一次走一个，快的指针到达</span></span><br><span class="line">		Node s = head;               <span class="comment">//表尾时慢指针刚好走到表中</span></span><br><span class="line">		<span class="keyword">while</span>(f!=<span class="keyword">null</span>&amp;&amp;f.<span class="keyword">next</span>!=<span class="keyword">null</span>&amp;&amp;f.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			f = f.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">			s = s.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s.data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表的经典应用2:删除单链表中倒数第k个节点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node searchElem(<span class="keyword">int</span> k) &#123;</span><br><span class="line">		<span class="keyword">if</span>(k&gt;getLength()||k&lt;<span class="number">1</span>) &#123;</span><br><span class="line">			System.out.<span class="keyword">println</span>(<span class="string">"删除位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node pf = head;</span><br><span class="line">		Node ps = head;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">			pf = pf.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(pf!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			pf = pf.<span class="keyword">next</span>;</span><br><span class="line">			ps = ps.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ps;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对链表进行排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node sortList() &#123;</span><br><span class="line">		Node nextNode = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">		Node curNode = head;</span><br><span class="line">		<span class="keyword">while</span>(curNode.<span class="keyword">next</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			nextNode = curNode.<span class="keyword">next</span>;</span><br><span class="line">			<span class="keyword">while</span>(nextNode!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(curNode.data&gt;nextNode.data) &#123;</span><br><span class="line">					temp = curNode.data;</span><br><span class="line">					curNode.data = nextNode.data;</span><br><span class="line">					nextNode.data = temp;</span><br><span class="line">				&#125;</span><br><span class="line">				nextNode = nextNode.<span class="keyword">next</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			curNode = curNode.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除链表中重复的节点就用简单的遍历方法 如果数据相同则p.next = p.next.next跳过就可以了</span></span><br><span class="line">	<span class="comment">//用递归的方法输出链表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> diGuiPrint(Node head) &#123;</span><br><span class="line">		<span class="keyword">if</span>(head!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			diGuiPrint(head.<span class="keyword">next</span>);</span><br><span class="line">			System.out.<span class="keyword">println</span>(<span class="string">"采用递归的方式输出链表："</span>+head.data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">		Linklist linklist = <span class="keyword">new</span> Linklist();</span><br><span class="line">		linklist.addNode(<span class="number">1</span>);</span><br><span class="line">		linklist.addNode(<span class="number">2</span>);</span><br><span class="line">		linklist.addNode(<span class="number">3</span>);</span><br><span class="line">		linklist.addNode(<span class="number">4</span>);</span><br><span class="line">		printLinkList();</span><br><span class="line">		deleteNode(<span class="number">2</span>);</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"删除第二个结点后的单链表为："</span>);</span><br><span class="line">		printLinkList();</span><br><span class="line">		head = reverseList(head);</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"单链表反转后变为："</span>);</span><br><span class="line">		printLinkList();</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"中间节点的数据为"</span>+searchMid());</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"倒数第2个节点的数据为"</span>+searchElem(<span class="number">2</span>).data);</span><br><span class="line">		sortList();</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"排序后的链表数据为:"</span>);</span><br><span class="line">		printLinkList();</span><br><span class="line">		diGuiPrint(head);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】(二叉树的Java与C++实现)</title>
    <url>/2020/06/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84Java%E4%B8%8EC++%E5%AE%9E%E7%8E%B0)/</url>
    <content><![CDATA[<p><strong>二叉树作为重要的数据结构类型,本篇二叉树内部方法的实现多采用了递归,实现了诸如(四种遍历\结点删除\结点查找\叶子数量\高度\判断是否完全二叉树\某层结点数)等方法,是值得一读的二叉树的实现 ʅ(‾◡◝)ʃ</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>树结构的知识点比较复杂，在本篇中学习了很多Java用递归方式编写的函数体，值得一读。惰性删除是指当一个元素要被删除时，它仍被保留在树中，只是标记为删除了，这在有重复项的时候很常用，因为此时记录出现频率数的域可以减1，如果树中的实际节点数与“被删除”的节点数相同，那么树的深度预计只上升一个小的常数，因此存在一个与惰性删除相关的非常小的时间损耗，并且，如果被删除的项是重新插入的，那么久避免了分配一个新单元的开销了<br><img src="https://i.loli.net/2020/06/19/jkItJpTGE4qhO2u.jpg" alt="IMG_6581.jpg">   </p>
</blockquote>
<h2 id="二叉树的Java实现"><a href="#二叉树的Java实现" class="headerlink" title="二叉树的Java实现"></a>二叉树的Java实现</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package BinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> BiTree&#123;</span><br><span class="line"></span><br><span class="line">	private <span class="type">int</span> count;</span><br><span class="line">	private Node root;</span><br><span class="line">	<span class="built_in">public</span> <span class="type">int</span> <span class="keyword">index</span>;</span><br><span class="line">	<span class="keyword">class</span> Node &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">public</span> Node lchild;</span><br><span class="line">		<span class="built_in">public</span> Node rchild;</span><br><span class="line">		<span class="built_in">public</span> <span class="type">int</span> data;</span><br><span class="line">		<span class="built_in">public</span> Node(<span class="type">int</span> data) &#123;</span><br><span class="line">			this.data = data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> Node getLchild() &#123;</span><br><span class="line">			<span class="keyword">return</span> lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> <span class="type">void</span> setLchild(Node lchild) &#123;</span><br><span class="line">			this.lchild = lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> Node getRchild() &#123;</span><br><span class="line">			<span class="keyword">return</span> rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> <span class="type">void</span> setRchild(Node rchild) &#123;</span><br><span class="line">			this.rchild = rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> <span class="type">int</span> getData() &#123;</span><br><span class="line">			<span class="keyword">return</span> data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> <span class="type">void</span> setData(<span class="type">int</span> data) &#123;</span><br><span class="line">			this.data = data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//二叉树的建立</span><br><span class="line">	<span class="built_in">public</span> Node CreateBTree(<span class="type">int</span>[] a)&#123;</span><br><span class="line">		Node root = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[<span class="keyword">index</span>]!=<span class="string">'#'</span>)&#123;</span><br><span class="line">			root = <span class="built_in">new</span> Node(a[<span class="keyword">index</span>]);</span><br><span class="line">			<span class="keyword">index</span>++;</span><br><span class="line">			root.setLchild(CreateBTree(a));</span><br><span class="line">			<span class="keyword">index</span>++;</span><br><span class="line">			root.setRchild(CreateBTree(a));		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	//二叉树节点的删除</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> <span class="keyword">delete</span>(<span class="type">int</span> data) &#123;</span><br><span class="line">		Node <span class="keyword">current</span> = root;</span><br><span class="line">		Node parent = root;</span><br><span class="line">		<span class="type">boolean</span> isleftchild = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>.data!=data) &#123;</span><br><span class="line">			parent = <span class="keyword">current</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">current</span>.data&gt;data) &#123;</span><br><span class="line">				isleftchild = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">current</span> = <span class="keyword">current</span>.lchild;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				isleftchild = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">current</span> = <span class="keyword">current</span>.rchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">current</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//被删除的节点没有子节点</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">current</span>.lchild==<span class="keyword">null</span> &amp;&amp;<span class="keyword">current</span>.rchild==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">current</span>==root) &#123;</span><br><span class="line">				root = <span class="keyword">null</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(isleftchild) &#123;</span><br><span class="line">				parent.lchild = <span class="keyword">null</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				parent.rchild = <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		//被删除的节点有一个子节点</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">current</span>.lchild==<span class="keyword">null</span>&amp;&amp;<span class="keyword">current</span>.rchild!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(root == <span class="keyword">current</span>) &#123;</span><br><span class="line">				root = <span class="keyword">current</span>.rchild;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(isleftchild) &#123;</span><br><span class="line">				parent.lchild = <span class="keyword">current</span>.rchild;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				parent.rchild = <span class="keyword">current</span>.rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">current</span>.lchild!=<span class="keyword">null</span>&amp;&amp;<span class="keyword">current</span>.rchild==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(root == <span class="keyword">current</span>) &#123;</span><br><span class="line">				root = <span class="keyword">current</span>.lchild;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(isleftchild) &#123;</span><br><span class="line">				parent.lchild = <span class="keyword">current</span>.lchild;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				parent.rchild = <span class="keyword">current</span>.lchild;</span><br><span class="line">		    &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">		//被删除的节点有两个子节点</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">current</span>.lchild != <span class="keyword">null</span> &amp;&amp; <span class="keyword">current</span>.rchild != <span class="keyword">null</span>)&#123;</span><br><span class="line">            //获取删除节点的后继结点</span><br><span class="line">            Node successor = getSuccessor(<span class="keyword">current</span>);</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">current</span>) &#123;</span><br><span class="line">                root = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isleftchild) &#123;</span><br><span class="line">                parent.lchild = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.rchild = successor;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">public</span> Node getSuccessor(Node delNode) &#123;</span><br><span class="line">        Node successorParent = delNode;</span><br><span class="line">        Node successor = delNode;</span><br><span class="line">        Node <span class="keyword">current</span> = delNode.rchild;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">current</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">            successorParent = successor;</span><br><span class="line">            successor = <span class="keyword">current</span>;</span><br><span class="line">            <span class="keyword">current</span> = <span class="keyword">current</span>.lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (successor != delNode.rchild) &#123;</span><br><span class="line">            successorParent.lchild = successor.rchild;</span><br><span class="line">            successor.rchild = delNode.rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">    //先序遍历</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> prevOrder(Node root) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">System</span>.<span class="keyword">out</span>.print(root.getData()+" ");</span><br><span class="line">    	prevOrder(root.getLchild());</span><br><span class="line">    	prevOrder(root.getRchild());</span><br><span class="line">    &#125;</span><br><span class="line">    //中序遍历</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> inOrder(Node root) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	inOrder(root.getLchild());</span><br><span class="line">    	<span class="keyword">System</span>.<span class="keyword">out</span>.print(root.getData()+" ");</span><br><span class="line">    	inOrder(root.getRchild());</span><br><span class="line">    &#125;</span><br><span class="line">    //后序遍历</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> postOrder(Node root) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	postOrder(root.getLchild());</span><br><span class="line">    	postOrder(root.getRchild());</span><br><span class="line">    	<span class="keyword">System</span>.<span class="keyword">out</span>.print(root.getData()+" ");</span><br><span class="line">    &#125;</span><br><span class="line">    //层序遍历</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> BTreeLevelOrder()&#123;</span><br><span class="line">    	Node root = this.root;</span><br><span class="line">    	Queue &lt;Node&gt; queue = <span class="built_in">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    	LinkedList&lt;Node&gt; list = <span class="built_in">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    	queue.offer(root);</span><br><span class="line">    	<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">    		Node pre = queue.poll();</span><br><span class="line">    		list.<span class="keyword">add</span>(pre);</span><br><span class="line">    		<span class="keyword">if</span>(pre.getLchild()!=<span class="keyword">null</span>)</span><br><span class="line">    			queue.offer(pre.getLchild());</span><br><span class="line">    		<span class="keyword">if</span>(pre.getRchild()!=<span class="keyword">null</span>)</span><br><span class="line">    			queue.offer(pre.getRchild());</span><br><span class="line">    	&#125;</span><br><span class="line">    	Iterator&lt;Node&gt; it = list.iterator();</span><br><span class="line">    	<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    		Node cur = (Node)it.next();</span><br><span class="line">    		<span class="keyword">System</span>.<span class="keyword">out</span>.print(cur.getData()+" ");</span><br><span class="line">    	&#125;	</span><br><span class="line">    &#125;</span><br><span class="line">    //获得二叉树的高度</span><br><span class="line">  	<span class="built_in">public</span> <span class="type">int</span> getHeight(Node root)&#123;</span><br><span class="line">  		//递归获取</span><br><span class="line">  		<span class="type">int</span> leftHeight = <span class="number">0</span>;</span><br><span class="line">  		<span class="type">int</span> rightHeight = <span class="number">0</span>;</span><br><span class="line">  		<span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">  			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  			leftHeight = getHeight(root.getLchild());</span><br><span class="line">  			rightHeight = getHeight(root.getRchild());</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">return</span> leftHeight &gt;= rightHeight ? ++leftHeight:++rightHeight; //最终高度应是左右子树高度中最大的一个</span><br><span class="line">  	&#125;</span><br><span class="line">  	//获得二叉树的叶子结点</span><br><span class="line">  	<span class="built_in">public</span> <span class="type">int</span> getLeaf(Node root) &#123;</span><br><span class="line">  		<span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.getLchild()==<span class="keyword">null</span>&amp;&amp;root.getRchild()==<span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">System</span>.<span class="keyword">out</span>.println("叶子结点："+root.getData());</span><br><span class="line">  			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">return</span> getLeaf(root.getLchild())+getLeaf(root.getRchild());</span><br><span class="line">  	&#125;</span><br><span class="line">  	//获得二叉树某一层的节点</span><br><span class="line">  	<span class="built_in">public</span> <span class="type">int</span> getNum(Node root, <span class="type">int</span> deep) &#123;</span><br><span class="line">  		<span class="keyword">if</span>(deep == <span class="number">1</span>) &#123;</span><br><span class="line">  			<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">  				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  				<span class="keyword">System</span>.<span class="keyword">out</span>.println("结点："+root.getData());</span><br><span class="line">  				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">return</span> getNum(root.getLchild(), deep<span class="number">-1</span>)+getNum(root.getRchild(), deep<span class="number">-1</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">  	//查找某一值结点</span><br><span class="line">  	<span class="built_in">public</span> Node <span class="keyword">search</span>(Node root, <span class="type">int</span> key) &#123;</span><br><span class="line">  		<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.getData()==key) &#123;</span><br><span class="line">  			<span class="keyword">return</span> root;</span><br><span class="line">  		&#125;</span><br><span class="line">  		Node left = <span class="keyword">search</span>(root.getLchild(), key);</span><br><span class="line">  		<span class="keyword">if</span>(left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">return</span> left;</span><br><span class="line">  		&#125;</span><br><span class="line">  		Node right = <span class="keyword">search</span>(root.getRchild(), key);</span><br><span class="line">  		<span class="keyword">if</span>(right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">return</span> right;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">    //判断某一结点是否存在</span><br><span class="line">  	<span class="built_in">public</span> <span class="type">boolean</span> <span class="keyword">isNull</span>(Node root) &#123;</span><br><span class="line">  		<span class="keyword">return</span> root!=<span class="keyword">null</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">    //判断一棵树是否是完全二叉树</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> isCompleteBTree()&#123;</span><br><span class="line">		Node root = this.root;</span><br><span class="line">		Queue &lt;Node&gt; queue = <span class="built_in">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">		queue.offer(root);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">			Node pre = queue.poll();</span><br><span class="line">			<span class="keyword">if</span>(pre==<span class="keyword">null</span>)</span><br><span class="line">				break;</span><br><span class="line">			queue.offer(pre.getLchild());</span><br><span class="line">			queue.offer(pre.getRchild());</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">			Node cur = queue.poll();</span><br><span class="line">			<span class="keyword">if</span>(cur!=<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">		BiTree tree = <span class="built_in">new</span> BiTree();</span><br><span class="line">		<span class="type">int</span>[] a = <span class="built_in">new</span> <span class="type">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="string">'#'</span>,<span class="number">3</span>,<span class="string">'#'</span>,<span class="number">4</span>,<span class="string">'#'</span>,<span class="string">'#'</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">'#'</span>,<span class="string">'#'</span>,<span class="string">'#'</span> &#125;;</span><br><span class="line">		tree.root = tree.CreateBTree(a);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("先序遍历：");</span><br><span class="line">		tree.prevOrder(tree.root);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("中序遍历：");</span><br><span class="line">		tree.inOrder(tree.root);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("后序遍历：");</span><br><span class="line">		tree.postOrder(tree.root);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("层序遍历：");</span><br><span class="line">		tree.BTreeLevelOrder();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("此二叉树的高度为："+tree.getHeight(tree.root));</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("此二叉树的叶子结点数："+tree.getLeaf(tree.root));</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("第二层的结点树为："+tree.getNum(tree.root, <span class="number">2</span>));</span><br><span class="line">		Node <span class="keyword">order</span> =tree.<span class="keyword">search</span>(tree.root, <span class="number">6</span>);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("查找值为6的结点是否存在："+tree.<span class="keyword">isNull</span>(<span class="keyword">order</span>));</span><br><span class="line">		Node order1 = tree.<span class="keyword">search</span>(tree.root, <span class="number">7</span>);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("查找值为7的结点是否存在："+tree.<span class="keyword">isNull</span>(order1));</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("这是一棵完全二叉树吗："+tree.isCompleteBTree());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的C-实现"><a href="#二叉树的C-实现" class="headerlink" title="二叉树的C++实现"></a>二叉树的C++实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> elemtype;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//二叉树的存储结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    elemtype data;</span><br><span class="line">    bitree *lchild,*rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//建立二叉树</span></span><br><span class="line"><span class="function">bitree* <span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitree *root,*s,*q[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> front=<span class="number">1</span>,rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入结点值，（‘ # ’结束）"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">while</span>(ch!=<span class="string">'#'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch!=<span class="string">','</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s=<span class="keyword">new</span> bitree;</span><br><span class="line">            s-&gt;data=ch;</span><br><span class="line">            s-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">            s-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;</span><br><span class="line">        q[rear]=s; <span class="comment">// 进队</span></span><br><span class="line">        <span class="keyword">if</span>(rear==<span class="number">1</span>)</span><br><span class="line">        root=s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>((s!=<span class="literal">NULL</span>)&amp;&amp;(q[front]!=<span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(rear%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            q[front]-&gt;lchild=s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q[front]-&gt;rchild=s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rear%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            front++; <span class="comment">// 出队</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(bitree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitree *p;</span><br><span class="line">    p=root;</span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        preorder(p-&gt;lchild);</span><br><span class="line">        preorder(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(bitree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitree *p;</span><br><span class="line">    p=root;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inorder(p-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        inorder(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(bitree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitree *p;</span><br><span class="line">    p=root;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postorder(p-&gt;lchild);</span><br><span class="line">        postorder(p-&gt;rchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求二叉树中叶子结点的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(bitree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!T-&gt;lchild&amp;&amp;!T-&gt;rchild)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">(bitree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> L,R;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		L=Height(root-&gt;lchild);</span><br><span class="line">		R=Height(root-&gt;rchild);</span><br><span class="line">		<span class="keyword">return</span> (L&gt;R)?L+<span class="number">1</span>:R+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitree *root;</span><br><span class="line">    <span class="keyword">int</span> leaf;</span><br><span class="line">    root=create();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"各种遍历方式对应的遍历结果："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"先序遍历的结果："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    preorder(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"中序遍历的结果："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"后序遍历的结果："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    postorder(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"树的叶子结点个数为："</span>&lt;&lt;LeafCount(root)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"树的高度为："</span>&lt;&lt;Height(root)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】(图的两种Java实现与经典应用)</title>
    <url>/2020/06/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%9B%BE%E7%9A%84%E4%B8%A4%E7%A7%8DJava%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8)/</url>
    <content><![CDATA[<p><strong>图已经是数据机构基础中最复杂的结构,它几乎涵盖了前面所有的基础数据结构,本篇涉及到了图的两种构造方式(邻接矩阵和邻接表),以及对应的深度优先遍历/广度优先遍历/Dijkstra/最小生成树/等方法,很多的方法代码复杂难以理解,共勉(●’◡’●)ﾉ♥</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>我们将会遇到的应用使用几乎都是稀疏图——《算法第四版》   </p>
</blockquote>
<blockquote>
<p>邻接矩阵的处理思路是将顶点和关系分别保存到一个一维数组和一个二维数组中。但是，即使我们保存的是int型数据，一旦数据量达到10万。那么这个数组需要使用的内存空间为：100000 * 100000 * 4Byte = 40GB 所以在这个时候邻接表的优势就很明显了.<br><img src="https://i.loli.net/2020/06/27/eXIdZO6mMg1CNt3.jpg" alt="IMG_5716.jpg"></p>
</blockquote>
<h3 id="邻接矩阵表示图"><a href="#邻接矩阵表示图" class="headerlink" title="邻接矩阵表示图"></a>邻接矩阵表示图</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> VERTEX_MAX = <span class="number">10</span>;  <span class="comment">//最大结点数</span></span><br><span class="line">	Vertex[] vertex;  <span class="comment">//结点</span></span><br><span class="line">	<span class="keyword">int</span> num; <span class="comment">//目前的结点数</span></span><br><span class="line">	<span class="keyword">int</span> [][] adjacency;  <span class="comment">//临街矩阵</span></span><br><span class="line">	<span class="comment">//内部类表示结点</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>&#123;</span>  </span><br><span class="line">		<span class="keyword">char</span> content;</span><br><span class="line">		<span class="keyword">boolean</span> isSearch;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(<span class="keyword">char</span> content)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.content = content;</span><br><span class="line">			<span class="keyword">this</span>.isSearch = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//内部类表示栈</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> STACK_MAX = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">stack</span>[];</span><br><span class="line">		<span class="keyword">int</span> top;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">stack</span> = <span class="keyword">new</span> <span class="keyword">int</span>[STACK_MAX];</span><br><span class="line">			top = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(top==<span class="number">9</span>) &#123;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="string">"栈已满，无法入栈啦"</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">stack</span>[++top]=content;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(top==<span class="number">-1</span>) &#123;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="string">"栈已空，无法出栈啦"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">stack</span>[top--];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">stack</span>[top];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> top==<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> QUEUE_MAX = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> [] <span class="built_in">queue</span>;</span><br><span class="line">		<span class="keyword">int</span> front;</span><br><span class="line">		<span class="keyword">int</span> rear;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">queue</span> = <span class="keyword">new</span> <span class="keyword">int</span>[QUEUE_MAX];</span><br><span class="line">			front = <span class="number">0</span>;</span><br><span class="line">			rear = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(rear==QUEUE_MAX) &#123;</span><br><span class="line">				rear=<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">queue</span>[++rear]=content;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(front==QUEUE_MAX) &#123;</span><br><span class="line">				front=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> temp = <span class="built_in">queue</span>[front++];</span><br><span class="line">			<span class="keyword">return</span> temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (rear+<span class="number">1</span>==front || front+QUEUE_MAX<span class="number">-1</span>==rear);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化图</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>.vertex = <span class="keyword">new</span> Vertex[VERTEX_MAX];</span><br><span class="line">		<span class="keyword">this</span>.adjacency = <span class="keyword">new</span> <span class="keyword">int</span>[VERTEX_MAX][VERTEX_MAX];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;VERTEX_MAX;i++) &#123;  <span class="comment">//邻接矩阵的初始化 所有的结点都没有被访问过</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;VERTEX_MAX;j++) &#123;</span><br><span class="line">				adjacency[i][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//添加结点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addVertex</span><span class="params">(<span class="keyword">char</span> content)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num&lt;VERTEX_MAX<span class="number">-1</span>) &#123;</span><br><span class="line">			vertex[num++] = <span class="keyword">new</span> Vertex(content);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"图已满最大结点，不可以再添加结点了喔～"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//无向图添加边</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNAdj</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(start&lt;VERTEX_MAX &amp;&amp; <span class="built_in">end</span>&lt;VERTEX_MAX) &#123;</span><br><span class="line">			adjacency[start][<span class="built_in">end</span>] =  <span class="number">1</span>;</span><br><span class="line">			adjacency[<span class="built_in">end</span>][start] = <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"连接的图结点位置不合法，无法连接～"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有向图添加边</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addYAdj</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(start&lt;VERTEX_MAX &amp;&amp; <span class="built_in">end</span>&lt;VERTEX_MAX) &#123;</span><br><span class="line">			adjacency[start][<span class="built_in">end</span>] = <span class="number">-1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"连接的图结点位置不合法，无法连接～"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印图中的某个结点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printVertex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(index&gt;=<span class="number">0</span> &amp;&amp; index&lt;VERTEX_MAX) &#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(<span class="keyword">this</span>.vertex[index].content);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"打印结点位置不合法，无法打印～"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印邻接矩阵</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAdjacency</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(j!=num<span class="number">-1</span>) &#123;</span><br><span class="line">					System.out.<span class="built_in">print</span>(adjacency[i][j]+<span class="string">" "</span>);</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					System.out.<span class="built_in">println</span>(adjacency[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//寻找某一结点的未被访问的邻接点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchUnsearchVertex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(adjacency[i][index]==<span class="number">1</span> &amp;&amp; vertex[i].isSearch==<span class="literal">false</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//图的深度优先遍历 Depth-first traversal</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dpt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Stack <span class="built_in">stack</span> = <span class="keyword">new</span> Stack();</span><br><span class="line">		vertex[<span class="number">0</span>].isSearch = <span class="literal">true</span>;</span><br><span class="line">		printVertex(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> index = searchUnsearchVertex(<span class="built_in">stack</span>.<span class="built_in">peek</span>());</span><br><span class="line">			<span class="keyword">if</span>(index==<span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="built_in">stack</span>.pop();</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				vertex[index].isSearch = <span class="literal">true</span>;</span><br><span class="line">				printVertex(index);</span><br><span class="line">				<span class="built_in">stack</span>.push(index);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//遍历结束后将原图返回初始值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">			vertex[i].isSearch=<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//图的广度优先遍历 Breadth-first traversal</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bpt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Queue <span class="built_in">queue</span> = <span class="keyword">new</span> Queue();</span><br><span class="line">		vertex[<span class="number">0</span>].isSearch = <span class="literal">true</span>;</span><br><span class="line">		printVertex(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">queue</span>.insert(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> v1 = <span class="built_in">queue</span>.<span class="built_in">remove</span>();</span><br><span class="line">			<span class="keyword">int</span> v2 = searchUnsearchVertex(v1); </span><br><span class="line">			<span class="keyword">if</span>(v2!=<span class="number">-1</span>) &#123;</span><br><span class="line">				vertex[v2].isSearch = <span class="literal">true</span>;</span><br><span class="line">				printVertex(v2);</span><br><span class="line">				<span class="built_in">queue</span>.insert(v2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">			vertex[i].isSearch = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最小生成树 Minimum spanning tree</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Stack <span class="built_in">stack</span> = <span class="keyword">new</span> Stack();</span><br><span class="line">		vertex[<span class="number">0</span>].isSearch = <span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> cur = <span class="built_in">stack</span>.<span class="built_in">peek</span>();</span><br><span class="line">			<span class="keyword">int</span> index = searchUnsearchVertex(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(index == <span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="built_in">stack</span>.pop();</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				vertex[index].isSearch = <span class="literal">true</span>;</span><br><span class="line">				<span class="built_in">stack</span>.push(index);</span><br><span class="line">				printVertex(cur);</span><br><span class="line">				printVertex(index);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">			vertex[i].isSearch = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		Graph graph = <span class="keyword">new</span> Graph();</span><br><span class="line">		graph.addVertex(<span class="string">'F'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'O'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'R'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'E'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'V'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'E'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'R'</span>);</span><br><span class="line">		graph.addNAdj(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">		graph.addNAdj(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">		graph.addNAdj(<span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">		graph.addNAdj(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">		graph.addNAdj(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">		graph.printAdjacency();</span><br><span class="line">		graph.printVertex(<span class="number">3</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"深度优先遍历："</span>);</span><br><span class="line">		graph.dpt();</span><br><span class="line">		System.out.<span class="built_in">println</span>();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"广度优先遍历："</span>);</span><br><span class="line">		graph.bpt();</span><br><span class="line">		System.out.<span class="built_in">println</span>();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"最小生成树："</span>);</span><br><span class="line">		graph.mst();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="邻接表的对应实现"><a href="#邻接表的对应实现" class="headerlink" title="邻接表的对应实现"></a>邻接表的对应实现</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package Graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.<span class="keyword">Array</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> GraphAdj&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">	VNode&lt;E&gt;[] vers; //用来存储图的结点</span><br><span class="line">	<span class="type">int</span> max_size; //图的最大结点数量</span><br><span class="line">	<span class="type">int</span> numofvers; //图的当前结点数量</span><br><span class="line">	//邻接表建立图的结点</span><br><span class="line">	<span class="keyword">class</span> VNode&lt;E&gt;&#123;</span><br><span class="line">		E data; //存储定点数据</span><br><span class="line">		LNode first; //结点的邻接表的第一个结点</span><br><span class="line">		<span class="type">boolean</span> isvisited = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//邻接表建立图的邻接表的结点</span><br><span class="line">	<span class="keyword">class</span> LNode&#123;</span><br><span class="line">		<span class="type">int</span> weight; //存储权值</span><br><span class="line">		<span class="type">int</span> firstadj; //邻接表结点的序号</span><br><span class="line">		LNode nextvex; //下一个邻接结点</span><br><span class="line">		<span class="built_in">public</span> LNode(<span class="type">int</span> weight, <span class="type">int</span> firstadj) &#123;</span><br><span class="line">			this.weight = weight;</span><br><span class="line">			this.firstadj = firstadj;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//邻接表建立图的初始化</span><br><span class="line">	<span class="built_in">public</span> GraphAdj(<span class="type">int</span> max_size) &#123;</span><br><span class="line">		this.max_size = max_size;</span><br><span class="line">		vers = (VNode[])<span class="keyword">Array</span>.newInstance(VNode.<span class="keyword">class</span>, max_size);</span><br><span class="line">	&#125;</span><br><span class="line">	//获取图结点的树木</span><br><span class="line">	<span class="built_in">public</span> <span class="type">int</span> getNumOfGraph() &#123;</span><br><span class="line">		<span class="keyword">return</span> numofvers;</span><br><span class="line">	&#125;</span><br><span class="line">	//向图中插入结点</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> <span class="keyword">insert</span>(E e) &#123;</span><br><span class="line">		<span class="keyword">if</span>(numofvers&gt;=max_size) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		VNode&lt;E&gt; ver = <span class="built_in">new</span> VNode&lt;E&gt;();</span><br><span class="line">		ver.data = e;</span><br><span class="line">		vers[numofvers++] = ver;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取某结点的位置</span><br><span class="line">	<span class="built_in">public</span> <span class="type">int</span> getIndex(E e) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numofvers;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vers[i].data == e) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取指定位置的结点</span><br><span class="line">	<span class="built_in">public</span> E gerData(<span class="type">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">index</span>&lt;<span class="number">0</span> || <span class="keyword">index</span>&gt;=numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> vers[<span class="keyword">index</span>].data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//向图中插入边</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> insertEdg(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v1&lt;<span class="number">0</span> || v2&lt;<span class="number">0</span> || v1&gt;=numofvers || v2&gt;=numofvers) &#123; //合法性判断</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LNode vers1 = <span class="built_in">new</span> LNode(v2, weight);</span><br><span class="line">		LNode vers2 = <span class="built_in">new</span> LNode(v1, weight);</span><br><span class="line">		//当v1结点没有邻接结点时</span><br><span class="line">		<span class="keyword">if</span>(vers[v1].first==<span class="keyword">null</span>) &#123;</span><br><span class="line">			vers[v1].first=vers1;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;//当v1结点有邻接结点时</span><br><span class="line">			vers1.nextvex = vers[v1].first;</span><br><span class="line">			vers[v1].first = vers1;</span><br><span class="line">		&#125;</span><br><span class="line">		//当v2结点没有邻接结点时</span><br><span class="line">		<span class="keyword">if</span>(vers[v2].first==<span class="keyword">null</span>) &#123;</span><br><span class="line">			vers[v2].first = vers2;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;//当v2结点有邻接结点时</span><br><span class="line">			vers2.nextvex = vers[v2].first;</span><br><span class="line">			vers[v2].first = vers2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//删除图中的某条边</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> deleteEdg(<span class="type">int</span> v1, <span class="type">int</span> v2) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v1&lt;<span class="number">0</span> || v2&lt;<span class="number">0</span> || v1&gt;=numofvers || v2&gt;=numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LNode <span class="keyword">current</span> = vers[v1].first;</span><br><span class="line">		LNode pre = <span class="keyword">null</span>;</span><br><span class="line">		//判断v1到v2之间是否存在边</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">current</span>.firstadj!=v2) &#123;</span><br><span class="line">			pre = <span class="keyword">current</span>;</span><br><span class="line">			<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">		&#125;</span><br><span class="line">		//v1到v2之间存在边则删除</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			pre.nextvex = <span class="keyword">current</span>.nextvex;</span><br><span class="line">		&#125;</span><br><span class="line">		//判断v2到v1之间是否存在边</span><br><span class="line">		<span class="keyword">current</span> = vers[v2].first;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">current</span>.firstadj!=v1) &#123;</span><br><span class="line">			pre = <span class="keyword">current</span>;</span><br><span class="line">			<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">		&#125;</span><br><span class="line">		//v2到v1之间存在边则删除</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			pre.nextvex = <span class="keyword">current</span>.nextvex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//获得指定的结点间的边</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> getEdg(<span class="type">int</span> v1, <span class="type">int</span> v2) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v1&lt;<span class="number">0</span> || v2&lt;<span class="number">0</span> || v1&gt;=numofvers || v2&gt;=numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LNode <span class="keyword">current</span> = vers[v1].first;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">current</span>.firstadj == v2) &#123;</span><br><span class="line">				<span class="keyword">System</span>.<span class="keyword">out</span>.println("结点v"+v1+"-&gt;"+"结点v"+v2+"边的权值为："+<span class="keyword">current</span>.weight);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">current</span> = vers[v2].first;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">current</span>.firstadj == v2) &#123;</span><br><span class="line">				<span class="keyword">System</span>.<span class="keyword">out</span>.println("结点v"+v2+"-&gt;"+"结点v"+v1+"边的权值为："+<span class="keyword">current</span>.weight);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//深度优先遍历 Deep-first traversal</span><br><span class="line">	<span class="built_in">public</span> <span class="type">void</span> DFT(<span class="type">int</span> v) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;<span class="number">0</span> || v&gt;=numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Stack&lt;<span class="type">Integer</span>&gt; stack = <span class="built_in">new</span> Stack&lt;<span class="type">Integer</span>&gt;();</span><br><span class="line">		vers[v].isvisited = <span class="keyword">true</span>;</span><br><span class="line">		LNode <span class="keyword">current</span>;</span><br><span class="line">		stack.push(v);</span><br><span class="line">		<span class="keyword">while</span>(stack!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			v = stack.pop();</span><br><span class="line">			<span class="keyword">System</span>.<span class="keyword">out</span>.println(vers[v].data+" ");</span><br><span class="line">			<span class="keyword">current</span> = vers[v].first;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(vers[<span class="keyword">current</span>.firstadj].isvisited==<span class="keyword">false</span>) &#123;</span><br><span class="line">					stack.push(<span class="keyword">current</span>.firstadj);</span><br><span class="line">					vers[<span class="keyword">current</span>.firstadj].isvisited = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//遍历完成后恢复初始状态</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numofvers;i++) &#123;</span><br><span class="line">			vers[i].isvisited = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//广度优先遍历 Breadth-first traversal</span><br><span class="line">	<span class="built_in">public</span> <span class="type">void</span> BFT(<span class="type">int</span> v) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;<span class="number">0</span> || v&gt;=numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Queue&lt;<span class="type">Integer</span>&gt; queue = <span class="built_in">new</span> LinkedList&lt;<span class="type">Integer</span>&gt;();</span><br><span class="line">		LNode <span class="keyword">current</span>;</span><br><span class="line">		vers[v].isvisited = <span class="keyword">true</span>;</span><br><span class="line">		queue.offer(v);</span><br><span class="line">		<span class="keyword">while</span>(queue!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			v = queue.poll();</span><br><span class="line">			<span class="keyword">System</span>.<span class="keyword">out</span>.println(vers[v].data+" ");</span><br><span class="line">			<span class="keyword">current</span> = vers[v].first;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(vers[<span class="keyword">current</span>.firstadj].isvisited==<span class="keyword">false</span>) &#123;</span><br><span class="line">					queue.offer(<span class="keyword">current</span>.firstadj);</span><br><span class="line">					vers[<span class="keyword">current</span>.firstadj].isvisited = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//遍历完成后恢复初始状态</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numofvers;i++) &#123;</span><br><span class="line">			vers[i].isvisited = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//Dijkstra最短路径</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 基本思路就是先建立一个源点与各个结点的距离库</span></span><br><span class="line"><span class="comment">	 * 然后将结点作为入度的结点与源点通过的的各个结点距离相加 若小于最初的距离 则更新 直到全部更新完毕</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">public</span> <span class="type">int</span>[] Dijkstra(<span class="type">int</span> v) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;<span class="number">0</span> || v&gt;numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LNode <span class="keyword">current</span>;</span><br><span class="line">		<span class="keyword">current</span> = vers[v].first;</span><br><span class="line">		<span class="type">int</span>[] distance = <span class="built_in">new</span> <span class="type">int</span>[numofvers];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numofvers;i++) &#123;</span><br><span class="line">			distance[i] = <span class="type">Integer</span>.MAX_VALUE;  //即∞</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			distance[<span class="keyword">current</span>.firstadj] = <span class="keyword">current</span>.weight;</span><br><span class="line">			<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">		&#125;</span><br><span class="line">		distance[v] = <span class="number">0</span>;</span><br><span class="line">		vers[v].isvisited = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numofvers;i++) &#123;</span><br><span class="line">			<span class="type">int</span> min = <span class="type">Integer</span>.MAX_VALUE;</span><br><span class="line">			<span class="type">int</span> <span class="keyword">index</span> = <span class="number">-1</span>;</span><br><span class="line">			// 比较从源点到其余顶点的路径长度</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numofvers; j++) &#123;</span><br><span class="line">				// 从源点到j顶点的最短路径还没有找到</span><br><span class="line">				<span class="keyword">if</span> (vers[j].isvisited == <span class="keyword">false</span>) &#123;</span><br><span class="line">					// 从源点到j顶点的路径长度最小</span><br><span class="line">					<span class="keyword">if</span> (distance[j] &lt; min) &#123;</span><br><span class="line">						<span class="keyword">index</span> = j;</span><br><span class="line">						min = distance[j];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			// 找到源点到索引为<span class="keyword">index</span>顶点的最短路径长度</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">index</span> != <span class="number">-1</span>)</span><br><span class="line">				vers[<span class="keyword">index</span>].isvisited = <span class="keyword">true</span>;</span><br><span class="line">			// 更新当前最短路径及距离</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; numofvers; t++)</span><br><span class="line">				<span class="keyword">if</span> (vers[t].isvisited == <span class="keyword">false</span>) &#123;</span><br><span class="line">					<span class="keyword">current</span> = vers[t].first;</span><br><span class="line">					<span class="keyword">while</span> (<span class="keyword">current</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">if</span> (<span class="keyword">current</span>.firstadj == <span class="keyword">index</span>)</span><br><span class="line">							<span class="keyword">if</span> ((min + <span class="keyword">current</span>.weight) &lt; distance[t]) &#123;</span><br><span class="line">								distance[t] = min + <span class="keyword">current</span>.weight;</span><br><span class="line">								break;</span><br><span class="line">							&#125;</span><br><span class="line">						<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> distance;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】(堆栈的三种Java实现与经典应用)</title>
    <url>/2020/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%A0%86%E6%A0%88%E7%9A%84%E4%B8%89%E7%A7%8DJava%E5%AE%9E%E7%8E%B0%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8)/</url>
    <content><![CDATA[<p><strong>堆栈在Java编程中无处不在,作为重要的数据结构类型之一,本篇使用了三种方式(数组\链表\共享数组空间)来实现堆栈,并且对一些经典的应用方法进行了定义,欢迎阅览ㄟ(◑‿◐ )ㄏ</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>LIFO(先进后出)的一种线性表，栈的优点是存取速度快，仅次于寄存器，并且栈的数据是可共享的，但是存放在栈的数据的大小和生存周期是固定的，缺乏一定的灵活性。在本篇对栈的实现使用的是链表与数组的形式，因为这两种形式简化了在ArrayList和LinkedList中的逻辑。<br><img src="https://i.loli.net/2020/06/15/cr2inNtdUVW1GK5.jpg" alt="IMG_7966.jpg"></p>
</blockquote>
<h2 id="数组形式对栈实现"><a href="#数组形式对栈实现" class="headerlink" title="数组形式对栈实现"></a>数组形式对栈实现</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;E&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Object[] data;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxsize;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line">	<span class="comment">//若没有定义初始长度则自定义一个5为初始长度</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//若有定义初始长度，则调用此构造函数来初始化数组长度</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> maxsize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(maxsize&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.maxsize = maxsize;</span><br><span class="line">			data = <span class="keyword">new</span> Object[maxsize];</span><br><span class="line">			top = <span class="number">-1</span>;  <span class="comment">//top目前指向第一个元素之前的位置</span></span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"初始化长度不能为0及小于0"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断栈是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top==<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(top&gt;=maxsize<span class="number">-1</span>) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"栈满，无法放入新元素"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			data[++top] = o;  <span class="comment">//若栈味满则此时top指针向上移动一位后存放入元素，此时成为栈顶元素</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取栈顶元素但不弹出</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"栈空，无栈顶元素"</span>);</span><br><span class="line">			<span class="keyword">return</span> null;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (E)data[top];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//出栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"栈空，无栈顶元素"</span>);</span><br><span class="line">			<span class="keyword">return</span> null;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (E)data[top--];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//寻找元素在栈中的位置</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(E order)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> toptem = top;  <span class="comment">//临时top节点，以便查找完成后回到初始状态</span></span><br><span class="line">		<span class="keyword">while</span>(top!=<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(data[top]==order) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				--top;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> result = ++top;</span><br><span class="line">		top = toptem;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		Stack mystack= <span class="keyword">new</span> Stack(<span class="number">6</span>);</span><br><span class="line">		mystack.push(<span class="number">1</span>);</span><br><span class="line">		mystack.push(<span class="number">2</span>);</span><br><span class="line">		mystack.push(<span class="number">3</span>);</span><br><span class="line">		mystack.push(<span class="number">4</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"mystack 是否为空？"</span>+mystack.isEmpty());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"mystack的栈顶元素为："</span>+mystack.<span class="built_in">peek</span>());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"依次出栈前两个:"</span>+mystack.pop()+mystack.pop());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"此时栈顶元素为："</span>+mystack.<span class="built_in">peek</span>());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"元素1此时在栈中的位置为："</span>+mystack.search(<span class="number">2</span>));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表形式堆栈实现"><a href="#链表形式堆栈实现" class="headerlink" title="链表形式堆栈实现"></a>链表形式堆栈实现</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkStack</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	Node&lt;T&gt; top = <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">//用内部类对栈的节点进行定义</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">T</span>&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> T <span class="keyword">data</span>;</span><br><span class="line">		<span class="keyword">private</span> Node&lt;T&gt; next=<span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">public</span> Node(T <span class="keyword">data</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入栈</span></span><br><span class="line">	<span class="keyword">public</span> void push(T <span class="keyword">data</span>) &#123;</span><br><span class="line">		Node&lt;T&gt; newnode = new Node&lt;T&gt;(<span class="keyword">data</span>);</span><br><span class="line">		newnode.next = top;</span><br><span class="line">		top = newnode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//出栈</span></span><br><span class="line">	<span class="keyword">public</span> T pop() &#123;</span><br><span class="line">		<span class="keyword">if</span>(top==<span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		T <span class="keyword">data</span> = top.<span class="keyword">data</span>;</span><br><span class="line">		top = top.next;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">data</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断栈是否为空</span></span><br><span class="line">	<span class="keyword">public</span> boolean isEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> top==<span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取栈顶的值</span></span><br><span class="line">	<span class="keyword">public</span> T peek() &#123;</span><br><span class="line">		<span class="keyword">if</span>(top==<span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> top.<span class="keyword">data</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">		LinkStack ls = new LinkStack();</span><br><span class="line">		ls.push(<span class="number">1</span>);</span><br><span class="line">		ls.push(<span class="number">6</span>);  <span class="comment">//依次入栈</span></span><br><span class="line">		ls.push(<span class="number">2</span>);</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"栈是否为空:"</span>+ls.isEmpty());</span><br><span class="line">		System.<span class="keyword">out</span>.println(ls.pop());</span><br><span class="line">		System.<span class="keyword">out</span>.println(ls.pop());  <span class="comment">//先入后出是栈的最大的特点</span></span><br><span class="line">		System.<span class="keyword">out</span>.println(ls.pop());</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"取出栈顶元素:"</span>+ls.peek()); <span class="comment">//栈已经全部弹出 栈顶元素为null</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>3.共享数组空间的双重栈形式</em></strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxsize = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> topl;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> topr;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DoubleStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		data = <span class="keyword">new</span> <span class="keyword">int</span>[maxsize];</span><br><span class="line">		topl = <span class="number">-1</span>;</span><br><span class="line">		topr = maxsize;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断是否栈空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ((topl==<span class="number">0</span>)&amp;&amp;(topr==maxsize));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断是否栈满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (topl+<span class="number">1</span>==topr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//清空栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		topl = <span class="number">-1</span>;</span><br><span class="line">		topr = maxsize;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取栈的长度</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">			<span class="keyword">return</span> maxsize;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> length = (topl+<span class="number">1</span>)+(maxsize-topr);</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取左栈栈顶值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(topl==<span class="number">-1</span>) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"左栈什么都没有喔～"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> data[topl];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取右栈栈顶值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(topr==maxsize) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"右栈什么都没有喔～"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> data[topr];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">String</span> stackdir, <span class="keyword">int</span> e)</span> </span>&#123;  <span class="comment">//stackdir分为左栈和右栈</span></span><br><span class="line">		<span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"嘻嘻嘻栈满啦，不能再入啦～～"</span>);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(stackdir==<span class="string">"左栈"</span>) &#123;</span><br><span class="line">			topl+=<span class="number">1</span>;</span><br><span class="line">			data[topl]=e;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(stackdir==<span class="string">"右栈"</span>) &#123;</span><br><span class="line">			topr-=<span class="number">1</span>;</span><br><span class="line">			data[topr]=e;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//出栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">String</span> stackdir)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"555这里什么都没有，不能再出了～～～"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(stackdir==<span class="string">"左栈"</span>) &#123;</span><br><span class="line">			result = data[topl--];</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(stackdir==<span class="string">"右栈"</span>) &#123;</span><br><span class="line">			result = data[topr++];</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历此双栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackTraverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;=topl) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(data[i]+<span class="string">" "</span>);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		i = topr;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;maxsize) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(data[i]+<span class="string">" "</span>);;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		DoubleStack <span class="built_in">stack</span> = <span class="keyword">new</span> DoubleStack();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"此时栈为空吗？"</span>+<span class="built_in">stack</span>.isEmpty());</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"左栈"</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"左栈"</span>, <span class="number">2</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"左栈"</span>, <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"右栈"</span>, <span class="number">4</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"右栈"</span>, <span class="number">5</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"右栈"</span>, <span class="number">6</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"此时栈的长度为:"</span>+<span class="built_in">stack</span>.length());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我放入了一些元素，此时栈为空吗？"</span>+<span class="built_in">stack</span>.isEmpty());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我想看看左栈栈顶是什么:"</span>+<span class="built_in">stack</span>.getLeftStack());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我还想看右栈栈顶是什么:"</span>+<span class="built_in">stack</span>.getRightStack());</span><br><span class="line">		System.out.<span class="built_in">print</span>(<span class="string">"让我看看栈里面都有什么吧："</span>);</span><br><span class="line">		<span class="built_in">stack</span>.stackTraverse();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我想弹出一些左栈的元素"</span>+<span class="built_in">stack</span>.pop(<span class="string">"左栈"</span>)+<span class="built_in">stack</span>.pop(<span class="string">"左栈"</span>));</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我想弹出一些右栈的元素"</span>+<span class="built_in">stack</span>.pop(<span class="string">"右栈"</span>)+<span class="built_in">stack</span>.pop(<span class="string">"右栈"</span>));</span><br><span class="line">		System.out.<span class="built_in">print</span>(<span class="string">"现在栈里都还剩哪些元素呢？:"</span>);</span><br><span class="line">		<span class="built_in">stack</span>.stackTraverse();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】(队列的Java实现与经典应用)</title>
    <url>/2020/06/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%A4%E7%A7%8DJava%E5%AE%9E%E7%8E%B0%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8)/</url>
    <content><![CDATA[<p><strong>队列的出现迎合了很多Java复杂结构的应用,如二叉树的层序遍历,本篇用两种方法(数组\链表)实现了队列的定义,与此同时还有一些经典的方法进行了定义,涵盖了简单队列的内容,欢迎阅览喔( ͡° ͜ʖ ͡°)✧</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>与栈的结构相反，队列是一种先进先出的特殊表结构，普通队列的假溢出现象十分糟糕，所有目前对于队列的实现一般都使用循环队列，需要注意的是为了区分空队列和满队列的条件不同，故需要牺牲一个存储位置来满足循环队列的判断，具体可见数组形式的队列实现代码。<br><img src="https://i.loli.net/2020/06/14/HizbhIlXqKQ9f25.jpg" alt="IMG_7968.jpg"></p>
</blockquote>
<h2 id="队列的数组实现"><a href="#队列的数组实现" class="headerlink" title="队列的数组实现"></a>队列的数组实现</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package SquenceList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;T&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> T[] datas;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> maxsize;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> realmaxsize; <span class="comment">//真正储存的只有最大值-1个元素</span></span><br><span class="line">		<span class="comment">//队列的初始化</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> maxsize)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(maxsize&lt;<span class="number">1</span>) &#123;</span><br><span class="line">				maxsize=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.maxsize = maxsize;</span><br><span class="line">			realmaxsize = maxsize<span class="number">-1</span>;</span><br><span class="line">			rear = <span class="number">0</span>;</span><br><span class="line">			front = <span class="number">0</span>;</span><br><span class="line">			datas = (T[])<span class="keyword">new</span> Object[maxsize];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断队列是否为空</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; </span><br><span class="line">			<span class="keyword">return</span> (front==rear);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断队列是否已满</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">//注意循环队列判断是否已满的条件，为了和队空的条件区别</span></span><br><span class="line">			<span class="keyword">if</span>((rear+<span class="number">1</span>)%maxsize==front) &#123;</span><br><span class="line">				rear--;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;                                      <span class="comment">//所以这里牺牲了一个存储空间从而找到了判断队满的条件</span></span><br><span class="line">		<span class="comment">//进队</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="string">"队满啦，不能再进啦～"</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			datas[rear]=t;</span><br><span class="line">			rear++;</span><br><span class="line">			rear = rear%maxsize;  <span class="comment">//循环队列的特点，若要知其值则%maxsize</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//出队</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="string">"我队什么都没有，不可以再出去了～"</span>);</span><br><span class="line">				<span class="keyword">return</span> null;</span><br><span class="line">			&#125;</span><br><span class="line">			T data = datas[front++];</span><br><span class="line">			front = front%maxsize;</span><br><span class="line">			<span class="keyword">return</span> data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的队头位置</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> front;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的队尾位置</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> <span class="built_in">end</span> = rear<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">end</span>;  <span class="comment">//倒数第二个位置放着队列的队尾元素</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的对头位置元素</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">getFrontData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> datas[front];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的队尾位置元素</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">getRearData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> <span class="built_in">end</span> = rear<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">return</span> datas[<span class="built_in">end</span>]; <span class="comment">//队尾指针始终为空，故队尾元素在倒数第二个</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的元素</span></span><br><span class="line">		<span class="keyword">public</span> T[] getDatas() &#123;</span><br><span class="line">			<span class="keyword">return</span> datas;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的最大长度</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> realmaxsize;  <span class="comment">//这里因为我们创建的是循环形式的队列，所以在判断队列是否满的时候需要牺牲一个位置</span></span><br><span class="line">		&#125;                      <span class="comment">//所以真实的存储空间应为空间数-1</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		ArrayQueue myqueue = <span class="keyword">new</span> ArrayQueue(<span class="number">5</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我的队列现在是空的吗:"</span>+myqueue.isEmpty());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我的队列现在是满的吗:"</span>+myqueue.isFull());</span><br><span class="line">		myqueue.push(<span class="number">1</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在队头是第几个呢:"</span>+myqueue.getFront());</span><br><span class="line">		myqueue.push(<span class="number">3</span>);</span><br><span class="line">		myqueue.push(<span class="number">5</span>);</span><br><span class="line">		<span class="comment">//myqueue.push(7);</span></span><br><span class="line">		<span class="comment">//myqueue.push(9); //空间只能存放最大数量-1个数量的元素</span></span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"在我入队了一些元素后，现在我的队列现在是空的吗:"</span>+myqueue.isEmpty());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"在我入队了一些元素后，现在我的队列现在是满的吗:"</span>+myqueue.isFull());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"出队:"</span>+myqueue.pop());</span><br><span class="line">		<span class="comment">//System.out.println("出队:"+myqueue.pop());</span></span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在我的队伍都有谁呢:"</span>+myqueue.getDatas());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在队头是第几个呢:"</span>+myqueue.getFront());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在队尾是第几个呢:"</span>+myqueue.getRear());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在队头是谁呢:"</span>+myqueue.getFrontData());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在队尾是谁呢:"</span>+myqueue.getRearData());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我的队列能放多少个元素呢:"</span>+myqueue.getLength());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列的链表实现"><a href="#队列的链表实现" class="headerlink" title="队列的链表实现"></a>队列的链表实现</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> LinkedQueue&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Node&lt;T&gt; front;</span><br><span class="line">	<span class="keyword">private</span> Node&lt;T&gt; rear;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxsize;</span><br><span class="line">	<span class="keyword">class</span> Node&lt;T&gt;&#123;  <span class="comment">//同样用内部类来作为节点的定义</span></span><br><span class="line">		<span class="keyword">private</span> T data;</span><br><span class="line">		<span class="keyword">public</span> Node&lt;T&gt; <span class="keyword">next</span>;</span><br><span class="line">		<span class="keyword">public</span> Node ()&#123;</span><br><span class="line">			<span class="keyword">this</span>.data=<span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">this</span>.<span class="keyword">next</span>=<span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> Node(T data) &#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">			<span class="keyword">this</span>.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> T getData() &#123;</span><br><span class="line">			<span class="keyword">return</span> data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> setData(T data) &#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> Node getNext() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//构造链队的初始化方法</span></span><br><span class="line">	<span class="keyword">public</span> LinkedQueue() &#123;</span><br><span class="line">		<span class="keyword">this</span>.front = <span class="keyword">new</span> Node();</span><br><span class="line">		<span class="keyword">this</span>.rear = <span class="keyword">new</span> Node();</span><br><span class="line">		maxsize = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化链队</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> initQueue() &#123;</span><br><span class="line">		<span class="keyword">this</span>.front = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">this</span>.rear = <span class="keyword">null</span>;</span><br><span class="line">		maxsize = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入队</span></span><br><span class="line">	<span class="comment">//判断链队是否为空</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> isEmpty() &#123;</span><br><span class="line">		<span class="keyword">if</span>(front.<span class="keyword">next</span>==<span class="keyword">null</span>||rear.<span class="keyword">next</span>==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入队</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">push</span>(T data) &#123;</span><br><span class="line">		Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;(data);</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			front.<span class="keyword">next</span> = node;</span><br><span class="line">			rear.<span class="keyword">next</span> = node;</span><br><span class="line">			maxsize++;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			node.<span class="keyword">next</span> = front.<span class="keyword">next</span>;</span><br><span class="line">			front.<span class="keyword">next</span> = node;</span><br><span class="line">			maxsize++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//出队</span></span><br><span class="line">	<span class="keyword">public</span> Node <span class="keyword">pop</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			System.out.<span class="keyword">println</span>(<span class="string">"这里是空的无法出队哦"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxsize ==<span class="number">1</span>) &#123;</span><br><span class="line">			Node node = front.<span class="keyword">next</span>;</span><br><span class="line">			initQueue();</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			Node end = front;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxsize-<span class="number">1</span>;i++) &#123;</span><br><span class="line">				end = end.<span class="keyword">next</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Node node = rear.<span class="keyword">next</span>;</span><br><span class="line">			rear.<span class="keyword">next</span> = end.<span class="keyword">next</span>;</span><br><span class="line">			maxsize--;</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">		LinkedQueue&lt;Integer&gt; lq = <span class="keyword">new</span> LinkedQueue&lt;Integer&gt;();</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"我现在还没有入队，队是空的吗？"</span>+lq.isEmpty());</span><br><span class="line">		lq.<span class="keyword">push</span>(<span class="number">1</span>);</span><br><span class="line">		lq.<span class="keyword">push</span>(<span class="number">2</span>);</span><br><span class="line">		lq.<span class="keyword">push</span>(<span class="number">3</span>);</span><br><span class="line">		lq.<span class="keyword">push</span>(<span class="number">4</span>);</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"我入队了一些元素，现在队还是空的吗？"</span>+lq.isEmpty());</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"出队所有元素元素："</span>);</span><br><span class="line">		System.out.<span class="keyword">println</span>(lq.<span class="keyword">pop</span>().data);</span><br><span class="line">		System.out.<span class="keyword">println</span>(lq.<span class="keyword">pop</span>().data);</span><br><span class="line">		System.out.<span class="keyword">println</span>(lq.<span class="keyword">pop</span>().data);</span><br><span class="line">		System.out.<span class="keyword">println</span>(lq.<span class="keyword">pop</span>().data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】(顺序表的Java与C++实现及经典应用)</title>
    <url>/2020/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84Java%E4%B8%8EC++%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8)/</url>
    <content><![CDATA[<p><strong>从入坑到入土的坑就是顺序表,珍惜最基础的数据结构,当然也要掌握好这个数据结构大厦的基石,顺序表的实现形式给很多复杂的数据结构形式提供了简单实现的方案,在有些时候,用顺序表的实现并非是差的选择(♥◠‿◠)ﾉ</strong></p>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/06/15/dqgl9kEIMwfuVAo.jpg" alt="IMG_7969.jpg"></p>
<h2 id="顺序表的Java实现"><a href="#顺序表的Java实现" class="headerlink" title="顺序表的Java实现"></a>顺序表的Java实现</h2><blockquote>
<p>Java代码是对顺序表的简单数组实现，对于顺序表的任何操作都可以利用数组来实现，但是往往使用数组时需要对数组的长度进行估计，这也很不符合实际也是很大的缺陷，但是在Java等现代语言中均不需要再对数组的长度进行估算，若数组长度达到了最大值可以用相应的方法进行扩充建立一个新的顺序表，当然对于顺序表的实现即使是数组实现但也有插入和删除需要大量移动数组带来的时间复杂度的问题。</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java代码实现</span></span><br><span class="line">package SquenceList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Sqlist</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span> MAXSIZE;</span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span>[] sqlist;</span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span> length;</span><br><span class="line">	<span class="comment">//用最大数组长度来初始化顺序表</span></span><br><span class="line">	<span class="keyword">public</span> Sqlist(<span class="built_in">int</span> MAXSIZE)&#123;</span><br><span class="line">		<span class="keyword">this</span>.sqlist = new <span class="built_in">int</span>[MAXSIZE];</span><br><span class="line">		<span class="keyword">this</span>.MAXSIZE=MAXSIZE;</span><br><span class="line">		<span class="keyword">this</span>.length=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//用数组来初始化顺序表</span></span><br><span class="line">	<span class="keyword">public</span> Sqlist(<span class="built_in">int</span>[] arr) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">			sqlist[i] = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.length = arr.length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对由数组实现的顺序表进行扩充</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> expandList()&#123;</span><br><span class="line">	    <span class="built_in">int</span>[] newarr = new <span class="built_in">int</span>[arr.length*<span class="number">2</span>]</span><br><span class="line">	    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">	        newarr[i]=arr[i]</span><br><span class="line">	    &#125;</span><br><span class="line">	    arr = newarr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//向顺序表指定位置插入元素</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> listInsert(<span class="built_in">int</span> i, <span class="built_in">int</span> e) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>) &#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"非法插入位置"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.length == <span class="keyword">this</span>.MAXSIZE) &#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"顺序表已满"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> k=length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--) &#123;</span><br><span class="line">			sqlist[k+<span class="number">1</span>]=sqlist[k];  <span class="comment">//数组中插入位置及其后的元素均向后移动一位</span></span><br><span class="line">		&#125;</span><br><span class="line">		sqlist[i<span class="number">-1</span>]=e;  <span class="comment">//将制定元素插入此位置</span></span><br><span class="line">		<span class="keyword">this</span>.length++;  <span class="comment">//插入后的顺序表长度+1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//清空顺序表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> listClear() &#123;</span><br><span class="line">		<span class="keyword">this</span>.length = <span class="number">0</span>;  <span class="comment">//仅用来判断是否为空，直接将长度设置为0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断顺序表是否为空</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">bool</span>ean isEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.length==<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取指定位置的顺序表元素</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">int</span> getElem(<span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;length)</span><br><span class="line">		&#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"获取位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sqlist[i<span class="number">-1</span>];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取制定元素的位置信息</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> getIndex(<span class="built_in">int</span> e, <span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;=length<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(sqlist[j]==e) &#123;</span><br><span class="line">				i=j++;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"顺序表中无对应元素"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印顺序表</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">void</span> printList() &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;=length<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">int</span> t=i+<span class="number">1</span>;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"第"</span>+t+<span class="string">"个元素为"</span>+sqlist[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除顺序表指定位置的元素</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">int</span> listDelete(<span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;length)</span><br><span class="line">		&#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"删除位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=i;j&lt;=length<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sqlist[j<span class="number">-1</span>]=sqlist[j];</span><br><span class="line">		&#125;</span><br><span class="line">		length--;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">		Sqlist sqlist = new Sqlist(<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			sqlist.listInsert(i, i);</span><br><span class="line">		&#125;</span><br><span class="line">		printList();</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"第3个元素为"</span>+getElem(<span class="number">3</span>));</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"删除第二个元素后的顺序表的内容为："</span>)</span><br><span class="line">		listDelete(<span class="number">2</span>);</span><br><span class="line">		printList();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺序表的C-实现"><a href="#顺序表的C-实现" class="headerlink" title="顺序表的C++实现"></a>顺序表的C++实现</h2><blockquote>
<p>C++代码实现顺序表的实现由于有指针的牵制而使得代码的实现比较复杂，需要多加理解和记忆。</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立顺序表的存储结构</span></span><br><span class="line">typedef <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> *elem;</span><br><span class="line">    <span class="built_in">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//构造一个空的顺序表</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">InitList(SqList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">L</span>.</span></span>elem=<span class="keyword">new</span> ElemType<span class="literal">[<span class="identifier">maxsize</span>]</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="module-access"><span class="module"><span class="identifier">L</span>.</span></span>elem) exit(overflow);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">L</span>.</span></span>length=<span class="number">0</span>;</span><br><span class="line">    return ok;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顺序表的插入</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ListInsert(SqList &amp;L,<span class="params">int</span> <span class="params">i</span>,<span class="params">int</span> <span class="params">e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((i&lt;<span class="number">1</span>)<span class="pattern-match"><span class="operator">||</span>(i&gt;<span class="constructor">L</span>.length+1)) return error; <span class="operator">/</span><span class="operator">/</span>插入位置是否合法的判断</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(<span class="constructor">L</span>.length<span class="operator">==</span>maxsize)  return error;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> j=<span class="constructor">L</span>.length-1;j&gt;=i-1;j--)</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">L</span>.elem[j+1]=<span class="constructor">L</span>.elem[j];  <span class="operator">/</span><span class="operator">/</span>插入后元素位置的移动变化</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">L</span>.elem[i-1]=e;</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">++</span><span class="constructor">L</span>.length;</span></span><br><span class="line"><span class="pattern-match">    return ok;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span>顺序表元素的获取</span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> <span class="constructor">GetElem(SqList L,<span class="params">int</span> <span class="params">i</span>,<span class="params">int</span> &amp;<span class="params">e</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(i&lt;1<span class="operator">||</span>i&gt;<span class="constructor">L</span>.length) return error;</span></span><br><span class="line"><span class="pattern-match">    e=<span class="constructor">L</span>.elem[i-1];</span></span><br><span class="line"><span class="pattern-match">    return e;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span>判断值是否相等</span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> <span class="constructor">EqualList(<span class="params">int</span> <span class="params">a</span>,<span class="params">int</span> <span class="params">b</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(a<span class="operator">==</span>b)</span></span><br><span class="line"><span class="pattern-match">        return ok;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">        return error;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span>判断顺序表中是否存在值为e的元素</span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> <span class="constructor">LocateElem(SqList L,ElemType <span class="params">e</span>,<span class="params">int</span> EqualList(<span class="params">int</span> <span class="params">a</span>, <span class="params">int</span> <span class="params">b</span>)</span>)</span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> i=1;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> <span class="operator">*</span>p=<span class="constructor">L</span>.elem;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">while</span>(i&lt;=<span class="constructor">L</span>.length<span class="operator">&amp;&amp;</span>!<span class="constructor">EqualList(<span class="operator">*</span><span class="params">p</span><span class="operator">++</span>,<span class="params">e</span>)</span>)</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">++</span>i;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(i&lt;=<span class="constructor">L</span>.length)</span></span><br><span class="line"><span class="pattern-match">        return 1;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">        return 0;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span>顺序表的打印</span></span><br><span class="line"><span class="pattern-match">void <span class="constructor">PrintList(SqList L)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> i=0; i&lt;<span class="constructor">L</span>.length; i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        cout&lt;&lt;<span class="constructor">L</span>.elem[i]&lt;&lt;" ";</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span>顺序表表示集合的并集</span></span><br><span class="line"><span class="pattern-match">void <span class="constructor">MergeList(SqList LA,SqList LB,SqList &amp; LC)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">   <span class="built_in">int</span> m,n,e;</span></span><br><span class="line"><span class="pattern-match">   m=<span class="constructor">LA</span>.length;n=<span class="constructor">LB</span>.length;</span></span><br><span class="line"><span class="pattern-match">   for(<span class="built_in">int</span> i=1;i&lt;=n;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">   &#123;</span></span><br><span class="line"><span class="pattern-match">       <span class="constructor">GetElem(LB,<span class="params">i</span>,<span class="params">e</span>)</span>;  <span class="operator">/</span><span class="operator">/</span>获取<span class="constructor">B</span>中第i个元素并返回给e</span></span><br><span class="line"><span class="pattern-match">       <span class="keyword">if</span>(!<span class="constructor">LocateElem(LA,<span class="params">e</span>,EqualList)</span> )</span></span><br><span class="line"><span class="pattern-match">           &#123;</span></span><br><span class="line"><span class="pattern-match">               <span class="constructor">ListInsert(LA,<span class="operator">++</span><span class="params">m</span>,<span class="params">e</span>)</span>;    <span class="operator">/</span><span class="operator">/</span>将e插在<span class="constructor">LC</span>的最后</span></span><br><span class="line"><span class="pattern-match">           &#125;</span></span><br><span class="line"><span class="pattern-match">   &#125;</span></span><br><span class="line"><span class="pattern-match">   for(<span class="built_in">int</span> i=1;i&lt;=m;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">GetElem(LA,<span class="params">i</span>,<span class="params">e</span>)</span>;   <span class="operator">/</span><span class="operator">/</span>获取<span class="constructor">A</span>中第i个元素并赋给e</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">ListInsert(LC,<span class="params">i</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> <span class="constructor">Mixture(SqList LA,SqList LB,SqList &amp;LC)</span></span></span><br><span class="line"><span class="pattern-match">&#123;<span class="operator">/</span><span class="operator">/</span>a与b的交集</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> m,n,e;</span></span><br><span class="line"><span class="pattern-match">    m=<span class="constructor">LA</span>.length;</span></span><br><span class="line"><span class="pattern-match">    n=<span class="constructor">LB</span>.length;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> j=0;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> p=m&lt;=n?<span class="constructor">LA</span>:<span class="constructor">LB</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> q=m&gt;n?<span class="constructor">LA</span>:<span class="constructor">LB</span>;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> i=1;i&lt;=p.length;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">GetElem(<span class="params">p</span>,<span class="params">i</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span>(<span class="constructor">LocateElem(<span class="params">q</span>,<span class="params">e</span>,EqualList)</span>)</span></span><br><span class="line"><span class="pattern-match">        &#123;</span></span><br><span class="line"><span class="pattern-match">            <span class="constructor">ListInsert(LC,<span class="operator">++</span><span class="params">j</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(<span class="constructor">LC</span>.length)</span></span><br><span class="line"><span class="pattern-match">        return ok;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">        return error;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> <span class="constructor">Different(SqList LA,SqList LB,SqList &amp;LC)</span></span></span><br><span class="line"><span class="pattern-match">&#123;<span class="operator">/</span><span class="operator">/</span>求<span class="constructor">A</span>-<span class="constructor">B</span>的集合</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> m=<span class="constructor">LA</span>.length;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> e;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> j=0;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> i=1;i&lt;=m;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">GetElem(LA,<span class="params">i</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span>(!<span class="constructor">LocateElem(LB,<span class="params">e</span>,EqualList)</span>)</span></span><br><span class="line"><span class="pattern-match">            <span class="constructor">ListInsert(LC,<span class="operator">++</span><span class="params">j</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(<span class="constructor">LC</span>.length)</span></span><br><span class="line"><span class="pattern-match">        return ok;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">        return error;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> main()</span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> <span class="constructor">LA</span>,<span class="constructor">LB</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">InitList(LA)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">InitList(LB)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"线性表a的长度："&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> la;</span></span><br><span class="line"><span class="pattern-match">    cin&gt;&gt;la;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"请输入a中的元素："&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> e;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> i=1;i&lt;=la;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        cin&gt;&gt;e;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">ListInsert(LA,<span class="params">i</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"<span class="constructor">A</span>中的元素:"&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">PrintList(LA)</span>;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"线性表b的长度："&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> lb;</span></span><br><span class="line"><span class="pattern-match">    cin&gt;&gt;lb;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"请输入b中的元素："&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> i=1;i&lt;=lb;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        cin&gt;&gt;e;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">ListInsert(LB,<span class="params">i</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"<span class="constructor">B</span>中的元素"&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">PrintList(LB)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"<span class="constructor">A</span>并<span class="constructor">B</span>:";</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> <span class="constructor">LC1</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">InitList(LC1)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">MergeList(LA,LB,LC1)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">PrintList(LC1)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"<span class="constructor">A</span>交<span class="constructor">B</span>：";</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> <span class="constructor">LC2</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">InitList(LC2)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">Mixture(LA,LB,LC2)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">PrintList(LC2)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"<span class="constructor">A</span>差<span class="constructor">B</span>：";</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> <span class="constructor">LC3</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">InitList(LC3)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">Different(LA,LB,LC3)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">PrintList(LC3)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    return 0;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Java】Java后知后觉(初阶)</title>
    <url>/2020/04/29/Java%E5%90%8E%E7%9F%A5%E5%90%8E%E8%A7%89/</url>
    <content><![CDATA[<p><strong>那些Java中你可能不知道的一些事&lt;(▰˘◡˘▰)&gt;</strong></p>
 <a id="more"></a>
<p><img src="https://i.loli.net/2020/06/20/Rix9mJo7VXUFkDM.jpg" alt="IMG_6579.jpg"></p>
<ol>
<li><h2 id="关于命令"><a href="#关于命令" class="headerlink" title="关于命令"></a>关于命令</h2></li>
</ol>
<ul>
<li><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">javac </span>HelloWorld.<span class="keyword">java </span> </span><br><span class="line">$ <span class="keyword">java </span>HelloWorld  </span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>相信这是大家刚刚接触Java时接触到的第一个程序</strong><br><strong>在这个命令行终端中我们用到了两个命令javac和java</strong></p>
<ul>
<li>javac后跟着的是一个典型的java文件，javac此时所做的事就是<em>将java源文件编译成字节码文件</em>此时如果编译成功的话是会生成一个名为HelloWorld.class的文件，此时就是成功编译为字节码文件；</li>
<li>java后跟的是Java文件中的类名，比如这里的HelloWorld但是不要加.class后缀。</li>
</ul>
<ol start="2">
<li><h2 id="关于修饰符"><a href="#关于修饰符" class="headerlink" title="关于修饰符"></a>关于修饰符</h2></li>
</ol>
<p>-</p>
<h3 id="synchronized修饰符"><a href="#synchronized修饰符" class="headerlink" title="synchronized修饰符"></a>synchronized修饰符</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">easonHe</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<strong>synchronized</strong>修饰符是在多线程的程序编码中常会用到的修饰符，<em>synchronized</em>修饰符旨在<em>确保方法在同一时间只能被一个线程访问</em>。同时<strong>synchronized</strong>可以用于四个访问修饰符。  </p>
<p>-</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> active;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        active = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(active)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        active = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>volatile</em>修饰词也是常用于多线程中，每当线程准备访问<em>volatile</em>所修饰的成员变量时，必须要从共享内存中重新读取该成员变量的值，另外，如果遇到该成员变量的值发生改变时，线程也必须将该成员变量的值写入到共享内存中更新，这样以来，多线程中每个线程所看到的都是成员变量的同一个值。  </p>
</blockquote>
<blockquote>
<p>这个成程序中，若是一个线程调用run()方法，此时另一线程调用stop()方法时，如果线程已经进入while的缓冲区，那么即使stop()方法中的active=false线程也不会停止，但是由于这个线程中的active是被<em>volatile</em>修饰符所修饰，所以这个循环会停止。</p>
</blockquote>
<p>-</p>
<h3 id="transient修饰符"><a href="#transient修饰符" class="headerlink" title="transient修饰符"></a>transient修饰符</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> transient <span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> b;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>transient</em>修饰符用来定义变量时，其作用是用来预处理类与变量的数据类型，也就是说，如果序列化的对象包含别<em>transient</em>修饰的实例变量，那么JVM将会跳过此特定的变量。</p>
</blockquote>
<h2 id="关于运算符"><a href="#关于运算符" class="headerlink" title="关于运算符"></a>关于运算符</h2><p>-</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">A = <span class="number">0101</span> <span class="number">1100</span></span><br><span class="line">B = <span class="number">0010</span> <span class="number">0101</span>  </span><br><span class="line">---------------</span><br><span class="line">A&amp;B = <span class="number">0000</span> <span class="number">0100</span></span><br><span class="line">A|B = <span class="number">0111</span> <span class="number">1101</span></span><br><span class="line">A^B = <span class="number">0111</span> <span class="number">1001</span></span><br><span class="line">~A = <span class="number">1010</span> <span class="number">0011</span></span><br><span class="line">B&lt;&lt;<span class="number">2</span> = <span class="number">1001</span> <span class="number">0100</span></span><br><span class="line">B&gt;&gt;<span class="number">2</span> = <span class="number">1001</span></span><br><span class="line">B&gt;&gt;&gt;<span class="number">2</span> = <span class="number">0000</span> <span class="number">1001</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><em>^如果对应位值相等则为0不等则为1</em>；</li>
<li><em>～按位取反运算符</em>；</li>
<li>*&lt;&lt;按位左移运算符，左操作数按位左移右操作数指定的位数*;  </li>
<li><em>&gt;&gt;按位右移运算符，左操作数按位右移右操作数指定的位数</em>；</li>
<li><em>&gt;&gt;&gt;按位右移补零运算符，在按位右移的情况下将最高位的空位用零填充</em></li>
</ol>
</blockquote>
<p>但是其实我们真正用到它的时候并非如此使用，而是下面这种情况：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(<span class="keyword">String</span>[], args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">13</span>; <span class="comment">//即 a=0000 1101</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">28</span>; <span class="comment">//即 b=0001 1100</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        c = a &amp; b;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"a &amp; b = "</span>+c) <span class="comment">//此时c的值为12 即0000 1100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说我们平时使用的往往并非二进制编码，而是对应的十进制编码，但有时我们也会为了满足某种需求而使用到十进制编码进行位操作符的运算。  </p>
<p>-</p>
<h3 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[], args)&#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">6</span>;</span><br><span class="line">        <span class="built_in">bool</span>ean result = (a&lt;<span class="number">2</span>&amp;&amp;++a&lt;<span class="number">8</span>) <span class="comment">//a=6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码中，result结果为false，因为a&lt;2已经是false了所以结果必定是false，所以说第二个操作判断就不被执行了，也就是++a不被执行，所以此时a仍然为6.</p>
</blockquote>
<p>-</p>
<h3 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"watermelon"</span>;</span><br><span class="line"><span class="built_in">boolean</span> isReal = <span class="built_in">str</span> <span class="keyword">instanceof</span> <span class="keyword">String</span>;</span><br><span class="line"><span class="comment">// is Real = true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>instanceof运算符用于操作一个对象的实例，若为此特定类类型或接口类型则为真，否则为假，即如果运算符左侧所指的对象是右侧类或者接口的一个对象则结果为真。  </p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cola</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Pepsi</span> <span class="keyword">extends</span> <span class="title">Cola</span></span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[], args)&#123;</span><br><span class="line">        <span class="type">Cola</span> cola = <span class="keyword">new</span> <span class="type">Pepsi</span>();</span><br><span class="line">        boolean result = cola instanceof <span class="type">Pepsi</span>;</span><br><span class="line">        <span class="comment">//此时result=true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用instanceof操作符如果被比较的对象兼容于右侧的类型，则同样成立。这里应该注意<strong><em>判断一个实例引用的类型时，使用的是实际类型，而不是声明的类型，如上代码中cola是Pepsi类型而不是Cola类型，并且，子类的实例可以声明为父类，但是父类的实例不可以声明为子类</em></strong>。</p>
</blockquote>
<h2 id="关于循环"><a href="#关于循环" class="headerlink" title="关于循环"></a>关于循环</h2><p>-</p>
<h3 id="加强型for循环-For-Each"><a href="#加强型for循环-For-Each" class="headerlink" title="加强型for循环(For-Each)"></a>加强型for循环(For-Each)</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[], args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] num = &#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : num)&#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(i+<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//此时将会打印出2 6 9 30</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">String</span> [] drinks = &#123;<span class="string">"cola"</span>, <span class="string">"coffee"</span>, <span class="string">"tea"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> name : drinks)&#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(name+<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//此时将会打印出cola coffee tea </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种情况是Java引入的为了用于数组形式的增强版for循环。</p>
</blockquote>
<p><strong>ps:在循环或者条件以及选择语句中需要注意的几点：</strong>  </p>
<ol>
<li>在循环操作语句中，如果遇到break语句被执行，那么将会直接跳出最内层的一个循环体，如果遇到continue语句被执行，那么接下来的语句将不会被执行，而是直接进入新一轮的循环，这种用法往往用来选择性退出或者是去刻意忽略某次循环体内的语句；</li>
<li>在选择操作语句中，如switch语句，如果case没有与变量类型相匹配的，那么将会执行default语句（如果有的话），如果匹配的case语句没有break，那么将会顺序输出以下的语句，直到遇到break或全部输出。  </li>
</ol>
<h2 id="关于Java类"><a href="#关于Java类" class="headerlink" title="关于Java类"></a>关于Java类</h2><p>-</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>由于java属于面向对象的编程语言，所以我们难免会遇到使用数据时需要使用对象而不是内置数据类型的情形，针对于此，java提供了包装类：Double,Float, Long, Integer, Short, Byte.</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">IntergerTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[], args)&#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">128</span>;</span><br><span class="line">        Interger b = <span class="number">128</span>;</span><br><span class="line">        Interger c = new Interger(<span class="number">128</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(a==b); <span class="comment">//true 因为与内置数据类型比较，所以Interger会自动拆箱比较  </span></span><br><span class="line">        <span class="comment">// a==c 与 a==b情况相同</span></span><br><span class="line">        Interger b1 = <span class="number">127</span>;</span><br><span class="line">        Interger c1 = <span class="number">127</span>; <span class="comment">//此时经编译时为Interger b2 = Interger.valueOf(127)  </span></span><br><span class="line">        System.<span class="keyword">out</span>.println(b1==c1); <span class="comment">//true</span></span><br><span class="line">        Interger b2 = <span class="number">128</span>;</span><br><span class="line">        Interger c2 = <span class="number">128</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(b2==c2); <span class="comment">//false 因为Interger中的valueOf函数只会对int类型的取值范围内（-128～127）之间的数进行缓存。  </span></span><br><span class="line">        Interger b3 = new Interger(<span class="number">127</span>);</span><br><span class="line">        Interger c3 = <span class="number">127</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(b3==c3); <span class="comment">//false 无论如何Interger与new得到的Interger不会相等，</span></span><br><span class="line">        <span class="comment">//因为new得到的对象放在堆存储区里，非new得到的常量则放在常量池即方法区里，故不会经历拆箱，两地址也不同，故不会相等</span></span><br><span class="line">        Interger b4 = new Interger(<span class="number">127</span>);</span><br><span class="line">        Interger c4 = new Interger(<span class="number">127</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(b4==c4); <span class="comment">//false 因为都是通过new得到的对象，所以地址不相同</span></span><br><span class="line">        Interger b5 = <span class="number">127</span>;</span><br><span class="line">        Interger c5 = <span class="number">127</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(b5.equals(c5)); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译器特别支持的包装成为装箱，所以在内置类型要作为对象使用时，编译器就会将其装箱成为一个包装类，若是一个对象要作为内置数据类型使用时，编译器也会将其拆箱；  </p>
</blockquote>
<blockquote>
<h2 id="要注意在进行比较时-比较的是地址，equals-比较的是对象的内容，所以在Interger-valueOf-时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。"><a href="#要注意在进行比较时-比较的是地址，equals-比较的是对象的内容，所以在Interger-valueOf-时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。" class="headerlink" title="要注意在进行比较时 =比较的是地址，equals()比较的是对象的内容，所以在Interger.valueOf()时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。  "></a>要注意在进行比较时 =比较的是地址，equals()比较的是对象的内容，所以在Interger.valueOf()时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。  </h2></blockquote>
<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] <span class="built_in">array</span> = &#123;<span class="string">"E"</span>, <span class="string">"a"</span>, <span class="string">"s"</span>, <span class="string">"o"</span>, <span class="string">"n"</span>&#125;;</span><br><span class="line">        <span class="keyword">String</span> str = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="built_in">array</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(str);</span><br><span class="line">        <span class="comment">//输出结果为Eason</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Java中，String字符串属于对象，String类有11中构造方法，这些方法提供不同的参数来初始化字符串，比如这段代码中提供一个字符数组来初始化一个字符串；  </p>
</blockquote>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class Demo&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main()&#123;</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"Eason"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">        <span class="comment">//输出Eason</span></span><br><span class="line">        <span class="built_in">str</span> = <span class="string">"He"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">        <span class="comment">//输出He</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>特别需要注意的是一旦String对象被创建那么它就无法被更改了，也就是说String是被final修饰的，但是这段代码中str在结果上看是改变了，但其实它并没有被更改，因为实例str只是一个String的对象引用，当执行str=”He”的时候它创建了一个新的String对象”He”,原来的”Eason”对象仍然存储在内存中；  </p>
</blockquote>
<blockquote>
<p>也就是说，如果需要对字符串做很多修改，那么应该选择使用<em>StringBuffer和StringBuilder</em>类。<br>    1.StringBuffer:字符串变量，Synchronized线程安全，如果想专成String类型，则可以使用toString()方法，Java.lang.StringBuffer可以通过某些特定的方法调用可以改变该序列的长度和内容，可以将字符串缓冲区安全的应用于多个线程；<br>    2.StringBuilder:字符串变量，非线程安全，在内部StringBuilder对象被当作是一个包含自负序列的变长数组；<br>    <strong><em>总结</em></strong>：<strong>-</strong> 如果操作少量的数据用String <strong>-</strong> 单线程操作大量数据用StringBuilder <strong>-</strong> 多线程操作大量数据用StringBuffer。<br>    ps：其实StringBuffer的线程安全也是很低能的也就是说它也只能保证jvm不抛出异常而向下运行而已，所以针对于StringBuilder的高效，所以<strong><em>在绝大部分情况下直接使用StringBuilder</em></strong>。</p>
</blockquote>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">String <span class="built_in">s1</span> = <span class="string">"a"</span>+<span class="string">"b"</span>+<span class="string">"c"</span>;</span><br><span class="line">String <span class="built_in">s2</span> = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(<span class="built_in">s1</span>==<span class="built_in">s2</span>)<span class="comment">;//true</span></span><br><span class="line">System.out.println(<span class="built_in">s1</span>.equals(<span class="built_in">s2</span>))<span class="comment">;//true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是道面试经常会被问到的问题，在Java常量优化机制中，编译时s1已经成为”abc”在常量池中查找创建，故此时s2就不用再创建了；  </p>
</blockquote>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="built_in">s1</span> = <span class="string">"a"</span>+<span class="string">"b"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="built_in">s2</span> = <span class="string">"abc"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="built_in">s3</span> = <span class="built_in">s1</span>+<span class="string">"c"</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">System.out.println</span>(<span class="built_in">s3</span>=<span class="symbol">=s2</span>)<span class="comment">;//false</span></span><br><span class="line"><span class="symbol">System.out.println</span>(<span class="built_in">s3</span>.equals(<span class="built_in">s2</span>))<span class="comment">;//true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这也是道面试经常会被问到的问题，在编译时，”ab”在常量池中被创建其地址为a1,”abc”接着被创建其地址为a2,对于s3，先创建一个StringBuilder或StringBuffer对象，通过append方法连接得到abc，再调用toString()转换为String得到的地址为a3，故==为false，equals比较对象的值为true。</p>
</blockquote>
<p><strong>另外</strong>：length(), length属性，size()之间的一些区别</p>
<ol>
<li>length()方法是针对字符串来说的，要求一个字符串的长度时就要用到这个方法；</li>
<li>length属性是针对Java中的数组来说的，要求数组的长度可以用length属性；</li>
<li>size()方法是针对泛型集合List来说的，如果想看一个泛型集合中有多少个元素就使用此方法；</li>
</ol>
<h2 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h2><p>-</p>
<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[], args)&#123;</span><br><span class="line">        <span class="built_in">int</span> [] num = new <span class="built_in">int</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="built_in">int</span> [] num1 = &#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Arrays.fill(num, <span class="number">6</span>);<span class="comment">//此时num数组内的元素为66666666</span></span><br><span class="line">        Arrays.fill(num, <span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>);<span class="comment">//将num数组中第1，2个元素赋值为8</span></span><br><span class="line">        Arrays.sort(num1);<span class="comment">//对num1数组进行排序</span></span><br><span class="line">        Arrays.equals(num, num1);<span class="comment">//比较两数组元素是否相等</span></span><br><span class="line">        Arrays.binarySearch(num1, <span class="number">2</span>);<span class="comment">//查找元素3在数组中的位置，如果不存在就返回负数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java.util.Arrays类能够很方便的处理数组，它提供的所有方法都是静态的，它的部分功能：<br>    1. 通过fill()方法给数组赋值；<br>    2. 通过sort()方法按升序排序；<br>    3. 通过equals()方法判断数组中的元素是否相等；<br>    4. 通过binarySearch()方法能对排好序的数组进行二分法查找等等。</p>
</blockquote>
<h2 id="关于正则表达式"><a href="#关于正则表达式" class="headerlink" title="关于正则表达式"></a>关于正则表达式</h2><p>-</p>
<h3 id="Pattern与Matcher类"><a href="#Pattern与Matcher类" class="headerlink" title="Pattern与Matcher类"></a>Pattern与Matcher类</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[], args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">String</span> str = <span class="string">"My number is 56? Yes!"</span>;</span><br><span class="line">        <span class="keyword">String</span> regex = <span class="string">"(\\d+)(\\D*)(.*)"</span>;</span><br><span class="line">        Pattern p = Pattern.compile(regex);<span class="comment">//创建Pattern对象</span></span><br><span class="line">        Matcher m = p.matcher(str);<span class="comment">//创建Matcher(适配器)对象</span></span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">find</span>())&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(m.group(<span class="number">0</span>));<span class="comment">//输出：My number is 56? Yes!</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(m.group(<span class="number">1</span>));<span class="comment">//输出：56</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(m.group(<span class="number">2</span>));<span class="comment">//输出：My number is Yes</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(m.group(<span class="number">3</span>));<span class="comment">//输出：? Yes!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本段代码中group()方法为捕获组，比如正则表达式中((A)(B(C)))这其中就有四个组((A)(B(C)))、(A)、(B(C))、(C),技巧是左边数第几个括号所对应的内容就是相应的第几组；  </p>
</blockquote>
<blockquote>
<p>Pattern与Matcher类都没有公共的构造方法，都是通过调用静态函数所得到的返回类型来创建类；</p>
</blockquote>
<blockquote>
<p>在其他语言的正则表达式中往往一个反斜杠\就具有转义作用，但是Java的正则表达式中两个反斜杠才能表示转义作用，比如\\d表示一位数字。</p>
</blockquote>
<blockquote>
<p>在Matcher类中有两个重要的方法就是start()和end()方法，start()方法返回由给定组所捕获的初始索引，end()方法是返回最后一个匹配字符的索引+1</p>
</blockquote>
<h2 id="关于Java方法"><a href="#关于Java方法" class="headerlink" title="关于Java方法"></a>关于Java方法</h2><p>-</p>
<h3 id="出现在方法名称"><a href="#出现在方法名称" class="headerlink" title="_出现在方法名称"></a>_出现在方法名称</h3><blockquote>
<h2 id="在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test-例如：textPop-emptyStack"><a href="#在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test-例如：textPop-emptyStack" class="headerlink" title="在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test 例如：textPop_emptyStack."></a>在方法的命名中，下划线<em>可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test<MethodUnderTest></em><state> 例如：textPop_emptyStack.</h2></blockquote>
<h3 id="命令行参数的使用"><a href="#命令行参数的使用" class="headerlink" title="命令行参数的使用"></a>命令行参数的使用</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"args["</span>+i+<span class="string">"] = "</span>+args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行此程序：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ javac Demo.java</span><br><span class="line">$ java Demo This <span class="keyword">is</span> <span class="keyword">a</span> <span class="keyword">command</span> <span class="built_in">line</span></span><br><span class="line"><span class="keyword">args</span>[<span class="number">0</span>] = This</span><br><span class="line"><span class="keyword">args</span>[<span class="number">1</span>] = <span class="keyword">is</span></span><br><span class="line"><span class="keyword">args</span>[<span class="number">2</span>] = <span class="keyword">a</span></span><br><span class="line"><span class="keyword">args</span>[<span class="number">3</span>] = <span class="keyword">command</span></span><br><span class="line"><span class="keyword">args</span>[<span class="number">4</span>] = <span class="built_in">line</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息"><a href="#这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息" class="headerlink" title="这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息  "></a>这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息  </h2></blockquote>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main()&#123;</span><br><span class="line">        printMin(&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0.6</span>,&#125;);<span class="comment">//输出：The min value is : 0.6</span></span><br><span class="line">        printMin(new <span class="built_in">double</span>[]&#123;<span class="number">3.2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6.7</span>&#125;)<span class="comment">//输出：The min value is : 3.2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> printMin(doulbe... num)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.length==<span class="number">0</span>)&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"No agument passed"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">double</span> result = num[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]&lt;result)&#123;</span><br><span class="line">                result=num[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"The min value is : "</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个函数中最多只能有一个可变参数，并且要放在参数列表的最后，代码在执行时，编译器会将可变参数编译为一个数组，所以在函数的内部，参数名可以看作是数组名； </p>
</blockquote>
<blockquote>
<h2 id="由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法"><a href="#由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法" class="headerlink" title="由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法"></a>由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法</h2></blockquote>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizationDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Cola cola1 = <span class="keyword">new</span> Cola(<span class="number">1</span>);</span><br><span class="line">        Cola cola2 = <span class="keyword">new</span> Cola(<span class="number">2</span>);</span><br><span class="line">        Cola cola3 = <span class="keyword">new</span> Cola(<span class="number">3</span>);</span><br><span class="line">        cola2 = cola3 = <span class="keyword">null</span>;<span class="comment">//将两对象作废，接下来会被回收</span></span><br><span class="line">        System.gc();<span class="comment">//调用Java垃圾收容器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cola</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cola</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i=i;</span><br><span class="line">        System.out.println(<span class="string">"Cola object "</span>+i+<span class="string">" is created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cola object "</span>+i+<span class="string">" is disposed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//Cola object 1 is created</span></span><br><span class="line"><span class="comment">//Cola object 2 is created</span></span><br><span class="line"><span class="comment">//Cola object 3 is created</span></span><br><span class="line"><span class="comment">//Cola object 2 is disposed</span></span><br><span class="line"><span class="comment">//Cola object 3 is disposed</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>finalize()方法在对象被回收之前调用，它用来清除回收对象，可以用这个方法来确保一个对象打开的文件被关闭，并且该方法需要protected限定其余类不可调用此方法，当然JVM自动完成内存的回收，也可以通过这个方法来手动操作  </p>
</blockquote>
<h2 id="关于文件的Stream-流-与File-文件"><a href="#关于文件的Stream-流-与File-文件" class="headerlink" title="关于文件的Stream(流)与File(文件)"></a>关于文件的Stream(流)与File(文件)</h2><p>-</p>
<h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bWrite = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;<span class="comment">//写入的数据为byte类型</span></span><br><span class="line">            Outputstream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bWrite.length;i++)&#123;</span><br><span class="line">                os.<span class="built_in">write</span>(bWtite[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            os.<span class="built_in">close</span>();</span><br><span class="line">        </span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = is.<span class="built_in">available</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)&#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>((<span class="keyword">byte</span>)is.<span class="built_in">read</span>());<span class="comment">//最终要的要将读取数据强制转换成同类型才能避免乱码</span></span><br><span class="line">            &#125;</span><br><span class="line">            is.<span class="built_in">close</span>();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">"Exception"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FileOutputStream读写文件中容易出现乱码问题，这跟字符集编码无关，主要是要保证读写的类型一致，当然如果不一致也可以通过OutputStramWriter与InputStreamReader来规定相同的编码  </p>
</blockquote>
<h2 id="关于scanner类"><a href="#关于scanner类" class="headerlink" title="关于scanner类"></a>关于scanner类</h2><p>-</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        scanner scan = <span class="keyword">new</span> Scanner(System.in)<span class="comment">//控制台输入</span></span><br><span class="line">        <span class="comment">//scanner scanf = new Scanner(new File(test.text));从文件中读取</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(scan.hasNext())&#123;</span><br><span class="line">        <span class="keyword">String</span> str = scan.next();<span class="comment">//单个字符返回，若是空字符则退出</span></span><br><span class="line">        <span class="comment">//String str1 = scan.nextLine(); 每次读取一行，包含空字符，这时的判断应为scan.hasNextLine()</span></span><br><span class="line">        <span class="comment">//int i = scan.nextInt();如果要接收数据，则为next***() 相应的判断语句也更改</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>scanner类在输入时的字符都是可见的，所以带来了一定的安全问题，故可以使用Console类来实现输入密码的目的，即：</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Console cns = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>console<span class="literal">()</span>;</span><br><span class="line">String userame = cns.read<span class="constructor">Line(<span class="string">"User name: "</span>)</span>;</span><br><span class="line"><span class="built_in">char</span><span class="literal">[]</span> password = cns.read<span class="constructor">Password(<span class="string">"Password: "</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="关于Java异常处理"><a href="#关于Java异常处理" class="headerlink" title="关于Java异常处理"></a>关于Java异常处理</h2><p>-</p>
<h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><blockquote>
<p>1、error–错误: 是指程序无法处理的错误，表示应用程序运行时出现的重大错误。例如jvm运行时出现的OutOfMemoryError以及Socket编程时出现的端口占用等程序无法处理的错误。<br>2、Exception-异常 ：异常可分为运行时异常跟编译异常<br>    -<em>运行时异常</em>：即RuntimeException及其之类的异常。这类异常在代码编写的时候不会被编译器所检测出来，是可以不需要被捕获，但是程序员也可以根据需要进行捕获抛出。常见的RUNtimeException有：NullpointException（空指针异常），ClassCastException（类型转换异常），IndexOutOfBoundsException（数组越界异常）等。<br>    -<em>编译异常</em>：RuntimeException以外的异常。这类异常在编译时编译器会提示需要捕获，如果不进行捕获则编译错误。常见编译异常有：IOException（流传输异常），SQLException（数据库操作异常）等。<br>-</p>
</blockquote>
<h3 id="语句块执行问题"><a href="#语句块执行问题" class="headerlink" title="语句块执行问题"></a>语句块执行问题</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//函数语句</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"catch is begin"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//不被执行</span></span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"finally is begin"</span>);<span class="comment">//被执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//被执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了"><a href="#这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了" class="headerlink" title="这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了"></a>这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了</h2></blockquote>
<h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">Demo</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>throws经常会被用在方法声明后，方法体之前，表明方法可能跑出一个异常，throw经常被用在方法体内，表示此时抛出一个已定义的异常。</p>
</blockquote>
<h2 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h2><p>-</p>
<h3 id="构造器-构造方法或构造函数"><a href="#构造器-构造方法或构造函数" class="headerlink" title="构造器(构造方法或构造函数)"></a>构造器(构造方法或构造函数)</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    father()&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    public father(int i)&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="type">Son</span>()&#123;</span><br><span class="line">        <span class="comment">//super() 自动调用父类的无参构造器</span></span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="type">Son</span>(int i)&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">3</span>)<span class="comment">//主动调用父类的有参构造器，就不再默认调用父类的无参构造器</span></span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="在Son-继承Father-后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器-主动调用，如果有的话-，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器-但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super-参数-否则系统报错"><a href="#在Son-继承Father-后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器-主动调用，如果有的话-，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器-但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super-参数-否则系统报错" class="headerlink" title="在Son()继承Father()后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器(主动调用，如果有的话)，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器,但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super(参数),否则系统报错"></a>在Son()继承Father()后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器(主动调用，如果有的话)，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器,但是<strong><em>如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super(参数),否则系统报错</em></strong></h2></blockquote>
<h3 id="重写-覆盖-中的调用问题"><a href="#重写-覆盖-中的调用问题" class="headerlink" title="重写(覆盖)中的调用问题"></a>重写(覆盖)中的调用问题</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    public void demo()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Father's demo()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    public void demo()&#123;</span><br><span class="line">        <span class="keyword">super</span>.demo();<span class="comment">//此时输出Father's demo()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用"><a href="#如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用" class="headerlink" title="如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用"></a>如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用</h2></blockquote>
<h3 id="转型问题"><a href="#转型问题" class="headerlink" title="转型问题"></a>转型问题</h3><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">Father f1 = <span class="keyword">new</span> <span class="type">Son</span>();<span class="comment">//upcasting(向上转型)f1引用指向Son对象</span></span><br><span class="line">Son s1 = (Son)f1;<span class="comment">//downcasting(向下转型)f1引用仍然指向Son对象</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line"></span><br><span class="line">Father f2 = <span class="keyword">new</span> <span class="type">Father</span>();</span><br><span class="line">Son s2 = (Son)f2;<span class="comment">//错误，子类引用不能指向父类对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>向上转型：子类对象直接赋给父类引用，不用强制转换<br>向下转型：把指向子类对象的父类赋给了子类，需要强制转换</p>
</blockquote>
<h2 id="关于Java重写-Override-与重载-Overload"><a href="#关于Java重写-Override-与重载-Overload" class="headerlink" title="关于Java重写(Override)与重载(Overload)"></a>关于Java重写(Override)与重载(Overload)</h2><p>-</p>
<h3 id="向上转型带来的问题"><a href="#向上转型带来的问题" class="headerlink" title="向上转型带来的问题"></a>向上转型带来的问题</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Animal方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="title">extends</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Cat重写方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Cat特有方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal a1 = <span class="keyword">new</span> Cat();<span class="comment">//向上转型</span></span><br><span class="line">        a.<span class="built_in">move</span>();<span class="comment">//调用Animal自己的move()</span></span><br><span class="line">        a1.<span class="built_in">move</span>();<span class="comment">//调用Cat重写过的move()</span></span><br><span class="line">        a1.jump();<span class="comment">//error 因为a1的引用类型Animal中没有jump()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码中由于Animal中没有jump()方法导致编译失败，但是可以通过强制转型(UP)来访问引用父类中没有但是子类中有的方法或成员变量  </p>
</blockquote>
<blockquote>
<p>方法重写规则中需要注意的几点：<br>    1. 返回类型可以与被重写方法的返回类型不同，但是得是父类返回值的派生类；<br>    2. 访问权限不能比父类被重写方法的访问权限更低，比如父类方法的访问权限为public，子类重写方法后不能为protected或更低；<br>    4. 重写方法不能抛出更更广泛的强制性异常；  </p>
</blockquote>
<h2 id="关于Java多态"><a href="#关于Java多态" class="headerlink" title="关于Java多态"></a>关于Java多态</h2><p>-</p>
<h3 id="静态方法重写问题"><a href="#静态方法重写问题" class="headerlink" title="静态方法重写问题"></a>静态方法重写问题</h3><blockquote>
<p>父类的静态方法被子类重写后，调用问题应该看指向子类对象的是父类引用还是子类引用，如果是父类引用指向子类对象则会调用父类的静态方法，如果是子类引用指向子类对象，则会调用子类的静态方法</p>
</blockquote>
<h2 id="关于Java接口"><a href="#关于Java接口" class="headerlink" title="关于Java接口"></a>关于Java接口</h2><p>-</p>
<h3 id="接口的一些特性"><a href="#接口的一些特性" class="headerlink" title="接口的一些特性"></a>接口的一些特性</h3><blockquote>
<p>-接口的方法都是且只能是public abstract；<br>-接口的成员变量都是且只能是public static final;<br>-Java不支持多继承，但是一个接口可以继承多个接口；<br>-类继承接口必须要实现接口里的全部方法，除非类为抽象类；<br>-如果基本功能在不断改变那么要使用抽象类，因为如果要用接口那么功能改变要更改所有继承这个接口的实体内的方法，<strong><em>这也可以理解abstract表示的是”is-a”的一种关系，interface表示的是”has-a”的一种关系</em></strong>；<br>-JDK1.8以后接口中开始允许出现静态方法和方法体； </p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title">demo</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"这里是interface里的默认实现方法"</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"这里是interface里的静态方法"</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//接口中只允许这两种非抽象方法实现</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用"><a href="#如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用" class="headerlink" title="如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用"></a>如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用</h2></blockquote>
<h3 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">import java.util;</span><br><span class="line">public<span class="built_in"> interface </span>EventListener&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个接口就是监听接口，类似于MouseListener类就继承了这个接口。<br>标记接口存在的目的：<br>1.向一个类添加数据类型，因为不需要实现该类的方法(因为本身就没有方法)；<br>2.建立一个公共的父接口，正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口，它可以使得使用instanceof进行类型查询。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM】类加载机制</title>
    <url>/2020/06/30/%E3%80%90JVM%E3%80%91%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><strong>类加载机制作为Java虚拟机最基础的部分，在学习Java语言是不容忽略的一部分，懂得类加载机制才是深入理解JVM的敲门砖，加油ヽ(.◕ฺˇд ˇ◕ฺ;)ﾉ</strong></p>
<a id="more"></a>
<hr>
<h2 id="什么是类加载机制"><a href="#什么是类加载机制" class="headerlink" title="什么是类加载机制"></a>什么是类加载机制</h2><blockquote>
<p>类加载机制是指将类的.class文件的二进制数据读取到运行时的<strong>数据区的方法区</strong>内,然后在<strong>堆区</strong>内创建一个java.lang.Class对象,用来封装类在方法区内的数据结构,类的加载的最终产品就是位于堆中的Class对象,对象向用户提供了访问方法区内的数据结构的接口。</p>
</blockquote>
<hr>
<h2 id="类加载机制的过程"><a href="#类加载机制的过程" class="headerlink" title="类加载机制的过程"></a>类加载机制的过程</h2><p><img src="https://wx2.sbimg.cn/2020/06/28/2d57R.png" alt="2d57R.png"></p>
<p>类的加载过程分为了五个过程：加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化，其中(验证准备和解析)三个阶段也被成为连接阶段,<strong>这几个阶段是按顺序开始，而并不是按顺序完成，往往这些阶段会交叉的混合运行，一般在某个阶段运行过程中去调用激活另一个阶段</strong>，这里需要注意的是这五个阶段中有四个阶段的发生顺序是确定的（加载-&gt;验证-&gt;准备-&gt;初始化）,但是解析并非一定在顺序中,它有时会在初始化过程之后,这样的目的是为了支持Java语言的动态绑定。接下来我们分别来看一个类加载过程中的每个阶段的内容：</p>
<h3 id="加载（查找并获取字节流）"><a href="#加载（查找并获取字节流）" class="headerlink" title="加载（查找并获取字节流）"></a>加载（<strong><em>查找并获取字节流</em></strong>）</h3><blockquote>
<ol>
<li>通过类的全限定名来获取其定义的二进制字节流；    </li>
<li>将这个字节流所代表的静态存储结构转为方法的运行时的数据结构；</li>
<li>在Java堆中生成一个代表这个类的Java.lang.Class对象，作为方法区中这些数据的访问入口。   </li>
</ol>
</blockquote>
<p>这几个步骤是JVM需要在这个阶段完成的三件事情，相比于其他几个阶段来说，<strong>加载阶段（准确的说应该是加载获取类的二进制字节流的动作）是可控性最强的阶段</strong>，因为在这个阶段，开发人员可以利用系统提供的类加载器来加载，也可以使用自己定义的类加载器进行加载。<strong>加载阶段完成后JVM外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，并且创建了一个对应的java.lang.Class对象，用来访问这些数据</strong>。加载的具体方式和类加载器在后面的模块中解释。   </p>
<h3 id="验证（确保类加载的正确性）"><a href="#验证（确保类加载的正确性）" class="headerlink" title="验证（确保类加载的正确性）"></a>验证（<strong><em>确保类加载的正确性</em></strong>）</h3><blockquote>
<ol>
<li>文件格式验证：验证字节流是否符合文件的规范；   </li>
<li>元数据验证：对字节码的描述的信息进行语义分析，以保证其描述的信息符合语言规范的要求；</li>
<li>字节码验证：通过数据流和控制流分析，保证程序的语义合法逻辑；</li>
<li>符号引用验证：确保解析动作能够正确执行。   </li>
</ol>
</blockquote>
<p><strong>验证是连接阶段的第一步，这一步是为了确认Class文件字节流符合当前JVM的需求，并且不会危害到JVM本身的安全</strong>，所以进行了如上四个方面的验证动作，值得注意的是，<em>验证并不是必需的阶段，它不会影响到程序的运行，所以如果类进行了反复的验证，那么完全可以通过参数Xverifynone来关闭大部分的验证措施，从而缩短虚拟机加载类的时长。</em></p>
<h3 id="准备（为静态变量分配内存和初始化）"><a href="#准备（为静态变量分配内存和初始化）" class="headerlink" title="准备（为静态变量分配内存和初始化）"></a>准备（<strong><em>为静态变量分配内存和初始化</em></strong>）</h3><p><strong>准备阶段是为类的静态变量分配内存，并将其初始化为默认值</strong>，但是要注意：</p>
<blockquote>
<ol>
<li><em>这里分配内存仅是为类的静态变量，并不包括类中的实例变量，这个将在以后的对象实例化中分配到堆中</em>；</li>
<li><em>这里所说的初始化为默认值是指将对应的变量类型赋予对应的0值，如0、null、false等，而不是初始化为用户设置的变量值，将变量赋值为用户定义数值是在初始化阶段才做的工作</em>;  </li>
<li>全局变量如果没有显示的对其赋值，那么在使用时将会用到准备阶段为其赋予的0值，当然局部变量必须显示的赋值，否则编译是不通过的；</li>
<li>对于引用类型来说，如数组的引用或对象的引用，如果都没有对其进行显示的赋值而使用，那么都将用到系统为其赋予的0值null；</li>
<li>同时被static与final修饰的值将在此阶段就被赋予显示的初始值，也就是在编译期间就已经将其结果放到了调用它的类的常量池中了。</li>
</ol>
</blockquote>
<h3 id="解析（符号引用转为直接引用）"><a href="#解析（符号引用转为直接引用）" class="headerlink" title="解析（符号引用转为直接引用）"></a>解析（<strong><em>符号引用转为直接引用</em></strong>）</h3><p>解析阶段是虚拟机将常量池中的符号引用（<em>主要是类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符7种</em>）转化为直接引用的过程。其中直接引用就是一个直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p>
<h3 id="初始化（为类的静态变量赋予真正的初始值）"><a href="#初始化（为类的静态变量赋予真正的初始值）" class="headerlink" title="初始化（为类的静态变量赋予真正的初始值）"></a>初始化（<strong><em>为类的静态变量赋予真正的初始值</em></strong>）</h3><p>JVM对静态变量初始化的两种方式：</p>
<blockquote>
<ol>
<li>声明类变量是指定初始值；</li>
<li>使用静态代码块为类变量指定初始值。   </li>
</ol>
</blockquote>
<p>JVM初始化的步骤为：</p>
<blockquote>
<ol>
<li>若初始化的这个类还没有进行加载和连接，那么先将类进行加载和连接；</li>
<li>若初始化的这个类的父类还没有进行初始化，则先去初始化父类；</li>
<li>若初始化的这个类中有初始化语句，则系统依次执行这些初始化语句。</li>
</ol>
</blockquote>
<p>类初始化的时机：(对类进行主动调用的时候)</p>
<blockquote>
<ol>
<li>创建类的实例，及new一个对象；</li>
<li>访问某个类或接口的静态变量或对静态变量进行赋值时；</li>
<li>调用某个类的静态方法时；</li>
<li>某个类的子类被初始化时;</li>
<li>使用反射方式强制创建某个类或接口对应的java.lang.Class对象；</li>
<li>JVM启动时被标明为启动类的类；</li>
</ol>
</blockquote>
<p>初始化总结：   </p>
<blockquote>
<p>初始化是类加载机制的最后一个阶段，本阶段才真正意义上执行了class内部代码，但是其实这也只是执行类构造器<clinit>()方法，所以说，执行代码也只是一个开端。</p>
</blockquote>
<hr>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="定义及一些分类与关系"><a href="#定义及一些分类与关系" class="headerlink" title="定义及一些分类与关系"></a>定义及一些分类与关系</h3><p>提到类加载机制就不得不提到类加载器，，它是用在类加载机制的第一个阶段-加载，一个类在JVM中的唯一性依赖于类与其类加载器，即使两个类来源于同一个class文件，但是由于类加载器的不同也让两个类在JVM中是两个不同的存在。并且在加载阶段类加载器获取二进制字节流并非只在Class文件中，还可以从jar包中以及网络和其他文件生成。其种类可分为如下：</p>
<blockquote>
<p><em>以虚拟机的角度</em>：   </p>
<ol>
<li><strong>启动类加载器</strong>:它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分。</li>
<li><strong>所有其他的类加载器</strong>：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。   </li>
</ol>
</blockquote>
<blockquote>
<p><em>以开发人员的角度</em>:</p>
<ol>
<li><strong>启动类加载器</strong>：Bootstrap-ClassLoader，跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap-ClassLoader加载）,并且启动类加载器是无法被Java程序直接引用的。</li>
<li><strong>扩展类加载器</strong>：Extension-ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li>
<li><strong>应用程序类加载器</strong>：Application-ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ol>
</blockquote>
<p>一般应用程序的加载都是由这三种类加载器互相协作完成的，<em>当然也可以加入自定义的ClassLoader，因为JVM自带的ClassLoader只是在本地文件系统加载标准的java class文件</em>。其实在使用Applet时就用到了自定义的ClassLoader，因为它需要加载网络上的Java class文件，并且可以做到:   </p>
<ol>
<li>在执行非置信代码之前，自动验证数字签名。</li>
<li>动态地创建符合用户特定需要的定制化构建类。</li>
<li>从特定的场所取得java class，例如数据库中和网络中。   </li>
</ol>
<p>这样可以检验相关的安全信息，应用服务器也大都使用了自定义ClassLoader技术。</p>
<h3 id="几种类加载器的层级关系"><a href="#几种类加载器的层级关系" class="headerlink" title="几种类加载器的层级关系"></a>几种类加载器的层级关系</h3><p><a href="https://sbimg.cn/image/2smPO" target="_blank" rel="noopener"><img src="https://wx2.sbimg.cn/2020/06/28/2smPO.png" alt="2smPO.png"></a><br>这种层级关系称为<strong>双亲委派模型</strong>，每一层类加载器的上一层为其父加载器，但是，它们的这种关系不是通过继承实现的，而是通过组合关系来复用父加载器中的代码的。这就不得不提到JVM类加载的3种机制了：</p>
<blockquote>
<ol>
<li>父类委托：当收到类加载请求时，先让父类进行加载，也就是一直到顶层的启动类加载器向下，只有当父类无法加载时，子类类加载器才会尝试从自己的类路径中加载；</li>
<li>全盘负责：当一个类加载器负责加载某个类时，该类的所依赖和引用的其他类也将由该类加载器全权负责，除非显示的使用另一个类加载器；</li>
<li>缓存机制：该机制会保证所有加载过的类都会被缓存，当需要加载某个类时，类加载器会先从缓存区中寻找是否有该类，若无，系统才会加载该类并放入缓存区。这也解释了为什么修改了类之后需要重新启动JVM新的类才会生效。   </li>
</ol>
</blockquote>
<h3 id="双亲委派机制："><a href="#双亲委派机制：" class="headerlink" title="双亲委派机制："></a>双亲委派机制：</h3><blockquote>
<p>1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。<br>2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。<br>3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；<br>4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</p>
</blockquote>
<p>这里给出<strong><em>双亲委派机制的源码</em></strong>以便于更好的理解双亲委派机制的作用原理：   </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public Class&lt;?&gt; load<span class="constructor">Class(String <span class="params">name</span>)</span>throws ClassNotFoundException &#123;</span><br><span class="line">            return load<span class="constructor">Class(<span class="params">name</span>, <span class="params">false</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected synchronized Class&lt;?&gt; load<span class="constructor">Class(String <span class="params">name</span>, <span class="params">boolean</span> <span class="params">resolve</span>)</span>throws ClassNotFoundException &#123;</span><br><span class="line">            Class c = find<span class="constructor">LoadedClass(<span class="params">name</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (c<span class="operator"> == </span>null) &#123;  <span class="comment">//判断类是否已经被加载</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != null) &#123;<span class="comment">//如果该加载器有父类，则传递给父类加载器加载</span></span><br><span class="line">                        c = parent.load<span class="constructor">Class(<span class="params">name</span>, <span class="params">false</span>)</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span></span><br><span class="line">                        c = find<span class="constructor">BootstrapClass0(<span class="params">name</span>)</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;<span class="comment">// 如果无父类加载器并且启动类加载器都不能加载，则调用自身的加载功能</span></span><br><span class="line">                    c = find<span class="constructor">Class(<span class="params">name</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolve<span class="constructor">Class(<span class="params">c</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里给出几个ClassLoader加载的Demo：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package First;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> Demo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String<span class="literal">[]</span> args) throws ClassNotFoundException &#123;</span><br><span class="line">		ClassLoader loader = <span class="module-access"><span class="module"><span class="identifier">HelloWorld</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ClassLoader()</span>;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(loader);</span><br><span class="line">		loader.load<span class="constructor">Class(<span class="string">"First.Text"</span>)</span>;  <span class="comment">//loader.loadClass()的方式加载类 默认不执行初始化块</span></span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"First.Text"</span>)</span>;  <span class="comment">//Class.forNmae()的方式加载类 默认执行初始化块</span></span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"First.Text"</span>, <span class="params">false</span>, <span class="params">loader</span>)</span>;  <span class="comment">//Class.forNmae()指定类加载器的方式 默认不执行初始化块(false)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package First;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"执行静态代码块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">jdk.<span class="built_in">int</span>ernal.loader.ClassLoaders$<span class="symbol">AppClassLoader@</span><span class="number">3</span>a71f4dd</span><br><span class="line">执行静态代码块</span><br></pre></td></tr></table></figure>
<h3 id="这里记录一个坑"><a href="#这里记录一个坑" class="headerlink" title="这里记录一个坑"></a>这里记录一个坑</h3><p>在普通的使用loader.loadClass(ClassNmae)或Class.forName(ClassName)或指定加载器的加载类时若ClassName只填写类名称将抛出ClassNotFoundException异常。<br><strong>解决方法</strong>:同一个包中的类虽然可以直接引用但是由于类名前的包名已由编译器加载上去了，所以在通过这几个方法加载类时，如果不加包名则会默认在default中寻找，自然也就找不到了，所以在ClassName前应该加上包名，问题就解决了。   </p>
<blockquote>
<p><strong>三种类加载方式的不同</strong>：<br>1 . ClassLoader.loadClass(ClassName)方式默认只是将其加载到JVM中而不会去加载类的静态代码块，只有等到new Instance时才会去执行；<br>2 . Class.forName(ClassName)方法是将类的.class文件加载到JVM中并对类进行解释，执行类的静态代码块；<br>3 . Class.forNmae(ClassName, Initialize, Loader)这种类加载方式是使用指定的类加载器进行加载类，并且可以指定是否执行类的静态代码块。   </p>
</blockquote>
<hr>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本篇对于类加载机制通过累加载机制的过程将5个阶段的任务以及相关的机制原理以及所用到的一些外部实体做了解释，我们可以看到，在整个类加载机制的过程中，只有类加载阶段可以由用户控制，即使用指定的类加载器进行加载，其余的阶段都是由JVM所控制的，并且类加载机制的结束仅仅是代码运行的一个开端，所以说，类加载机制也仅仅是将类文件加载到JVM的内存中，只有在类加载结束后，才真正的开始执行字节码的操作。</p>
<p>参考：<br>《深入理解JAVA虚拟机》<br><a href="https://www.cnblogs.com/ityouknow/p/5603287.html" target="_blank" rel="noopener">https://www.cnblogs.com/ityouknow/p/5603287.html</a></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】Java设计模式(记忆点)</title>
    <url>/2020/05/27/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>这里是初读程杰老师的《大话设计模式》得到的一些对应模式应用场景的简单总结,后期深读时会继续更新设计模式系列的博文哒✪ω✪</strong></p>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/06/15/VUPQWpBE9hdLxl2.jpg" alt="IMG_7799.jpg"></p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote>
<p><strong><em>策略模式用来封装算法，当遇到不同时间使用不同时可以使用策略模式</em></strong>   </p>
</blockquote>
<blockquote>
<p>虽然当业务变更时仍需要改变Text里的switch语句中的判断条件，但是任何需求的变更都是需要成本的<br>—</p>
</blockquote>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><blockquote>
<p><strong><em>装饰模式就是为已有功能动态添加更多功能的一种方式，当代码需要新功能时不必向主类中添加代码从而增加主类的复杂度，可以使用修饰类来完成这个功能</em></strong></p>
</blockquote>
<hr>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote>
<p><strong><em>代理模式的应用场景：1.远程代理，即为一个对象在不同的地址空间提供局部代表，从而可以隐藏对象在不同地址空间的事实；2.虚拟代理，是根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象如HTML网页中的大量图片信息；3.安全代理，用来控制真实对象的访问权限；4.智能指引，指在调用真实的对象时代理处理另外一些事</em></strong></p>
</blockquote>
<hr>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote>
<p><strong><em>工厂方法定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂模式使一个类实例化延迟到了子类。相比于简单工厂的添加功能需要修改工厂的switch语句，这违背了开-闭原则，所以引入了工厂模式，它将修改的代码从普通类移动到了客户端</em></strong>   </p>
</blockquote>
<hr>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><blockquote>
<p><strong><em>原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。一般在初始化信息不变的的情况下，克隆是最好的方法，既隐藏了初始化的细节，又是对性能的极大提高</em></strong></p>
</blockquote>
<hr>
<h2 id="模版模式"><a href="#模版模式" class="headerlink" title="模版模式"></a>模版模式</h2><blockquote>
<p><strong><em>模版模式提供了一个代码复用的平台，通过模版模式将一些单一的行为整合到一个单一的地方，这样使子类摆脱了重复单一行为的纠缠</em></strong></p>
</blockquote>
<hr>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><blockquote>
<p><strong><em>迪米特法则指出如果两个类不必彼此直接通信，那么它们就不应该直接发生相互作用，如果其中一个类需要调用另一个类的方法的话，那么可以通过第三方转发这个调用</em></strong>   </p>
</blockquote>
<blockquote>
<p>迪米特法则根本思想其实强调了类之间的松耦合</p>
</blockquote>
<hr>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><blockquote>
<p><strong><em>外观模式为子系统的一组接口提供了一致的界面，此模式定义了一个高层接口，这个接口使得这个子系统更加容易使用</em></strong>   </p>
</blockquote>
<blockquote>
<p>外观模式用一个高层接口使得原本设计粗糙且复杂的遗留代码有了一个清晰的接口，这样让新的系统更加容易与其交互</p>
</blockquote>
<hr>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><blockquote>
<p><strong><em>建造者模式将一个复杂对象的构建与表示分离，这样使得同样的构建过程可以创建不同的表示</em></strong>   </p>
</blockquote>
<blockquote>
<p>建造者模式的Builder定义了抽象的建造过程，使得实例化的建造可以不遗漏建造过程（遗漏的话是不能通过编译的）,与此同时创建Director类可以用来创建具体的想要创建的对象</p>
</blockquote>
<hr>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote>
<p><strong><em>观察者模式一般使用在当一个对象改变同时需要改变其他对象时，并且并不知道具体有多少对象需要改变，观察者模式的工作其实就是在接触耦合，使得耦合双方依赖于抽象而非具体，从而使得各自的变化不回影响另一个的变化</em></strong></p>
</blockquote>
<hr>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><blockquote>
<p><strong><em>抽象工厂模式提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类</em></strong></p>
</blockquote>
<hr>
<h2 id="三种工厂模式对比"><a href="#三种工厂模式对比" class="headerlink" title="三种工厂模式对比"></a>三种工厂模式对比</h2><blockquote>
<p><strong>简单工厂模式</strong>:生产一个有多种款式的对象，对象通用抽象父类，用Switch决定实例化哪一种款式的对象；<br><strong>工厂模式</strong>：生产一个有多重款式的对象，对象通用抽象父类，每种款式有其特定的生产工厂，它们都继承一个工厂接口，在客户端种决定用哪一个特定工厂来实例化工厂，这将实例化延迟到了客户端；<br><strong>抽象工厂模式</strong>：生产多个有多种款式的对象3应其抽象父类，多个对象用多个特定工厂来连接工厂接口，接口里对应了每个款式对应的对象创建实例</p>
</blockquote>
<hr>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><blockquote>
<p><strong><em>状态模式:当一个对象的行为取决于它的状态，并且它必须在运行时刻根据自己的状态来改变自己的行为的时候可以考虑使用状态模式</em></strong>   </p>
</blockquote>
<blockquote>
<p>由于对于状态来判断行为会含有很长的判断语句，这将是long method其实就已经有了坏味道，这违反了单一职责和开-闭原则，状态模式说白了就是将很长的判断语句分离开来，以便后期修改与维护</p>
</blockquote>
<hr>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote>
<p><strong><em>适配器模式：适配器类继承适配目标的父类，被适配作为适配器的内部对象变量，在构造函数时将其实例化，然后将目标父类的函数内部调用被适配的对象的相对应的内方法</em></strong></p>
</blockquote>
<hr>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><blockquote>
<p><strong><em>备忘录模式：在需要进行存储备忘录的类里添加保存备忘录的方法，并将需要保存的属性加入，由于对备忘录的封装属性最好再加备忘录管理者类，通过管理者类来对备忘录进行存储和使用</em></strong></p>
</blockquote>
<hr>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote>
<p><strong><em>组合模式：将对象组合成树形结构，以表示它们之间的额“整体-部分”的层次结构，组合模式使得客户对单个对象和组合对象的使用具有一致性</em></strong>   </p>
</blockquote>
<blockquote>
<p>当发现需求中是整体与部分的结构层次时，并且客户可以忽略组合对象与单个对象之间的关系，从而统一的使用组合结构中的所有对象时就可以考虑使用组合模式了</p>
</blockquote>
<hr>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><blockquote>
<p><strong><em>迭代器模式：提供了一个方法可以顺序的访问某聚合类型里的各个元素，而又不暴露各个对象的内部表示</em></strong>   </p>
</blockquote>
<blockquote>
<p>很多语言中已经不再显式的使用迭代器模式而是已经把这个模式做到了语言当中例如foreach in循环或者枚举类型，但是迭代器模式还是拥有它本身的优点，比如可以自己定义一种循环方式，而不是简单的进行顺序遍历</p>
</blockquote>
<hr>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p><strong><em>单例模式：为了确保类被一次且只能被实例化一次，并且提供获取此实例的方法 一般来说不建议使用懒汉方式，一般使用饿汉方式，在明确要用lazy loading时会使用登记模式，如果涉及到反序列化创建对象时可以考虑使用枚举方式，如果有特殊需求可以使用双检锁方式</em></strong></p>
</blockquote>
<hr>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><blockquote>
<p><strong><em>桥接模式：由于大量的继承会导致更改影响大难以更新维护，违背了开-闭原则，所以也就是当多角度分类时，就可以将这些类分离出来，这种时候使用合成/聚合复用原则，尽量不使用继承</em></strong>   </p>
</blockquote>
<blockquote>
<p>可以这样想：猪八戒投胎，灵魂在河的一边，河对面有两个肉体，红猪和绿猪；灵魂需要过桥，选择红猪的肉体或者绿猪的肉体完成投胎。在上面的例子中，红猪和绿猪就是 HandsetGame 和 HandsetPhone，灵魂是 HandsetBand 类，而那座桥就是 HandsetBand 这个接口。</p>
</blockquote>
<hr>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><blockquote>
<p><strong><em>命令模式：把请求一个操作的对象与它怎么执行一个操作的对象分割开来，这样在程序中请求者和实现者分割开来，可以方便的加入一个新的命令，并且降低了系统的耦合度</em></strong></p>
</blockquote>
<hr>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><blockquote>
<p><strong><em>责任链模式有点类似于迭代器模式，一个对象管理对应的业务，超出范围则转入下一个对象管理，以此类推</em></strong></p>
</blockquote>
<hr>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><blockquote>
<p><strong><em>中介者模式是将很多实体之间的交互封装在一个特定的类当中，使得类之间松耦合，一般应用于一组定义良好但是复杂的方式进行通信的场合，但是由于中介者模式的特点使得中介者类很复杂难以维护</em></strong></p>
</blockquote>
<hr>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote>
<p><strong><em>享元模式是在一个程序需要创建大量的对象并且这些对象大多数的状态都可以是外部状态时就可以考虑使用享元模式，享元模式是通过对象生产工厂生产出来具有内部状态的对象，然后提供给不同用户赋予对象外部状态来使用，，这样避免了大量的创建对象而造成的占用大量的空间问题</em></strong></p>
</blockquote>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java】静态类型与实际类型</title>
    <url>/2020/07/02/%E3%80%90Java%E3%80%91%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>Java的静态类型与实际类型的相关问题，同时有助于理解Java中的转型问题 (๑´ڡ`๑)</strong></p>
<a id="more"></a>
<h2 id="代码观察"><a href="#代码观察" class="headerlink" title="代码观察"></a>代码观察</h2><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Father do it"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="title">extends</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Son do it"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(Father father)</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"Father say Hi"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(Son son)</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"Son say Hi"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		Text t = <span class="keyword">new</span> Text();</span><br><span class="line">		Father f = <span class="keyword">new</span> Son();</span><br><span class="line">		f.doIt();</span><br><span class="line">		t.sayHi(f);</span><br><span class="line">		System.out.<span class="built_in">println</span>(f.getClass());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><blockquote>
<p>Son do it<br>Father say Hi<br>class Second.Text$Son</p>
</blockquote>
<h2 id="相关解释"><a href="#相关解释" class="headerlink" title="相关解释"></a>相关解释</h2><blockquote>
<p>在本段代码中Father f = new Son()实例化时<strong>Father为静态类型，Son为实际类型</strong>，并且<strong>静态类型在编译期间就是可知的，而实际类型要等到运行期间才可知</strong>，Son（）中的doIt（）方法重写了父类中的此方法，而最后执行结果是调用的子类的方法，这说明方法的<strong>重写是动态的</strong>，以此类推当f作为参数传入时是作为father这个静态类型传入的，因为结果调用的father的方法，这也说明了<strong>重载是静态的的</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【置顶】和我的Blog认识一下吧</title>
    <url>/2022/07/03/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E5%92%8C%E6%88%91%E7%9A%84Blog%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%8B%E5%90%A7/</url>
    <content><![CDATA[<p><strong>Hi～欢迎来到小贺同学的blog，如果你不知道怎么来了解它的话先来康康我吧 o‿≖✧</strong></p>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>做这个blog的初心呢是想记录着自己在技术所做出的努力所带来的一些成果，也想用它来激励自己，还有就是想和你们交流啦，自从开始做撸码肥宅之后感觉真的是越来越和大家脱轨了，很多很多的想法想跟你们讲却又苦于如何开口，所以我就把它们都写在了这，希望能与你们共勉。（大家一定要来找我玩  (;´༎ຶД༎ຶ`)  ）还有就是因为我目前对于前端开发语言和框架不太熟悉，所以blog是建立在了前人开发的基础上做起来的，所以很遗憾很多想要实现的功能和想要更换的布置还没办法去完成，在后端开发学习进度不错的情况下将会将会对前端开发进行学习，如果有什么大家希望博客改进/改错的地方或者想要看那些方面的blog内容分享还烦请跟我联系喔～总之希望和大家一起成长～</p>
</blockquote>
<hr>
<h2 id="Blog导航"><a href="#Blog导航" class="headerlink" title="Blog导航"></a>Blog导航</h2><h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><p><img src="https://wx1.sbimg.cn/2020/07/03/2nWck.png" alt="2nWck.png"></p>
<blockquote>
<p>这里是通过索引和分区快速找到你感兴趣的blog的地方，它们的作用是这样</p>
<ol>
<li>首页：如果你不知道现在在哪那就一键首页吧，带你回到最初的这个样子；</li>
<li>分类：这里我目前把学习与生活分成了两个分区，你可以只挑你感兴趣的分区浏览喔；</li>
<li>归档：以时间轴为线整合了所有文章的地方；</li>
<li>搜索：通过关键字快速寻找文章（目前踩坑还未出坑）</li>
</ol>
</blockquote>
<h3 id="信息栏"><a href="#信息栏" class="headerlink" title="信息栏"></a>信息栏</h3><p><img src="https://wx1.sbimg.cn/2020/07/03/2nZVh.png" alt="2nZVh.png"></p>
<blockquote>
<p>点击左下角的菜单小图标将会显示Blog的信息栏，在这里你可以选择从哪里联系我（这个方面还比较鸡肋，后期会更新）还可以听一下我为Blog设定的BGM音乐并且还可以点击最下方的小箭头直接回到网页头部</p>
</blockquote>
<h2 id="分类导航"><a href="#分类导航" class="headerlink" title="分类导航"></a>分类导航</h2><blockquote>
<p>学习区：当然是博客的重头戏啦，我将按照我的Java开发路线进行不断前进，所以写技术博客就是对自己最好的督促了，我希望大家有兴趣的话可以跟着我的路线共勉，另外，大多数博客都是作为我在书籍或者网络上学习后写下来的学习笔记，所以若有不足或者错误之处还请不吝赐教，我也更希望大家可以跟我一起交流相关的开发知识，一起前进啦QAQ</p>
</blockquote>
<blockquote>
<p>生活区：喜欢的影音作品、好的App和实物的安利、对于某些作品及事物的观点看法、觉得不错的书籍推荐等等等等包罗万象的生活区将会是我更新日常的主阵地啦，还请大家多多联系我找我玩哦~。</p>
</blockquote>
<h2 id="文章导航"><a href="#文章导航" class="headerlink" title="文章导航"></a>文章导航</h2><blockquote>
<p>在更新的所有文章中我均设立了对应的目录结构，所以我在文章中对于各级标题都做了严格的梳理，所以既可以完整的阅读文章也可以通过目录结构直接定位到要阅读的部分～</p>
</blockquote>
<h2 id="更新计划"><a href="#更新计划" class="headerlink" title="更新计划"></a>更新计划</h2><p>更新原则（我要日更！！！）   </p>
<blockquote>
<ol>
<li>学习区：是将会在周日-周五每天更新至少一篇学习区的博客文章以督促自己的学习进度，周六将会着重复习和消化本周及之前的文章内容所以将不更新学习区的博客文章；</li>
<li>生活区：这个作为不定时更新的博客栏目所以会在有想分享或者想和大家交流以及当天目标完成比较早的时候（偷懒的时候）更新，更新的形式与篇幅均不确定。</li>
</ol>
</blockquote>
<h2 id="更新预告"><a href="#更新预告" class="headerlink" title="更新预告"></a>更新预告</h2><blockquote>
<p>由于小贺还是个技术萌新，所以Java的开发路线先按照编程基础进行：</p>
</blockquote>
<ul>
<li>目前继续更新JVM的相关内容</li>
<li>接着是并发以及多线程的相关知识</li>
<li>之后是完善数据结构与的相关内容</li>
<li>计算机网络这个大块的内容</li>
<li>…(完成后将更新此块内容)</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
  </entry>
  <entry>
    <title>【看法分享】浅谈考研</title>
    <url>/2020/06/30/%E3%80%90%E7%94%9F%E6%B4%BB%E5%8C%BA%E3%80%91%E6%9C%AC%E7%A7%91%E5%9C%A8%E8%AF%BB%E7%94%9F%E6%B5%85%E8%B0%88%E8%80%83%E7%A0%94/</url>
    <content><![CDATA[<p><strong>本科毕业考研一定是个不错的选择吗？我到底适不适合考研？大家都在互劝考研之时，本科在读生与你分享一些对考研的认知和建议，给你不一样的声音（●&gt;∀&lt;●）</strong></p>
<a id="more"></a>
<hr>
<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p><strong>最近恶补JVM的深入理解搞的有点头晕目眩，这会就偷懒一下写一点关于我对考研这条路的理解，希望能和大家一起交流，这仅仅代表我个人看法，不建议作为大家的决定参考。</strong></p>
<hr>
<h2 id="大家怎么说？"><a href="#大家怎么说？" class="headerlink" title="大家怎么说？"></a>大家怎么说？</h2><p>考研这个问题呢相信是在看这篇blog的你我都很关注的问题，我在很多很多场合和很多很多朋友都有交流过类似的问题，这些问题都有个通常的开头：你准备考研吗？我通常的回答：我大概率是不考研的。大家这时候往往开始用一些我们都听出茧的理由diss我，比如：<br><img src="https://wx1.sbimg.cn/2020/06/30/2tegO.png" alt="2tegO.png"><br>稍微做个总结把：</p>
<blockquote>
<ol>
<li>感觉不考研就找不到工作</li>
<li>感觉大家都考研了 不考就落下了</li>
<li>本科学的很鸡肋 需要考个研补一补</li>
<li>全村的希望 学历越高越牛X</li>
<li>想要找个好工作</li>
<li>靠 不知道本科毕了业能干什么<br>。。。   </li>
</ol>
</blockquote>
<p>所以针对这些普遍的疑问，就几个方面谈一谈我的理解吧</p>
<hr>
<h2 id="考研的目的"><a href="#考研的目的" class="headerlink" title="考研的目的"></a>考研的目的</h2><h3 id="研究生毕业真有那么香？"><a href="#研究生毕业真有那么香？" class="headerlink" title="研究生毕业真有那么香？"></a>研究生毕业真有那么香？</h3><p>暂且不谈论考研能否上岸问题，就考研的目的来讲只有很少数人是想从事科研方向才选择考研的，而大部分人是想利用研究生这个敲门砖走进自己理想工作的大门的，这个目的好吗？当然没错，没有人不想找到好工作，更没有人不想拿到更高的文凭。<br><strong>那么问题就来了！读研后真的能找到更好的工作？我拿一位已经毕业工作多年的华中科技大学的学长的经历跟大家分享一下：</strong></p>
<blockquote>
<p>这位学长自己导师手下毕业的小伙伴共5个，有两个去了某互联网厂做开发，有一个去了某通信厂的销服岗，另外一个也去了某通信厂，不过也是做开发，<strong>有且仅有一个</strong>小伙伴去了某算法研究院继续做图像相关的算法。   </p>
</blockquote>
<p>这段历程表面能看到的就是这样算下来，从事老本行图像相关算法研究的也只有一个，不严谨的计算也就是只有20%的比例。是的20%，并且唯一的20%是作为研究型人才的成神道路。也就是说每个人还是一样在IT基层做起了开发工作，<strong>并且比本科生要晚了3年</strong>。你能想象这三年本科生在这个技术岗上积累了多少东西了吗？面个试就盯你文凭？兄弟醒醒了</p>
<h3 id="鱼与熊掌整一套？"><a href="#鱼与熊掌整一套？" class="headerlink" title="鱼与熊掌整一套？"></a>鱼与熊掌整一套？</h3><p>我现在大二刚刚结业，也拿到了大三的课程信息，当我看见的第一眼便心里暗自发问：C#？What fuck？合着大一C++、大二Java、到了大三又拿起了C#？这是学校带着我们集体摸鱼？大四学什么？Python？学了一年的Java突然来了C语言版的数据结构？所以对于学校课程的安排我心里只能默念我<strong><strong>***</strong></strong>，没办法，学校有学校自己的理由，我们不得不去接受，所以按照学校的步伐我的简历可以怎么写呢：<br>1.了解C++；<br>2.了解Java；<br>3.了解C#；<br>4.了解Python；<br>所以，到底会干嘛？我甚至还没有校外培训班的同学们会的多？学这么多语言还都是了解级别的，我教大家初识变成语言？我不知道考上研之后的课程是怎样的我也不敢多想，所以我想说：<strong>文凭和技术真的不能兼得</strong>（我不否认神级别的大牛能做到，但是不抬杠，仅仅个人想法，Peace）但是作为计算机专业的人来讲，<strong>因为学校不会教你Git SVN Maven Gradle怎么用，不会教你什么是Spring开发框架 什么是Nginx Tomcat Jetty Undertow，什么是中间件缓存技术，什么是Rocket消息队列，什么是RPC框架，什么数据库的链接是Druid，ORM层数据库框架，什么是MyCat分库分表，什么是分布式/微服务熔断降级网关服务调用负载均衡分布式事务链路追踪和监控日志分析容器技术容器排版技术</strong>你说你研究生再学完？那我瑞斯拜！<br><strong>大家都知道，搞开发是一碗青春饭，这碗饭过了青春就某的吃了，中年危机不是危言耸听，大家可以去了解一下很多中年程序员的经历分享你就有答案了。更不容忽略的是，搞开发真的看文凭吗？根据众多领英的人才分享来看，开发真的重点看技术能力，而不是你是不是研究生的学历。</strong></p>
<hr>
<h2 id="考研的难度"><a href="#考研的难度" class="headerlink" title="考研的难度"></a>考研的难度</h2><h3 id="扩招了研究生好考了？"><a href="#扩招了研究生好考了？" class="headerlink" title="扩招了研究生好考了？"></a>扩招了研究生好考了？</h3><p>给数据：<br><img src="https://wx2.sbimg.cn/2020/06/30/2tO1l.jpg" alt="2tO1l.jpg"><br><img src="https://wx1.sbimg.cn/2020/06/30/2tSE1.jpg" alt="2tSE1.jpg"><br>官方数据及预测：</p>
<blockquote>
<p>2019年考研报名人数为290万人，报录比预计为3.6：1，较2018年有明显的提升。<br>2020年考研报名人数再次上涨，共计 341万，特殊原因大幅扩招，报录比为3.4：1，勉强和去年持平。<br>预测：根据今年情况，预测2021年研究生报考人数有望突破400w，但招生人数涨幅应该不会太大。在这一情况下，2021年的考研报录比很可能会飙升至4:1!将创历史新高！</p>
</blockquote>
<h3 id="我不怕？"><a href="#我不怕？" class="headerlink" title="我不怕？"></a>我不怕？</h3><p><strong>你想，你仔细想，你以为你好好肝个一年就能肝考上清北考上华科考上复旦同济了？现在数据流通这么强，很多很多的同学越来越早的准备考研了，甚至于大一就开始了一门心思的考研，所以说这个竞争力一点点都不亚于高考。越早准备读研你就越早将你的赌注放到了这个上面，如果失利，你失去的要比你看到的多得多。具体参考上一章节鱼与熊掌来一套。</strong></p>
<h3 id="二战？三战？"><a href="#二战？三战？" class="headerlink" title="二战？三战？"></a>二战？三战？</h3><p><strong>赌注挺大，直接赌上了一切了，你要考不上清北感觉完全亏了昂，这个时间成本要是会算账的话自己心里悄悄算一下就知道亏了多少了，对于这种情况我只能Good luck！</strong></p>
<h3 id="祝福"><a href="#祝福" class="headerlink" title="祝福"></a>祝福</h3><p><strong>这里也希望正在考研或者准备考研的同学顺利上岸！！</strong><br><img src="https://wx2.sbimg.cn/2020/06/30/2wmoY.jpg" alt="2wmoY.jpg"></p>
<hr>
<h2 id="我到底适不适合读研"><a href="#我到底适不适合读研" class="headerlink" title="我到底适不适合读研"></a>我到底适不适合读研</h2><h3 id="什么样的人适合读研"><a href="#什么样的人适合读研" class="headerlink" title="什么样的人适合读研"></a>什么样的人适合读研</h3><p><strong>首先</strong></p>
<blockquote>
<p>我认为最适合读研的就是热衷于科技研究有着把自己专业深挖创新突破的人，这也是我很尊重的一类人，乐于把精力奉献在科研工作的人都很值得敬仰。</p>
</blockquote>
<p><strong>其次</strong></p>
<blockquote>
<p>你的大学文凭真的阻挡住了你进入理想工作大门的人，比如很多企业要求要985 211 双一流毕业的学生，如果真的是这样好好读个研也是个不错的选择，因为这样你才能跨过门槛离理想更进一步不是？</p>
</blockquote>
<p><strong>再者</strong></p>
<blockquote>
<p>你对更好的院校充满向往，你的生活中心并非在就业，而是期望得到更牛X的文凭，这种也适合继续考研，而且加油吧哈哈</p>
</blockquote>
<p><strong>还有</strong></p>
<blockquote>
<p>你的专业非常需要更高的文凭，比如要硕士博士以上，例如我知道的医学哈哈那么也别犹豫了 继续考吧加油</p>
</blockquote>
<p><strong>最后</strong></p>
<blockquote>
<p>看完本篇blog或者无论是看过怎样的踩坑经验都仍然觉得考研才能找到好工作的，那我就拜拜，加油考</p>
</blockquote>
<h3 id="什么样的人不适合读研"><a href="#什么样的人不适合读研" class="headerlink" title="什么样的人不适合读研"></a>什么样的人不适合读研</h3><p><strong><em>首先要说我绝不会因为考研非易而鼓励大家不去考研！！！</em></strong>   </p>
<p><strong>首先</strong></p>
<blockquote>
<p>我认为厌学的人就最不适合读研了，厌学还要苦苦的逼着自己考研，到头来考个一般院校研究生，或者二战三战的真的没有必要兄弟，尽早的进入社会说不定能找到你热爱的事业</p>
</blockquote>
<p><strong>其次</strong></p>
<blockquote>
<p>如果你和我一样是一个热衷于技术的人那么你是否考研也要三思了，花多年的时间专心搞技术结果不是更好吗</p>
</blockquote>
<p><strong>再者</strong></p>
<blockquote>
<p>如果你和我专业计算机性质一样，都是技术至上的专业，那么我也劝不读研，何必赌这一把呢</p>
</blockquote>
<p><strong>最后</strong></p>
<blockquote>
<p>如果你的家庭真的不太能支撑你读研究生，你的工作能为家庭作出卓越贡献，这样我也劝不读研，读研真的不一定能带给你什么</p>
</blockquote>
<hr>
<h2 id="写在结尾"><a href="#写在结尾" class="headerlink" title="写在结尾"></a>写在结尾</h2><p><strong>本篇blog我也基本阐明了我对于考研的一些浅薄的看法，希望能对大家纠结的问题提供一些解答的思路，我始终觉得，任何决定都是应该三思而后行的，不要被身边的言论所左右，不要被眼前的一些趋势一些现象蒙蔽了双眼，多看一看外面的世界是怎样的，你周围之外的言论又是什么样的？</strong></p>
<blockquote>
<p>再次声明本篇blog仅代表个人看法不希望作为决定标准，还有期间言论如有得罪还望海涵，希望能与你一起成长！瑞斯拜！<br><img src="https://wx2.sbimg.cn/2020/06/30/2wkEV.jpg" alt="2wkEV.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>生活区</category>
      </categories>
      <tags>
        <tag>生活区</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】(二叉树的Java与C++实现)</title>
    <url>/2020/06/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84Java%E4%B8%8EC++%E5%AE%9E%E7%8E%B0)/</url>
    <content><![CDATA[<p><strong>二叉树作为重要的数据结构类型,本篇二叉树内部方法的实现多采用了递归,实现了诸如(四种遍历\结点删除\结点查找\叶子数量\高度\判断是否完全二叉树\某层结点数)等方法,是值得一读的二叉树的实现 ʅ(‾◡◝)ʃ</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>树结构的知识点比较复杂，在本篇中学习了很多Java用递归方式编写的函数体，值得一读。惰性删除是指当一个元素要被删除时，它仍被保留在树中，只是标记为删除了，这在有重复项的时候很常用，因为此时记录出现频率数的域可以减1，如果树中的实际节点数与“被删除”的节点数相同，那么树的深度预计只上升一个小的常数，因此存在一个与惰性删除相关的非常小的时间损耗，并且，如果被删除的项是重新插入的，那么久避免了分配一个新单元的开销了<br><img src="https://i.loli.net/2020/06/19/jkItJpTGE4qhO2u.jpg" alt="IMG_6581.jpg">   </p>
</blockquote>
<h2 id="二叉树的Java实现"><a href="#二叉树的Java实现" class="headerlink" title="二叉树的Java实现"></a>二叉树的Java实现</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package BinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> BiTree&#123;</span><br><span class="line"></span><br><span class="line">	private <span class="type">int</span> count;</span><br><span class="line">	private Node root;</span><br><span class="line">	<span class="built_in">public</span> <span class="type">int</span> <span class="keyword">index</span>;</span><br><span class="line">	<span class="keyword">class</span> Node &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">public</span> Node lchild;</span><br><span class="line">		<span class="built_in">public</span> Node rchild;</span><br><span class="line">		<span class="built_in">public</span> <span class="type">int</span> data;</span><br><span class="line">		<span class="built_in">public</span> Node(<span class="type">int</span> data) &#123;</span><br><span class="line">			this.data = data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> Node getLchild() &#123;</span><br><span class="line">			<span class="keyword">return</span> lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> <span class="type">void</span> setLchild(Node lchild) &#123;</span><br><span class="line">			this.lchild = lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> Node getRchild() &#123;</span><br><span class="line">			<span class="keyword">return</span> rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> <span class="type">void</span> setRchild(Node rchild) &#123;</span><br><span class="line">			this.rchild = rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> <span class="type">int</span> getData() &#123;</span><br><span class="line">			<span class="keyword">return</span> data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> <span class="type">void</span> setData(<span class="type">int</span> data) &#123;</span><br><span class="line">			this.data = data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//二叉树的建立</span><br><span class="line">	<span class="built_in">public</span> Node CreateBTree(<span class="type">int</span>[] a)&#123;</span><br><span class="line">		Node root = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[<span class="keyword">index</span>]!=<span class="string">'#'</span>)&#123;</span><br><span class="line">			root = <span class="built_in">new</span> Node(a[<span class="keyword">index</span>]);</span><br><span class="line">			<span class="keyword">index</span>++;</span><br><span class="line">			root.setLchild(CreateBTree(a));</span><br><span class="line">			<span class="keyword">index</span>++;</span><br><span class="line">			root.setRchild(CreateBTree(a));		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	//二叉树节点的删除</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> <span class="keyword">delete</span>(<span class="type">int</span> data) &#123;</span><br><span class="line">		Node <span class="keyword">current</span> = root;</span><br><span class="line">		Node parent = root;</span><br><span class="line">		<span class="type">boolean</span> isleftchild = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>.data!=data) &#123;</span><br><span class="line">			parent = <span class="keyword">current</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">current</span>.data&gt;data) &#123;</span><br><span class="line">				isleftchild = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">current</span> = <span class="keyword">current</span>.lchild;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				isleftchild = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">current</span> = <span class="keyword">current</span>.rchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">current</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//被删除的节点没有子节点</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">current</span>.lchild==<span class="keyword">null</span> &amp;&amp;<span class="keyword">current</span>.rchild==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">current</span>==root) &#123;</span><br><span class="line">				root = <span class="keyword">null</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(isleftchild) &#123;</span><br><span class="line">				parent.lchild = <span class="keyword">null</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				parent.rchild = <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		//被删除的节点有一个子节点</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">current</span>.lchild==<span class="keyword">null</span>&amp;&amp;<span class="keyword">current</span>.rchild!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(root == <span class="keyword">current</span>) &#123;</span><br><span class="line">				root = <span class="keyword">current</span>.rchild;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(isleftchild) &#123;</span><br><span class="line">				parent.lchild = <span class="keyword">current</span>.rchild;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				parent.rchild = <span class="keyword">current</span>.rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">current</span>.lchild!=<span class="keyword">null</span>&amp;&amp;<span class="keyword">current</span>.rchild==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(root == <span class="keyword">current</span>) &#123;</span><br><span class="line">				root = <span class="keyword">current</span>.lchild;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(isleftchild) &#123;</span><br><span class="line">				parent.lchild = <span class="keyword">current</span>.lchild;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				parent.rchild = <span class="keyword">current</span>.lchild;</span><br><span class="line">		    &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">		//被删除的节点有两个子节点</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">current</span>.lchild != <span class="keyword">null</span> &amp;&amp; <span class="keyword">current</span>.rchild != <span class="keyword">null</span>)&#123;</span><br><span class="line">            //获取删除节点的后继结点</span><br><span class="line">            Node successor = getSuccessor(<span class="keyword">current</span>);</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">current</span>) &#123;</span><br><span class="line">                root = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isleftchild) &#123;</span><br><span class="line">                parent.lchild = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.rchild = successor;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">public</span> Node getSuccessor(Node delNode) &#123;</span><br><span class="line">        Node successorParent = delNode;</span><br><span class="line">        Node successor = delNode;</span><br><span class="line">        Node <span class="keyword">current</span> = delNode.rchild;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">current</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">            successorParent = successor;</span><br><span class="line">            successor = <span class="keyword">current</span>;</span><br><span class="line">            <span class="keyword">current</span> = <span class="keyword">current</span>.lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (successor != delNode.rchild) &#123;</span><br><span class="line">            successorParent.lchild = successor.rchild;</span><br><span class="line">            successor.rchild = delNode.rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">    //先序遍历</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> prevOrder(Node root) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">System</span>.<span class="keyword">out</span>.print(root.getData()+" ");</span><br><span class="line">    	prevOrder(root.getLchild());</span><br><span class="line">    	prevOrder(root.getRchild());</span><br><span class="line">    &#125;</span><br><span class="line">    //中序遍历</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> inOrder(Node root) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	inOrder(root.getLchild());</span><br><span class="line">    	<span class="keyword">System</span>.<span class="keyword">out</span>.print(root.getData()+" ");</span><br><span class="line">    	inOrder(root.getRchild());</span><br><span class="line">    &#125;</span><br><span class="line">    //后序遍历</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> postOrder(Node root) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	postOrder(root.getLchild());</span><br><span class="line">    	postOrder(root.getRchild());</span><br><span class="line">    	<span class="keyword">System</span>.<span class="keyword">out</span>.print(root.getData()+" ");</span><br><span class="line">    &#125;</span><br><span class="line">    //层序遍历</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> BTreeLevelOrder()&#123;</span><br><span class="line">    	Node root = this.root;</span><br><span class="line">    	Queue &lt;Node&gt; queue = <span class="built_in">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    	LinkedList&lt;Node&gt; list = <span class="built_in">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    	queue.offer(root);</span><br><span class="line">    	<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">    		Node pre = queue.poll();</span><br><span class="line">    		list.<span class="keyword">add</span>(pre);</span><br><span class="line">    		<span class="keyword">if</span>(pre.getLchild()!=<span class="keyword">null</span>)</span><br><span class="line">    			queue.offer(pre.getLchild());</span><br><span class="line">    		<span class="keyword">if</span>(pre.getRchild()!=<span class="keyword">null</span>)</span><br><span class="line">    			queue.offer(pre.getRchild());</span><br><span class="line">    	&#125;</span><br><span class="line">    	Iterator&lt;Node&gt; it = list.iterator();</span><br><span class="line">    	<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    		Node cur = (Node)it.next();</span><br><span class="line">    		<span class="keyword">System</span>.<span class="keyword">out</span>.print(cur.getData()+" ");</span><br><span class="line">    	&#125;	</span><br><span class="line">    &#125;</span><br><span class="line">    //获得二叉树的高度</span><br><span class="line">  	<span class="built_in">public</span> <span class="type">int</span> getHeight(Node root)&#123;</span><br><span class="line">  		//递归获取</span><br><span class="line">  		<span class="type">int</span> leftHeight = <span class="number">0</span>;</span><br><span class="line">  		<span class="type">int</span> rightHeight = <span class="number">0</span>;</span><br><span class="line">  		<span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">  			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  			leftHeight = getHeight(root.getLchild());</span><br><span class="line">  			rightHeight = getHeight(root.getRchild());</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">return</span> leftHeight &gt;= rightHeight ? ++leftHeight:++rightHeight; //最终高度应是左右子树高度中最大的一个</span><br><span class="line">  	&#125;</span><br><span class="line">  	//获得二叉树的叶子结点</span><br><span class="line">  	<span class="built_in">public</span> <span class="type">int</span> getLeaf(Node root) &#123;</span><br><span class="line">  		<span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.getLchild()==<span class="keyword">null</span>&amp;&amp;root.getRchild()==<span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">System</span>.<span class="keyword">out</span>.println("叶子结点："+root.getData());</span><br><span class="line">  			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">return</span> getLeaf(root.getLchild())+getLeaf(root.getRchild());</span><br><span class="line">  	&#125;</span><br><span class="line">  	//获得二叉树某一层的节点</span><br><span class="line">  	<span class="built_in">public</span> <span class="type">int</span> getNum(Node root, <span class="type">int</span> deep) &#123;</span><br><span class="line">  		<span class="keyword">if</span>(deep == <span class="number">1</span>) &#123;</span><br><span class="line">  			<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">  				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  				<span class="keyword">System</span>.<span class="keyword">out</span>.println("结点："+root.getData());</span><br><span class="line">  				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">return</span> getNum(root.getLchild(), deep<span class="number">-1</span>)+getNum(root.getRchild(), deep<span class="number">-1</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">  	//查找某一值结点</span><br><span class="line">  	<span class="built_in">public</span> Node <span class="keyword">search</span>(Node root, <span class="type">int</span> key) &#123;</span><br><span class="line">  		<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.getData()==key) &#123;</span><br><span class="line">  			<span class="keyword">return</span> root;</span><br><span class="line">  		&#125;</span><br><span class="line">  		Node left = <span class="keyword">search</span>(root.getLchild(), key);</span><br><span class="line">  		<span class="keyword">if</span>(left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">return</span> left;</span><br><span class="line">  		&#125;</span><br><span class="line">  		Node right = <span class="keyword">search</span>(root.getRchild(), key);</span><br><span class="line">  		<span class="keyword">if</span>(right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">return</span> right;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">    //判断某一结点是否存在</span><br><span class="line">  	<span class="built_in">public</span> <span class="type">boolean</span> <span class="keyword">isNull</span>(Node root) &#123;</span><br><span class="line">  		<span class="keyword">return</span> root!=<span class="keyword">null</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">    //判断一棵树是否是完全二叉树</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> isCompleteBTree()&#123;</span><br><span class="line">		Node root = this.root;</span><br><span class="line">		Queue &lt;Node&gt; queue = <span class="built_in">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">		queue.offer(root);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">			Node pre = queue.poll();</span><br><span class="line">			<span class="keyword">if</span>(pre==<span class="keyword">null</span>)</span><br><span class="line">				break;</span><br><span class="line">			queue.offer(pre.getLchild());</span><br><span class="line">			queue.offer(pre.getRchild());</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">			Node cur = queue.poll();</span><br><span class="line">			<span class="keyword">if</span>(cur!=<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">		BiTree tree = <span class="built_in">new</span> BiTree();</span><br><span class="line">		<span class="type">int</span>[] a = <span class="built_in">new</span> <span class="type">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="string">'#'</span>,<span class="number">3</span>,<span class="string">'#'</span>,<span class="number">4</span>,<span class="string">'#'</span>,<span class="string">'#'</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">'#'</span>,<span class="string">'#'</span>,<span class="string">'#'</span> &#125;;</span><br><span class="line">		tree.root = tree.CreateBTree(a);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("先序遍历：");</span><br><span class="line">		tree.prevOrder(tree.root);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("中序遍历：");</span><br><span class="line">		tree.inOrder(tree.root);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("后序遍历：");</span><br><span class="line">		tree.postOrder(tree.root);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("层序遍历：");</span><br><span class="line">		tree.BTreeLevelOrder();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("此二叉树的高度为："+tree.getHeight(tree.root));</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("此二叉树的叶子结点数："+tree.getLeaf(tree.root));</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("第二层的结点树为："+tree.getNum(tree.root, <span class="number">2</span>));</span><br><span class="line">		Node <span class="keyword">order</span> =tree.<span class="keyword">search</span>(tree.root, <span class="number">6</span>);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("查找值为6的结点是否存在："+tree.<span class="keyword">isNull</span>(<span class="keyword">order</span>));</span><br><span class="line">		Node order1 = tree.<span class="keyword">search</span>(tree.root, <span class="number">7</span>);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("查找值为7的结点是否存在："+tree.<span class="keyword">isNull</span>(order1));</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("这是一棵完全二叉树吗："+tree.isCompleteBTree());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的C-实现"><a href="#二叉树的C-实现" class="headerlink" title="二叉树的C++实现"></a>二叉树的C++实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> elemtype;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//二叉树的存储结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    elemtype data;</span><br><span class="line">    bitree *lchild,*rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//建立二叉树</span></span><br><span class="line"><span class="function">bitree* <span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitree *root,*s,*q[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> front=<span class="number">1</span>,rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入结点值，（‘ # ’结束）"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">while</span>(ch!=<span class="string">'#'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch!=<span class="string">','</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s=<span class="keyword">new</span> bitree;</span><br><span class="line">            s-&gt;data=ch;</span><br><span class="line">            s-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">            s-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;</span><br><span class="line">        q[rear]=s; <span class="comment">// 进队</span></span><br><span class="line">        <span class="keyword">if</span>(rear==<span class="number">1</span>)</span><br><span class="line">        root=s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>((s!=<span class="literal">NULL</span>)&amp;&amp;(q[front]!=<span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(rear%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            q[front]-&gt;lchild=s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q[front]-&gt;rchild=s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rear%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            front++; <span class="comment">// 出队</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(bitree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitree *p;</span><br><span class="line">    p=root;</span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        preorder(p-&gt;lchild);</span><br><span class="line">        preorder(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(bitree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitree *p;</span><br><span class="line">    p=root;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inorder(p-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        inorder(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(bitree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitree *p;</span><br><span class="line">    p=root;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postorder(p-&gt;lchild);</span><br><span class="line">        postorder(p-&gt;rchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求二叉树中叶子结点的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(bitree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!T-&gt;lchild&amp;&amp;!T-&gt;rchild)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">(bitree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> L,R;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		L=Height(root-&gt;lchild);</span><br><span class="line">		R=Height(root-&gt;rchild);</span><br><span class="line">		<span class="keyword">return</span> (L&gt;R)?L+<span class="number">1</span>:R+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitree *root;</span><br><span class="line">    <span class="keyword">int</span> leaf;</span><br><span class="line">    root=create();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"各种遍历方式对应的遍历结果："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"先序遍历的结果："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    preorder(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"中序遍历的结果："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"后序遍历的结果："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    postorder(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"树的叶子结点个数为："</span>&lt;&lt;LeafCount(root)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"树的高度为："</span>&lt;&lt;Height(root)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】(链表的Java实现与经典应用)</title>
    <url>/2020/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(Java%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0)/</url>
    <content><![CDATA[<p><strong>链表作为数据结构的基石,它的出现给很多的方法提供了优化措施,链表是最重要的数据结构之一,在我心里,链表就是数据结构的灵魂，本篇利用数组和内部类两种方式实现了链表的定义和基本方法的实现,当然我最爱内部类的实现形式( `)3’)▃▃▃▅▆▇▉</strong></p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://i.loli.net/2020/06/15/wJlYTC5oxUXtSZM.jpg" alt="IMG_7967.jpg"></p>
<blockquote>
<p>对于Java实现链表将Node作为内部类是个很好的选择，所以这里给出两个Java实现链表的版本，个人比较认同第二种。因为在链表的添加顺序是由右向左，先添加的节点对下一节点的引用可以为空，并且引用是引用下一节点而不是下一节点的对象，因为具有连续引用使得头节点可以操作所有节点，所以需要一个头节点和视情况而定的若干临时节点</p>
</blockquote>
<h2 id="链表的Java实现"><a href="#链表的Java实现" class="headerlink" title="链表的Java实现"></a>链表的Java实现</h2><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">package SqueneList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Sqlist</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span> MAXSIZE;</span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span>[] sqlist;</span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span> length;</span><br><span class="line">	<span class="comment">//用最大数组长度来初始化顺序表</span></span><br><span class="line">	<span class="keyword">public</span> Sqlist(<span class="built_in">int</span> MAXSIZE)&#123;</span><br><span class="line">		<span class="keyword">this</span>.sqlist = new <span class="built_in">int</span>[MAXSIZE];</span><br><span class="line">		<span class="keyword">this</span>.MAXSIZE=MAXSIZE;</span><br><span class="line">		<span class="keyword">this</span>.length=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//用数组来初始化顺序表</span></span><br><span class="line">	<span class="keyword">public</span> Sqlist(<span class="built_in">int</span>[] arr) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">			sqlist[i] = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.length = arr.length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对由数组实现的顺序表进行扩充</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> expandList()&#123;</span><br><span class="line">	    <span class="built_in">int</span>[] newarr = new <span class="built_in">int</span>[arr.length*<span class="number">2</span>]</span><br><span class="line">	    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">	        newarr[i]=arr[i]</span><br><span class="line">	    &#125;</span><br><span class="line">	    arr = newarr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//向顺序表指定位置插入元素</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> listInsert(<span class="built_in">int</span> i, <span class="built_in">int</span> e) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>) &#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"非法插入位置"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.length == <span class="keyword">this</span>.MAXSIZE) &#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"顺序表已满"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> k=length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--) &#123;</span><br><span class="line">			sqlist[k+<span class="number">1</span>]=sqlist[k];  <span class="comment">//数组中插入位置及其后的元素均向后移动一位</span></span><br><span class="line">		&#125;</span><br><span class="line">		sqlist[i<span class="number">-1</span>]=e;  <span class="comment">//将制定元素插入此位置</span></span><br><span class="line">		<span class="keyword">this</span>.length++;  <span class="comment">//插入后的顺序表长度+1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//清空顺序表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> listClear() &#123;</span><br><span class="line">		<span class="keyword">this</span>.length = <span class="number">0</span>;  <span class="comment">//仅用来判断是否为空，直接将长度设置为0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断顺序表是否为空</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">bool</span>ean isEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.length==<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取指定位置的顺序表元素</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">int</span> getElem(<span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;length)</span><br><span class="line">		&#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"获取位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sqlist[i<span class="number">-1</span>];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取制定元素的位置信息</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> getIndex(<span class="built_in">int</span> e, <span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;=length<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(sqlist[j]==e) &#123;</span><br><span class="line">				i=j++;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"顺序表中无对应元素"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印顺序表</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">void</span> printList() &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;=length<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">int</span> t=i+<span class="number">1</span>;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"第"</span>+t+<span class="string">"个元素为"</span>+sqlist[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除顺序表指定位置的元素</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">int</span> listDelete(<span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;length)</span><br><span class="line">		&#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"删除位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=i;j&lt;=length<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sqlist[j<span class="number">-1</span>]=sqlist[j];</span><br><span class="line">		&#125;</span><br><span class="line">		length--;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">		Sqlist sqlist = new Sqlist(<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			sqlist.listInsert(i, i);</span><br><span class="line">		&#125;</span><br><span class="line">		printList();</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"第3个元素为"</span>+getElem(<span class="number">3</span>));</span><br><span class="line">		listDelete(<span class="number">2</span>);</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"删除第二个元素后的顺序表的内容为："</span>);</span><br><span class="line">		printList();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> SqueneList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Linklist &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> Node head = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//使用内部类来作为普通结点，这样就只有头结点可以操作其他节点</span></span><br><span class="line">	<span class="keyword">class</span> Node&#123;</span><br><span class="line">		Node <span class="keyword">next</span>=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">int</span> data;</span><br><span class="line">		<span class="keyword">public</span> Node(<span class="keyword">int</span> data) &#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取单链表的长度</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> getLength() &#123;</span><br><span class="line">		<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">		Node temp = head;</span><br><span class="line">		<span class="keyword">while</span>(temp.<span class="keyword">next</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			length++;</span><br><span class="line">			temp = temp.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//单链表的增加</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> addNode(<span class="keyword">int</span> d) &#123;</span><br><span class="line">		Node newnode = <span class="keyword">new</span> Node(d);</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			head = newnode;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node temp = head;  <span class="comment">//临时结点</span></span><br><span class="line">		<span class="keyword">while</span>(temp.<span class="keyword">next</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">			temp = temp.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp.<span class="keyword">next</span> = newnode;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">//删除指定位置的结点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> deleteNode(<span class="keyword">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;getLength()) &#123;</span><br><span class="line">			System.out.<span class="keyword">println</span>(<span class="string">"删除位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) &#123;</span><br><span class="line">			head = head.<span class="keyword">next</span>;  <span class="comment">//若删除第一个结点则直接删去头结点即可</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">1</span>;</span><br><span class="line">		Node pre = head;  <span class="comment">//定义两个临时结点分别为前驱结点与后继结点</span></span><br><span class="line">		Node cur = pre.<span class="keyword">next</span>;</span><br><span class="line">		<span class="keyword">while</span>(cur!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(index == i-<span class="number">1</span>) &#123;</span><br><span class="line">				pre.<span class="keyword">next</span> = cur.<span class="keyword">next</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			pre = cur;</span><br><span class="line">			cur = cur.<span class="keyword">next</span>;</span><br><span class="line">			index++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印单链表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> printLinkList() &#123;</span><br><span class="line">		Node temp = head;</span><br><span class="line">		<span class="keyword">while</span>(temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.<span class="keyword">println</span>(temp.data);</span><br><span class="line">			temp = temp.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表的经典应用1:反转</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node reverseList(Node head) &#123;</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">		Node pre = head;</span><br><span class="line">		Node cur = head.<span class="keyword">next</span>;</span><br><span class="line">		Node tmp;</span><br><span class="line">		<span class="keyword">while</span>(cur!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			tmp = cur.<span class="keyword">next</span>;</span><br><span class="line">			cur.<span class="keyword">next</span> = pre;</span><br><span class="line">			pre = cur;</span><br><span class="line">			cur = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		head.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">return</span> pre;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表的经典应用2:查找单链表的中间节点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> searchMid() &#123;  <span class="comment">//这里对单链表中间位置查找使用的是快慢指针法</span></span><br><span class="line">		Node f = head;               <span class="comment">//即：快的指针一次走两个慢的指针一次走一个，快的指针到达</span></span><br><span class="line">		Node s = head;               <span class="comment">//表尾时慢指针刚好走到表中</span></span><br><span class="line">		<span class="keyword">while</span>(f!=<span class="keyword">null</span>&amp;&amp;f.<span class="keyword">next</span>!=<span class="keyword">null</span>&amp;&amp;f.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			f = f.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">			s = s.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s.data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表的经典应用2:删除单链表中倒数第k个节点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node searchElem(<span class="keyword">int</span> k) &#123;</span><br><span class="line">		<span class="keyword">if</span>(k&gt;getLength()||k&lt;<span class="number">1</span>) &#123;</span><br><span class="line">			System.out.<span class="keyword">println</span>(<span class="string">"删除位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node pf = head;</span><br><span class="line">		Node ps = head;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">			pf = pf.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(pf!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			pf = pf.<span class="keyword">next</span>;</span><br><span class="line">			ps = ps.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ps;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对链表进行排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node sortList() &#123;</span><br><span class="line">		Node nextNode = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">		Node curNode = head;</span><br><span class="line">		<span class="keyword">while</span>(curNode.<span class="keyword">next</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			nextNode = curNode.<span class="keyword">next</span>;</span><br><span class="line">			<span class="keyword">while</span>(nextNode!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(curNode.data&gt;nextNode.data) &#123;</span><br><span class="line">					temp = curNode.data;</span><br><span class="line">					curNode.data = nextNode.data;</span><br><span class="line">					nextNode.data = temp;</span><br><span class="line">				&#125;</span><br><span class="line">				nextNode = nextNode.<span class="keyword">next</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			curNode = curNode.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除链表中重复的节点就用简单的遍历方法 如果数据相同则p.next = p.next.next跳过就可以了</span></span><br><span class="line">	<span class="comment">//用递归的方法输出链表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> diGuiPrint(Node head) &#123;</span><br><span class="line">		<span class="keyword">if</span>(head!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			diGuiPrint(head.<span class="keyword">next</span>);</span><br><span class="line">			System.out.<span class="keyword">println</span>(<span class="string">"采用递归的方式输出链表："</span>+head.data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">		Linklist linklist = <span class="keyword">new</span> Linklist();</span><br><span class="line">		linklist.addNode(<span class="number">1</span>);</span><br><span class="line">		linklist.addNode(<span class="number">2</span>);</span><br><span class="line">		linklist.addNode(<span class="number">3</span>);</span><br><span class="line">		linklist.addNode(<span class="number">4</span>);</span><br><span class="line">		printLinkList();</span><br><span class="line">		deleteNode(<span class="number">2</span>);</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"删除第二个结点后的单链表为："</span>);</span><br><span class="line">		printLinkList();</span><br><span class="line">		head = reverseList(head);</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"单链表反转后变为："</span>);</span><br><span class="line">		printLinkList();</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"中间节点的数据为"</span>+searchMid());</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"倒数第2个节点的数据为"</span>+searchElem(<span class="number">2</span>).data);</span><br><span class="line">		sortList();</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"排序后的链表数据为:"</span>);</span><br><span class="line">		printLinkList();</span><br><span class="line">		diGuiPrint(head);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM】类文件结构</title>
    <url>/2020/06/29/%E3%80%90JVM%E3%80%91%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><strong>学习JVM居然能忽略类文件结构？不存在的！类文件结构作为理解JVM入门级的垫脚石，你不能不清楚它的存在及意义 °(°ˊДˋ°) °</strong></p>
<a id="more"></a>
<hr>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>如今的计算机仍然只能识别0和1，但将我们编写的程序编译成二进制本地机器码已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、 平台中立的格式作为程序编译后的存储格式。各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石，而且语言无关性正越来越被开发者所重视。Java虚拟机不和包括Java在内的任何语言绑定，它只与Class文件这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。</p>
<hr>
<h2 id="类文件结构的相关概念与属性"><a href="#类文件结构的相关概念与属性" class="headerlink" title="类文件结构的相关概念与属性"></a>类文件结构的相关概念与属性</h2><h3 id="类文件定义"><a href="#类文件定义" class="headerlink" title="类文件定义"></a>类文件定义</h3><blockquote>
<p>Class文件是一组以8位字节为基础单位的二进制流，各项数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，如果是超过8位字节以上空间的数据项，则会按照高位在前的方式（Big-Endian）分割成若干个8位字节进行存储。    </p>
</blockquote>
<p>来看一个类文件二进制流实例：</p>
<p><img src="https://wx2.sbimg.cn/2020/06/29/2jo44.png" alt="2jo44.png"><br><strong>其中一个字节为2位16进制数，图中的‘cafe’就是为两个字节</strong>   </p>
<h3 id="魔数与文件版本"><a href="#魔数与文件版本" class="headerlink" title="魔数与文件版本"></a>魔数与文件版本</h3><blockquote>
<p><strong>魔数</strong>是每个class文件的4个字节组成的数，如图中的‘cafe babe’就是魔数，魔数的唯一作用就是用来判断此class文件是否是能被虚拟机接受的文件。很多种文件都是用到了魔数进行文件类别的识别，如：.gif, .jpeg等   </p>
</blockquote>
<blockquote>
<p><strong>文件版本</strong>号就是紧跟在魔数后的四个字节，其中，第5 6个字节表示的是次版本号，第7 8个字节表示的是主版本号。如图中的0000为次版本号，0034为主版本号，Java的版本号是从45开始的，JDK1.1之后每个JDK大版本发布，其主版本号就向上加1，这就让高版本的JDK能向下兼容低版本的class文件，但是不能向上兼容高版本的class文件，因为<em>虚拟机是拒绝执行超过它版本号的class文件</em>。</p>
</blockquote>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><blockquote>
<p>常量池的入口紧跟在主次版本号之后，<strong>向后的两个字节为常量池的个数，再向后就是从常量1….到常量n</strong>,常量池是class文件的数据仓库，也是占用class文件空间最大的数据项目之一，它是与class文件的其他项目关联最多的数据类型。<br>常量池中主要存放着<strong><em>两大元素</em></strong>：    </p>
<ol>
<li><strong>字面量</strong>：类似于常量概念，如final修饰的常量值等等   </li>
<li><strong>符号引用</strong>：包含类和进口的全限定名、字段的名称和描述符、方法的名称和描述符这三种常量，属于编译方面的概念。</li>
</ol>
</blockquote>
<p>当JVM运行时，需要从常量池中获取对应的符号引用，然后在类创建或运行时进行解析，得到真正的内存地址。</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><blockquote>
<p>访问标志是在常量池继续向后的两个字节，这个标志（access-flags）表示一些类或接口的访问信息，比如，这个Class是一个类呢还是一个接口呢，它是被什么限定符所修饰的？public？abstract？final？这些都在访问标志中被标明。</p>
</blockquote>
<h3 id="类索引-父索引-接口索引"><a href="#类索引-父索引-接口索引" class="headerlink" title="类索引-父索引-接口索引"></a>类索引-父索引-接口索引</h3><blockquote>
<p>类索引（this_class）与父索引（super_class）都是一个两个字节的数据集合，因为Java的单一继承所以让类索引和父索引只能有一个，以此类推，接口索引就不再只是一个两个字节的数据集合了，而是一组两个字节的数据集合，前两个字节代表着接口索引的个数，后面的字节分别就代表了接口1….接口n，其中<strong><em>类索引是用来确定这个类的全限定名，父所以与接口索引用来确定这个类的继承连接关系</em></strong>，接口索引的顺序是按照implements（或extends）后的顺序以此展开的。</p>
</blockquote>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><blockquote>
<p>字段表中存放用于描述类或接口中声明的变量信息，也是由一个两个字节的数据表示字段个数后面字节代表字段1….字段n，其中包括类级和实例级变量（static修饰符来区分）但是其中<strong>不包括局部变量也不包括从超类或父类中继承来的字段</strong>，还有一些是有着特殊含义的字段，如内部类通常会添加指向外部类的字段用来保持对外部类的访问性。其中<strong>字段的通常信息</strong>包括：   </p>
<ol>
<li>字段的作用域（public protected private default修饰符区分）；   </li>
<li>变量的级别（类级变量或实例级变量）；   </li>
<li>可变性（final修饰符区分）；   </li>
<li>并发可见性（volatile修饰符）；   </li>
<li>可否序列化（reansient修饰符）；   </li>
<li>字段的数据类型（int char double float等修饰符）；    </li>
<li>字段的名称等等。</li>
</ol>
</blockquote>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><blockquote>
<p>与字段表一致的是方法集合在class文件中采用了相同的存储方式，也是由一个两个字节的数据表示方法个数后面字节代表方法1….方法n，其中方法表的集合的信息通常包含：</p>
<ol>
<li>访问标志（access_flags）；   </li>
<li>名称索引（name_index）；   </li>
<li>描述符索引（descriptor_index）；   </li>
<li>属性表集合（attributes）这个里面包含的是类文件方法里的Java代码经过虚拟机编译后的<strong>字节码指令</strong>，这些指令都被放在了一个叫属性表的集合里面的“code”属性里。</li>
</ol>
</blockquote>
<p>解释一下字节码指令：字节码指令是指JVM的指令由一个字节长度的、代表着某种特定操作含义的数字（操作码，Opcode）以及跟随其后的0至多个爱表此操作所需参数（操作数，Operands）构成。字节码指令集是一种具有鲜明特点、优劣势都很突出的指令集架构，由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不可能超过256 条；又由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构。</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><blockquote>
<p>在class 文件、字段表、方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息，它也是由一个两个字节的数据表示属性个数后面字节代表属性1….方属性n。其中的属性包括：</p>
<ol>
<li><strong>code属性</strong>：这个在方法表集合中提到过，类文件方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。但是要注意，抽象类和接口的方法是没有code属性的；</li>
<li><strong>Exception属性</strong>：这个应该是很常见的，这个是一个异常类的统称，Exception属性就是用来列举出方法中可能抛出的（thorows关键字后的）受检查异常；</li>
<li><strong>LineNumberTable属性</strong>：用于描述 Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，但默认会生成到 Class 文件之中，可以在 javac 中分别使用 -g:none 或 -g:lines选项来取消或要求生成这项信息。如果选择不生成LineNumberTable 属性，对程序运行产生的最主要的影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。</li>
<li><strong>LocalVariableTable属性</strong>:用于描述栈帧中局部变量表中的变量与 Java 源码中定义的变量之间的关系,它也不是运行时必需的属性，但默认会生成到 Class 文件之中，可以在 Javac 中分别使用 -g:none 或 -g:vars 选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，IDE 将会使用诸如 arg0、arg1 之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不变，而且在调试期间无法根据参数名称从上下文获得参数值。</li>
<li><strong>SourceFile属性</strong>:用于记录生成这个 Class 文件的源码文件名称。这个属性也是可选的，可以分别使用 javac 的 -g:none 或 -g:source 选项来关闭或要求生成这项信息。在 Java 中，对于大多数的类来说，类名和文件名是一致的，但是又一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。</li>
<li><strong>ConstantValue属性</strong>:作用是通知虚拟机自动为静态变量赋值。只有被 static 关键字修饰的变量（类变量）才可以使用这项属性。类似 “int x = 1” 和 “static int x = 1” 这样的变量定义在 Java 程序中是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。对于非 static 类型的变量（也就是实例变量）的赋值是在实例构造器 <init> 方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器 <clinit> 方法中或者使用 ConstantValue 属性。目前 Sun Javac 编译器的选择是：如果同时使用 final 和 static 来修饰一个变量（按照习惯，这里称 “常量” 更贴切），并且这个变量的数据类型是基本类型或者 java.lang.String 的话，就生成 ConstantValue 属性来进行初始化，如果这个变量没有被 final 修饰，或者并非基本类型及字符串，则将会选择在 <clinit> 方法中进行初始化。</li>
<li><strong>InnerClass属性</strong>:用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成 InnerClass 属性。</li>
<li><strong>Deprecated和Synthetic属性</strong>：Deprecated 和 Synthetic 两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。Deprecated 属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过在代码中使用 @deprecated 注释进行设置。<br>Synthetic 属性代表此字段或者方法并不是由 Java 源码直接产生的，而是由编译器自行添加的，在 JDK 1.5 之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的 ACC_SYNTHETIC 标志位，其中最典型的例子就是 Bridge Method。所有由非用户代码产生的类、方法及字段都应当至少设置 Synthetic 属性和 ACC_SYNTHETIC 标志位中的一项，唯一的例外是实例构造器 “<init>” 方法和类构造器 “<clinit>” 方法。</li>
<li><strong>StackMapTable属性</strong>:在 JDK 1.6 发布后增加到了 Class 文件规范中，它是一个复杂的变长属性，位于 Code 属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</li>
<li><strong>Signature属性</strong>:在 JDK 1.5 发布后增加到了 Class 文件规范之中，它是一个可选的定长属性，可以出现于类、属性表和方法表结构的属性表中。在 JDK 1.5 中大幅增强了 Java 语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则 Signature 属性会为它记录泛型签名信息。之所以要专门使用这样一个属性去记录泛型类型，是因为 Java 语言的泛型采用的是擦除法实现的伪泛型，在字节码（Code 属性）中，泛型信息编译（类型变量、参数化类型）之后都通通被擦除掉。使用擦除法的好处是实现简单（主要修改 Javac 编译器，虚拟机内部只做了很少的改动）、非常容易实现 backport，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像 C# 等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得泛型信息。Signature 属性就是为了弥补这个缺陷而增设的，现在 Java 的反射 API 能够获取泛型类型，最终的数据来源也就是这个属性。</li>
<li><strong>BootstrapMethods属性</strong>:在 JDK 1.7 发布后增加到了 Class 文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存 invokedynamic 指令引用的引导方法限定符。</li>
</ol>
</blockquote>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Java类文件结构是java技术体系的重要基础之一，类文件是JVM对于编译首先要识别的入口，这是个数据和指令的开端，所以想要深入理解Java虚拟机，就不能不对class文件结构进行一个详细的认知。</p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】(图的两种Java实现与经典应用)</title>
    <url>/2020/06/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%9B%BE%E7%9A%84%E4%B8%A4%E7%A7%8DJava%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8)/</url>
    <content><![CDATA[<p><strong>图已经是数据机构基础中最复杂的结构,它几乎涵盖了前面所有的基础数据结构,本篇涉及到了图的两种构造方式(邻接矩阵和邻接表),以及对应的深度优先遍历/广度优先遍历/Dijkstra/最小生成树/等方法,很多的方法代码复杂难以理解,共勉(●’◡’●)ﾉ♥</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>我们将会遇到的应用使用几乎都是稀疏图——《算法第四版》   </p>
</blockquote>
<blockquote>
<p>邻接矩阵的处理思路是将顶点和关系分别保存到一个一维数组和一个二维数组中。但是，即使我们保存的是int型数据，一旦数据量达到10万。那么这个数组需要使用的内存空间为：100000 * 100000 * 4Byte = 40GB 所以在这个时候邻接表的优势就很明显了.<br><img src="https://i.loli.net/2020/06/27/eXIdZO6mMg1CNt3.jpg" alt="IMG_5716.jpg"></p>
</blockquote>
<h3 id="邻接矩阵表示图"><a href="#邻接矩阵表示图" class="headerlink" title="邻接矩阵表示图"></a>邻接矩阵表示图</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> VERTEX_MAX = <span class="number">10</span>;  <span class="comment">//最大结点数</span></span><br><span class="line">	Vertex[] vertex;  <span class="comment">//结点</span></span><br><span class="line">	<span class="keyword">int</span> num; <span class="comment">//目前的结点数</span></span><br><span class="line">	<span class="keyword">int</span> [][] adjacency;  <span class="comment">//临街矩阵</span></span><br><span class="line">	<span class="comment">//内部类表示结点</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>&#123;</span>  </span><br><span class="line">		<span class="keyword">char</span> content;</span><br><span class="line">		<span class="keyword">boolean</span> isSearch;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(<span class="keyword">char</span> content)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.content = content;</span><br><span class="line">			<span class="keyword">this</span>.isSearch = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//内部类表示栈</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> STACK_MAX = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">stack</span>[];</span><br><span class="line">		<span class="keyword">int</span> top;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">stack</span> = <span class="keyword">new</span> <span class="keyword">int</span>[STACK_MAX];</span><br><span class="line">			top = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(top==<span class="number">9</span>) &#123;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="string">"栈已满，无法入栈啦"</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">stack</span>[++top]=content;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(top==<span class="number">-1</span>) &#123;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="string">"栈已空，无法出栈啦"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">stack</span>[top--];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">stack</span>[top];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> top==<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> QUEUE_MAX = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> [] <span class="built_in">queue</span>;</span><br><span class="line">		<span class="keyword">int</span> front;</span><br><span class="line">		<span class="keyword">int</span> rear;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">queue</span> = <span class="keyword">new</span> <span class="keyword">int</span>[QUEUE_MAX];</span><br><span class="line">			front = <span class="number">0</span>;</span><br><span class="line">			rear = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(rear==QUEUE_MAX) &#123;</span><br><span class="line">				rear=<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">queue</span>[++rear]=content;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(front==QUEUE_MAX) &#123;</span><br><span class="line">				front=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> temp = <span class="built_in">queue</span>[front++];</span><br><span class="line">			<span class="keyword">return</span> temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (rear+<span class="number">1</span>==front || front+QUEUE_MAX<span class="number">-1</span>==rear);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化图</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>.vertex = <span class="keyword">new</span> Vertex[VERTEX_MAX];</span><br><span class="line">		<span class="keyword">this</span>.adjacency = <span class="keyword">new</span> <span class="keyword">int</span>[VERTEX_MAX][VERTEX_MAX];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;VERTEX_MAX;i++) &#123;  <span class="comment">//邻接矩阵的初始化 所有的结点都没有被访问过</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;VERTEX_MAX;j++) &#123;</span><br><span class="line">				adjacency[i][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//添加结点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addVertex</span><span class="params">(<span class="keyword">char</span> content)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num&lt;VERTEX_MAX<span class="number">-1</span>) &#123;</span><br><span class="line">			vertex[num++] = <span class="keyword">new</span> Vertex(content);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"图已满最大结点，不可以再添加结点了喔～"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//无向图添加边</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNAdj</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(start&lt;VERTEX_MAX &amp;&amp; <span class="built_in">end</span>&lt;VERTEX_MAX) &#123;</span><br><span class="line">			adjacency[start][<span class="built_in">end</span>] =  <span class="number">1</span>;</span><br><span class="line">			adjacency[<span class="built_in">end</span>][start] = <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"连接的图结点位置不合法，无法连接～"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有向图添加边</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addYAdj</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(start&lt;VERTEX_MAX &amp;&amp; <span class="built_in">end</span>&lt;VERTEX_MAX) &#123;</span><br><span class="line">			adjacency[start][<span class="built_in">end</span>] = <span class="number">-1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"连接的图结点位置不合法，无法连接～"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印图中的某个结点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printVertex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(index&gt;=<span class="number">0</span> &amp;&amp; index&lt;VERTEX_MAX) &#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(<span class="keyword">this</span>.vertex[index].content);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"打印结点位置不合法，无法打印～"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印邻接矩阵</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAdjacency</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(j!=num<span class="number">-1</span>) &#123;</span><br><span class="line">					System.out.<span class="built_in">print</span>(adjacency[i][j]+<span class="string">" "</span>);</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					System.out.<span class="built_in">println</span>(adjacency[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//寻找某一结点的未被访问的邻接点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchUnsearchVertex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(adjacency[i][index]==<span class="number">1</span> &amp;&amp; vertex[i].isSearch==<span class="literal">false</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//图的深度优先遍历 Depth-first traversal</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dpt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Stack <span class="built_in">stack</span> = <span class="keyword">new</span> Stack();</span><br><span class="line">		vertex[<span class="number">0</span>].isSearch = <span class="literal">true</span>;</span><br><span class="line">		printVertex(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> index = searchUnsearchVertex(<span class="built_in">stack</span>.<span class="built_in">peek</span>());</span><br><span class="line">			<span class="keyword">if</span>(index==<span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="built_in">stack</span>.pop();</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				vertex[index].isSearch = <span class="literal">true</span>;</span><br><span class="line">				printVertex(index);</span><br><span class="line">				<span class="built_in">stack</span>.push(index);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//遍历结束后将原图返回初始值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">			vertex[i].isSearch=<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//图的广度优先遍历 Breadth-first traversal</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bpt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Queue <span class="built_in">queue</span> = <span class="keyword">new</span> Queue();</span><br><span class="line">		vertex[<span class="number">0</span>].isSearch = <span class="literal">true</span>;</span><br><span class="line">		printVertex(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">queue</span>.insert(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> v1 = <span class="built_in">queue</span>.<span class="built_in">remove</span>();</span><br><span class="line">			<span class="keyword">int</span> v2 = searchUnsearchVertex(v1); </span><br><span class="line">			<span class="keyword">if</span>(v2!=<span class="number">-1</span>) &#123;</span><br><span class="line">				vertex[v2].isSearch = <span class="literal">true</span>;</span><br><span class="line">				printVertex(v2);</span><br><span class="line">				<span class="built_in">queue</span>.insert(v2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">			vertex[i].isSearch = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最小生成树 Minimum spanning tree</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Stack <span class="built_in">stack</span> = <span class="keyword">new</span> Stack();</span><br><span class="line">		vertex[<span class="number">0</span>].isSearch = <span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> cur = <span class="built_in">stack</span>.<span class="built_in">peek</span>();</span><br><span class="line">			<span class="keyword">int</span> index = searchUnsearchVertex(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(index == <span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="built_in">stack</span>.pop();</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				vertex[index].isSearch = <span class="literal">true</span>;</span><br><span class="line">				<span class="built_in">stack</span>.push(index);</span><br><span class="line">				printVertex(cur);</span><br><span class="line">				printVertex(index);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">			vertex[i].isSearch = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		Graph graph = <span class="keyword">new</span> Graph();</span><br><span class="line">		graph.addVertex(<span class="string">'F'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'O'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'R'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'E'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'V'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'E'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'R'</span>);</span><br><span class="line">		graph.addNAdj(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">		graph.addNAdj(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">		graph.addNAdj(<span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">		graph.addNAdj(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">		graph.addNAdj(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">		graph.printAdjacency();</span><br><span class="line">		graph.printVertex(<span class="number">3</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"深度优先遍历："</span>);</span><br><span class="line">		graph.dpt();</span><br><span class="line">		System.out.<span class="built_in">println</span>();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"广度优先遍历："</span>);</span><br><span class="line">		graph.bpt();</span><br><span class="line">		System.out.<span class="built_in">println</span>();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"最小生成树："</span>);</span><br><span class="line">		graph.mst();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="邻接表的对应实现"><a href="#邻接表的对应实现" class="headerlink" title="邻接表的对应实现"></a>邻接表的对应实现</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package Graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.<span class="keyword">Array</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> GraphAdj&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">	VNode&lt;E&gt;[] vers; //用来存储图的结点</span><br><span class="line">	<span class="type">int</span> max_size; //图的最大结点数量</span><br><span class="line">	<span class="type">int</span> numofvers; //图的当前结点数量</span><br><span class="line">	//邻接表建立图的结点</span><br><span class="line">	<span class="keyword">class</span> VNode&lt;E&gt;&#123;</span><br><span class="line">		E data; //存储定点数据</span><br><span class="line">		LNode first; //结点的邻接表的第一个结点</span><br><span class="line">		<span class="type">boolean</span> isvisited = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//邻接表建立图的邻接表的结点</span><br><span class="line">	<span class="keyword">class</span> LNode&#123;</span><br><span class="line">		<span class="type">int</span> weight; //存储权值</span><br><span class="line">		<span class="type">int</span> firstadj; //邻接表结点的序号</span><br><span class="line">		LNode nextvex; //下一个邻接结点</span><br><span class="line">		<span class="built_in">public</span> LNode(<span class="type">int</span> weight, <span class="type">int</span> firstadj) &#123;</span><br><span class="line">			this.weight = weight;</span><br><span class="line">			this.firstadj = firstadj;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//邻接表建立图的初始化</span><br><span class="line">	<span class="built_in">public</span> GraphAdj(<span class="type">int</span> max_size) &#123;</span><br><span class="line">		this.max_size = max_size;</span><br><span class="line">		vers = (VNode[])<span class="keyword">Array</span>.newInstance(VNode.<span class="keyword">class</span>, max_size);</span><br><span class="line">	&#125;</span><br><span class="line">	//获取图结点的树木</span><br><span class="line">	<span class="built_in">public</span> <span class="type">int</span> getNumOfGraph() &#123;</span><br><span class="line">		<span class="keyword">return</span> numofvers;</span><br><span class="line">	&#125;</span><br><span class="line">	//向图中插入结点</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> <span class="keyword">insert</span>(E e) &#123;</span><br><span class="line">		<span class="keyword">if</span>(numofvers&gt;=max_size) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		VNode&lt;E&gt; ver = <span class="built_in">new</span> VNode&lt;E&gt;();</span><br><span class="line">		ver.data = e;</span><br><span class="line">		vers[numofvers++] = ver;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取某结点的位置</span><br><span class="line">	<span class="built_in">public</span> <span class="type">int</span> getIndex(E e) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numofvers;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vers[i].data == e) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取指定位置的结点</span><br><span class="line">	<span class="built_in">public</span> E gerData(<span class="type">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">index</span>&lt;<span class="number">0</span> || <span class="keyword">index</span>&gt;=numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> vers[<span class="keyword">index</span>].data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//向图中插入边</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> insertEdg(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v1&lt;<span class="number">0</span> || v2&lt;<span class="number">0</span> || v1&gt;=numofvers || v2&gt;=numofvers) &#123; //合法性判断</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LNode vers1 = <span class="built_in">new</span> LNode(v2, weight);</span><br><span class="line">		LNode vers2 = <span class="built_in">new</span> LNode(v1, weight);</span><br><span class="line">		//当v1结点没有邻接结点时</span><br><span class="line">		<span class="keyword">if</span>(vers[v1].first==<span class="keyword">null</span>) &#123;</span><br><span class="line">			vers[v1].first=vers1;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;//当v1结点有邻接结点时</span><br><span class="line">			vers1.nextvex = vers[v1].first;</span><br><span class="line">			vers[v1].first = vers1;</span><br><span class="line">		&#125;</span><br><span class="line">		//当v2结点没有邻接结点时</span><br><span class="line">		<span class="keyword">if</span>(vers[v2].first==<span class="keyword">null</span>) &#123;</span><br><span class="line">			vers[v2].first = vers2;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;//当v2结点有邻接结点时</span><br><span class="line">			vers2.nextvex = vers[v2].first;</span><br><span class="line">			vers[v2].first = vers2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//删除图中的某条边</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> deleteEdg(<span class="type">int</span> v1, <span class="type">int</span> v2) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v1&lt;<span class="number">0</span> || v2&lt;<span class="number">0</span> || v1&gt;=numofvers || v2&gt;=numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LNode <span class="keyword">current</span> = vers[v1].first;</span><br><span class="line">		LNode pre = <span class="keyword">null</span>;</span><br><span class="line">		//判断v1到v2之间是否存在边</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">current</span>.firstadj!=v2) &#123;</span><br><span class="line">			pre = <span class="keyword">current</span>;</span><br><span class="line">			<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">		&#125;</span><br><span class="line">		//v1到v2之间存在边则删除</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			pre.nextvex = <span class="keyword">current</span>.nextvex;</span><br><span class="line">		&#125;</span><br><span class="line">		//判断v2到v1之间是否存在边</span><br><span class="line">		<span class="keyword">current</span> = vers[v2].first;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">current</span>.firstadj!=v1) &#123;</span><br><span class="line">			pre = <span class="keyword">current</span>;</span><br><span class="line">			<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">		&#125;</span><br><span class="line">		//v2到v1之间存在边则删除</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			pre.nextvex = <span class="keyword">current</span>.nextvex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//获得指定的结点间的边</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> getEdg(<span class="type">int</span> v1, <span class="type">int</span> v2) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v1&lt;<span class="number">0</span> || v2&lt;<span class="number">0</span> || v1&gt;=numofvers || v2&gt;=numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LNode <span class="keyword">current</span> = vers[v1].first;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">current</span>.firstadj == v2) &#123;</span><br><span class="line">				<span class="keyword">System</span>.<span class="keyword">out</span>.println("结点v"+v1+"-&gt;"+"结点v"+v2+"边的权值为："+<span class="keyword">current</span>.weight);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">current</span> = vers[v2].first;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">current</span>.firstadj == v2) &#123;</span><br><span class="line">				<span class="keyword">System</span>.<span class="keyword">out</span>.println("结点v"+v2+"-&gt;"+"结点v"+v1+"边的权值为："+<span class="keyword">current</span>.weight);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//深度优先遍历 Deep-first traversal</span><br><span class="line">	<span class="built_in">public</span> <span class="type">void</span> DFT(<span class="type">int</span> v) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;<span class="number">0</span> || v&gt;=numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Stack&lt;<span class="type">Integer</span>&gt; stack = <span class="built_in">new</span> Stack&lt;<span class="type">Integer</span>&gt;();</span><br><span class="line">		vers[v].isvisited = <span class="keyword">true</span>;</span><br><span class="line">		LNode <span class="keyword">current</span>;</span><br><span class="line">		stack.push(v);</span><br><span class="line">		<span class="keyword">while</span>(stack!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			v = stack.pop();</span><br><span class="line">			<span class="keyword">System</span>.<span class="keyword">out</span>.println(vers[v].data+" ");</span><br><span class="line">			<span class="keyword">current</span> = vers[v].first;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(vers[<span class="keyword">current</span>.firstadj].isvisited==<span class="keyword">false</span>) &#123;</span><br><span class="line">					stack.push(<span class="keyword">current</span>.firstadj);</span><br><span class="line">					vers[<span class="keyword">current</span>.firstadj].isvisited = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//遍历完成后恢复初始状态</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numofvers;i++) &#123;</span><br><span class="line">			vers[i].isvisited = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//广度优先遍历 Breadth-first traversal</span><br><span class="line">	<span class="built_in">public</span> <span class="type">void</span> BFT(<span class="type">int</span> v) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;<span class="number">0</span> || v&gt;=numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Queue&lt;<span class="type">Integer</span>&gt; queue = <span class="built_in">new</span> LinkedList&lt;<span class="type">Integer</span>&gt;();</span><br><span class="line">		LNode <span class="keyword">current</span>;</span><br><span class="line">		vers[v].isvisited = <span class="keyword">true</span>;</span><br><span class="line">		queue.offer(v);</span><br><span class="line">		<span class="keyword">while</span>(queue!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			v = queue.poll();</span><br><span class="line">			<span class="keyword">System</span>.<span class="keyword">out</span>.println(vers[v].data+" ");</span><br><span class="line">			<span class="keyword">current</span> = vers[v].first;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(vers[<span class="keyword">current</span>.firstadj].isvisited==<span class="keyword">false</span>) &#123;</span><br><span class="line">					queue.offer(<span class="keyword">current</span>.firstadj);</span><br><span class="line">					vers[<span class="keyword">current</span>.firstadj].isvisited = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//遍历完成后恢复初始状态</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numofvers;i++) &#123;</span><br><span class="line">			vers[i].isvisited = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//Dijkstra最短路径</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 基本思路就是先建立一个源点与各个结点的距离库</span></span><br><span class="line"><span class="comment">	 * 然后将结点作为入度的结点与源点通过的的各个结点距离相加 若小于最初的距离 则更新 直到全部更新完毕</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">public</span> <span class="type">int</span>[] Dijkstra(<span class="type">int</span> v) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;<span class="number">0</span> || v&gt;numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LNode <span class="keyword">current</span>;</span><br><span class="line">		<span class="keyword">current</span> = vers[v].first;</span><br><span class="line">		<span class="type">int</span>[] distance = <span class="built_in">new</span> <span class="type">int</span>[numofvers];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numofvers;i++) &#123;</span><br><span class="line">			distance[i] = <span class="type">Integer</span>.MAX_VALUE;  //即∞</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			distance[<span class="keyword">current</span>.firstadj] = <span class="keyword">current</span>.weight;</span><br><span class="line">			<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">		&#125;</span><br><span class="line">		distance[v] = <span class="number">0</span>;</span><br><span class="line">		vers[v].isvisited = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numofvers;i++) &#123;</span><br><span class="line">			<span class="type">int</span> min = <span class="type">Integer</span>.MAX_VALUE;</span><br><span class="line">			<span class="type">int</span> <span class="keyword">index</span> = <span class="number">-1</span>;</span><br><span class="line">			// 比较从源点到其余顶点的路径长度</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numofvers; j++) &#123;</span><br><span class="line">				// 从源点到j顶点的最短路径还没有找到</span><br><span class="line">				<span class="keyword">if</span> (vers[j].isvisited == <span class="keyword">false</span>) &#123;</span><br><span class="line">					// 从源点到j顶点的路径长度最小</span><br><span class="line">					<span class="keyword">if</span> (distance[j] &lt; min) &#123;</span><br><span class="line">						<span class="keyword">index</span> = j;</span><br><span class="line">						min = distance[j];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			// 找到源点到索引为<span class="keyword">index</span>顶点的最短路径长度</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">index</span> != <span class="number">-1</span>)</span><br><span class="line">				vers[<span class="keyword">index</span>].isvisited = <span class="keyword">true</span>;</span><br><span class="line">			// 更新当前最短路径及距离</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; numofvers; t++)</span><br><span class="line">				<span class="keyword">if</span> (vers[t].isvisited == <span class="keyword">false</span>) &#123;</span><br><span class="line">					<span class="keyword">current</span> = vers[t].first;</span><br><span class="line">					<span class="keyword">while</span> (<span class="keyword">current</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">if</span> (<span class="keyword">current</span>.firstadj == <span class="keyword">index</span>)</span><br><span class="line">							<span class="keyword">if</span> ((min + <span class="keyword">current</span>.weight) &lt; distance[t]) &#123;</span><br><span class="line">								distance[t] = min + <span class="keyword">current</span>.weight;</span><br><span class="line">								break;</span><br><span class="line">							&#125;</span><br><span class="line">						<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> distance;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM】字节码执行机制</title>
    <url>/2020/07/02/%E3%80%90JVM%E3%80%91%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><strong>本篇字节码执行机制将深入了解JVM字节码执行引擎在运行中怎么做( ∙̆ .̯ ∙̆ )</strong></p>
<a id="more"></a>
<h2 id="JVM字节码执行引擎概念"><a href="#JVM字节码执行引擎概念" class="headerlink" title="JVM字节码执行引擎概念"></a>JVM字节码执行引擎概念</h2><blockquote>
<p>作为JVM最为核心的组成部分，JVM执行引擎的工作方式本身就非常类似于真正物理机的编译以及汇编语言的执行机理，JVM执行引擎可以自己制定指令集和执行结构体系，很多不能被硬件所直接支持的指令集在执行引擎里也能够执行，这都是执行引擎自己所实现的，一般看来，<strong>所有的Java虚拟机的执行引擎都是将输入的字节码文件经过字节码解析过程从而得到执行结果的过程</strong>。<strong>字节码作为JVM的指令集，它需要JVM执行引擎去执行，达到从本地机器码到字节码的编译结果</strong>，这看似只是存储格式的转变，但这却深深的影响了编程语言。</p>
</blockquote>
<h2 id="线帧"><a href="#线帧" class="headerlink" title="线帧"></a>线帧</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>线帧（Stack Frame）是一种用于支持虚拟机进行方法调用和方法执行的数据结构，<strong>它是虚拟机运行时数据区中虚拟机栈的栈元素</strong>线帧作为栈元素并且能支持虚拟机对方法的相关操作自然包含了很多数据元素，也就是说，每一个方法的被调用到结束都对应着一个线帧从入栈到出栈的过程。</p>
</blockquote>
<p>在方法调用到结束的过程中还有一些相关概念</p>
<blockquote>
<p><strong>一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的</strong>,每当一个线程启动时，JVM都会为它分配一个栈，栈的单位是帧，并且它负责保存当前线程的运行状态，其中某个线程正在执行的方法就称为<strong>当前方法</strong>，当前方法所用到的帧称为<strong>当前帧</strong>，这个方法所属的类就被称作<strong>当前类</strong>，当前所用到的常量池成为<strong>当前常量池</strong>，所以在一个线程执行方法时就会追踪当前常量池。线帧作为当前方法所分配的一个帧，于是也就成了当前帧，这个帧就被用来存储当前方法的相关数据流被压入虚拟机栈中。</p>
</blockquote>
<p>概括的说</p>
<blockquote>
<p>栈是用来保存当前线程的运行状态的，而帧是用来保存当前方法的运行状态的，也就是线程中依次运行不同方法对应着帧的入栈和出栈   </p>
</blockquote>
<h3 id="组成成分"><a href="#组成成分" class="headerlink" title="组成成分"></a>组成成分</h3><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>相关概念：</p>
<blockquote>
<p>局部变量表的容量是<strong>容量槽slot</strong>为最小单位，一个slot大小为32bit，所以在<strong>64位的虚拟机</strong>中需要使用<strong>对齐补白</strong>的手段来使得使得容量槽slot在外观上看起来和32位的虚拟机保持一致，所以说对于<strong>64位的数据如long，double都需要使用两个容量槽slot去存储</strong>，并且在任何时候都不允许<strong>单独访问</strong>其中的一个。局部变量表的大小是在编译期间可以查询到的，因为它是作为方法的对应属性里的数据max_local数据项中存储的，也就是编译class文件的过程中，这个最大的需要分配变量的局部变量表的最大存储容量就已经确定了。</p>
</blockquote>
<p>局部变量表的顺序：</p>
<blockquote>
<p>变量表的索引从0开始，首先是方法所属的对象的引用（静态方法无）-&gt;其次是方法的参数变量（按照声明的顺序）-&gt;再者是方法的内部的局部变量（按照声明的顺序）。并且对于byte char short这三种数据类型需要转化为int类型存储在局部变量表中</p>
</blockquote>
<p>其他性质：</p>
<blockquote>
<p>在类被JVM加载时会为类变量赋初值，但是局部变量若声明了但却未赋初值是会出现编译错误的并且slot对于局部变量中没有覆盖整个方法的作用域的变量是可重用的。对于可重用的slot，如果后面没有在定义变量对这个slot进行覆盖，即使这个变量已经无效，那么这个变量在方法体内也不会被回收，除非解释执行的时候显示的赋值为null，但是在JIT编译器优化后赋值为null的操作就会被消除掉，这时候将变量设置为null就没有意义了。</p>
</blockquote>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>一些操作性质：</p>
<blockquote>
<p>操作数栈和局部变量表一样都是编译期间，操作数栈的最大深度在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的元素不明确Java的数据类型，也就是说在所有Java数据类型中，32位数据容量为1,64位数据容量为2，   </p>
</blockquote>
<p>其他性质：</p>
<blockquote>
<p>在概念模型中，一个县城的两个栈帧是相互独立的，但是在虚拟机实现中都会做一些优化处理，让两个栈帧出现一部分重叠，也就是让下面栈帧的部分操作数栈与上面的栈帧的部分局部变量表互相重重叠，这样在进行方法调用时就会公用一部分数据，无需进行额外的参数复制，达到了一定的优化效果。java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中栈指的就是操作数栈。</p>
</blockquote>
<h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><blockquote>
<p>栈帧包含了一个指向运行时常量池中该栈帧所属方法的引用，这个引用是为了支持方法调用过程中的<strong>动态连接</strong>。常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用有些会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外的符号引用将在每一次<strong>运行期间</strong>转化为直接引用，这部分称为<strong>动态解析</strong>。</p>
</blockquote>
<h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><blockquote>
<p>无论是正常完成退出方法还是异常完成退出方法，都需要返回到方法被调用的位置，才能将程序正常进行下去，方法正常退出时，PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值；方法异常退出时，要通过异常处理器表来确定返回的地址，栈帧中一般不会保存这部分信息。方法退出相当于把当前栈帧出栈，所以方法退出时可能执行恢复上层方法的局部变量表和操作数栈的操作和把返回值（如果存在）压入调用者栈帧的操作数栈中的操作以及调整PC计数器的值以指向方法调用指令后面的一条指令的操作。</p>
</blockquote>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p><img src="https://wx2.sbimg.cn/2020/07/02/2YjyJ.png" alt="2YjyJ.png"></p>
<h3 id="解析调用"><a href="#解析调用" class="headerlink" title="解析调用"></a>解析调用</h3><blockquote>
<p>我们知道，在类加载过程中有解析阶段，在这个阶段中，类文件的一部分符号引用会转化为直接引用，这么做主要是因为<strong>方法在真正的执行前就已经有了一个可确定的调用版本，并且这个版本在运行期间是不可变的</strong>，这类方法的调用就称作解析调用。并且满足条件的这类方法叫做<strong>非虚方法</strong>主要有静态方法、私有方法、父类方法、final类方法、实例构造器方法，其他的不满足这样过程的条件都称为<strong>虚方法</strong></p>
</blockquote>
<h2 id="分派与多态"><a href="#分派与多态" class="headerlink" title="分派与多态"></a>分派与多态</h2><h3 id="静态分派与重载"><a href="#静态分派与重载" class="headerlink" title="静态分派与重载"></a>静态分派与重载</h3><blockquote>
<p>重载是指方法名是相同的但是方法签名不同的情况，调用时使用<strong>方法签名</strong>来判断调用哪个具体方法，<strong>JVM在重载时是通过静态类型作为判断依据</strong>，所以javac编译器会根据参数的静态类型来决定选择哪个版本的方法，<strong>静态分派发生在编译阶段</strong>，因此确定静态分派的动作实际上不是有虚拟机来执行的。</p>
</blockquote>
<p>Java静态类型与实际类型的相关解释可以参考上一篇博客或直接点击<a href="http://www.easonhe.top/2020/07/02/%E3%80%90Java%E3%80%91%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">传送门</a></p>
<h4 id="方法签名的解释"><a href="#方法签名的解释" class="headerlink" title="方法签名的解释"></a>方法签名的解释</h4><blockquote>
<p><strong>方法头指定修饰符、返回值类型、方法名、和形式参数</strong>。方法头中定义的变量称为形参 ，形参如同占位符。当方法被调用时，传递一个值给形参，此值称为实参，形参列表指的是形参的类型、顺序和形参的数目。<strong>方法签名就是方法名和形参列表共同组成的</strong>。</p>
</blockquote>
<h3 id="动态分配与重写"><a href="#动态分配与重写" class="headerlink" title="动态分配与重写"></a>动态分配与重写</h3><blockquote>
<p>重写是指方法名和方法签名都相同的子类重写父类的方法，但是需要注意的是静态方法可以重载但是重写是无效的，因为在调用的过程中<strong>通过子类的实例对象调用就是调用子类的静态方法，通过父类的实例对象调用则调用父类的静态方法</strong></p>
</blockquote>
<blockquote>
<p>动态分派和多态重写的本质与<strong>字节码指令invokevirtual的多态查找过程</strong>相关：1.找到栈顶元素所指向的对象的实际类型，记为C；2. 在类型C中找到与常量池中的描述符与简单名称都相符的方法，然后进行访问权限检查，如果通过则返回这个方法的直接引用，查找结束；如果不通过，则返回java.lang.IllegalAccessError异常。3.否则，按照继承关系，继续重复2中搜索和验证过程。4.如果始终没有找到，则抛出java.lang.AbstractMethodError异常。这里注意，<strong>重写的本质其实就是invokevirtual指令把常量池中的符号引用解析到了不同的实际类型的直接引用上</strong></p>
</blockquote>
<p>用代码实例验证一下动态分配与静态方法重写问题：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"><span class="comment">//动态分配与静态方法重写的测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text1</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Father say Hi"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Father static"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="title">extends</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Son say Hi"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Son static"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Daughter</span> <span class="title">extends</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Daughter say Hi"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Daughter static"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"动态分配测试"</span>);</span><br><span class="line">		Father s = <span class="keyword">new</span> Son();</span><br><span class="line">		Father d = <span class="keyword">new</span> Daughter();</span><br><span class="line">		s.sayHi();</span><br><span class="line">		d.sayHi();</span><br><span class="line">		s = <span class="keyword">new</span> Daughter();</span><br><span class="line">		s.sayHi();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"静态方法重写测试"</span>);</span><br><span class="line">		s.testStatic();</span><br><span class="line">		d.testStatic();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>动态分配测试<br>Son say Hi<br>Daughter say Hi<br>Daughter say Hi<br>静态方法重写测试<br>Father static<br>Father static   </p>
</blockquote>
<p>这里需要注意的是：</p>
<blockquote>
<p>分派与解析并不是说只能选一个的问题，只是它们在不同的阶段不同层次上筛选和确定目标的过程，就比如静态方法在类加载过程的解析中就进行了解析，但若静态方法含有重载的版本那么这将在静态分派中完成选择问题。</p>
</blockquote>
<h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><blockquote>
<p>动态分派时为了避免频繁的搜索，会为类在方法区建立一个虚方法表，利用索引来代替元数据查找从而提高性能。<strong>虚方法表中存放着各个方法的实际入口地址</strong>。如果某个方法在子类中没有重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口，如果子类中重写了这个方法，那么子类对应的方法的地址将会替代指向父类方法的入口地址。具有相同方法签名的父类、子类的方法在父类和子类的虚方法表中具有相同的索引序号，这样当类型变换时，仅需要变更查找的方法表。</p>
</blockquote>
<h2 id="解释执行与直接执行"><a href="#解释执行与直接执行" class="headerlink" title="解释执行与直接执行"></a>解释执行与直接执行</h2><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><blockquote>
<p>解释器是将平台无关的字节码（原本由javac将java文件编译为class文件，并将源代码编译成了与平台无关的字节码）解释称对应平台的机器码解释执行</p>
</blockquote>
<h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><blockquote>
<p>（即时编译器）是一个把Java的字节码（包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序。JVM对这个函数就不再解释而是直接执行</p>
</blockquote>
<h3 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h3><blockquote>
<p>用户模式下:解释执行的。<br>server模式下：先解释执行，然后JVM统计函数执行热点，将这些热点代码仔细优化编译成本地机器码(默认为调用10000次以上)，即使用JIT编译器，当这个热点不再是热点的时候，重新解释执行。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】(队列的Java实现与经典应用)</title>
    <url>/2020/06/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%A4%E7%A7%8DJava%E5%AE%9E%E7%8E%B0%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8)/</url>
    <content><![CDATA[<p><strong>队列的出现迎合了很多Java复杂结构的应用,如二叉树的层序遍历,本篇用两种方法(数组\链表)实现了队列的定义,与此同时还有一些经典的方法进行了定义,涵盖了简单队列的内容,欢迎阅览喔( ͡° ͜ʖ ͡°)✧</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>与栈的结构相反，队列是一种先进先出的特殊表结构，普通队列的假溢出现象十分糟糕，所有目前对于队列的实现一般都使用循环队列，需要注意的是为了区分空队列和满队列的条件不同，故需要牺牲一个存储位置来满足循环队列的判断，具体可见数组形式的队列实现代码。<br><img src="https://i.loli.net/2020/06/14/HizbhIlXqKQ9f25.jpg" alt="IMG_7968.jpg"></p>
</blockquote>
<h2 id="队列的数组实现"><a href="#队列的数组实现" class="headerlink" title="队列的数组实现"></a>队列的数组实现</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package SquenceList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;T&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> T[] datas;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> maxsize;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> realmaxsize; <span class="comment">//真正储存的只有最大值-1个元素</span></span><br><span class="line">		<span class="comment">//队列的初始化</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> maxsize)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(maxsize&lt;<span class="number">1</span>) &#123;</span><br><span class="line">				maxsize=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.maxsize = maxsize;</span><br><span class="line">			realmaxsize = maxsize<span class="number">-1</span>;</span><br><span class="line">			rear = <span class="number">0</span>;</span><br><span class="line">			front = <span class="number">0</span>;</span><br><span class="line">			datas = (T[])<span class="keyword">new</span> Object[maxsize];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断队列是否为空</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; </span><br><span class="line">			<span class="keyword">return</span> (front==rear);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断队列是否已满</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">//注意循环队列判断是否已满的条件，为了和队空的条件区别</span></span><br><span class="line">			<span class="keyword">if</span>((rear+<span class="number">1</span>)%maxsize==front) &#123;</span><br><span class="line">				rear--;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;                                      <span class="comment">//所以这里牺牲了一个存储空间从而找到了判断队满的条件</span></span><br><span class="line">		<span class="comment">//进队</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="string">"队满啦，不能再进啦～"</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			datas[rear]=t;</span><br><span class="line">			rear++;</span><br><span class="line">			rear = rear%maxsize;  <span class="comment">//循环队列的特点，若要知其值则%maxsize</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//出队</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="string">"我队什么都没有，不可以再出去了～"</span>);</span><br><span class="line">				<span class="keyword">return</span> null;</span><br><span class="line">			&#125;</span><br><span class="line">			T data = datas[front++];</span><br><span class="line">			front = front%maxsize;</span><br><span class="line">			<span class="keyword">return</span> data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的队头位置</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> front;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的队尾位置</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> <span class="built_in">end</span> = rear<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">end</span>;  <span class="comment">//倒数第二个位置放着队列的队尾元素</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的对头位置元素</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">getFrontData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> datas[front];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的队尾位置元素</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">getRearData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> <span class="built_in">end</span> = rear<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">return</span> datas[<span class="built_in">end</span>]; <span class="comment">//队尾指针始终为空，故队尾元素在倒数第二个</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的元素</span></span><br><span class="line">		<span class="keyword">public</span> T[] getDatas() &#123;</span><br><span class="line">			<span class="keyword">return</span> datas;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的最大长度</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> realmaxsize;  <span class="comment">//这里因为我们创建的是循环形式的队列，所以在判断队列是否满的时候需要牺牲一个位置</span></span><br><span class="line">		&#125;                      <span class="comment">//所以真实的存储空间应为空间数-1</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		ArrayQueue myqueue = <span class="keyword">new</span> ArrayQueue(<span class="number">5</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我的队列现在是空的吗:"</span>+myqueue.isEmpty());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我的队列现在是满的吗:"</span>+myqueue.isFull());</span><br><span class="line">		myqueue.push(<span class="number">1</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在队头是第几个呢:"</span>+myqueue.getFront());</span><br><span class="line">		myqueue.push(<span class="number">3</span>);</span><br><span class="line">		myqueue.push(<span class="number">5</span>);</span><br><span class="line">		<span class="comment">//myqueue.push(7);</span></span><br><span class="line">		<span class="comment">//myqueue.push(9); //空间只能存放最大数量-1个数量的元素</span></span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"在我入队了一些元素后，现在我的队列现在是空的吗:"</span>+myqueue.isEmpty());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"在我入队了一些元素后，现在我的队列现在是满的吗:"</span>+myqueue.isFull());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"出队:"</span>+myqueue.pop());</span><br><span class="line">		<span class="comment">//System.out.println("出队:"+myqueue.pop());</span></span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在我的队伍都有谁呢:"</span>+myqueue.getDatas());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在队头是第几个呢:"</span>+myqueue.getFront());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在队尾是第几个呢:"</span>+myqueue.getRear());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在队头是谁呢:"</span>+myqueue.getFrontData());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在队尾是谁呢:"</span>+myqueue.getRearData());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我的队列能放多少个元素呢:"</span>+myqueue.getLength());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列的链表实现"><a href="#队列的链表实现" class="headerlink" title="队列的链表实现"></a>队列的链表实现</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> LinkedQueue&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Node&lt;T&gt; front;</span><br><span class="line">	<span class="keyword">private</span> Node&lt;T&gt; rear;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxsize;</span><br><span class="line">	<span class="keyword">class</span> Node&lt;T&gt;&#123;  <span class="comment">//同样用内部类来作为节点的定义</span></span><br><span class="line">		<span class="keyword">private</span> T data;</span><br><span class="line">		<span class="keyword">public</span> Node&lt;T&gt; <span class="keyword">next</span>;</span><br><span class="line">		<span class="keyword">public</span> Node ()&#123;</span><br><span class="line">			<span class="keyword">this</span>.data=<span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">this</span>.<span class="keyword">next</span>=<span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> Node(T data) &#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">			<span class="keyword">this</span>.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> T getData() &#123;</span><br><span class="line">			<span class="keyword">return</span> data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> setData(T data) &#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> Node getNext() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//构造链队的初始化方法</span></span><br><span class="line">	<span class="keyword">public</span> LinkedQueue() &#123;</span><br><span class="line">		<span class="keyword">this</span>.front = <span class="keyword">new</span> Node();</span><br><span class="line">		<span class="keyword">this</span>.rear = <span class="keyword">new</span> Node();</span><br><span class="line">		maxsize = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化链队</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> initQueue() &#123;</span><br><span class="line">		<span class="keyword">this</span>.front = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">this</span>.rear = <span class="keyword">null</span>;</span><br><span class="line">		maxsize = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入队</span></span><br><span class="line">	<span class="comment">//判断链队是否为空</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> isEmpty() &#123;</span><br><span class="line">		<span class="keyword">if</span>(front.<span class="keyword">next</span>==<span class="keyword">null</span>||rear.<span class="keyword">next</span>==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入队</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">push</span>(T data) &#123;</span><br><span class="line">		Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;(data);</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			front.<span class="keyword">next</span> = node;</span><br><span class="line">			rear.<span class="keyword">next</span> = node;</span><br><span class="line">			maxsize++;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			node.<span class="keyword">next</span> = front.<span class="keyword">next</span>;</span><br><span class="line">			front.<span class="keyword">next</span> = node;</span><br><span class="line">			maxsize++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//出队</span></span><br><span class="line">	<span class="keyword">public</span> Node <span class="keyword">pop</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			System.out.<span class="keyword">println</span>(<span class="string">"这里是空的无法出队哦"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxsize ==<span class="number">1</span>) &#123;</span><br><span class="line">			Node node = front.<span class="keyword">next</span>;</span><br><span class="line">			initQueue();</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			Node end = front;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxsize-<span class="number">1</span>;i++) &#123;</span><br><span class="line">				end = end.<span class="keyword">next</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Node node = rear.<span class="keyword">next</span>;</span><br><span class="line">			rear.<span class="keyword">next</span> = end.<span class="keyword">next</span>;</span><br><span class="line">			maxsize--;</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">		LinkedQueue&lt;Integer&gt; lq = <span class="keyword">new</span> LinkedQueue&lt;Integer&gt;();</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"我现在还没有入队，队是空的吗？"</span>+lq.isEmpty());</span><br><span class="line">		lq.<span class="keyword">push</span>(<span class="number">1</span>);</span><br><span class="line">		lq.<span class="keyword">push</span>(<span class="number">2</span>);</span><br><span class="line">		lq.<span class="keyword">push</span>(<span class="number">3</span>);</span><br><span class="line">		lq.<span class="keyword">push</span>(<span class="number">4</span>);</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"我入队了一些元素，现在队还是空的吗？"</span>+lq.isEmpty());</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"出队所有元素元素："</span>);</span><br><span class="line">		System.out.<span class="keyword">println</span>(lq.<span class="keyword">pop</span>().data);</span><br><span class="line">		System.out.<span class="keyword">println</span>(lq.<span class="keyword">pop</span>().data);</span><br><span class="line">		System.out.<span class="keyword">println</span>(lq.<span class="keyword">pop</span>().data);</span><br><span class="line">		System.out.<span class="keyword">println</span>(lq.<span class="keyword">pop</span>().data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】(堆栈的三种Java实现与经典应用)</title>
    <url>/2020/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%A0%86%E6%A0%88%E7%9A%84%E4%B8%89%E7%A7%8DJava%E5%AE%9E%E7%8E%B0%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8)/</url>
    <content><![CDATA[<p><strong>堆栈在Java编程中无处不在,作为重要的数据结构类型之一,本篇使用了三种方式(数组\链表\共享数组空间)来实现堆栈,并且对一些经典的应用方法进行了定义,欢迎阅览ㄟ(◑‿◐ )ㄏ</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>LIFO(先进后出)的一种线性表，栈的优点是存取速度快，仅次于寄存器，并且栈的数据是可共享的，但是存放在栈的数据的大小和生存周期是固定的，缺乏一定的灵活性。在本篇对栈的实现使用的是链表与数组的形式，因为这两种形式简化了在ArrayList和LinkedList中的逻辑。<br><img src="https://i.loli.net/2020/06/15/cr2inNtdUVW1GK5.jpg" alt="IMG_7966.jpg"></p>
</blockquote>
<h2 id="数组形式对栈实现"><a href="#数组形式对栈实现" class="headerlink" title="数组形式对栈实现"></a>数组形式对栈实现</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;E&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Object[] data;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxsize;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line">	<span class="comment">//若没有定义初始长度则自定义一个5为初始长度</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//若有定义初始长度，则调用此构造函数来初始化数组长度</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> maxsize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(maxsize&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.maxsize = maxsize;</span><br><span class="line">			data = <span class="keyword">new</span> Object[maxsize];</span><br><span class="line">			top = <span class="number">-1</span>;  <span class="comment">//top目前指向第一个元素之前的位置</span></span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"初始化长度不能为0及小于0"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断栈是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top==<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(top&gt;=maxsize<span class="number">-1</span>) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"栈满，无法放入新元素"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			data[++top] = o;  <span class="comment">//若栈味满则此时top指针向上移动一位后存放入元素，此时成为栈顶元素</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取栈顶元素但不弹出</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"栈空，无栈顶元素"</span>);</span><br><span class="line">			<span class="keyword">return</span> null;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (E)data[top];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//出栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"栈空，无栈顶元素"</span>);</span><br><span class="line">			<span class="keyword">return</span> null;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (E)data[top--];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//寻找元素在栈中的位置</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(E order)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> toptem = top;  <span class="comment">//临时top节点，以便查找完成后回到初始状态</span></span><br><span class="line">		<span class="keyword">while</span>(top!=<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(data[top]==order) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				--top;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> result = ++top;</span><br><span class="line">		top = toptem;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		Stack mystack= <span class="keyword">new</span> Stack(<span class="number">6</span>);</span><br><span class="line">		mystack.push(<span class="number">1</span>);</span><br><span class="line">		mystack.push(<span class="number">2</span>);</span><br><span class="line">		mystack.push(<span class="number">3</span>);</span><br><span class="line">		mystack.push(<span class="number">4</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"mystack 是否为空？"</span>+mystack.isEmpty());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"mystack的栈顶元素为："</span>+mystack.<span class="built_in">peek</span>());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"依次出栈前两个:"</span>+mystack.pop()+mystack.pop());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"此时栈顶元素为："</span>+mystack.<span class="built_in">peek</span>());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"元素1此时在栈中的位置为："</span>+mystack.search(<span class="number">2</span>));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表形式堆栈实现"><a href="#链表形式堆栈实现" class="headerlink" title="链表形式堆栈实现"></a>链表形式堆栈实现</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkStack</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	Node&lt;T&gt; top = <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">//用内部类对栈的节点进行定义</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">T</span>&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> T <span class="keyword">data</span>;</span><br><span class="line">		<span class="keyword">private</span> Node&lt;T&gt; next=<span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">public</span> Node(T <span class="keyword">data</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入栈</span></span><br><span class="line">	<span class="keyword">public</span> void push(T <span class="keyword">data</span>) &#123;</span><br><span class="line">		Node&lt;T&gt; newnode = new Node&lt;T&gt;(<span class="keyword">data</span>);</span><br><span class="line">		newnode.next = top;</span><br><span class="line">		top = newnode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//出栈</span></span><br><span class="line">	<span class="keyword">public</span> T pop() &#123;</span><br><span class="line">		<span class="keyword">if</span>(top==<span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		T <span class="keyword">data</span> = top.<span class="keyword">data</span>;</span><br><span class="line">		top = top.next;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">data</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断栈是否为空</span></span><br><span class="line">	<span class="keyword">public</span> boolean isEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> top==<span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取栈顶的值</span></span><br><span class="line">	<span class="keyword">public</span> T peek() &#123;</span><br><span class="line">		<span class="keyword">if</span>(top==<span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> top.<span class="keyword">data</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">		LinkStack ls = new LinkStack();</span><br><span class="line">		ls.push(<span class="number">1</span>);</span><br><span class="line">		ls.push(<span class="number">6</span>);  <span class="comment">//依次入栈</span></span><br><span class="line">		ls.push(<span class="number">2</span>);</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"栈是否为空:"</span>+ls.isEmpty());</span><br><span class="line">		System.<span class="keyword">out</span>.println(ls.pop());</span><br><span class="line">		System.<span class="keyword">out</span>.println(ls.pop());  <span class="comment">//先入后出是栈的最大的特点</span></span><br><span class="line">		System.<span class="keyword">out</span>.println(ls.pop());</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"取出栈顶元素:"</span>+ls.peek()); <span class="comment">//栈已经全部弹出 栈顶元素为null</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>3.共享数组空间的双重栈形式</em></strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxsize = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> topl;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> topr;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DoubleStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		data = <span class="keyword">new</span> <span class="keyword">int</span>[maxsize];</span><br><span class="line">		topl = <span class="number">-1</span>;</span><br><span class="line">		topr = maxsize;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断是否栈空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ((topl==<span class="number">0</span>)&amp;&amp;(topr==maxsize));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断是否栈满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (topl+<span class="number">1</span>==topr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//清空栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		topl = <span class="number">-1</span>;</span><br><span class="line">		topr = maxsize;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取栈的长度</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">			<span class="keyword">return</span> maxsize;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> length = (topl+<span class="number">1</span>)+(maxsize-topr);</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取左栈栈顶值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(topl==<span class="number">-1</span>) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"左栈什么都没有喔～"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> data[topl];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取右栈栈顶值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(topr==maxsize) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"右栈什么都没有喔～"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> data[topr];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">String</span> stackdir, <span class="keyword">int</span> e)</span> </span>&#123;  <span class="comment">//stackdir分为左栈和右栈</span></span><br><span class="line">		<span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"嘻嘻嘻栈满啦，不能再入啦～～"</span>);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(stackdir==<span class="string">"左栈"</span>) &#123;</span><br><span class="line">			topl+=<span class="number">1</span>;</span><br><span class="line">			data[topl]=e;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(stackdir==<span class="string">"右栈"</span>) &#123;</span><br><span class="line">			topr-=<span class="number">1</span>;</span><br><span class="line">			data[topr]=e;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//出栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">String</span> stackdir)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"555这里什么都没有，不能再出了～～～"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(stackdir==<span class="string">"左栈"</span>) &#123;</span><br><span class="line">			result = data[topl--];</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(stackdir==<span class="string">"右栈"</span>) &#123;</span><br><span class="line">			result = data[topr++];</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历此双栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackTraverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;=topl) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(data[i]+<span class="string">" "</span>);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		i = topr;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;maxsize) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(data[i]+<span class="string">" "</span>);;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		DoubleStack <span class="built_in">stack</span> = <span class="keyword">new</span> DoubleStack();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"此时栈为空吗？"</span>+<span class="built_in">stack</span>.isEmpty());</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"左栈"</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"左栈"</span>, <span class="number">2</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"左栈"</span>, <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"右栈"</span>, <span class="number">4</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"右栈"</span>, <span class="number">5</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"右栈"</span>, <span class="number">6</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"此时栈的长度为:"</span>+<span class="built_in">stack</span>.length());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我放入了一些元素，此时栈为空吗？"</span>+<span class="built_in">stack</span>.isEmpty());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我想看看左栈栈顶是什么:"</span>+<span class="built_in">stack</span>.getLeftStack());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我还想看右栈栈顶是什么:"</span>+<span class="built_in">stack</span>.getRightStack());</span><br><span class="line">		System.out.<span class="built_in">print</span>(<span class="string">"让我看看栈里面都有什么吧："</span>);</span><br><span class="line">		<span class="built_in">stack</span>.stackTraverse();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我想弹出一些左栈的元素"</span>+<span class="built_in">stack</span>.pop(<span class="string">"左栈"</span>)+<span class="built_in">stack</span>.pop(<span class="string">"左栈"</span>));</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我想弹出一些右栈的元素"</span>+<span class="built_in">stack</span>.pop(<span class="string">"右栈"</span>)+<span class="built_in">stack</span>.pop(<span class="string">"右栈"</span>));</span><br><span class="line">		System.out.<span class="built_in">print</span>(<span class="string">"现在栈里都还剩哪些元素呢？:"</span>);</span><br><span class="line">		<span class="built_in">stack</span>.stackTraverse();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】(顺序表的Java与C++实现及经典应用)</title>
    <url>/2020/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84Java%E4%B8%8EC++%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8)/</url>
    <content><![CDATA[<p><strong>从入坑到入土的坑就是顺序表,珍惜最基础的数据结构,当然也要掌握好这个数据结构大厦的基石,顺序表的实现形式给很多复杂的数据结构形式提供了简单实现的方案,在有些时候,用顺序表的实现并非是差的选择(♥◠‿◠)ﾉ</strong></p>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/06/15/dqgl9kEIMwfuVAo.jpg" alt="IMG_7969.jpg"></p>
<h2 id="顺序表的Java实现"><a href="#顺序表的Java实现" class="headerlink" title="顺序表的Java实现"></a>顺序表的Java实现</h2><blockquote>
<p>Java代码是对顺序表的简单数组实现，对于顺序表的任何操作都可以利用数组来实现，但是往往使用数组时需要对数组的长度进行估计，这也很不符合实际也是很大的缺陷，但是在Java等现代语言中均不需要再对数组的长度进行估算，若数组长度达到了最大值可以用相应的方法进行扩充建立一个新的顺序表，当然对于顺序表的实现即使是数组实现但也有插入和删除需要大量移动数组带来的时间复杂度的问题。</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java代码实现</span></span><br><span class="line">package SquenceList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Sqlist</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span> MAXSIZE;</span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span>[] sqlist;</span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span> length;</span><br><span class="line">	<span class="comment">//用最大数组长度来初始化顺序表</span></span><br><span class="line">	<span class="keyword">public</span> Sqlist(<span class="built_in">int</span> MAXSIZE)&#123;</span><br><span class="line">		<span class="keyword">this</span>.sqlist = new <span class="built_in">int</span>[MAXSIZE];</span><br><span class="line">		<span class="keyword">this</span>.MAXSIZE=MAXSIZE;</span><br><span class="line">		<span class="keyword">this</span>.length=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//用数组来初始化顺序表</span></span><br><span class="line">	<span class="keyword">public</span> Sqlist(<span class="built_in">int</span>[] arr) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">			sqlist[i] = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.length = arr.length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对由数组实现的顺序表进行扩充</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> expandList()&#123;</span><br><span class="line">	    <span class="built_in">int</span>[] newarr = new <span class="built_in">int</span>[arr.length*<span class="number">2</span>]</span><br><span class="line">	    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">	        newarr[i]=arr[i]</span><br><span class="line">	    &#125;</span><br><span class="line">	    arr = newarr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//向顺序表指定位置插入元素</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> listInsert(<span class="built_in">int</span> i, <span class="built_in">int</span> e) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>) &#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"非法插入位置"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.length == <span class="keyword">this</span>.MAXSIZE) &#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"顺序表已满"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> k=length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--) &#123;</span><br><span class="line">			sqlist[k+<span class="number">1</span>]=sqlist[k];  <span class="comment">//数组中插入位置及其后的元素均向后移动一位</span></span><br><span class="line">		&#125;</span><br><span class="line">		sqlist[i<span class="number">-1</span>]=e;  <span class="comment">//将制定元素插入此位置</span></span><br><span class="line">		<span class="keyword">this</span>.length++;  <span class="comment">//插入后的顺序表长度+1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//清空顺序表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> listClear() &#123;</span><br><span class="line">		<span class="keyword">this</span>.length = <span class="number">0</span>;  <span class="comment">//仅用来判断是否为空，直接将长度设置为0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断顺序表是否为空</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">bool</span>ean isEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.length==<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取指定位置的顺序表元素</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">int</span> getElem(<span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;length)</span><br><span class="line">		&#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"获取位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sqlist[i<span class="number">-1</span>];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取制定元素的位置信息</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> getIndex(<span class="built_in">int</span> e, <span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;=length<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(sqlist[j]==e) &#123;</span><br><span class="line">				i=j++;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"顺序表中无对应元素"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印顺序表</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">void</span> printList() &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;=length<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">int</span> t=i+<span class="number">1</span>;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"第"</span>+t+<span class="string">"个元素为"</span>+sqlist[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除顺序表指定位置的元素</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">int</span> listDelete(<span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;length)</span><br><span class="line">		&#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"删除位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=i;j&lt;=length<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sqlist[j<span class="number">-1</span>]=sqlist[j];</span><br><span class="line">		&#125;</span><br><span class="line">		length--;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">		Sqlist sqlist = new Sqlist(<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			sqlist.listInsert(i, i);</span><br><span class="line">		&#125;</span><br><span class="line">		printList();</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"第3个元素为"</span>+getElem(<span class="number">3</span>));</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"删除第二个元素后的顺序表的内容为："</span>)</span><br><span class="line">		listDelete(<span class="number">2</span>);</span><br><span class="line">		printList();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺序表的C-实现"><a href="#顺序表的C-实现" class="headerlink" title="顺序表的C++实现"></a>顺序表的C++实现</h2><blockquote>
<p>C++代码实现顺序表的实现由于有指针的牵制而使得代码的实现比较复杂，需要多加理解和记忆。</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立顺序表的存储结构</span></span><br><span class="line">typedef <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> *elem;</span><br><span class="line">    <span class="built_in">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//构造一个空的顺序表</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">InitList(SqList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">L</span>.</span></span>elem=<span class="keyword">new</span> ElemType<span class="literal">[<span class="identifier">maxsize</span>]</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="module-access"><span class="module"><span class="identifier">L</span>.</span></span>elem) exit(overflow);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">L</span>.</span></span>length=<span class="number">0</span>;</span><br><span class="line">    return ok;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顺序表的插入</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ListInsert(SqList &amp;L,<span class="params">int</span> <span class="params">i</span>,<span class="params">int</span> <span class="params">e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((i&lt;<span class="number">1</span>)<span class="pattern-match"><span class="operator">||</span>(i&gt;<span class="constructor">L</span>.length+1)) return error; <span class="operator">/</span><span class="operator">/</span>插入位置是否合法的判断</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(<span class="constructor">L</span>.length<span class="operator">==</span>maxsize)  return error;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> j=<span class="constructor">L</span>.length-1;j&gt;=i-1;j--)</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">L</span>.elem[j+1]=<span class="constructor">L</span>.elem[j];  <span class="operator">/</span><span class="operator">/</span>插入后元素位置的移动变化</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">L</span>.elem[i-1]=e;</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">++</span><span class="constructor">L</span>.length;</span></span><br><span class="line"><span class="pattern-match">    return ok;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span>顺序表元素的获取</span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> <span class="constructor">GetElem(SqList L,<span class="params">int</span> <span class="params">i</span>,<span class="params">int</span> &amp;<span class="params">e</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(i&lt;1<span class="operator">||</span>i&gt;<span class="constructor">L</span>.length) return error;</span></span><br><span class="line"><span class="pattern-match">    e=<span class="constructor">L</span>.elem[i-1];</span></span><br><span class="line"><span class="pattern-match">    return e;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span>判断值是否相等</span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> <span class="constructor">EqualList(<span class="params">int</span> <span class="params">a</span>,<span class="params">int</span> <span class="params">b</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(a<span class="operator">==</span>b)</span></span><br><span class="line"><span class="pattern-match">        return ok;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">        return error;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span>判断顺序表中是否存在值为e的元素</span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> <span class="constructor">LocateElem(SqList L,ElemType <span class="params">e</span>,<span class="params">int</span> EqualList(<span class="params">int</span> <span class="params">a</span>, <span class="params">int</span> <span class="params">b</span>)</span>)</span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> i=1;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> <span class="operator">*</span>p=<span class="constructor">L</span>.elem;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">while</span>(i&lt;=<span class="constructor">L</span>.length<span class="operator">&amp;&amp;</span>!<span class="constructor">EqualList(<span class="operator">*</span><span class="params">p</span><span class="operator">++</span>,<span class="params">e</span>)</span>)</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">++</span>i;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(i&lt;=<span class="constructor">L</span>.length)</span></span><br><span class="line"><span class="pattern-match">        return 1;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">        return 0;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span>顺序表的打印</span></span><br><span class="line"><span class="pattern-match">void <span class="constructor">PrintList(SqList L)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> i=0; i&lt;<span class="constructor">L</span>.length; i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        cout&lt;&lt;<span class="constructor">L</span>.elem[i]&lt;&lt;" ";</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span>顺序表表示集合的并集</span></span><br><span class="line"><span class="pattern-match">void <span class="constructor">MergeList(SqList LA,SqList LB,SqList &amp; LC)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">   <span class="built_in">int</span> m,n,e;</span></span><br><span class="line"><span class="pattern-match">   m=<span class="constructor">LA</span>.length;n=<span class="constructor">LB</span>.length;</span></span><br><span class="line"><span class="pattern-match">   for(<span class="built_in">int</span> i=1;i&lt;=n;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">   &#123;</span></span><br><span class="line"><span class="pattern-match">       <span class="constructor">GetElem(LB,<span class="params">i</span>,<span class="params">e</span>)</span>;  <span class="operator">/</span><span class="operator">/</span>获取<span class="constructor">B</span>中第i个元素并返回给e</span></span><br><span class="line"><span class="pattern-match">       <span class="keyword">if</span>(!<span class="constructor">LocateElem(LA,<span class="params">e</span>,EqualList)</span> )</span></span><br><span class="line"><span class="pattern-match">           &#123;</span></span><br><span class="line"><span class="pattern-match">               <span class="constructor">ListInsert(LA,<span class="operator">++</span><span class="params">m</span>,<span class="params">e</span>)</span>;    <span class="operator">/</span><span class="operator">/</span>将e插在<span class="constructor">LC</span>的最后</span></span><br><span class="line"><span class="pattern-match">           &#125;</span></span><br><span class="line"><span class="pattern-match">   &#125;</span></span><br><span class="line"><span class="pattern-match">   for(<span class="built_in">int</span> i=1;i&lt;=m;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">GetElem(LA,<span class="params">i</span>,<span class="params">e</span>)</span>;   <span class="operator">/</span><span class="operator">/</span>获取<span class="constructor">A</span>中第i个元素并赋给e</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">ListInsert(LC,<span class="params">i</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> <span class="constructor">Mixture(SqList LA,SqList LB,SqList &amp;LC)</span></span></span><br><span class="line"><span class="pattern-match">&#123;<span class="operator">/</span><span class="operator">/</span>a与b的交集</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> m,n,e;</span></span><br><span class="line"><span class="pattern-match">    m=<span class="constructor">LA</span>.length;</span></span><br><span class="line"><span class="pattern-match">    n=<span class="constructor">LB</span>.length;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> j=0;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> p=m&lt;=n?<span class="constructor">LA</span>:<span class="constructor">LB</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> q=m&gt;n?<span class="constructor">LA</span>:<span class="constructor">LB</span>;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> i=1;i&lt;=p.length;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">GetElem(<span class="params">p</span>,<span class="params">i</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span>(<span class="constructor">LocateElem(<span class="params">q</span>,<span class="params">e</span>,EqualList)</span>)</span></span><br><span class="line"><span class="pattern-match">        &#123;</span></span><br><span class="line"><span class="pattern-match">            <span class="constructor">ListInsert(LC,<span class="operator">++</span><span class="params">j</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(<span class="constructor">LC</span>.length)</span></span><br><span class="line"><span class="pattern-match">        return ok;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">        return error;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> <span class="constructor">Different(SqList LA,SqList LB,SqList &amp;LC)</span></span></span><br><span class="line"><span class="pattern-match">&#123;<span class="operator">/</span><span class="operator">/</span>求<span class="constructor">A</span>-<span class="constructor">B</span>的集合</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> m=<span class="constructor">LA</span>.length;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> e;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> j=0;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> i=1;i&lt;=m;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">GetElem(LA,<span class="params">i</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span>(!<span class="constructor">LocateElem(LB,<span class="params">e</span>,EqualList)</span>)</span></span><br><span class="line"><span class="pattern-match">            <span class="constructor">ListInsert(LC,<span class="operator">++</span><span class="params">j</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(<span class="constructor">LC</span>.length)</span></span><br><span class="line"><span class="pattern-match">        return ok;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">        return error;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> main()</span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> <span class="constructor">LA</span>,<span class="constructor">LB</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">InitList(LA)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">InitList(LB)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"线性表a的长度："&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> la;</span></span><br><span class="line"><span class="pattern-match">    cin&gt;&gt;la;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"请输入a中的元素："&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> e;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> i=1;i&lt;=la;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        cin&gt;&gt;e;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">ListInsert(LA,<span class="params">i</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"<span class="constructor">A</span>中的元素:"&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">PrintList(LA)</span>;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"线性表b的长度："&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> lb;</span></span><br><span class="line"><span class="pattern-match">    cin&gt;&gt;lb;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"请输入b中的元素："&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> i=1;i&lt;=lb;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        cin&gt;&gt;e;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">ListInsert(LB,<span class="params">i</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"<span class="constructor">B</span>中的元素"&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">PrintList(LB)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"<span class="constructor">A</span>并<span class="constructor">B</span>:";</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> <span class="constructor">LC1</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">InitList(LC1)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">MergeList(LA,LB,LC1)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">PrintList(LC1)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"<span class="constructor">A</span>交<span class="constructor">B</span>：";</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> <span class="constructor">LC2</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">InitList(LC2)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">Mixture(LA,LB,LC2)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">PrintList(LC2)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"<span class="constructor">A</span>差<span class="constructor">B</span>：";</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> <span class="constructor">LC3</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">InitList(LC3)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">Different(LA,LB,LC3)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">PrintList(LC3)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    return 0;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
</search>

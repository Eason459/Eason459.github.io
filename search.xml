<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Java】Java后知后觉(初阶)</title>
    <url>/2020/04/29/Java%E5%90%8E%E7%9F%A5%E5%90%8E%E8%A7%89/</url>
    <content><![CDATA[<p><strong>那些Java中你可能不知道的一些事&lt;(▰˘◡˘▰)&gt;</strong></p>
 <a id="more"></a>
<p><img src="https://i.loli.net/2020/06/20/Rix9mJo7VXUFkDM.jpg" alt="IMG_6579.jpg"></p>
<ol>
<li><h2 id="关于命令"><a href="#关于命令" class="headerlink" title="关于命令"></a>关于命令</h2></li>
</ol>
<ul>
<li><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">javac </span>HelloWorld.<span class="keyword">java </span> </span><br><span class="line">$ <span class="keyword">java </span>HelloWorld  </span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>相信这是大家刚刚接触Java时接触到的第一个程序</strong><br><strong>在这个命令行终端中我们用到了两个命令javac和java</strong></p>
<ul>
<li>javac后跟着的是一个典型的java文件，javac此时所做的事就是<em>将java源文件编译成字节码文件</em>此时如果编译成功的话是会生成一个名为HelloWorld.class的文件，此时就是成功编译为字节码文件；</li>
<li>java后跟的是Java文件中的类名，比如这里的HelloWorld但是不要加.class后缀。</li>
</ul>
<ol start="2">
<li><h2 id="关于修饰符"><a href="#关于修饰符" class="headerlink" title="关于修饰符"></a>关于修饰符</h2></li>
</ol>
<p>-</p>
<h3 id="synchronized修饰符"><a href="#synchronized修饰符" class="headerlink" title="synchronized修饰符"></a>synchronized修饰符</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">easonHe</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<strong>synchronized</strong>修饰符是在多线程的程序编码中常会用到的修饰符，<em>synchronized</em>修饰符旨在<em>确保方法在同一时间只能被一个线程访问</em>。同时<strong>synchronized</strong>可以用于四个访问修饰符。  </p>
<p>-</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> active;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        active = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(active)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        active = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>volatile</em>修饰词也是常用于多线程中，每当线程准备访问<em>volatile</em>所修饰的成员变量时，必须要从共享内存中重新读取该成员变量的值，另外，如果遇到该成员变量的值发生改变时，线程也必须将该成员变量的值写入到共享内存中更新，这样以来，多线程中每个线程所看到的都是成员变量的同一个值。  </p>
</blockquote>
<blockquote>
<p>这个成程序中，若是一个线程调用run()方法，此时另一线程调用stop()方法时，如果线程已经进入while的缓冲区，那么即使stop()方法中的active=false线程也不会停止，但是由于这个线程中的active是被<em>volatile</em>修饰符所修饰，所以这个循环会停止。</p>
</blockquote>
<p>-</p>
<h3 id="transient修饰符"><a href="#transient修饰符" class="headerlink" title="transient修饰符"></a>transient修饰符</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> transient <span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> b;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>transient</em>修饰符用来定义变量时，其作用是用来预处理类与变量的数据类型，也就是说，如果序列化的对象包含别<em>transient</em>修饰的实例变量，那么JVM将会跳过此特定的变量。</p>
</blockquote>
<h2 id="关于运算符"><a href="#关于运算符" class="headerlink" title="关于运算符"></a>关于运算符</h2><p>-</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">A = <span class="number">0101</span> <span class="number">1100</span></span><br><span class="line">B = <span class="number">0010</span> <span class="number">0101</span>  </span><br><span class="line">---------------</span><br><span class="line">A&amp;B = <span class="number">0000</span> <span class="number">0100</span></span><br><span class="line">A|B = <span class="number">0111</span> <span class="number">1101</span></span><br><span class="line">A^B = <span class="number">0111</span> <span class="number">1001</span></span><br><span class="line">~A = <span class="number">1010</span> <span class="number">0011</span></span><br><span class="line">B&lt;&lt;<span class="number">2</span> = <span class="number">1001</span> <span class="number">0100</span></span><br><span class="line">B&gt;&gt;<span class="number">2</span> = <span class="number">1001</span></span><br><span class="line">B&gt;&gt;&gt;<span class="number">2</span> = <span class="number">0000</span> <span class="number">1001</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><em>^如果对应位值相等则为0不等则为1</em>；</li>
<li><em>～按位取反运算符</em>；</li>
<li>*&lt;&lt;按位左移运算符，左操作数按位左移右操作数指定的位数*;  </li>
<li><em>&gt;&gt;按位右移运算符，左操作数按位右移右操作数指定的位数</em>；</li>
<li><em>&gt;&gt;&gt;按位右移补零运算符，在按位右移的情况下将最高位的空位用零填充</em></li>
</ol>
</blockquote>
<p>但是其实我们真正用到它的时候并非如此使用，而是下面这种情况：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(<span class="keyword">String</span>[], args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">13</span>; <span class="comment">//即 a=0000 1101</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">28</span>; <span class="comment">//即 b=0001 1100</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        c = a &amp; b;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"a &amp; b = "</span>+c) <span class="comment">//此时c的值为12 即0000 1100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说我们平时使用的往往并非二进制编码，而是对应的十进制编码，但有时我们也会为了满足某种需求而使用到十进制编码进行位操作符的运算。  </p>
<p>-</p>
<h3 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[], args)&#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">6</span>;</span><br><span class="line">        <span class="built_in">bool</span>ean result = (a&lt;<span class="number">2</span>&amp;&amp;++a&lt;<span class="number">8</span>) <span class="comment">//a=6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码中，result结果为false，因为a&lt;2已经是false了所以结果必定是false，所以说第二个操作判断就不被执行了，也就是++a不被执行，所以此时a仍然为6.</p>
</blockquote>
<p>-</p>
<h3 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"watermelon"</span>;</span><br><span class="line"><span class="built_in">boolean</span> isReal = <span class="built_in">str</span> <span class="keyword">instanceof</span> <span class="keyword">String</span>;</span><br><span class="line"><span class="comment">// is Real = true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>instanceof运算符用于操作一个对象的实例，若为此特定类类型或接口类型则为真，否则为假，即如果运算符左侧所指的对象是右侧类或者接口的一个对象则结果为真。  </p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cola</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Pepsi</span> <span class="keyword">extends</span> <span class="title">Cola</span></span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[], args)&#123;</span><br><span class="line">        <span class="type">Cola</span> cola = <span class="keyword">new</span> <span class="type">Pepsi</span>();</span><br><span class="line">        boolean result = cola instanceof <span class="type">Pepsi</span>;</span><br><span class="line">        <span class="comment">//此时result=true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用instanceof操作符如果被比较的对象兼容于右侧的类型，则同样成立。这里应该注意<strong><em>判断一个实例引用的类型时，使用的是实际类型，而不是声明的类型，如上代码中cola是Pepsi类型而不是Cola类型，并且，子类的实例可以声明为父类，但是父类的实例不可以声明为子类</em></strong>。</p>
</blockquote>
<h2 id="关于循环"><a href="#关于循环" class="headerlink" title="关于循环"></a>关于循环</h2><p>-</p>
<h3 id="加强型for循环-For-Each"><a href="#加强型for循环-For-Each" class="headerlink" title="加强型for循环(For-Each)"></a>加强型for循环(For-Each)</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[], args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] num = &#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : num)&#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(i+<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//此时将会打印出2 6 9 30</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">String</span> [] drinks = &#123;<span class="string">"cola"</span>, <span class="string">"coffee"</span>, <span class="string">"tea"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> name : drinks)&#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(name+<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//此时将会打印出cola coffee tea </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种情况是Java引入的为了用于数组形式的增强版for循环。</p>
</blockquote>
<p><strong>ps:在循环或者条件以及选择语句中需要注意的几点：</strong>  </p>
<ol>
<li>在循环操作语句中，如果遇到break语句被执行，那么将会直接跳出最内层的一个循环体，如果遇到continue语句被执行，那么接下来的语句将不会被执行，而是直接进入新一轮的循环，这种用法往往用来选择性退出或者是去刻意忽略某次循环体内的语句；</li>
<li>在选择操作语句中，如switch语句，如果case没有与变量类型相匹配的，那么将会执行default语句（如果有的话），如果匹配的case语句没有break，那么将会顺序输出以下的语句，直到遇到break或全部输出。  </li>
</ol>
<h2 id="关于Java类"><a href="#关于Java类" class="headerlink" title="关于Java类"></a>关于Java类</h2><p>-</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>由于java属于面向对象的编程语言，所以我们难免会遇到使用数据时需要使用对象而不是内置数据类型的情形，针对于此，java提供了包装类：Double,Float, Long, Integer, Short, Byte.</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">IntergerTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[], args)&#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">128</span>;</span><br><span class="line">        Interger b = <span class="number">128</span>;</span><br><span class="line">        Interger c = new Interger(<span class="number">128</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(a==b); <span class="comment">//true 因为与内置数据类型比较，所以Interger会自动拆箱比较  </span></span><br><span class="line">        <span class="comment">// a==c 与 a==b情况相同</span></span><br><span class="line">        Interger b1 = <span class="number">127</span>;</span><br><span class="line">        Interger c1 = <span class="number">127</span>; <span class="comment">//此时经编译时为Interger b2 = Interger.valueOf(127)  </span></span><br><span class="line">        System.<span class="keyword">out</span>.println(b1==c1); <span class="comment">//true</span></span><br><span class="line">        Interger b2 = <span class="number">128</span>;</span><br><span class="line">        Interger c2 = <span class="number">128</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(b2==c2); <span class="comment">//false 因为Interger中的valueOf函数只会对int类型的取值范围内（-128～127）之间的数进行缓存。  </span></span><br><span class="line">        Interger b3 = new Interger(<span class="number">127</span>);</span><br><span class="line">        Interger c3 = <span class="number">127</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(b3==c3); <span class="comment">//false 无论如何Interger与new得到的Interger不会相等，</span></span><br><span class="line">        <span class="comment">//因为new得到的对象放在堆存储区里，非new得到的常量则放在常量池即方法区里，故不会经历拆箱，两地址也不同，故不会相等</span></span><br><span class="line">        Interger b4 = new Interger(<span class="number">127</span>);</span><br><span class="line">        Interger c4 = new Interger(<span class="number">127</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(b4==c4); <span class="comment">//false 因为都是通过new得到的对象，所以地址不相同</span></span><br><span class="line">        Interger b5 = <span class="number">127</span>;</span><br><span class="line">        Interger c5 = <span class="number">127</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(b5.equals(c5)); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译器特别支持的包装成为装箱，所以在内置类型要作为对象使用时，编译器就会将其装箱成为一个包装类，若是一个对象要作为内置数据类型使用时，编译器也会将其拆箱；  </p>
</blockquote>
<blockquote>
<h2 id="要注意在进行比较时-比较的是地址，equals-比较的是对象的内容，所以在Interger-valueOf-时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。"><a href="#要注意在进行比较时-比较的是地址，equals-比较的是对象的内容，所以在Interger-valueOf-时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。" class="headerlink" title="要注意在进行比较时 =比较的是地址，equals()比较的是对象的内容，所以在Interger.valueOf()时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。  "></a>要注意在进行比较时 =比较的是地址，equals()比较的是对象的内容，所以在Interger.valueOf()时，范围内相同的值使用同一个地址，但是超出范围后的地址又不相同了。  </h2></blockquote>
<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] <span class="built_in">array</span> = &#123;<span class="string">"E"</span>, <span class="string">"a"</span>, <span class="string">"s"</span>, <span class="string">"o"</span>, <span class="string">"n"</span>&#125;;</span><br><span class="line">        <span class="keyword">String</span> str = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="built_in">array</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(str);</span><br><span class="line">        <span class="comment">//输出结果为Eason</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Java中，String字符串属于对象，String类有11中构造方法，这些方法提供不同的参数来初始化字符串，比如这段代码中提供一个字符数组来初始化一个字符串；  </p>
</blockquote>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class Demo&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main()&#123;</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"Eason"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">        <span class="comment">//输出Eason</span></span><br><span class="line">        <span class="built_in">str</span> = <span class="string">"He"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">        <span class="comment">//输出He</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>特别需要注意的是一旦String对象被创建那么它就无法被更改了，也就是说String是被final修饰的，但是这段代码中str在结果上看是改变了，但其实它并没有被更改，因为实例str只是一个String的对象引用，当执行str=”He”的时候它创建了一个新的String对象”He”,原来的”Eason”对象仍然存储在内存中；  </p>
</blockquote>
<blockquote>
<p>也就是说，如果需要对字符串做很多修改，那么应该选择使用<em>StringBuffer和StringBuilder</em>类。<br>    1.StringBuffer:字符串变量，Synchronized线程安全，如果想专成String类型，则可以使用toString()方法，Java.lang.StringBuffer可以通过某些特定的方法调用可以改变该序列的长度和内容，可以将字符串缓冲区安全的应用于多个线程；<br>    2.StringBuilder:字符串变量，非线程安全，在内部StringBuilder对象被当作是一个包含自负序列的变长数组；<br>    <strong><em>总结</em></strong>：<strong>-</strong> 如果操作少量的数据用String <strong>-</strong> 单线程操作大量数据用StringBuilder <strong>-</strong> 多线程操作大量数据用StringBuffer。<br>    ps：其实StringBuffer的线程安全也是很低能的也就是说它也只能保证jvm不抛出异常而向下运行而已，所以针对于StringBuilder的高效，所以<strong><em>在绝大部分情况下直接使用StringBuilder</em></strong>。</p>
</blockquote>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">String <span class="built_in">s1</span> = <span class="string">"a"</span>+<span class="string">"b"</span>+<span class="string">"c"</span>;</span><br><span class="line">String <span class="built_in">s2</span> = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(<span class="built_in">s1</span>==<span class="built_in">s2</span>)<span class="comment">;//true</span></span><br><span class="line">System.out.println(<span class="built_in">s1</span>.equals(<span class="built_in">s2</span>))<span class="comment">;//true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是道面试经常会被问到的问题，在Java常量优化机制中，编译时s1已经成为”abc”在常量池中查找创建，故此时s2就不用再创建了；  </p>
</blockquote>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="built_in">s1</span> = <span class="string">"a"</span>+<span class="string">"b"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="built_in">s2</span> = <span class="string">"abc"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="built_in">s3</span> = <span class="built_in">s1</span>+<span class="string">"c"</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">System.out.println</span>(<span class="built_in">s3</span>=<span class="symbol">=s2</span>)<span class="comment">;//false</span></span><br><span class="line"><span class="symbol">System.out.println</span>(<span class="built_in">s3</span>.equals(<span class="built_in">s2</span>))<span class="comment">;//true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这也是道面试经常会被问到的问题，在编译时，”ab”在常量池中被创建其地址为a1,”abc”接着被创建其地址为a2,对于s3，先创建一个StringBuilder或StringBuffer对象，通过append方法连接得到abc，再调用toString()转换为String得到的地址为a3，故==为false，equals比较对象的值为true。</p>
</blockquote>
<p><strong>另外</strong>：length(), length属性，size()之间的一些区别</p>
<ol>
<li>length()方法是针对字符串来说的，要求一个字符串的长度时就要用到这个方法；</li>
<li>length属性是针对Java中的数组来说的，要求数组的长度可以用length属性；</li>
<li>size()方法是针对泛型集合List来说的，如果想看一个泛型集合中有多少个元素就使用此方法；</li>
</ol>
<h2 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h2><p>-</p>
<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[], args)&#123;</span><br><span class="line">        <span class="built_in">int</span> [] num = new <span class="built_in">int</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="built_in">int</span> [] num1 = &#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Arrays.fill(num, <span class="number">6</span>);<span class="comment">//此时num数组内的元素为66666666</span></span><br><span class="line">        Arrays.fill(num, <span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>);<span class="comment">//将num数组中第1，2个元素赋值为8</span></span><br><span class="line">        Arrays.sort(num1);<span class="comment">//对num1数组进行排序</span></span><br><span class="line">        Arrays.equals(num, num1);<span class="comment">//比较两数组元素是否相等</span></span><br><span class="line">        Arrays.binarySearch(num1, <span class="number">2</span>);<span class="comment">//查找元素3在数组中的位置，如果不存在就返回负数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java.util.Arrays类能够很方便的处理数组，它提供的所有方法都是静态的，它的部分功能：<br>    1. 通过fill()方法给数组赋值；<br>    2. 通过sort()方法按升序排序；<br>    3. 通过equals()方法判断数组中的元素是否相等；<br>    4. 通过binarySearch()方法能对排好序的数组进行二分法查找等等。</p>
</blockquote>
<h2 id="关于正则表达式"><a href="#关于正则表达式" class="headerlink" title="关于正则表达式"></a>关于正则表达式</h2><p>-</p>
<h3 id="Pattern与Matcher类"><a href="#Pattern与Matcher类" class="headerlink" title="Pattern与Matcher类"></a>Pattern与Matcher类</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[], args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">String</span> str = <span class="string">"My number is 56? Yes!"</span>;</span><br><span class="line">        <span class="keyword">String</span> regex = <span class="string">"(\\d+)(\\D*)(.*)"</span>;</span><br><span class="line">        Pattern p = Pattern.compile(regex);<span class="comment">//创建Pattern对象</span></span><br><span class="line">        Matcher m = p.matcher(str);<span class="comment">//创建Matcher(适配器)对象</span></span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">find</span>())&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(m.group(<span class="number">0</span>));<span class="comment">//输出：My number is 56? Yes!</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(m.group(<span class="number">1</span>));<span class="comment">//输出：56</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(m.group(<span class="number">2</span>));<span class="comment">//输出：My number is Yes</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(m.group(<span class="number">3</span>));<span class="comment">//输出：? Yes!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本段代码中group()方法为捕获组，比如正则表达式中((A)(B(C)))这其中就有四个组((A)(B(C)))、(A)、(B(C))、(C),技巧是左边数第几个括号所对应的内容就是相应的第几组；  </p>
</blockquote>
<blockquote>
<p>Pattern与Matcher类都没有公共的构造方法，都是通过调用静态函数所得到的返回类型来创建类；</p>
</blockquote>
<blockquote>
<p>在其他语言的正则表达式中往往一个反斜杠\就具有转义作用，但是Java的正则表达式中两个反斜杠才能表示转义作用，比如\\d表示一位数字。</p>
</blockquote>
<blockquote>
<p>在Matcher类中有两个重要的方法就是start()和end()方法，start()方法返回由给定组所捕获的初始索引，end()方法是返回最后一个匹配字符的索引+1</p>
</blockquote>
<h2 id="关于Java方法"><a href="#关于Java方法" class="headerlink" title="关于Java方法"></a>关于Java方法</h2><p>-</p>
<h3 id="出现在方法名称"><a href="#出现在方法名称" class="headerlink" title="_出现在方法名称"></a>_出现在方法名称</h3><blockquote>
<h2 id="在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test-例如：textPop-emptyStack"><a href="#在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test-例如：textPop-emptyStack" class="headerlink" title="在方法的命名中，下划线可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test 例如：textPop_emptyStack."></a>在方法的命名中，下划线<em>可能出现在JUnit测试方法名称中用来分割名称的逻辑组件，典型模式：test<MethodUnderTest></em><state> 例如：textPop_emptyStack.</h2></blockquote>
<h3 id="命令行参数的使用"><a href="#命令行参数的使用" class="headerlink" title="命令行参数的使用"></a>命令行参数的使用</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"args["</span>+i+<span class="string">"] = "</span>+args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行此程序：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ javac Demo.java</span><br><span class="line">$ java Demo This <span class="keyword">is</span> <span class="keyword">a</span> <span class="keyword">command</span> <span class="built_in">line</span></span><br><span class="line"><span class="keyword">args</span>[<span class="number">0</span>] = This</span><br><span class="line"><span class="keyword">args</span>[<span class="number">1</span>] = <span class="keyword">is</span></span><br><span class="line"><span class="keyword">args</span>[<span class="number">2</span>] = <span class="keyword">a</span></span><br><span class="line"><span class="keyword">args</span>[<span class="number">3</span>] = <span class="keyword">command</span></span><br><span class="line"><span class="keyword">args</span>[<span class="number">4</span>] = <span class="built_in">line</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息"><a href="#这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息" class="headerlink" title="这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息  "></a>这种情况适用于一个程序在运行时再给它传递消息，命令行参数是紧跟在执行程序名称的后边的信息  </h2></blockquote>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main()&#123;</span><br><span class="line">        printMin(&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0.6</span>,&#125;);<span class="comment">//输出：The min value is : 0.6</span></span><br><span class="line">        printMin(new <span class="built_in">double</span>[]&#123;<span class="number">3.2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6.7</span>&#125;)<span class="comment">//输出：The min value is : 3.2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> printMin(doulbe... num)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.length==<span class="number">0</span>)&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"No agument passed"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">double</span> result = num[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]&lt;result)&#123;</span><br><span class="line">                result=num[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"The min value is : "</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个函数中最多只能有一个可变参数，并且要放在参数列表的最后，代码在执行时，编译器会将可变参数编译为一个数组，所以在函数的内部，参数名可以看作是数组名； </p>
</blockquote>
<blockquote>
<h2 id="由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法"><a href="#由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法" class="headerlink" title="由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法"></a>由于函数重载关系到形参列表，所以当形参列表是多个相同类型的参数这时就与可变参数具有相同的功能，但是对于可变参数的重载，系统有限匹配固定参数的方法</h2></blockquote>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizationDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Cola cola1 = <span class="keyword">new</span> Cola(<span class="number">1</span>);</span><br><span class="line">        Cola cola2 = <span class="keyword">new</span> Cola(<span class="number">2</span>);</span><br><span class="line">        Cola cola3 = <span class="keyword">new</span> Cola(<span class="number">3</span>);</span><br><span class="line">        cola2 = cola3 = <span class="keyword">null</span>;<span class="comment">//将两对象作废，接下来会被回收</span></span><br><span class="line">        System.gc();<span class="comment">//调用Java垃圾收容器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cola</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cola</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i=i;</span><br><span class="line">        System.out.println(<span class="string">"Cola object "</span>+i+<span class="string">" is created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cola object "</span>+i+<span class="string">" is disposed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//Cola object 1 is created</span></span><br><span class="line"><span class="comment">//Cola object 2 is created</span></span><br><span class="line"><span class="comment">//Cola object 3 is created</span></span><br><span class="line"><span class="comment">//Cola object 2 is disposed</span></span><br><span class="line"><span class="comment">//Cola object 3 is disposed</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>finalize()方法在对象被回收之前调用，它用来清除回收对象，可以用这个方法来确保一个对象打开的文件被关闭，并且该方法需要protected限定其余类不可调用此方法，当然JVM自动完成内存的回收，也可以通过这个方法来手动操作  </p>
</blockquote>
<h2 id="关于文件的Stream-流-与File-文件"><a href="#关于文件的Stream-流-与File-文件" class="headerlink" title="关于文件的Stream(流)与File(文件)"></a>关于文件的Stream(流)与File(文件)</h2><p>-</p>
<h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bWrite = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;<span class="comment">//写入的数据为byte类型</span></span><br><span class="line">            Outputstream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bWrite.length;i++)&#123;</span><br><span class="line">                os.<span class="built_in">write</span>(bWtite[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            os.<span class="built_in">close</span>();</span><br><span class="line">        </span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = is.<span class="built_in">available</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)&#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>((<span class="keyword">byte</span>)is.<span class="built_in">read</span>());<span class="comment">//最终要的要将读取数据强制转换成同类型才能避免乱码</span></span><br><span class="line">            &#125;</span><br><span class="line">            is.<span class="built_in">close</span>();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">"Exception"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FileOutputStream读写文件中容易出现乱码问题，这跟字符集编码无关，主要是要保证读写的类型一致，当然如果不一致也可以通过OutputStramWriter与InputStreamReader来规定相同的编码  </p>
</blockquote>
<h2 id="关于scanner类"><a href="#关于scanner类" class="headerlink" title="关于scanner类"></a>关于scanner类</h2><p>-</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        scanner scan = <span class="keyword">new</span> Scanner(System.in)<span class="comment">//控制台输入</span></span><br><span class="line">        <span class="comment">//scanner scanf = new Scanner(new File(test.text));从文件中读取</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(scan.hasNext())&#123;</span><br><span class="line">        <span class="keyword">String</span> str = scan.next();<span class="comment">//单个字符返回，若是空字符则退出</span></span><br><span class="line">        <span class="comment">//String str1 = scan.nextLine(); 每次读取一行，包含空字符，这时的判断应为scan.hasNextLine()</span></span><br><span class="line">        <span class="comment">//int i = scan.nextInt();如果要接收数据，则为next***() 相应的判断语句也更改</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>scanner类在输入时的字符都是可见的，所以带来了一定的安全问题，故可以使用Console类来实现输入密码的目的，即：</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Console cns = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>console<span class="literal">()</span>;</span><br><span class="line">String userame = cns.read<span class="constructor">Line(<span class="string">"User name: "</span>)</span>;</span><br><span class="line"><span class="built_in">char</span><span class="literal">[]</span> password = cns.read<span class="constructor">Password(<span class="string">"Password: "</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="关于Java异常处理"><a href="#关于Java异常处理" class="headerlink" title="关于Java异常处理"></a>关于Java异常处理</h2><p>-</p>
<h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><blockquote>
<p>1、error–错误: 是指程序无法处理的错误，表示应用程序运行时出现的重大错误。例如jvm运行时出现的OutOfMemoryError以及Socket编程时出现的端口占用等程序无法处理的错误。<br>2、Exception-异常 ：异常可分为运行时异常跟编译异常<br>    -<em>运行时异常</em>：即RuntimeException及其之类的异常。这类异常在代码编写的时候不会被编译器所检测出来，是可以不需要被捕获，但是程序员也可以根据需要进行捕获抛出。常见的RUNtimeException有：NullpointException（空指针异常），ClassCastException（类型转换异常），IndexOutOfBoundsException（数组越界异常）等。<br>    -<em>编译异常</em>：RuntimeException以外的异常。这类异常在编译时编译器会提示需要捕获，如果不进行捕获则编译错误。常见编译异常有：IOException（流传输异常），SQLException（数据库操作异常）等。<br>-</p>
</blockquote>
<h3 id="语句块执行问题"><a href="#语句块执行问题" class="headerlink" title="语句块执行问题"></a>语句块执行问题</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//函数语句</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"catch is begin"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//不被执行</span></span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"finally is begin"</span>);<span class="comment">//被执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//被执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了"><a href="#这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了" class="headerlink" title="这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了"></a>这是一个面试中经常会见到的题目。在这段代码表明了，finally语句块是要在return之前被执行的，并且如果finally语句块中有return语句，则直接执行finally语句块中的return语句，其他语句块中的return就不能被执行了</h2></blockquote>
<h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">Demo</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>throws经常会被用在方法声明后，方法体之前，表明方法可能跑出一个异常，throw经常被用在方法体内，表示此时抛出一个已定义的异常。</p>
</blockquote>
<h2 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h2><p>-</p>
<h3 id="构造器-构造方法或构造函数"><a href="#构造器-构造方法或构造函数" class="headerlink" title="构造器(构造方法或构造函数)"></a>构造器(构造方法或构造函数)</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    father()&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    public father(int i)&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="type">Son</span>()&#123;</span><br><span class="line">        <span class="comment">//super() 自动调用父类的无参构造器</span></span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="type">Son</span>(int i)&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">3</span>)<span class="comment">//主动调用父类的有参构造器，就不再默认调用父类的无参构造器</span></span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="在Son-继承Father-后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器-主动调用，如果有的话-，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器-但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super-参数-否则系统报错"><a href="#在Son-继承Father-后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器-主动调用，如果有的话-，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器-但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super-参数-否则系统报错" class="headerlink" title="在Son()继承Father()后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器(主动调用，如果有的话)，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器,但是如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super(参数),否则系统报错"></a>在Son()继承Father()后，在子类的构造函数中第一行要先调用父类的构造器，可以调用父类的有参构造器(主动调用，如果有的话)，也可以不主动调用，但是系统会自动在子类的第一行调用父类的无参构造器,但是<strong><em>如果父类只有一个有参构造器，则在子类的构造器的首行必须要先调用super(参数),否则系统报错</em></strong></h2></blockquote>
<h3 id="重写-覆盖-中的调用问题"><a href="#重写-覆盖-中的调用问题" class="headerlink" title="重写(覆盖)中的调用问题"></a>重写(覆盖)中的调用问题</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    public void demo()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Father's demo()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    public void demo()&#123;</span><br><span class="line">        <span class="keyword">super</span>.demo();<span class="comment">//此时输出Father's demo()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用"><a href="#如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用" class="headerlink" title="如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用"></a>如果子类对父类的方法进行了重写或覆盖，则若想在子类中调用父类的相同的方法，则需要使用super进行调用</h2></blockquote>
<h3 id="转型问题"><a href="#转型问题" class="headerlink" title="转型问题"></a>转型问题</h3><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">Father f1 = <span class="keyword">new</span> <span class="type">Son</span>();<span class="comment">//upcasting(向上转型)f1引用指向Son对象</span></span><br><span class="line">Son s1 = (Son)f1;<span class="comment">//downcasting(向下转型)f1引用仍然指向Son对象</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line"></span><br><span class="line">Father f2 = <span class="keyword">new</span> <span class="type">Father</span>();</span><br><span class="line">Son s2 = (Son)f2;<span class="comment">//错误，子类引用不能指向父类对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>向上转型：子类对象直接赋给父类引用，不用强制转换<br>向下转型：把指向子类对象的父类赋给了子类，需要强制转换</p>
</blockquote>
<h2 id="关于Java重写-Override-与重载-Overload"><a href="#关于Java重写-Override-与重载-Overload" class="headerlink" title="关于Java重写(Override)与重载(Overload)"></a>关于Java重写(Override)与重载(Overload)</h2><p>-</p>
<h3 id="向上转型带来的问题"><a href="#向上转型带来的问题" class="headerlink" title="向上转型带来的问题"></a>向上转型带来的问题</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Animal方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="title">extends</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Cat重写方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Cat特有方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal a1 = <span class="keyword">new</span> Cat();<span class="comment">//向上转型</span></span><br><span class="line">        a.<span class="built_in">move</span>();<span class="comment">//调用Animal自己的move()</span></span><br><span class="line">        a1.<span class="built_in">move</span>();<span class="comment">//调用Cat重写过的move()</span></span><br><span class="line">        a1.jump();<span class="comment">//error 因为a1的引用类型Animal中没有jump()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码中由于Animal中没有jump()方法导致编译失败，但是可以通过强制转型(UP)来访问引用父类中没有但是子类中有的方法或成员变量  </p>
</blockquote>
<blockquote>
<p>方法重写规则中需要注意的几点：<br>    1. 返回类型可以与被重写方法的返回类型不同，但是得是父类返回值的派生类；<br>    2. 访问权限不能比父类被重写方法的访问权限更低，比如父类方法的访问权限为public，子类重写方法后不能为protected或更低；<br>    4. 重写方法不能抛出更更广泛的强制性异常；  </p>
</blockquote>
<h2 id="关于Java多态"><a href="#关于Java多态" class="headerlink" title="关于Java多态"></a>关于Java多态</h2><p>-</p>
<h3 id="静态方法重写问题"><a href="#静态方法重写问题" class="headerlink" title="静态方法重写问题"></a>静态方法重写问题</h3><blockquote>
<p>父类的静态方法被子类重写后，调用问题应该看指向子类对象的是父类引用还是子类引用，如果是父类引用指向子类对象则会调用父类的静态方法，如果是子类引用指向子类对象，则会调用子类的静态方法</p>
</blockquote>
<h2 id="关于Java接口"><a href="#关于Java接口" class="headerlink" title="关于Java接口"></a>关于Java接口</h2><p>-</p>
<h3 id="接口的一些特性"><a href="#接口的一些特性" class="headerlink" title="接口的一些特性"></a>接口的一些特性</h3><blockquote>
<p>-接口的方法都是且只能是public abstract；<br>-接口的成员变量都是且只能是public static final;<br>-Java不支持多继承，但是一个接口可以继承多个接口；<br>-类继承接口必须要实现接口里的全部方法，除非类为抽象类；<br>-如果基本功能在不断改变那么要使用抽象类，因为如果要用接口那么功能改变要更改所有继承这个接口的实体内的方法，<strong><em>这也可以理解abstract表示的是”is-a”的一种关系，interface表示的是”has-a”的一种关系</em></strong>；<br>-JDK1.8以后接口中开始允许出现静态方法和方法体； </p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title">demo</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"这里是interface里的默认实现方法"</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"这里是interface里的静态方法"</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//接口中只允许这两种非抽象方法实现</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用"><a href="#如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用" class="headerlink" title="如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用"></a>如果要对接口内的非抽象方法进行调用的话。静态类方法：只能通过接口名调用；default类方法：只能通过接口实现类的类名调用</h2></blockquote>
<h3 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">import java.util;</span><br><span class="line">public<span class="built_in"> interface </span>EventListener&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个接口就是监听接口，类似于MouseListener类就继承了这个接口。<br>标记接口存在的目的：<br>1.向一个类添加数据类型，因为不需要实现该类的方法(因为本身就没有方法)；<br>2.建立一个公共的父接口，正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口，它可以使得使用instanceof进行类型查询。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM】内存模型</title>
    <url>/2020/07/03/%E3%80%90JVM%E3%80%91%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>JVM内存模型是JVM高效运行的基础，也是JVM核心部分，同样也是面试官手里的香饽饽，盘它不要犹豫(●･̆⍛･̆●)</strong></p>
<a id="more"></a>
<hr>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><blockquote>
<p>内存作为重要的系统资源，为硬盘和CPU的握手做了桥梁，JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行，不同的JVM对于内存的划分方式和管理机制存在着部分差异。为了直观感受，先上经典JVM内存模型的<strong>结构组成图</strong>。</p>
</blockquote>
<p><img src="https://wx1.sbimg.cn/2020/07/03/2UAF1.png" alt="2UAF1.png"></p>
<h2 id="区域解释"><a href="#区域解释" class="headerlink" title="区域解释"></a>区域解释</h2><h3 id="程序计数器（PC）"><a href="#程序计数器（PC）" class="headerlink" title="程序计数器（PC）"></a>程序计数器（PC）</h3><blockquote>
<p>便于记忆的说，PC就是一块内存区域，<strong>里面存放着下一条要执行的指令的地址，也就是当前所执行的字节码的行号指示区</strong>，它会告诉字节码解释器下一条要解释的字节码的行号，起到了一个定位作用，其中类似于分支、循环、跳转、异常处理、线程恢复等功能都是依赖于PC来完成的。由于PC是线程隔离的，所以它<strong>不仅可以实现代码的流程控制，而且在多线程的情况下，它还可以记录下当前线程的执行位置，以便于再次切换到线程时能够继续顺序执行</strong>。</p>
</blockquote>
<p>需要注意的是：程序计数器是唯不会出现 OutOfMemoryError 的内存区域，因为它的生命周期与线程保持同步，随着线程的创建而创建，随着线程的结束而死亡。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><blockquote>
<p>我们在JVM字节码执行机制中详细的讲述了关于线帧的内容，它包括了局部变量表、操作数栈、动态链接、方法出口信息的内容，这里虚拟机栈就是线帧作为组成成分的栈结构，所以在方法执行中，虚拟机栈就是运用压栈出栈的方式对方法的执行进行控制，对于具体的操作流程这里不再赘述，不清楚这一块内容的小伙伴可以看往期blog《【JVM】字节码执行机制》或直接点击<a href="http://www.easonhe.top/2020/07/02/%E3%80%90JVM%E3%80%91%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<blockquote>
<p>虚拟机栈是JVM内存模型中非常重要的一个角色，关于它我们还需要注意的是虚拟机栈会出现的两种异常问题：</p>
<ol>
<li>StackOverFlowError:如果虚拟机栈的大小不允许动态扩展，那么如果当前线程请求超过了虚拟机栈的最大深度，那么将会抛出此异常；   </li>
<li>OutOfMemeoryError:如果虚拟机栈的大小允许动态扩展，那么如果当前线程请求栈时内存已经用尽，那么将会抛出此异常。</li>
</ol>
</blockquote>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote>
<p>本地方法栈不仅在名字上与虚拟机栈相似，他们的作用也非常的相似，<strong>本地方法栈与虚拟机栈的运作方式基本相同</strong>，包括可能抛出的两种异常。<strong>虚拟机栈主要是为了虚拟机执行字节码服务，而本地方法栈服务的是虚拟机使用native方法</strong>，在<a href="https://blog.csdn.net/tianshuhao/article/details/89819214" target="_blank" rel="noopener">HotSpot虚拟机</a>中与Java虚拟机相融合.</p>
</blockquote>
<p>关于native方法：</p>
<blockquote>
<p>简单来说native方法就是一个不是使用Java代码编写的但是Java需要使用的这么一个方法，这个方法的接口并非Java代码的接口，也就是说<strong>native是用作Java和其他语言协作时使用到的方法</strong>。这个特性在很多种语言中都支持，这种是Java底层的机制，实际上Java的平台无关性很大程度上就是在不同的平台上调用不同的native方法实现对操作系统的访问的。正是因为非Java接口所以<strong>native方法是由操作系统实现的</strong>，Java虚拟机只进行调用就可以了。</p>
</blockquote>
<h3 id="Java堆（heap）"><a href="#Java堆（heap）" class="headerlink" title="Java堆（heap）"></a>Java堆（heap）</h3><blockquote>
<ol>
<li>Java堆作为线程共享的数据区，所以它作为JVM所管理的最大的最大的一块内存，它可以供几乎所有类实例对象与数组对象分配内存，但是如果无节制的大量创建对象，那么将会消耗完内存空间，所以Java堆也是OOM异常出现的主要发源地;   </li>
<li>由于Java堆的特点，Java堆也是垃圾收集器主要管理的区域，所以也被成错Garbage Collected Heap（GC堆）;   </li>
<li>堆内存既可以固定大小也可以动态调整，但是通常情况下，在服务器运行的过程中，堆内存不断的进行扩容或收缩形成了不必要的系统压力，所以一般在线上生产环境中会给堆内存设置固定大小，避免了在GC后调整堆内存大小所带来的不必要的压力</li>
<li>从GC的角度来说，现在的垃圾收集器一般均采用分代垃圾收集算法，所以java堆又分成了新生代和老年代的空间。</li>
</ol>
</blockquote>
<p>在Java堆中新生代和老年代之间的运作关系很有意思，这里着重的说一下：</p>
<blockquote>
<p>新生代：<strong>1个Eden(伊甸园）区+2个Survivor（幸存者）区；其中绝大部分的对象的生成是在Eden区，当Eden区已满后将会触发GC垃圾回收机制，经过GC垃圾回收后只有少量对象可以存活（被引用的对象）然后被复制到其中的一个Survivor区，每次GC的时候，将存活的对象复制到未使用的那块Survivor空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态，如果YGC要移送的对象大于Survivor区容量上限，则直接移交给老年代。并且重要的是对象是不可以在两个Survuvir区一直交换的，因为每进行一次交换就要将对象的1个计数器的值+1，也就是“年龄”+1，当年龄到达某个阀值的时候就会自动进入老年代</strong></p>
</blockquote>
<blockquote>
<p>老年代：在新生代经历了多次GC回收后仍然存活的对象都放在了此区域，这个区域存放的对象存活率非常高，所以对于老年代的GC机制又被称为Major GC（老年代的垃圾回收），<strong>MGC通常使用的算法是“标记-清理”或者“标记-整理”的算法</strong>，其中整堆回收的机制也被成为Full GC（包括新生代）</p>
</blockquote>
<blockquote>
<p>永久代（Perm区）：故名思议这里主要存放的是例如Class、Method的元信息，由于GC主要回收的是Java对象所以这里相对于Young Generation和Old Generation来说受GC影响是很小的（<strong>JDK 1.8之后此区域已经被替换成了物理内存中的元空间区域</strong>）</p>
</blockquote>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote>
<p>方法区用于<strong>存放已经被虚拟机加载的类的信息、常量、静态变量、JIT编译后的代码等等</strong>，虽然它在逻辑上也是堆的一部分，但是方法区还有一个别名叫做Non-Heap（非堆），目的就是为了与堆区分开来。对于它存放的这些数据的特点简单的虚拟机实现<strong>可以不在这个区域进行垃圾收集</strong>，方法区和堆一样在实际内存中的存储可以是不连续的，这个区域存放的数据一般都<strong>长期存在</strong>，在这个区域垃圾回收主要也就是对于常量池的回收和类型的卸载，也同堆一样可以根据需求动态扩充和收缩内存大小也可以固定大小，如果内存不足也将抛出OutOfMemory异常。</p>
</blockquote>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><blockquote>
<p>虽然直接内存并不是实际JVM运行时内存区的一部分，他是利用了本地方法在Java堆之外申请的内存区域，但是这部分内存也将会被频繁的使用并且也会抛出OOM异常，JVM通过一个存储在Java堆中的 DirectByteBuffer对象作为这块内存的引用并进行操作，这样一来，就可以<strong>避免在Java堆和Native堆之间频繁的复制数据</strong>，就能在一些场景中显著提高性能。</p>
</blockquote>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><blockquote>
<p>运行时常量池是JVM内存模型方法区中的一部分，java文件被编译之后生成的class文件中除了包含：类的版本、字段、方法、接口等信息外，还有一项就是常量池，在类和接口被加载到虚拟机中之后对应的运行时常量池也就被创建了出来，Class文件中除了有类的版本、字段、方法、接口等描述信息外,还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入运行时常量池中存放。运行期间也可能将新的常量放入池中。当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用，那么就需要垃圾收集器回收。它也有可能抛出OOM异常。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM】GC垃圾回收机制</title>
    <url>/2020/07/05/%E3%80%90JVM%E3%80%91GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><strong>说真的我要是不懂GC我都不好意思说自己懂Java（坏笑）探秘Java最能打能秀的GC=͟͟͞͞( •̀д•́)</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>GC垃圾回收机制简直要被HR问爆了，在哪都能刷到关于GC的问题，看来不懂是不行了。说到底<strong>GC的最终目的还是对Java程序的性能进行优化</strong>。Java和C++不同，C++是垃圾自动回收的，这使得一旦C++一旦搞丢的自己new的一个对象就会导致内存得不到释放而致使的内存泄露问题，看来垃圾自动回收还是不能打鸭，那就来看看Java的GC垃圾回收机制吧</p>
</blockquote>
<h2 id="关于GC的几个问题"><a href="#关于GC的几个问题" class="headerlink" title="关于GC的几个问题"></a>关于GC的几个问题</h2><h3 id="怎么判断一个对象是不是垃圾"><a href="#怎么判断一个对象是不是垃圾" class="headerlink" title="怎么判断一个对象是不是垃圾"></a>怎么判断一个对象是不是垃圾</h3><blockquote>
<p>在上篇JVM内存模型种讲到了GC垃圾回收，一个对象是不是垃圾简单的回答就是看这么<strong>对象有没有被引用</strong>，如果某个对象从始至终都没有被其他对象或直接引用，那么它就变成了垃圾对象。或者说<strong>作用域发生未捕获异常</strong>和<strong>程序在作用域正常执行完毕</strong>又或者<strong>程序执行了System.exit()</strong>以及<strong>程序发生意外终止（被杀线程等）</strong></p>
</blockquote>
<h3 id="GC的工作区域在哪"><a href="#GC的工作区域在哪" class="headerlink" title="GC的工作区域在哪"></a>GC的工作区域在哪</h3><blockquote>
<p>GC主要是在Java堆和方法区中工作的，因为堆内存放着所有对象的数据，<a href="http://www.easonhe.top/2020/07/03/%E3%80%90JVM%E3%80%91%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">如果不了解可快速飞机去了解堆</a>，所以对于内存中的栈来说，一旦存储的数据超出了作用域就将被JVM自动释放掉，所以GC并不管辖有关栈的区域。</p>
</blockquote>
<h3 id="GC什么时候会被执行"><a href="#GC什么时候会被执行" class="headerlink" title="GC什么时候会被执行"></a>GC什么时候会被执行</h3><blockquote>
<p>GC的触发主要是在新生代的Eden区满了的时候就会触发Minro GC，还有一个情况是当从新生代“升级”到老年代的数量要大于老年代剩余容量的时候会触发Full GC（调优主要需要控制的对象），为了减少Full GC的触发次数我们可以通过NewRatio控制新生代转老年代的比例，也可以通过控制年龄阀值的方式限制。</p>
</blockquote>
<h3 id="GC的主要任务都是什么"><a href="#GC的主要任务都是什么" class="headerlink" title="GC的主要任务都是什么"></a>GC的主要任务都是什么</h3><blockquote>
<ul>
<li>分配内存；   </li>
<li>确保被引用对象的内存不被错误的回收；</li>
<li>回收不再被引用的对象的内存空间.</li>
</ul>
</blockquote>
<h2 id="按代GC的垃圾回收机制"><a href="#按代GC的垃圾回收机制" class="headerlink" title="按代GC的垃圾回收机制"></a>按代GC的垃圾回收机制</h2><h3 id="关于新生代老年代问题的补充"><a href="#关于新生代老年代问题的补充" class="headerlink" title="关于新生代老年代问题的补充"></a>关于新生代老年代问题的补充</h3><blockquote>
<ul>
<li>默认的新生代与老年代所占空间比例为 1 : 2 ；</li>
<li>默认新生代空间的分配：Eden : Fron : To = 8 : 1 : 1;</li>
<li>年龄阀值设定，默认15</li>
<li>对于一些比较大的对象（需要分配一块比较大的连续内存空间）则直接进入到老年代。一般在Survivor 空间不足的情况下发生</li>
<li>Full GC（Major GC）发生的次数不会有Minor GC 那么频繁，并且做一次Major GC 的时间比Minor GC 要更长（约10倍）。</li>
</ul>
</blockquote>
<h3 id="各个代出发GC的条件"><a href="#各个代出发GC的条件" class="headerlink" title="各个代出发GC的条件"></a>各个代出发GC的条件</h3><blockquote>
<p>我们了解了新生代与老年代的垃圾回收条件及机制了（内存模型章节），作为“持久代“的方法区怎样进行GC呢？方法区内存储的并不是从老年代中存活下来的对象数据，而是那些类的常量以及字符串常量等数据，但是根据存储的对象来看这个区域要被GC的概率是不高的，所以说这个区域GC的条件十分苛刻，<strong>必须符合下列三个条件后才能被回收</strong>：</p>
<ul>
<li>所有的实例都被回收了</li>
<li>加载该类的类加载器被回收了</li>
<li>class对象已经无法通过任何包括反射的途径访问了</li>
</ul>
</blockquote>
<h3 id="一个性能问题的解决"><a href="#一个性能问题的解决" class="headerlink" title="一个性能问题的解决"></a>一个性能问题的解决</h3><blockquote>
<p>在老年代中存在着一个card table，它是一个512byte大小的块。所有老年代的对象指向新生代对象的引用都会被记录在这个表中。当针对新生代执行GC的时候，只需要查询 card table 来决定是否可以被回收，而不用查询整个老年代。这个 card table 由一个write barrier 来管理。write barrier给GC带来了很大的性能提升，虽然由此可能带来一些开销，但完全是值得的。</p>
</blockquote>
<h2 id="GC判断算法"><a href="#GC判断算法" class="headerlink" title="GC判断算法"></a>GC判断算法</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><blockquote>
<p>当某个对象被引用时那么计数器就会+1，当这个对象的引用失效时计数器就会-1，当某个对象的计数值为0的时候就说明这个对象不可能再被引用的，是可被回收的对象。但是根据调用System.gc()情况来看，这种算法不能解决对象之间相互循环引用问题</p>
</blockquote>
<h3 id="可达性分析法（主流判断法）"><a href="#可达性分析法（主流判断法）" class="headerlink" title="可达性分析法（主流判断法）"></a>可达性分析法（主流判断法）</h3><p><img src="https://wx1.sbimg.cn/2020/07/05/2yRU2.png" alt="2yRU2.png"></p>
<blockquote>
<p> 根搜索算法是按照离散数学中的图演化而来的，也就是将一个结点看成GC Root，然后从Root结点出发搜寻它对应的引用结点，找到后再搜索引用它的结点的引用结点，一直搜索下去，然后将所有未被标记的对象即为可回收对象。</p>
</blockquote>
<blockquote>
<p>可以当作GC Root结点的有：</p>
<ul>
<li>虚拟机栈中线帧所包含的本地变量表中引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量所引用的对象</li>
<li>本地方法栈中所引用的Native对象</li>
</ul>
</blockquote>
<h2 id="GC回收算法"><a href="#GC回收算法" class="headerlink" title="GC回收算法"></a>GC回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p><img src="https://wx2.sbimg.cn/2020/07/05/2yesV.png" alt="2yesV.png"></p>
<blockquote>
<p>标记清除算法   </p>
<ul>
<li>第一步：从根集合开始对对象进行扫描，被引用的即存活的就会被标记</li>
<li>第二步：将未被标记的对象进行GC回收<br>从图中可以看到，我们不需要对存活的对象进行移动，这样的情况下如果存活的对象非常多的话，那么这个方法的效率会比较高，但是<strong>缺点是这会造成很多不连续性的内存碎片</strong>，比如图中第二步中将中间结点回收的例子</li>
</ul>
</blockquote>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="https://wx1.sbimg.cn/2020/07/05/2ytU7.png" alt="2ytU7.png"></p>
<blockquote>
<ul>
<li>第一步：将内存均等分为两份：空间A与空间B，并且所有动态分配的对象都只在其中的一个空间（图中空间A）另一个空间为空（图中空间B）</li>
<li>第二步：将从根集合出发扫描对象并将引用的对象（存活的对象）复制到为空的空间内（图中空间B）</li>
<li>第三步：将原本的活动空间（空间A）对象全部回收，此时活动空间就变成了空闲空间，原本的空闲空间（空间B）变成了活动空间</li>
</ul>
</blockquote>
<blockquote>
<p>很明显，这种算法堆对于对象存活率低的情况比较高效，但是也很明显的是在动态分配内存中我们必须要牺牲一半的空间充当空闲区，所以我们得克服一半内存的浪费</p>
</blockquote>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p><img src="https://wx2.sbimg.cn/2020/07/05/2yHKe.png" alt="2yHKe.png"></p>
<blockquote>
<p>标记-整理算法的前两步与标记-清理的方法相同，前两步图参考标记-清理算法，它完整的步骤为：</p>
<ul>
<li>第一步：从根集合开始对对象进行扫描，被引用的即存活的就会被标记</li>
<li>第二步：将未被标记的对象进行GC回收    </li>
<li>第三步：将存活的对象进行统一向左移动</li>
</ul>
</blockquote>
<blockquote>
<p>很明显，添加第三步这样的做法是避免了标记-清除算法中造成的大量内存碎片问题，但是这样需要再次更新对应结点的指针，这样做的成本也明显增高了</p>
</blockquote>
<h3 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h3><blockquote>
<p>JVM为了优化GC回收机制，使用了分代回收的方法，所以对应的不同代的区域也使用了不同的回收算法</p>
<ul>
<li>新生代内存的回收（Minor GC）：主要采用复制算法</li>
<li>老年代的内存回收（Major GC）：主要采用标记-整理算法</li>
</ul>
</blockquote>
<h2 id="垃圾收集器（GC）"><a href="#垃圾收集器（GC）" class="headerlink" title="垃圾收集器（GC）"></a>垃圾收集器（GC）</h2><h3 id="相关参数的定义"><a href="#相关参数的定义" class="headerlink" title="相关参数的定义"></a>相关参数的定义</h3><blockquote>
<p>停顿时间：垃圾收集器进行垃圾回收工作时需要暂停应用程序的时间，这个由参数 -XX:MaxGCPauseMillis决定</p>
</blockquote>
<blockquote>
<p>吞吐量：在垃圾收集上的耗时与在应用上的耗时的占比。由参数-XX:GCTimeRatio=<n>决定，比如设置n为10，那么垃圾收集的时间的比重为 1/ (10+1)=1/11</p>
</blockquote>
<blockquote>
<p>stop-the-world:它会在任何一种GC算法中发生。stop-the-world 意味着JVM因为需要执行GC而停止了应用程序的执行。当stop-the-world 发生时，除GC所需的线程外，所有的线程都进入等待状态，直到GC任务完成。GC优化很多时候就是减少stop-the-world 的发生。<strong>对这两个参数的调整就是JVM优化经常要做的工作</strong></p>
</blockquote>
<h3 id="串行垃圾收集器（Serial）（-XX-UseSerialGC）"><a href="#串行垃圾收集器（Serial）（-XX-UseSerialGC）" class="headerlink" title="串行垃圾收集器（Serial）（-XX:+UseSerialGC）"></a>串行垃圾收集器（Serial）（-XX:+UseSerialGC）</h3><blockquote>
<p><strong>单线程一个GC</strong>，当JVM发现我们的内存不够时就会<strong>暂停应用程序的执行</strong>，然后开启一个垃圾回收线程来回收垃圾，这种一般只适用于很小的嵌入式设备。 </p>
</blockquote>
<blockquote>
<p>Java虚拟机中最基本、历史最悠久的收集器，在JDK1.3之前是Java虚拟机新生代收集器的唯一选择。目前也是ClientVM下ServerVM 4核4GB以下机器默认垃圾回收器。Serial收集器虽然是最老的，但是它对于限定单个CPU的环境来说，由于没有线程交互的开销，专心做垃圾收集，所以它在这种情况下是相对于其他收集器中最高效的。</p>
</blockquote>
<blockquote>
<p>-XX:+UseSerialGC Young（新生代）选择使用串行垃圾收集器<br>-XX:+UseSerialOldGC Old（老年代）选择使用串行垃圾收集器，开启前面那个参数，该参数会默认开启，所以若想用串行垃圾收集器开启前面的参数即可,这个收集器目前主要用于Client模式下使用。如果在Server模式下，它主要还有两大用途：一个是在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，如果CMS出现Concurrent Mode Failure，则SerialOld将作为后备收集器。注意web应用场景基本不使用串行垃圾收集器   </p>
</blockquote>
<h3 id="并行垃圾收集器（ParNew）（-XX-UseParNewGC）"><a href="#并行垃圾收集器（ParNew）（-XX-UseParNewGC）" class="headerlink" title="并行垃圾收集器（ParNew）（-XX:+UseParNewGC）"></a>并行垃圾收集器（ParNew）（-XX:+UseParNewGC）</h3><blockquote>
<p>并行并不是说垃圾收集线程和用户程序并行，而是说<strong>多个垃圾收集线程的并行</strong>，也就是说当内存不足的时候<strong>仍然需要暂停的用户线程</strong>来启动多个垃圾收集线程进行垃圾收集工作，也就是多线程版本的Serial，<strong>*使用复制算法</strong>，除了Serial收集器外，只有它能与CMS收集器配合工作。ParNew是许多运行在Server模式下的JVM首选的新生代收集器。但是在单CPU的情况下，它的效率远远低于Serial收集器，所以一定要注意使用场景。</p>
</blockquote>
<h3 id="吞吐量优先收集器-ParallelScavenge-XX-UseParallelGC"><a href="#吞吐量优先收集器-ParallelScavenge-XX-UseParallelGC" class="headerlink" title="吞吐量优先收集器(ParallelScavenge)(-XX:+UseParallelGC)"></a>吞吐量优先收集器(ParallelScavenge)(-XX:+UseParallelGC)</h3><blockquote>
<p>和ParNew一样，ParalleScavenge也是<strong>一个新生代收集器</strong>使用<strong>复制算法</strong>，ParallelScavenge收集器的目标是达到一个可控件的吞吐量。</p>
</blockquote>
<blockquote>
<p>ParallelOld（-XX:+UseParallelOldGC）<br>ParallelOld是一个<strong>老年代收集器</strong>，是老年代吞吐量优先收集器，它使用<strong>标记-整理算法</strong>。这个收集器在JDK1.6之后才开始提供的，在此之前，ParallelScavenge只能选择SerialOld来作为其老年代的收集器，这严重拖累了ParallelScavenge整体的速度。而ParallelOld的出现后，才证明了吞吐量优先收集器的大名。</p>
</blockquote>
<blockquote>
<p>在注重吞吐量与CPU数量大于1的情况下，都可以优先考虑ParallelScavenge + ParalleloOld收集器。</p>
</blockquote>
<h3 id="CMS-Concurrent-Mark-Sweep-Collector-XX-UseConcMarkSweepGC"><a href="#CMS-Concurrent-Mark-Sweep-Collector-XX-UseConcMarkSweepGC" class="headerlink" title="CMS(Concurrent Mark-Sweep Collector)(-XX:+UseConcMarkSweepGC)"></a>CMS(Concurrent Mark-Sweep Collector)(-XX:+UseConcMarkSweepGC)</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote>
<p>一种老年代垃圾收集器，其特点是<strong>响应时间优先，低延迟，低停顿</strong>,是JDK1.4后期开始引用的新GC收集器，在JDK1.5、1.6中得到了进一步的改进。它是对于<strong>响应时间的重要性需求大于吞吐量要求</strong>的收集器。<strong>它用两次短暂的暂停来代替串行或并行标记整理算法时候的长暂停</strong>，使用<strong>标记-清理</strong>算法。对于要求服务器响应速度高的情况下，使用CMS非常合适。</p>
</blockquote>
<h4 id="CMS的垃圾回收过程（注意并发与并行的区别）："><a href="#CMS的垃圾回收过程（注意并发与并行的区别）：" class="headerlink" title="CMS的垃圾回收过程（注意并发与并行的区别）："></a>CMS的垃圾回收过程（<strong>注意并发与并行的区别</strong>）：</h4><blockquote>
<p>1.<strong>初始标记阶段*</strong>（<strong>有暂停</strong>）（STW initial mark）：在这个阶段，<strong>需要虚拟机停顿正在执行的应用线程</strong>，官方的叫法STW（Stop The World）。这个过程从根对象扫描直接关联的对象，并作标记，这个过程进行的非常快；<br>2.<strong>并发标记阶段</strong>（Concurrent marking）：这个阶段紧随初始标记阶段，在初始标记的基础上<strong>继续向下追溯标记</strong>。注意这里是<strong>并发标记</strong>，表示用户线程可以和GC线程一起并发执行，不需要暂停用户线程；<br>3.<strong>并发预清理阶段</strong>（Concurrent precleaning）：<br>JVM<strong>查找正在执行“并发标记”阶段时候进入老年代的对象</strong>。通过重新扫描，减少下一阶段的工作，提高了性能，因为下一阶段会STW影响用户进程；<br>4.<strong>重新标记阶段</strong>（<strong>有暂停</strong>）（STW remark）：这个阶段会再次暂停用户线程，重新从根对象开始查找并标记并发阶段结束后对象状态的更新导致遗漏的对象，并处理对象关联。这一次耗时会比“初始标记”更长，并且这个阶段可以并行标记；<br>5.<strong>并发清理阶段</strong>（Concurrent sweeping）：应用线程和GC清除线程可以一起并发执行；<br>6.<strong>并发重置阶段</strong>（Concurrent reset）：重置CMS收集器的数据结构，等待下一次垃圾回收。</p>
</blockquote>
<h4 id="CMS的缺陷"><a href="#CMS的缺陷" class="headerlink" title="CMS的缺陷"></a>CMS的缺陷</h4><blockquote>
<ul>
<li><strong>CPU敏感</strong>：在CMS的工作过程中大都是使用的并发方式，这样以来将会占用更多的CPU资源，也牺牲了一定的吞吐量；</li>
<li><strong>浮动垃圾</strong>：同样因为CMS的并发性，导致在进行垃圾回收的过程中仍然在进行着用户线程，同样需要不断的向堆中存入对象，这样也会出现新的垃圾，但是这样的垃圾只能等到下一次GC时才能清理，成为了浮动垃圾；</li>
<li><strong>内存碎片</strong>：由于CMS使用“标记-清理”算法，所以会有算法产生的缺陷就是内存碎片。不过CMS收集器做了一些小的优化，就是把未分配的空间汇总成一个列表，当有JVM需要分配内存空间的时候，会搜索这个列表找到符合条件的空间来存储这个对象。如果一个对象需要多块连续的空间来存储，但是因为内存碎片所以寻找不到这样的空间，就会导致Full GC，这样一来内存碎片的问题依然存在；</li>
<li><strong>堆空间要求更大</strong>：因为CMS是属于并发进行的，那么就会有堆空间继续分配的问题，为了保障CMS在回收堆空间之前还有空间分配给新加入的对象，<strong>必须预留一部分空间</strong>。CMS默认在老年代空间使用68%时候启动垃圾回收，可以通过-XX:CMSinitiatingOccupancyFraction=n来设置这个阀值。</li>
</ul>
</blockquote>
<h3 id="G1（Garbage-First）垃圾收集器"><a href="#G1（Garbage-First）垃圾收集器" class="headerlink" title="G1（Garbage-First）垃圾收集器"></a>G1（Garbage-First）垃圾收集器</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><blockquote>
<p>G1(Garbage First)垃圾收集器是当今垃圾回收技术最前沿的成果之一。早在JDK7就已加入JVM的收集器大家庭中，成为HotSpot重点发展的垃圾回收技术。同优秀的CMS垃圾回收器一样，G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。G1最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。</p>
</blockquote>
<h4 id="G1GC的相关术语"><a href="#G1GC的相关术语" class="headerlink" title="G1GC的相关术语"></a>G1GC的相关术语</h4><blockquote>
<ul>
<li>Region：G1垃圾收集器利用分而治之的思想将堆进行分区，划分为一个个的区域。每次收集的时候，只收集其中几个区域，以此来控制垃圾回收产生的STW,G1和其他GC算法最大的区别是<strong>弱化分代概念，引入分区思想</strong>，如果要另外选择分区的尺寸，可以通过命令行选项：-XX:G1HeapRegionSize=n中进行设置；<br><img src="https://wx1.sbimg.cn/2020/07/05/2V22Y.png" alt="2V22Y.png"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>RSet：G1垃圾收集器里每一个RSet对应的是一个Region中存活对象的指针。在标记存活对象的时候，G1使用RSet概念，将每个分区指向分区内的引用记录在该分区，<strong>避免对整个堆扫描</strong>，并行独立处理垃圾集合<br>老年代对年轻代的引用，维护老年代分区指向年轻代分区的指针<br>老年代对老年代的引用。在这里，老年代中不同分区的指针将被维护在老年代拥有分区的RSet中。<br><img src="https://wx1.sbimg.cn/2020/07/05/2VMVm.png" alt="2VMVm.png"><br>在图中，我们可以看到3各分区，x（年轻代分区）、y和z（老年代分区）。x有一个来自z的对内引用。这个引用记录在x的RSet中，分区z有2个对内引用，一个来自x一个来自y，因为年轻代分区作为一个整体回收的，所以只需记录来自y的对内引用，不用记录x的对内引用；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>CSet：Collection Set，简称CSet。在垃圾收集过程中收集的Region集合可以称为收集集合（CSet），也就是在垃圾收集暂停过程中被回收的目标。GC时在CSet中的所有存活数据都会被转移，分区释放回空闲分区队列。<br><img src="https://wx1.sbimg.cn/2020/07/05/2Vptd.png" alt="2Vptd.png"><br>如图所示，左边的年轻代收集CSet代表年轻代的一部分分区，右边的混合收集CSet代表年轻代的一部分区和老年代的多个分区；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>PLAB：Promotion Local Allocation Buffers，对象晋升到survivor分区或者老年代分区的过程是在GC线程的晋升本地分配缓冲区（PLAB）进行的，每个线程有独立的PLAB。作用是避免多线程竞争相同数据。和下面介绍的TLAB思想是一致的；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>TLAB：Thread Local Allocation Buffers，线程本地分配缓存。JVM使用了TLAB这种线程专属的区间来避免多线程冲突（无锁方式），提高对象分配效率。TLAB本身占用了Eden空间，即JVM会为每一个线程都分配一块TLAB空间；<br><img src="https://wx2.sbimg.cn/2020/07/05/2Vkl4.png" alt="2Vkl4.png"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>IHOP：InitiatingHeapOccupancyPercent，简称IHOP。缺省情况是Java堆内存的45%。当老年代的空间超过45%，G1会启动一次混合周期收集。这也是G1和CMS之间较大的区别，G1的百分比是相对于整个Java堆而言的，CMS（CMSInitiatingOccupancyFraction）仅仅是针对老年代空间的占比。这样设计的原因是因为G1没有固定物理上分割一块内存作为老年代，而是用了Region的思想，这些Region可能是eden，survivor、老年代或者巨型分区，所以获取针对老年代本身的占用百分比没有意义；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>巨型分区：巨型对象会以连续分区的形式来存放，这种就叫巨型分区。巨型对象无法利用年轻代里的TLAB和PLAB。在JDK 8u40之前，它只能在并发收集周期的清除阶段回收，但是在JDK 8u40之后，巨型分区可以在年轻代收集中和full GC被回收。</li>
</ul>
</blockquote>
<h4 id="G1的设计"><a href="#G1的设计" class="headerlink" title="G1的设计"></a>G1的设计</h4><blockquote>
<p>之所以会有G1是因为并发、并行和CMS垃圾收集器都有2个共同的问题：老年代收集器大部分操作都必须扫描整个老年代空间（标记，清除和压缩）。这就导致了GC随着Java堆空间而线性增加或减少年轻代和老年代是独立的连续内存块，所以要先决定年轻代和年老代放在虚拟地址空间的位置。</p>
</blockquote>
<p><strong>设计目标</strong></p>
<blockquote>
<p>G1的设计目标就是把必要的调整限定在以下2个：</p>
<ul>
<li>设置最大的Java堆空间</li>
<li>设置指定GC暂停时间   </li>
</ul>
</blockquote>
<blockquote>
<p>G1会通过调整Java堆尺寸大小来满足设定的暂停时间目标，暂停时间目标越短，年轻代空间越小，老年代空间相对越大.</p>
</blockquote>
<p><strong>使用场景</strong>　　</p>
<blockquote>
<p>G1 GC切分堆内存为多个区间（Region），从而避免很多GC操作在整个Java堆或者整个年轻代进行。G1 GC只关注你有没有存货对象，都会被回收并放入可用的Region队列。G1 GC是基于Region的GC，适用于大内存机器。即使内存很大，Region扫描，性能还是很高的。<strong>如果现在采用的收集器没有问题，就不要选择G1，如果追求低停顿，那么G1已经是一个可尝试的选择，如果追求吞吐量，就不要选G1了</strong></p>
</blockquote>
<h4 id="G1垃圾收集机制"><a href="#G1垃圾收集机制" class="headerlink" title="G1垃圾收集机制"></a>G1垃圾收集机制</h4><blockquote>
<p>G1的垃圾收集周期主要有4种类型：年轻代收集周期、多级并发标记周期、混合收集周期和full GC（转移失败的安全保护机制），这节以应用启动的时间顺序来讲，可以参照G1垃圾收集活动时序图：<br><img src="https://wx2.sbimg.cn/2020/07/05/2VCLA.png" alt="2VCLA.png"></p>
</blockquote>
<h5 id="年轻代收集"><a href="#年轻代收集" class="headerlink" title="年轻代收集"></a>年轻代收集</h5><blockquote>
<p>应用刚启动，慢慢流量进来，开始生成对象。G1会选一个分区并指定他为eden分区，当这块分区用满了之后，G1会选一个新的分区作为eden分区，这个操作会一直进行下去直到达到eden分区上限，也就是说<strong>eden分区已经被占满，那么会触发一次年轻代收集</strong>。年轻代收集首先做的就是迁移存活对象，它使用单eden，双survivor进行复制算法，它将存活的对象从eden分区转移到survivor分区，survivor分区内的某些对象达到了任期阈值之后，会晋升到老年代分区中。原有的年轻代分区会被整个回收掉。同时，年轻代收集还负责维护对象年龄，存活对象经历过年轻代收集总次数等信息。G1将晋升对象的尺寸总和和它们的年龄信息维护到年龄表中，结合年龄表、survivor占比（–XX:TargetSurvivorRatio 缺省50%）、最大任期阈值（–XX:MaxTenuringThreshold 缺省为15）来计算出一个合适的任期阈值。<strong>调优</strong>：我们可以通过–XX:MaxGCPauseMillis，调优年轻代收集，缩小暂停时间。</p>
</blockquote>
<h5 id="并发标记周期"><a href="#并发标记周期" class="headerlink" title="并发标记周期"></a>并发标记周期</h5><blockquote>
<p>随着时间推移，越来越多的对象晋升到老年代中，当老年代占比（相对于Java总堆而言）达到IHOP参数（上图的IHOP Trigger）之后，那么G1首先会触发并发标记周期（上图的Concurrent Marking Cycle），当完成后才会开始下一小节的混合垃圾收集周期<br>G1的并发标记循环分5个阶段：</p>
<ul>
<li>第一阶段：初始标记（上图Young Collection with Initial Mark），收集所有GC根（对象的起源指针，根引用），STW，在年轻代完成</li>
<li>第二阶段：根区间扫描，标记所有幸存者区间的对象引用</li>
<li>第三阶段：并发标记（上图Concurrent Marking），标记存活对象</li>
<li>第四阶段：重新标记（上图Remark），是最后一个标记阶段，STW，很短，完成所有标记工作</li>
<li>第五阶段：清除（上图Clean），回收没有存活对象的Region并加入可用Region队列</li>
</ul>
</blockquote>
<blockquote>
<p>调优：我们可以通过–XX:InitiatingHeapOccupancyPercent，配置适合应用的IHOP值（过大会可能转移失败，过小可能过早引起并发标记周期)。我们也可以通过–XX:ConcGCThreads，增加并发线程数</p>
</blockquote>
<h5 id="混合收集周期"><a href="#混合收集周期" class="headerlink" title="混合收集周期"></a>混合收集周期</h5><blockquote>
<p>当达到IHOP参数并完成上一小节的并发标记周期之后，混合收集周期就启动了，一个周期里的单次STW的混合收集和年轻代收集是类似的，唯一区别就是在混合收集过程中会包含一部分老年分区，所以也叫混合收集<br>看上图的Mixed Collection Cycle，中间有好几段Mixed Collection，说明混合收集周期包含多次收集次数。那么什么影响收集次数呢？是固定的？还是？有两个参数比较重要：</p>
<ul>
<li>XX:G1MixedGCCountTarget：缺省值为8，意思是能启动混合收集的数目设定一个物理限制。G1根据将回收的老年分区除以该参数值得到每次混合收集的老年代CSet最小数量</li>
<li>XX:G1HeapWastePercent：缺省值为5%，每次混合收集暂停，G1算出废物百分比，根据堆废物百分比，当收集达到参数时，不再启动新的混合收集</li>
</ul>
</blockquote>
<blockquote>
<p>调优：当暂停时间和运行时间呈现指数级增长，可以通过-XX:G1HeapWastePercent，调高该参数会有所帮助，但这也导致更多碎片化</p>
</blockquote>
<h5 id="full-GC"><a href="#full-GC" class="headerlink" title="full GC"></a>full GC</h5><blockquote>
<p>有2个条件同时满足则会触发full GC</p>
<ul>
<li>拷贝存活对象晋升（promotion）失败，无法找到可用的空闲分区，GC日志记录为to-space exhausted。或分配巨型对象无法在老年代找到连续足够的分区</li>
<li>当发生第一个条件后，G1会尝试增加堆使用量，如果扩展失败，那么会触发安全措施机制同时发生full GC<br><img src="https://wx1.sbimg.cn/2020/07/05/2VDiV.png" alt="2VDiV.png"><br>full GC中，单个线程会对整个堆的所有代中所有分区做标记、清除以及压缩动作！！非常非常昂贵的操作！</li>
</ul>
</blockquote>
<h2 id="整理总结"><a href="#整理总结" class="headerlink" title="整理总结"></a>整理总结</h2><blockquote>
<p>新生代收集器：</p>
<ul>
<li>Serial （-XX:+UseSerialGC）</li>
<li>ParNew（-XX:+UseParNewGC）</li>
<li>ParallelScavenge（-XX:+UseParallelGC）</li>
<li>G1 收集器</li>
</ul>
</blockquote>
<blockquote>
<p>老年代收集器：</p>
<ul>
<li>SerialOld（-XX:+UseSerialOldGC）</li>
<li>ParallelOld（-XX:+UseParallelOldGC）</li>
<li>CMS（-XX:+UseConcMarkSweepGC）</li>
<li>G1 收集器</li>
</ul>
</blockquote>
<blockquote>
<p>G1是一款非常优秀的垃圾收集器，不仅适合堆内存大的应用，同时也简化了调优的工作。通过主要的参数初始和最大堆空间、以及最大容忍的GC暂停目标，就能得到不错的性能；同时，我们也看到G1对内存空间的浪费较高，但通过<strong>首先收集尽可能多的垃圾(Garbage First)</strong>的设计原则，可以及时发现过期对象，从而让内存占用处于合理的水平。</p>
</blockquote>
<p>参考：<br><a href="https://zhuanlan.zhihu.com/p/25539690" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25539690</a><br><a href="https://blog.csdn.net/qq_36652619/article/details/90645422" target="_blank" rel="noopener">https://blog.csdn.net/qq_36652619/article/details/90645422</a><br><a href="https://www.cnblogs.com/GrimMjx/p/12234564.html" target="_blank" rel="noopener">https://www.cnblogs.com/GrimMjx/p/12234564.html</a> （G1垃圾收集器）<br><a href="https://blog.csdn.net/coderlius/article/details/79272773" target="_blank" rel="noopener">https://blog.csdn.net/coderlius/article/details/79272773</a></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM】字节码执行机制</title>
    <url>/2020/07/02/%E3%80%90JVM%E3%80%91%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><strong>本篇字节码执行机制将深入了解JVM字节码执行引擎在运行中怎么做( ∙̆ .̯ ∙̆ )</strong></p>
<a id="more"></a>
<h2 id="JVM字节码执行引擎概念"><a href="#JVM字节码执行引擎概念" class="headerlink" title="JVM字节码执行引擎概念"></a>JVM字节码执行引擎概念</h2><blockquote>
<p>作为JVM最为核心的组成部分，JVM执行引擎的工作方式本身就非常类似于真正物理机的编译以及汇编语言的执行机理，JVM执行引擎可以自己制定指令集和执行结构体系，很多不能被硬件所直接支持的指令集在执行引擎里也能够执行，这都是执行引擎自己所实现的，一般看来，<strong>所有的Java虚拟机的执行引擎都是将输入的字节码文件经过字节码解析过程从而得到执行结果的过程</strong>。<strong>字节码作为JVM的指令集，它需要JVM执行引擎去执行，达到从本地机器码到字节码的编译结果</strong>，这看似只是存储格式的转变，但这却深深的影响了编程语言。</p>
</blockquote>
<h2 id="线帧"><a href="#线帧" class="headerlink" title="线帧"></a>线帧</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>线帧（Stack Frame）是一种用于支持虚拟机进行方法调用和方法执行的数据结构，<strong>它是虚拟机运行时数据区中虚拟机栈的栈元素</strong>线帧作为栈元素并且能支持虚拟机对方法的相关操作自然包含了很多数据元素，也就是说，每一个方法的被调用到结束都对应着一个线帧从入栈到出栈的过程。</p>
</blockquote>
<p>在方法调用到结束的过程中还有一些相关概念</p>
<blockquote>
<p><strong>一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的</strong>,每当一个线程启动时，JVM都会为它分配一个栈，栈的单位是帧，并且它负责保存当前线程的运行状态，其中某个线程正在执行的方法就称为<strong>当前方法</strong>，当前方法所用到的帧称为<strong>当前帧</strong>，这个方法所属的类就被称作<strong>当前类</strong>，当前所用到的常量池成为<strong>当前常量池</strong>，所以在一个线程执行方法时就会追踪当前常量池。线帧作为当前方法所分配的一个帧，于是也就成了当前帧，这个帧就被用来存储当前方法的相关数据流被压入虚拟机栈中。</p>
</blockquote>
<p>概括的说</p>
<blockquote>
<p>栈是用来保存当前线程的运行状态的，而帧是用来保存当前方法的运行状态的，也就是线程中依次运行不同方法对应着帧的入栈和出栈   </p>
</blockquote>
<h3 id="组成成分"><a href="#组成成分" class="headerlink" title="组成成分"></a>组成成分</h3><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>相关概念：</p>
<blockquote>
<p>局部变量表的容量是<strong>容量槽slot</strong>为最小单位，一个slot大小为32bit，所以在<strong>64位的虚拟机</strong>中需要使用<strong>对齐补白</strong>的手段来使得使得容量槽slot在外观上看起来和32位的虚拟机保持一致，所以说对于<strong>64位的数据如long，double都需要使用两个容量槽slot去存储</strong>，并且在任何时候都不允许<strong>单独访问</strong>其中的一个。局部变量表的大小是在编译期间可以查询到的，因为它是作为方法的对应属性里的数据max_local数据项中存储的，也就是编译class文件的过程中，这个最大的需要分配变量的局部变量表的最大存储容量就已经确定了。</p>
</blockquote>
<p>局部变量表的顺序：</p>
<blockquote>
<p>变量表的索引从0开始，首先是方法所属的对象的引用（静态方法无）-&gt;其次是方法的参数变量（按照声明的顺序）-&gt;再者是方法的内部的局部变量（按照声明的顺序）。并且对于byte char short这三种数据类型需要转化为int类型存储在局部变量表中</p>
</blockquote>
<p>其他性质：</p>
<blockquote>
<p>在类被JVM加载时会为类变量赋初值，但是局部变量若声明了但却未赋初值是会出现编译错误的并且slot对于局部变量中没有覆盖整个方法的作用域的变量是可重用的。对于可重用的slot，如果后面没有在定义变量对这个slot进行覆盖，即使这个变量已经无效，那么这个变量在方法体内也不会被回收，除非解释执行的时候显示的赋值为null，但是在JIT编译器优化后赋值为null的操作就会被消除掉，这时候将变量设置为null就没有意义了。</p>
</blockquote>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>一些操作性质：</p>
<blockquote>
<p>操作数栈和局部变量表一样都是编译期间，操作数栈的最大深度在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的元素不明确Java的数据类型，也就是说在所有Java数据类型中，32位数据容量为1,64位数据容量为2，   </p>
</blockquote>
<p>其他性质：</p>
<blockquote>
<p>在概念模型中，一个县城的两个栈帧是相互独立的，但是在虚拟机实现中都会做一些优化处理，让两个栈帧出现一部分重叠，也就是让下面栈帧的部分操作数栈与上面的栈帧的部分局部变量表互相重重叠，这样在进行方法调用时就会公用一部分数据，无需进行额外的参数复制，达到了一定的优化效果。java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中栈指的就是操作数栈。</p>
</blockquote>
<h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><blockquote>
<p>栈帧包含了一个指向运行时常量池中该栈帧所属方法的引用，这个引用是为了支持方法调用过程中的<strong>动态连接</strong>。常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用有些会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外的符号引用将在每一次<strong>运行期间</strong>转化为直接引用，这部分称为<strong>动态解析</strong>。</p>
</blockquote>
<h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><blockquote>
<p>无论是正常完成退出方法还是异常完成退出方法，都需要返回到方法被调用的位置，才能将程序正常进行下去，方法正常退出时，PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值；方法异常退出时，要通过异常处理器表来确定返回的地址，栈帧中一般不会保存这部分信息。方法退出相当于把当前栈帧出栈，所以方法退出时可能执行恢复上层方法的局部变量表和操作数栈的操作和把返回值（如果存在）压入调用者栈帧的操作数栈中的操作以及调整PC计数器的值以指向方法调用指令后面的一条指令的操作。</p>
</blockquote>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p><img src="https://wx2.sbimg.cn/2020/07/02/2YjyJ.png" alt="2YjyJ.png"></p>
<h3 id="解析调用"><a href="#解析调用" class="headerlink" title="解析调用"></a>解析调用</h3><blockquote>
<p>我们知道，在类加载过程中有解析阶段，在这个阶段中，类文件的一部分符号引用会转化为直接引用，这么做主要是因为<strong>方法在真正的执行前就已经有了一个可确定的调用版本，并且这个版本在运行期间是不可变的</strong>，这类方法的调用就称作解析调用。并且满足条件的这类方法叫做<strong>非虚方法</strong>主要有静态方法、私有方法、父类方法、final类方法、实例构造器方法，其他的不满足这样过程的条件都称为<strong>虚方法</strong></p>
</blockquote>
<h2 id="分派与多态"><a href="#分派与多态" class="headerlink" title="分派与多态"></a>分派与多态</h2><h3 id="静态分派与重载"><a href="#静态分派与重载" class="headerlink" title="静态分派与重载"></a>静态分派与重载</h3><blockquote>
<p>重载是指方法名是相同的但是方法签名不同的情况，调用时使用<strong>方法签名</strong>来判断调用哪个具体方法，<strong>JVM在重载时是通过静态类型作为判断依据</strong>，所以javac编译器会根据参数的静态类型来决定选择哪个版本的方法，<strong>静态分派发生在编译阶段</strong>，因此确定静态分派的动作实际上不是有虚拟机来执行的。</p>
</blockquote>
<p>Java静态类型与实际类型的相关解释可以参考上一篇博客或直接点击<a href="http://www.easonhe.top/2020/07/02/%E3%80%90Java%E3%80%91%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">传送门</a></p>
<h4 id="方法签名的解释"><a href="#方法签名的解释" class="headerlink" title="方法签名的解释"></a>方法签名的解释</h4><blockquote>
<p><strong>方法头指定修饰符、返回值类型、方法名、和形式参数</strong>。方法头中定义的变量称为形参 ，形参如同占位符。当方法被调用时，传递一个值给形参，此值称为实参，形参列表指的是形参的类型、顺序和形参的数目。<strong>方法签名就是方法名和形参列表共同组成的</strong>。</p>
</blockquote>
<h3 id="动态分配与重写"><a href="#动态分配与重写" class="headerlink" title="动态分配与重写"></a>动态分配与重写</h3><blockquote>
<p>重写是指方法名和方法签名都相同的子类重写父类的方法，但是需要注意的是静态方法可以重载但是重写是无效的，因为在调用的过程中<strong>通过子类的实例对象调用就是调用子类的静态方法，通过父类的实例对象调用则调用父类的静态方法</strong></p>
</blockquote>
<blockquote>
<p>动态分派和多态重写的本质与<strong>字节码指令invokevirtual的多态查找过程</strong>相关：1.找到栈顶元素所指向的对象的实际类型，记为C；2. 在类型C中找到与常量池中的描述符与简单名称都相符的方法，然后进行访问权限检查，如果通过则返回这个方法的直接引用，查找结束；如果不通过，则返回java.lang.IllegalAccessError异常。3.否则，按照继承关系，继续重复2中搜索和验证过程。4.如果始终没有找到，则抛出java.lang.AbstractMethodError异常。这里注意，<strong>重写的本质其实就是invokevirtual指令把常量池中的符号引用解析到了不同的实际类型的直接引用上</strong></p>
</blockquote>
<p>用代码实例验证一下动态分配与静态方法重写问题：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"><span class="comment">//动态分配与静态方法重写的测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text1</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Father say Hi"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Father static"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="title">extends</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Son say Hi"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Son static"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Daughter</span> <span class="title">extends</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Daughter say Hi"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Daughter static"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"动态分配测试"</span>);</span><br><span class="line">		Father s = <span class="keyword">new</span> Son();</span><br><span class="line">		Father d = <span class="keyword">new</span> Daughter();</span><br><span class="line">		s.sayHi();</span><br><span class="line">		d.sayHi();</span><br><span class="line">		s = <span class="keyword">new</span> Daughter();</span><br><span class="line">		s.sayHi();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"静态方法重写测试"</span>);</span><br><span class="line">		s.testStatic();</span><br><span class="line">		d.testStatic();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>动态分配测试<br>Son say Hi<br>Daughter say Hi<br>Daughter say Hi<br>静态方法重写测试<br>Father static<br>Father static   </p>
</blockquote>
<p>这里需要注意的是：</p>
<blockquote>
<p>分派与解析并不是说只能选一个的问题，只是它们在不同的阶段不同层次上筛选和确定目标的过程，就比如静态方法在类加载过程的解析中就进行了解析，但若静态方法含有重载的版本那么这将在静态分派中完成选择问题。</p>
</blockquote>
<h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><blockquote>
<p>动态分派时为了避免频繁的搜索，会为类在方法区建立一个虚方法表，利用索引来代替元数据查找从而提高性能。<strong>虚方法表中存放着各个方法的实际入口地址</strong>。如果某个方法在子类中没有重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口，如果子类中重写了这个方法，那么子类对应的方法的地址将会替代指向父类方法的入口地址。具有相同方法签名的父类、子类的方法在父类和子类的虚方法表中具有相同的索引序号，这样当类型变换时，仅需要变更查找的方法表。</p>
</blockquote>
<h2 id="解释执行与直接执行"><a href="#解释执行与直接执行" class="headerlink" title="解释执行与直接执行"></a>解释执行与直接执行</h2><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><blockquote>
<p>解释器是将平台无关的字节码（原本由javac将java文件编译为class文件，并将源代码编译成了与平台无关的字节码）解释称对应平台的机器码解释执行</p>
</blockquote>
<h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><blockquote>
<p>（即时编译器）是一个把Java的字节码（包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序。JVM对这个函数就不再解释而是直接执行</p>
</blockquote>
<h3 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h3><blockquote>
<p>用户模式下:解释执行的。<br>server模式下：先解释执行，然后JVM统计函数执行热点，将这些热点代码仔细优化编译成本地机器码(默认为调用10000次以上)，即使用JIT编译器，当这个热点不再是热点的时候，重新解释执行。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM】类加载机制</title>
    <url>/2020/06/30/%E3%80%90JVM%E3%80%91%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><strong>类加载机制作为Java虚拟机最基础的部分，在学习Java语言是不容忽略的一部分，懂得类加载机制才是深入理解JVM的敲门砖，加油ヽ(.◕ฺˇд ˇ◕ฺ;)ﾉ</strong></p>
<a id="more"></a>
<hr>
<h2 id="什么是类加载机制"><a href="#什么是类加载机制" class="headerlink" title="什么是类加载机制"></a>什么是类加载机制</h2><blockquote>
<p>类加载机制是指将类的.class文件的二进制数据读取到运行时的<strong>数据区的方法区</strong>内,然后在<strong>堆区</strong>内创建一个java.lang.Class对象,用来封装类在方法区内的数据结构,类的加载的最终产品就是位于堆中的Class对象,对象向用户提供了访问方法区内的数据结构的接口。</p>
</blockquote>
<hr>
<h2 id="类加载机制的过程"><a href="#类加载机制的过程" class="headerlink" title="类加载机制的过程"></a>类加载机制的过程</h2><p><img src="https://wx2.sbimg.cn/2020/06/28/2d57R.png" alt="2d57R.png"></p>
<p>类的加载过程分为了五个过程：加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化，其中(验证准备和解析)三个阶段也被成为连接阶段,<strong>这几个阶段是按顺序开始，而并不是按顺序完成，往往这些阶段会交叉的混合运行，一般在某个阶段运行过程中去调用激活另一个阶段</strong>，这里需要注意的是这五个阶段中有四个阶段的发生顺序是确定的（加载-&gt;验证-&gt;准备-&gt;初始化）,但是解析并非一定在顺序中,它有时会在初始化过程之后,这样的目的是为了支持Java语言的动态绑定。接下来我们分别来看一个类加载过程中的每个阶段的内容：</p>
<h3 id="加载（查找并获取字节流）"><a href="#加载（查找并获取字节流）" class="headerlink" title="加载（查找并获取字节流）"></a>加载（<strong><em>查找并获取字节流</em></strong>）</h3><blockquote>
<ol>
<li>通过类的全限定名来获取其定义的二进制字节流；    </li>
<li>将这个字节流所代表的静态存储结构转为方法的运行时的数据结构；</li>
<li>在Java堆中生成一个代表这个类的Java.lang.Class对象，作为方法区中这些数据的访问入口。   </li>
</ol>
</blockquote>
<p>这几个步骤是JVM需要在这个阶段完成的三件事情，相比于其他几个阶段来说，<strong>加载阶段（准确的说应该是加载获取类的二进制字节流的动作）是可控性最强的阶段</strong>，因为在这个阶段，开发人员可以利用系统提供的类加载器来加载，也可以使用自己定义的类加载器进行加载。<strong>加载阶段完成后JVM外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，并且创建了一个对应的java.lang.Class对象，用来访问这些数据</strong>。加载的具体方式和类加载器在后面的模块中解释。   </p>
<h3 id="验证（确保类加载的正确性）"><a href="#验证（确保类加载的正确性）" class="headerlink" title="验证（确保类加载的正确性）"></a>验证（<strong><em>确保类加载的正确性</em></strong>）</h3><blockquote>
<ol>
<li>文件格式验证：验证字节流是否符合文件的规范；   </li>
<li>元数据验证：对字节码的描述的信息进行语义分析，以保证其描述的信息符合语言规范的要求；</li>
<li>字节码验证：通过数据流和控制流分析，保证程序的语义合法逻辑；</li>
<li>符号引用验证：确保解析动作能够正确执行。   </li>
</ol>
</blockquote>
<p><strong>验证是连接阶段的第一步，这一步是为了确认Class文件字节流符合当前JVM的需求，并且不会危害到JVM本身的安全</strong>，所以进行了如上四个方面的验证动作，值得注意的是，<em>验证并不是必需的阶段，它不会影响到程序的运行，所以如果类进行了反复的验证，那么完全可以通过参数Xverifynone来关闭大部分的验证措施，从而缩短虚拟机加载类的时长。</em></p>
<h3 id="准备（为静态变量分配内存和初始化）"><a href="#准备（为静态变量分配内存和初始化）" class="headerlink" title="准备（为静态变量分配内存和初始化）"></a>准备（<strong><em>为静态变量分配内存和初始化</em></strong>）</h3><p><strong>准备阶段是为类的静态变量分配内存，并将其初始化为默认值</strong>，但是要注意：</p>
<blockquote>
<ol>
<li><em>这里分配内存仅是为类的静态变量，并不包括类中的实例变量，这个将在以后的对象实例化中分配到堆中</em>；</li>
<li><em>这里所说的初始化为默认值是指将对应的变量类型赋予对应的0值，如0、null、false等，而不是初始化为用户设置的变量值，将变量赋值为用户定义数值是在初始化阶段才做的工作</em>;  </li>
<li>全局变量如果没有显示的对其赋值，那么在使用时将会用到准备阶段为其赋予的0值，当然局部变量必须显示的赋值，否则编译是不通过的；</li>
<li>对于引用类型来说，如数组的引用或对象的引用，如果都没有对其进行显示的赋值而使用，那么都将用到系统为其赋予的0值null；</li>
<li>同时被static与final修饰的值将在此阶段就被赋予显示的初始值，也就是在编译期间就已经将其结果放到了调用它的类的常量池中了。</li>
</ol>
</blockquote>
<h3 id="解析（符号引用转为直接引用）"><a href="#解析（符号引用转为直接引用）" class="headerlink" title="解析（符号引用转为直接引用）"></a>解析（<strong><em>符号引用转为直接引用</em></strong>）</h3><p>解析阶段是虚拟机将常量池中的符号引用（<em>主要是类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符7种</em>）转化为直接引用的过程。其中直接引用就是一个直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p>
<h3 id="初始化（为类的静态变量赋予真正的初始值）"><a href="#初始化（为类的静态变量赋予真正的初始值）" class="headerlink" title="初始化（为类的静态变量赋予真正的初始值）"></a>初始化（<strong><em>为类的静态变量赋予真正的初始值</em></strong>）</h3><p>JVM对静态变量初始化的两种方式：</p>
<blockquote>
<ol>
<li>声明类变量是指定初始值；</li>
<li>使用静态代码块为类变量指定初始值。   </li>
</ol>
</blockquote>
<p>JVM初始化的步骤为：</p>
<blockquote>
<ol>
<li>若初始化的这个类还没有进行加载和连接，那么先将类进行加载和连接；</li>
<li>若初始化的这个类的父类还没有进行初始化，则先去初始化父类；</li>
<li>若初始化的这个类中有初始化语句，则系统依次执行这些初始化语句。</li>
</ol>
</blockquote>
<p>类初始化的时机：(对类进行主动调用的时候)</p>
<blockquote>
<ol>
<li>创建类的实例，及new一个对象；</li>
<li>访问某个类或接口的静态变量或对静态变量进行赋值时；</li>
<li>调用某个类的静态方法时；</li>
<li>某个类的子类被初始化时;</li>
<li>使用反射方式强制创建某个类或接口对应的java.lang.Class对象；</li>
<li>JVM启动时被标明为启动类的类；</li>
</ol>
</blockquote>
<p>初始化总结：   </p>
<blockquote>
<p>初始化是类加载机制的最后一个阶段，本阶段才真正意义上执行了class内部代码，但是其实这也只是执行类构造器<clinit>()方法，所以说，执行代码也只是一个开端。</p>
</blockquote>
<hr>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="定义及一些分类与关系"><a href="#定义及一些分类与关系" class="headerlink" title="定义及一些分类与关系"></a>定义及一些分类与关系</h3><p>提到类加载机制就不得不提到类加载器，，它是用在类加载机制的第一个阶段-加载，一个类在JVM中的唯一性依赖于类与其类加载器，即使两个类来源于同一个class文件，但是由于类加载器的不同也让两个类在JVM中是两个不同的存在。并且在加载阶段类加载器获取二进制字节流并非只在Class文件中，还可以从jar包中以及网络和其他文件生成。其种类可分为如下：</p>
<blockquote>
<p><em>以虚拟机的角度</em>：   </p>
<ol>
<li><strong>启动类加载器</strong>:它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分。</li>
<li><strong>所有其他的类加载器</strong>：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。   </li>
</ol>
</blockquote>
<blockquote>
<p><em>以开发人员的角度</em>:</p>
<ol>
<li><strong>启动类加载器</strong>：Bootstrap-ClassLoader，跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap-ClassLoader加载）,并且启动类加载器是无法被Java程序直接引用的。</li>
<li><strong>扩展类加载器</strong>：Extension-ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li>
<li><strong>应用程序类加载器</strong>：Application-ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ol>
</blockquote>
<p>一般应用程序的加载都是由这三种类加载器互相协作完成的，<em>当然也可以加入自定义的ClassLoader，因为JVM自带的ClassLoader只是在本地文件系统加载标准的java class文件</em>。其实在使用Applet时就用到了自定义的ClassLoader，因为它需要加载网络上的Java class文件，并且可以做到:   </p>
<ol>
<li>在执行非置信代码之前，自动验证数字签名。</li>
<li>动态地创建符合用户特定需要的定制化构建类。</li>
<li>从特定的场所取得java class，例如数据库中和网络中。   </li>
</ol>
<p>这样可以检验相关的安全信息，应用服务器也大都使用了自定义ClassLoader技术。</p>
<h3 id="几种类加载器的层级关系"><a href="#几种类加载器的层级关系" class="headerlink" title="几种类加载器的层级关系"></a>几种类加载器的层级关系</h3><p><a href="https://sbimg.cn/image/2smPO" target="_blank" rel="noopener"><img src="https://wx2.sbimg.cn/2020/06/28/2smPO.png" alt="2smPO.png"></a><br>这种层级关系称为<strong>双亲委派模型</strong>，每一层类加载器的上一层为其父加载器，但是，它们的这种关系不是通过继承实现的，而是通过组合关系来复用父加载器中的代码的。这就不得不提到JVM类加载的3种机制了：</p>
<blockquote>
<ol>
<li>父类委托：当收到类加载请求时，先让父类进行加载，也就是一直到顶层的启动类加载器向下，只有当父类无法加载时，子类类加载器才会尝试从自己的类路径中加载；</li>
<li>全盘负责：当一个类加载器负责加载某个类时，该类的所依赖和引用的其他类也将由该类加载器全权负责，除非显示的使用另一个类加载器；</li>
<li>缓存机制：该机制会保证所有加载过的类都会被缓存，当需要加载某个类时，类加载器会先从缓存区中寻找是否有该类，若无，系统才会加载该类并放入缓存区。这也解释了为什么修改了类之后需要重新启动JVM新的类才会生效。   </li>
</ol>
</blockquote>
<h3 id="双亲委派机制："><a href="#双亲委派机制：" class="headerlink" title="双亲委派机制："></a>双亲委派机制：</h3><blockquote>
<p>1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。<br>2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。<br>3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；<br>4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</p>
</blockquote>
<p>这里给出<strong><em>双亲委派机制的源码</em></strong>以便于更好的理解双亲委派机制的作用原理：   </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public Class&lt;?&gt; load<span class="constructor">Class(String <span class="params">name</span>)</span>throws ClassNotFoundException &#123;</span><br><span class="line">            return load<span class="constructor">Class(<span class="params">name</span>, <span class="params">false</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected synchronized Class&lt;?&gt; load<span class="constructor">Class(String <span class="params">name</span>, <span class="params">boolean</span> <span class="params">resolve</span>)</span>throws ClassNotFoundException &#123;</span><br><span class="line">            Class c = find<span class="constructor">LoadedClass(<span class="params">name</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (c<span class="operator"> == </span>null) &#123;  <span class="comment">//判断类是否已经被加载</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != null) &#123;<span class="comment">//如果该加载器有父类，则传递给父类加载器加载</span></span><br><span class="line">                        c = parent.load<span class="constructor">Class(<span class="params">name</span>, <span class="params">false</span>)</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span></span><br><span class="line">                        c = find<span class="constructor">BootstrapClass0(<span class="params">name</span>)</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;<span class="comment">// 如果无父类加载器并且启动类加载器都不能加载，则调用自身的加载功能</span></span><br><span class="line">                    c = find<span class="constructor">Class(<span class="params">name</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolve<span class="constructor">Class(<span class="params">c</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里给出几个ClassLoader加载的Demo：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package First;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> Demo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String<span class="literal">[]</span> args) throws ClassNotFoundException &#123;</span><br><span class="line">		ClassLoader loader = <span class="module-access"><span class="module"><span class="identifier">HelloWorld</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ClassLoader()</span>;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(loader);</span><br><span class="line">		loader.load<span class="constructor">Class(<span class="string">"First.Text"</span>)</span>;  <span class="comment">//loader.loadClass()的方式加载类 默认不执行初始化块</span></span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"First.Text"</span>)</span>;  <span class="comment">//Class.forNmae()的方式加载类 默认执行初始化块</span></span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"First.Text"</span>, <span class="params">false</span>, <span class="params">loader</span>)</span>;  <span class="comment">//Class.forNmae()指定类加载器的方式 默认不执行初始化块(false)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package First;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"执行静态代码块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">jdk.<span class="built_in">int</span>ernal.loader.ClassLoaders$<span class="symbol">AppClassLoader@</span><span class="number">3</span>a71f4dd</span><br><span class="line">执行静态代码块</span><br></pre></td></tr></table></figure>
<h3 id="这里记录一个坑"><a href="#这里记录一个坑" class="headerlink" title="这里记录一个坑"></a>这里记录一个坑</h3><p>在普通的使用loader.loadClass(ClassNmae)或Class.forName(ClassName)或指定加载器的加载类时若ClassName只填写类名称将抛出ClassNotFoundException异常。<br><strong>解决方法</strong>:同一个包中的类虽然可以直接引用但是由于类名前的包名已由编译器加载上去了，所以在通过这几个方法加载类时，如果不加包名则会默认在default中寻找，自然也就找不到了，所以在ClassName前应该加上包名，问题就解决了。   </p>
<blockquote>
<p><strong>三种类加载方式的不同</strong>：<br>1 . ClassLoader.loadClass(ClassName)方式默认只是将其加载到JVM中而不会去加载类的静态代码块，只有等到new Instance时才会去执行；<br>2 . Class.forName(ClassName)方法是将类的.class文件加载到JVM中并对类进行解释，执行类的静态代码块；<br>3 . Class.forNmae(ClassName, Initialize, Loader)这种类加载方式是使用指定的类加载器进行加载类，并且可以指定是否执行类的静态代码块。   </p>
</blockquote>
<hr>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本篇对于类加载机制通过累加载机制的过程将5个阶段的任务以及相关的机制原理以及所用到的一些外部实体做了解释，我们可以看到，在整个类加载机制的过程中，只有类加载阶段可以由用户控制，即使用指定的类加载器进行加载，其余的阶段都是由JVM所控制的，并且类加载机制的结束仅仅是代码运行的一个开端，所以说，类加载机制也仅仅是将类文件加载到JVM的内存中，只有在类加载结束后，才真正的开始执行字节码的操作。</p>
<p>参考：<br>《深入理解JAVA虚拟机》<br><a href="https://www.cnblogs.com/ityouknow/p/5603287.html" target="_blank" rel="noopener">https://www.cnblogs.com/ityouknow/p/5603287.html</a></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【JVM】类文件结构</title>
    <url>/2020/06/29/%E3%80%90JVM%E3%80%91%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><strong>学习JVM居然能忽略类文件结构？不存在的！类文件结构作为理解JVM入门级的垫脚石，你不能不清楚它的存在及意义 °(°ˊДˋ°) °</strong></p>
<a id="more"></a>
<hr>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>如今的计算机仍然只能识别0和1，但将我们编写的程序编译成二进制本地机器码已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、 平台中立的格式作为程序编译后的存储格式。各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石，而且语言无关性正越来越被开发者所重视。Java虚拟机不和包括Java在内的任何语言绑定，它只与Class文件这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。</p>
<hr>
<h2 id="类文件结构的相关概念与属性"><a href="#类文件结构的相关概念与属性" class="headerlink" title="类文件结构的相关概念与属性"></a>类文件结构的相关概念与属性</h2><h3 id="类文件定义"><a href="#类文件定义" class="headerlink" title="类文件定义"></a>类文件定义</h3><blockquote>
<p>Class文件是一组以8位字节为基础单位的二进制流，各项数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，如果是超过8位字节以上空间的数据项，则会按照高位在前的方式（Big-Endian）分割成若干个8位字节进行存储。    </p>
</blockquote>
<p>来看一个类文件二进制流实例：</p>
<p><img src="https://wx2.sbimg.cn/2020/06/29/2jo44.png" alt="2jo44.png"><br><strong>其中一个字节为2位16进制数，图中的‘cafe’就是为两个字节</strong>   </p>
<h3 id="魔数与文件版本"><a href="#魔数与文件版本" class="headerlink" title="魔数与文件版本"></a>魔数与文件版本</h3><blockquote>
<p><strong>魔数</strong>是每个class文件的4个字节组成的数，如图中的‘cafe babe’就是魔数，魔数的唯一作用就是用来判断此class文件是否是能被虚拟机接受的文件。很多种文件都是用到了魔数进行文件类别的识别，如：.gif, .jpeg等   </p>
</blockquote>
<blockquote>
<p><strong>文件版本</strong>号就是紧跟在魔数后的四个字节，其中，第5 6个字节表示的是次版本号，第7 8个字节表示的是主版本号。如图中的0000为次版本号，0034为主版本号，Java的版本号是从45开始的，JDK1.1之后每个JDK大版本发布，其主版本号就向上加1，这就让高版本的JDK能向下兼容低版本的class文件，但是不能向上兼容高版本的class文件，因为<em>虚拟机是拒绝执行超过它版本号的class文件</em>。</p>
</blockquote>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><blockquote>
<p>常量池的入口紧跟在主次版本号之后，<strong>向后的两个字节为常量池的个数，再向后就是从常量1….到常量n</strong>,常量池是class文件的数据仓库，也是占用class文件空间最大的数据项目之一，它是与class文件的其他项目关联最多的数据类型。<br>常量池中主要存放着<strong><em>两大元素</em></strong>：    </p>
<ol>
<li><strong>字面量</strong>：类似于常量概念，如final修饰的常量值等等   </li>
<li><strong>符号引用</strong>：包含类和进口的全限定名、字段的名称和描述符、方法的名称和描述符这三种常量，属于编译方面的概念。</li>
</ol>
</blockquote>
<p>当JVM运行时，需要从常量池中获取对应的符号引用，然后在类创建或运行时进行解析，得到真正的内存地址。</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><blockquote>
<p>访问标志是在常量池继续向后的两个字节，这个标志（access-flags）表示一些类或接口的访问信息，比如，这个Class是一个类呢还是一个接口呢，它是被什么限定符所修饰的？public？abstract？final？这些都在访问标志中被标明。</p>
</blockquote>
<h3 id="类索引-父索引-接口索引"><a href="#类索引-父索引-接口索引" class="headerlink" title="类索引-父索引-接口索引"></a>类索引-父索引-接口索引</h3><blockquote>
<p>类索引（this_class）与父索引（super_class）都是一个两个字节的数据集合，因为Java的单一继承所以让类索引和父索引只能有一个，以此类推，接口索引就不再只是一个两个字节的数据集合了，而是一组两个字节的数据集合，前两个字节代表着接口索引的个数，后面的字节分别就代表了接口1….接口n，其中<strong><em>类索引是用来确定这个类的全限定名，父所以与接口索引用来确定这个类的继承连接关系</em></strong>，接口索引的顺序是按照implements（或extends）后的顺序以此展开的。</p>
</blockquote>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><blockquote>
<p>字段表中存放用于描述类或接口中声明的变量信息，也是由一个两个字节的数据表示字段个数后面字节代表字段1….字段n，其中包括类级和实例级变量（static修饰符来区分）但是其中<strong>不包括局部变量也不包括从超类或父类中继承来的字段</strong>，还有一些是有着特殊含义的字段，如内部类通常会添加指向外部类的字段用来保持对外部类的访问性。其中<strong>字段的通常信息</strong>包括：   </p>
<ol>
<li>字段的作用域（public protected private default修饰符区分）；   </li>
<li>变量的级别（类级变量或实例级变量）；   </li>
<li>可变性（final修饰符区分）；   </li>
<li>并发可见性（volatile修饰符）；   </li>
<li>可否序列化（reansient修饰符）；   </li>
<li>字段的数据类型（int char double float等修饰符）；    </li>
<li>字段的名称等等。</li>
</ol>
</blockquote>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><blockquote>
<p>与字段表一致的是方法集合在class文件中采用了相同的存储方式，也是由一个两个字节的数据表示方法个数后面字节代表方法1….方法n，其中方法表的集合的信息通常包含：</p>
<ol>
<li>访问标志（access_flags）；   </li>
<li>名称索引（name_index）；   </li>
<li>描述符索引（descriptor_index）；   </li>
<li>属性表集合（attributes）这个里面包含的是类文件方法里的Java代码经过虚拟机编译后的<strong>字节码指令</strong>，这些指令都被放在了一个叫属性表的集合里面的“code”属性里。</li>
</ol>
</blockquote>
<p>解释一下字节码指令：字节码指令是指JVM的指令由一个字节长度的、代表着某种特定操作含义的数字（操作码，Opcode）以及跟随其后的0至多个爱表此操作所需参数（操作数，Operands）构成。字节码指令集是一种具有鲜明特点、优劣势都很突出的指令集架构，由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不可能超过256 条；又由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构。</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><blockquote>
<p>在class 文件、字段表、方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息，它也是由一个两个字节的数据表示属性个数后面字节代表属性1….方属性n。其中的属性包括：</p>
<ol>
<li><strong>code属性</strong>：这个在方法表集合中提到过，类文件方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。但是要注意，抽象类和接口的方法是没有code属性的；</li>
<li><strong>Exception属性</strong>：这个应该是很常见的，这个是一个异常类的统称，Exception属性就是用来列举出方法中可能抛出的（thorows关键字后的）受检查异常；</li>
<li><strong>LineNumberTable属性</strong>：用于描述 Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，但默认会生成到 Class 文件之中，可以在 javac 中分别使用 -g:none 或 -g:lines选项来取消或要求生成这项信息。如果选择不生成LineNumberTable 属性，对程序运行产生的最主要的影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。</li>
<li><strong>LocalVariableTable属性</strong>:用于描述栈帧中局部变量表中的变量与 Java 源码中定义的变量之间的关系,它也不是运行时必需的属性，但默认会生成到 Class 文件之中，可以在 Javac 中分别使用 -g:none 或 -g:vars 选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，IDE 将会使用诸如 arg0、arg1 之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不变，而且在调试期间无法根据参数名称从上下文获得参数值。</li>
<li><strong>SourceFile属性</strong>:用于记录生成这个 Class 文件的源码文件名称。这个属性也是可选的，可以分别使用 javac 的 -g:none 或 -g:source 选项来关闭或要求生成这项信息。在 Java 中，对于大多数的类来说，类名和文件名是一致的，但是又一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。</li>
<li><strong>ConstantValue属性</strong>:作用是通知虚拟机自动为静态变量赋值。只有被 static 关键字修饰的变量（类变量）才可以使用这项属性。类似 “int x = 1” 和 “static int x = 1” 这样的变量定义在 Java 程序中是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。对于非 static 类型的变量（也就是实例变量）的赋值是在实例构造器 <init> 方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器 <clinit> 方法中或者使用 ConstantValue 属性。目前 Sun Javac 编译器的选择是：如果同时使用 final 和 static 来修饰一个变量（按照习惯，这里称 “常量” 更贴切），并且这个变量的数据类型是基本类型或者 java.lang.String 的话，就生成 ConstantValue 属性来进行初始化，如果这个变量没有被 final 修饰，或者并非基本类型及字符串，则将会选择在 <clinit> 方法中进行初始化。</li>
<li><strong>InnerClass属性</strong>:用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成 InnerClass 属性。</li>
<li><strong>Deprecated和Synthetic属性</strong>：Deprecated 和 Synthetic 两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。Deprecated 属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过在代码中使用 @deprecated 注释进行设置。<br>Synthetic 属性代表此字段或者方法并不是由 Java 源码直接产生的，而是由编译器自行添加的，在 JDK 1.5 之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的 ACC_SYNTHETIC 标志位，其中最典型的例子就是 Bridge Method。所有由非用户代码产生的类、方法及字段都应当至少设置 Synthetic 属性和 ACC_SYNTHETIC 标志位中的一项，唯一的例外是实例构造器 “<init>” 方法和类构造器 “<clinit>” 方法。</li>
<li><strong>StackMapTable属性</strong>:在 JDK 1.6 发布后增加到了 Class 文件规范中，它是一个复杂的变长属性，位于 Code 属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</li>
<li><strong>Signature属性</strong>:在 JDK 1.5 发布后增加到了 Class 文件规范之中，它是一个可选的定长属性，可以出现于类、属性表和方法表结构的属性表中。在 JDK 1.5 中大幅增强了 Java 语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则 Signature 属性会为它记录泛型签名信息。之所以要专门使用这样一个属性去记录泛型类型，是因为 Java 语言的泛型采用的是擦除法实现的伪泛型，在字节码（Code 属性）中，泛型信息编译（类型变量、参数化类型）之后都通通被擦除掉。使用擦除法的好处是实现简单（主要修改 Javac 编译器，虚拟机内部只做了很少的改动）、非常容易实现 backport，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像 C# 等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得泛型信息。Signature 属性就是为了弥补这个缺陷而增设的，现在 Java 的反射 API 能够获取泛型类型，最终的数据来源也就是这个属性。</li>
<li><strong>BootstrapMethods属性</strong>:在 JDK 1.7 发布后增加到了 Class 文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存 invokedynamic 指令引用的引导方法限定符。</li>
</ol>
</blockquote>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Java类文件结构是java技术体系的重要基础之一，类文件是JVM对于编译首先要识别的入口，这是个数据和指令的开端，所以想要深入理解Java虚拟机，就不能不对class文件结构进行一个详细的认知。</p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】Java设计模式(记忆点)</title>
    <url>/2020/05/27/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>这里是初读程杰老师的《大话设计模式》得到的一些对应模式应用场景的简单总结,后期深读时会继续更新设计模式系列的博文哒✪ω✪</strong></p>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/06/15/VUPQWpBE9hdLxl2.jpg" alt="IMG_7799.jpg"></p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote>
<p><strong><em>策略模式用来封装算法，当遇到不同时间使用不同时可以使用策略模式</em></strong>   </p>
</blockquote>
<blockquote>
<p>虽然当业务变更时仍需要改变Text里的switch语句中的判断条件，但是任何需求的变更都是需要成本的<br>—</p>
</blockquote>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><blockquote>
<p><strong><em>装饰模式就是为已有功能动态添加更多功能的一种方式，当代码需要新功能时不必向主类中添加代码从而增加主类的复杂度，可以使用修饰类来完成这个功能</em></strong></p>
</blockquote>
<hr>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote>
<p><strong><em>代理模式的应用场景：1.远程代理，即为一个对象在不同的地址空间提供局部代表，从而可以隐藏对象在不同地址空间的事实；2.虚拟代理，是根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象如HTML网页中的大量图片信息；3.安全代理，用来控制真实对象的访问权限；4.智能指引，指在调用真实的对象时代理处理另外一些事</em></strong></p>
</blockquote>
<hr>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote>
<p><strong><em>工厂方法定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂模式使一个类实例化延迟到了子类。相比于简单工厂的添加功能需要修改工厂的switch语句，这违背了开-闭原则，所以引入了工厂模式，它将修改的代码从普通类移动到了客户端</em></strong>   </p>
</blockquote>
<hr>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><blockquote>
<p><strong><em>原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。一般在初始化信息不变的的情况下，克隆是最好的方法，既隐藏了初始化的细节，又是对性能的极大提高</em></strong></p>
</blockquote>
<hr>
<h2 id="模版模式"><a href="#模版模式" class="headerlink" title="模版模式"></a>模版模式</h2><blockquote>
<p><strong><em>模版模式提供了一个代码复用的平台，通过模版模式将一些单一的行为整合到一个单一的地方，这样使子类摆脱了重复单一行为的纠缠</em></strong></p>
</blockquote>
<hr>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><blockquote>
<p><strong><em>迪米特法则指出如果两个类不必彼此直接通信，那么它们就不应该直接发生相互作用，如果其中一个类需要调用另一个类的方法的话，那么可以通过第三方转发这个调用</em></strong>   </p>
</blockquote>
<blockquote>
<p>迪米特法则根本思想其实强调了类之间的松耦合</p>
</blockquote>
<hr>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><blockquote>
<p><strong><em>外观模式为子系统的一组接口提供了一致的界面，此模式定义了一个高层接口，这个接口使得这个子系统更加容易使用</em></strong>   </p>
</blockquote>
<blockquote>
<p>外观模式用一个高层接口使得原本设计粗糙且复杂的遗留代码有了一个清晰的接口，这样让新的系统更加容易与其交互</p>
</blockquote>
<hr>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><blockquote>
<p><strong><em>建造者模式将一个复杂对象的构建与表示分离，这样使得同样的构建过程可以创建不同的表示</em></strong>   </p>
</blockquote>
<blockquote>
<p>建造者模式的Builder定义了抽象的建造过程，使得实例化的建造可以不遗漏建造过程（遗漏的话是不能通过编译的）,与此同时创建Director类可以用来创建具体的想要创建的对象</p>
</blockquote>
<hr>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote>
<p><strong><em>观察者模式一般使用在当一个对象改变同时需要改变其他对象时，并且并不知道具体有多少对象需要改变，观察者模式的工作其实就是在接触耦合，使得耦合双方依赖于抽象而非具体，从而使得各自的变化不回影响另一个的变化</em></strong></p>
</blockquote>
<hr>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><blockquote>
<p><strong><em>抽象工厂模式提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类</em></strong></p>
</blockquote>
<hr>
<h2 id="三种工厂模式对比"><a href="#三种工厂模式对比" class="headerlink" title="三种工厂模式对比"></a>三种工厂模式对比</h2><blockquote>
<p><strong>简单工厂模式</strong>:生产一个有多种款式的对象，对象通用抽象父类，用Switch决定实例化哪一种款式的对象；<br><strong>工厂模式</strong>：生产一个有多重款式的对象，对象通用抽象父类，每种款式有其特定的生产工厂，它们都继承一个工厂接口，在客户端种决定用哪一个特定工厂来实例化工厂，这将实例化延迟到了客户端；<br><strong>抽象工厂模式</strong>：生产多个有多种款式的对象3应其抽象父类，多个对象用多个特定工厂来连接工厂接口，接口里对应了每个款式对应的对象创建实例</p>
</blockquote>
<hr>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><blockquote>
<p><strong><em>状态模式:当一个对象的行为取决于它的状态，并且它必须在运行时刻根据自己的状态来改变自己的行为的时候可以考虑使用状态模式</em></strong>   </p>
</blockquote>
<blockquote>
<p>由于对于状态来判断行为会含有很长的判断语句，这将是long method其实就已经有了坏味道，这违反了单一职责和开-闭原则，状态模式说白了就是将很长的判断语句分离开来，以便后期修改与维护</p>
</blockquote>
<hr>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote>
<p><strong><em>适配器模式：适配器类继承适配目标的父类，被适配作为适配器的内部对象变量，在构造函数时将其实例化，然后将目标父类的函数内部调用被适配的对象的相对应的内方法</em></strong></p>
</blockquote>
<hr>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><blockquote>
<p><strong><em>备忘录模式：在需要进行存储备忘录的类里添加保存备忘录的方法，并将需要保存的属性加入，由于对备忘录的封装属性最好再加备忘录管理者类，通过管理者类来对备忘录进行存储和使用</em></strong></p>
</blockquote>
<hr>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote>
<p><strong><em>组合模式：将对象组合成树形结构，以表示它们之间的额“整体-部分”的层次结构，组合模式使得客户对单个对象和组合对象的使用具有一致性</em></strong>   </p>
</blockquote>
<blockquote>
<p>当发现需求中是整体与部分的结构层次时，并且客户可以忽略组合对象与单个对象之间的关系，从而统一的使用组合结构中的所有对象时就可以考虑使用组合模式了</p>
</blockquote>
<hr>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><blockquote>
<p><strong><em>迭代器模式：提供了一个方法可以顺序的访问某聚合类型里的各个元素，而又不暴露各个对象的内部表示</em></strong>   </p>
</blockquote>
<blockquote>
<p>很多语言中已经不再显式的使用迭代器模式而是已经把这个模式做到了语言当中例如foreach in循环或者枚举类型，但是迭代器模式还是拥有它本身的优点，比如可以自己定义一种循环方式，而不是简单的进行顺序遍历</p>
</blockquote>
<hr>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p><strong><em>单例模式：为了确保类被一次且只能被实例化一次，并且提供获取此实例的方法 一般来说不建议使用懒汉方式，一般使用饿汉方式，在明确要用lazy loading时会使用登记模式，如果涉及到反序列化创建对象时可以考虑使用枚举方式，如果有特殊需求可以使用双检锁方式</em></strong></p>
</blockquote>
<hr>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><blockquote>
<p><strong><em>桥接模式：由于大量的继承会导致更改影响大难以更新维护，违背了开-闭原则，所以也就是当多角度分类时，就可以将这些类分离出来，这种时候使用合成/聚合复用原则，尽量不使用继承</em></strong>   </p>
</blockquote>
<blockquote>
<p>可以这样想：猪八戒投胎，灵魂在河的一边，河对面有两个肉体，红猪和绿猪；灵魂需要过桥，选择红猪的肉体或者绿猪的肉体完成投胎。在上面的例子中，红猪和绿猪就是 HandsetGame 和 HandsetPhone，灵魂是 HandsetBand 类，而那座桥就是 HandsetBand 这个接口。</p>
</blockquote>
<hr>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><blockquote>
<p><strong><em>命令模式：把请求一个操作的对象与它怎么执行一个操作的对象分割开来，这样在程序中请求者和实现者分割开来，可以方便的加入一个新的命令，并且降低了系统的耦合度</em></strong></p>
</blockquote>
<hr>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><blockquote>
<p><strong><em>责任链模式有点类似于迭代器模式，一个对象管理对应的业务，超出范围则转入下一个对象管理，以此类推</em></strong></p>
</blockquote>
<hr>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><blockquote>
<p><strong><em>中介者模式是将很多实体之间的交互封装在一个特定的类当中，使得类之间松耦合，一般应用于一组定义良好但是复杂的方式进行通信的场合，但是由于中介者模式的特点使得中介者类很复杂难以维护</em></strong></p>
</blockquote>
<hr>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote>
<p><strong><em>享元模式是在一个程序需要创建大量的对象并且这些对象大多数的状态都可以是外部状态时就可以考虑使用享元模式，享元模式是通过对象生产工厂生产出来具有内部状态的对象，然后提供给不同用户赋予对象外部状态来使用，，这样避免了大量的创建对象而造成的占用大量的空间问题</em></strong></p>
</blockquote>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java】静态类型与实际类型</title>
    <url>/2020/07/02/%E3%80%90Java%E3%80%91%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>Java的静态类型与实际类型的相关问题，同时有助于理解Java中的转型问题 (๑´ڡ`๑)</strong></p>
<a id="more"></a>
<h2 id="代码观察"><a href="#代码观察" class="headerlink" title="代码观察"></a>代码观察</h2><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Father do it"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="title">extends</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"Son do it"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(Father father)</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"Father say Hi"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(Son son)</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"Son say Hi"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		Text t = <span class="keyword">new</span> Text();</span><br><span class="line">		Father f = <span class="keyword">new</span> Son();</span><br><span class="line">		f.doIt();</span><br><span class="line">		t.sayHi(f);</span><br><span class="line">		System.out.<span class="built_in">println</span>(f.getClass());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><blockquote>
<p>Son do it<br>Father say Hi<br>class Second.Text$Son</p>
</blockquote>
<h2 id="相关解释"><a href="#相关解释" class="headerlink" title="相关解释"></a>相关解释</h2><blockquote>
<p>在本段代码中Father f = new Son()实例化时<strong>Father为静态类型，Son为实际类型</strong>，并且<strong>静态类型在编译期间就是可知的，而实际类型要等到运行期间才可知</strong>，Son（）中的doIt（）方法重写了父类中的此方法，而最后执行结果是调用的子类的方法，这说明方法的<strong>重写是动态的</strong>，以此类推当f作为参数传入时是作为father这个静态类型传入的，因为结果调用的father的方法，这也说明了<strong>重载是静态的的</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】Executor框架</title>
    <url>/2020/07/15/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91Executor%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(九）Executor框架含简介/ThreadPoolExecutor详解/ScheduledThreadPoolExecutor详解/FutureTask详解</strong></p>
<a id="more"></a>
<h2 id="Executor框架简介"><a href="#Executor框架简介" class="headerlink" title="Executor框架简介"></a>Executor框架简介</h2><h3 id="Executor框架的两级调度模型"><a href="#Executor框架的两级调度模型" class="headerlink" title="Executor框架的两级调度模型"></a>Executor框架的两级调度模型</h3><p><img src="https://wx1.sbimg.cn/2020/07/14/CKcoU.png" alt="CKcoU.png"></p>
<p>在HotSpot VM的线程模型中，<strong>Java线程（java.lang.Thread）被一对一映射为本地操作系统线程</strong>。<strong>Java线程启动时会创建一个本地操作系统线程；当该Java线程终止时，这个操作系统线程 也会被回收</strong>。操作系统会调度所有线程并将它们分配给可用的CPU。<strong>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器 （Executor框架）将这些任务映射为固定数量的线程</strong>；<strong>在底层，操作系统内核将这些线程映射到硬件处理器上</strong>。从图中可以看出，应用程序通过Executor框架控制上层的调度；而下层的调度由操作系统内核控制，<strong>下层的调度不受应用程序的控制</strong>。</p>
<h3 id="Executor框架结构与成员"><a href="#Executor框架结构与成员" class="headerlink" title="Executor框架结构与成员"></a>Executor框架结构与成员</h3><h4 id="Executor框架结构"><a href="#Executor框架结构" class="headerlink" title="Executor框架结构"></a>Executor框架结构</h4><p><img src="https://wx2.sbimg.cn/2020/07/14/CKdqd.png" alt="CKdqd.png"></p>
<p>如图所示Executor框架主要由3大部分组成如下：</p>
<ul>
<li>任务：包括被执行任务需要实现的接口：Runnable接口或Callable接口。 </li>
<li>任务的执行：包括任务执行机制的核心接口Executor，以及继承自Executor的 ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口 （ThreadPoolExecutor和ScheduledThreadPoolExecutor）。</li>
<li>异步计算的结果。包括接口Future和实现Future接口的FutureTask类。Executor框架包含的主要的类与接口如图所示。下面是这些类和接口的简介：<blockquote>
<ul>
<li>Executor是一个接口，<strong>它是Executor框架的基础，它将任务的提交与任务的执行分离开</strong>。</li>
<li><strong>ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务</strong>。</li>
<li>ScheduledThreadPoolExecutor是一个实现类，<strong>可以在给定的延迟后运行命令，或者定期执行命令</strong>。ScheduledThreadPoolExecutor比Timer更灵活，功能更强大。</li>
<li>Future接口和实现Future接口的FutureTask类，<strong>代表异步计算的结果</strong>。</li>
<li>Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或Scheduled-ThreadPoolExecutor执行。</li>
</ul>
</blockquote>
</li>
</ul>
<p>如图所示Executor框架的使用示意图：</p>
<p><img src="https://wx1.sbimg.cn/2020/07/14/CKgN4.png" alt="CKgN4.png"></p>
<p><strong>主线程首先要创建实现Runnable或者Callable接口的任务对象</strong>。工具类Executors可以把一个Runnable对象封装为一个Callable对象（Executors.callable（Runnable task）或 Executors.callable（Runnable task，Object resule））。然后可以把Runnable对象直接交给ExecutorService执行（ExecutorService.execute（Runnable command））；或者也可以把Runnable对象或Callable对象提交给ExecutorService执行（Executor- Service.submit（Runnable task）或ExecutorService.submit（Callable<T>task））。 如果执行ExecutorService.submit（…），ExecutorService将返回一个实现Future接口的对象（到目前为止的JDK中，返回的是FutureTask对象）。由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</p>
<h4 id="Executor框架成员"><a href="#Executor框架成员" class="headerlink" title="Executor框架成员"></a>Executor框架成员</h4><p>Executor框架的主要成员：</p>
<ul>
<li>ThreadPoolExecutor</li>
<li>ScheduledThreadPoolExecutor </li>
<li>Future接口</li>
<li>Runnable接口</li>
<li>Callable接口</li>
<li>Executors。 </li>
</ul>
<h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><blockquote>
<p>ThreadPoolExecutor通常使用工厂类Executors来创建。<strong>Executors可以创建3种类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool和CachedThreadPool</strong>:</p>
<ul>
<li>FixedThreadPool:下面是Executors提供的，创建使用固定线程数的FixedThreadPool的 API:</li>
</ul>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads, ThreadFactorythreadFactory)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>FixedThreadPool适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器</strong>。</p>
<ul>
<li>SingleThreadExecutor。下面是Executors提供的，创建使用单个线程的SingleThread- Executor的API: </li>
</ul>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>(ThreadFactory threadFactory)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>SingleThreadExecutor适用于需要保证顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景</strong>。</p>
<ul>
<li>CachedThreadPool。下面是Executors提供的，创建一个会根据需要创建新线程的 CachedThreadPool的API:</li>
</ul>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>(ThreadFactory threadFactory)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>CachedThreadPool是大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器</strong>。</p>
</blockquote>
<h5 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h5><blockquote>
<p>ScheduledThreadPoolExecutor通常使用工厂类Executors来创建。Executors可以创建2种类型的ScheduledThreadPoolExecutor<br><strong>·ScheduledThreadPoolExecutor。包含若干个线程的ScheduledThreadPoolExecutor</strong>。<br><strong>·SingleThreadScheduledExecutor。只包含一个线程的ScheduledThreadPoolExecutor</strong>。 </p>
</blockquote>
<p>下面分别介绍这两种ScheduledThreadPoolExecutor：</p>
<blockquote>
<ul>
<li>下面是工厂类Executors提供的，创建固定个数线程的ScheduledThreadPoolExecutor的API:</li>
</ul>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static ScheduledExecutorService <span class="keyword">new</span><span class="constructor">ScheduledThreadPool(<span class="params">int</span> <span class="params">corePoolSize</span>)</span> </span><br><span class="line">public static ScheduledExecutorService <span class="keyword">new</span><span class="constructor">ScheduledThreadPool(<span class="params">int</span> <span class="params">corePoolSize</span>,ThreadFactory <span class="params">threadFactory</span>)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>ScheduledThreadPoolExecutor适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景</strong>。</p>
<ul>
<li>下面是Executors提供的，创建单个线程的SingleThreadScheduledExecutor的API：</li>
</ul>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="keyword">new</span><span class="type">SingleThreadScheduledExecutor</span>() </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="keyword">new</span><span class="type">SingleThreadScheduledExecutor</span> (ThreadFactory threadFactory)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>SingleThreadScheduledExecutor适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景</strong>。</p>
</blockquote>
<h5 id="future接口"><a href="#future接口" class="headerlink" title="future接口"></a>future接口</h5><p>Future接口和实现Future接口的FutureTask类用来表示异步计算的结果。当我们把Runnable接口或Callable接口的实现类提交（submit）给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduledThreadPoolExecutor会向我们返回一个FutureTask对象。下面是对应的API：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">T</span>&gt;</span> Future<span class="tag">&lt;<span class="name">T</span>&gt;</span> submit(Callable<span class="tag">&lt;<span class="name">T</span>&gt;</span> task) </span><br><span class="line"><span class="tag">&lt;<span class="name">T</span>&gt;</span> Future<span class="tag">&lt;<span class="name">T</span>&gt;</span> submit(Runnable task, T result) </span><br><span class="line">Future<span class="tag">&lt;&gt;</span> submit(Runnable task)</span><br></pre></td></tr></table></figure>

<h5 id="Runnable接口与Callable接口"><a href="#Runnable接口与Callable接口" class="headerlink" title="Runnable接口与Callable接口"></a>Runnable接口与Callable接口</h5><blockquote>
<p>Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或Scheduled- ThreadPoolExecutor执行。它们之间的<strong>区别是Runnable不会返回结果，而Callable可以返回结果</strong>。除了可以自己创建实现Callable接口的对象外，还可以使用工厂类Executors来把一个 Runnable包装成一个Callable。 下面是Executors提供的，把一个Runnable包装成一个Callable的API:</p>
</blockquote>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;<span class="keyword">Object</span>&gt; callable(Runnable task) </span><br><span class="line"><span class="comment">// 假设返回对象Callable1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>下面是Executors提供的，把一个Runnable和一个待返回的结果包装成一个Callable的API:</p>
</blockquote>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; callable(Runnable <span class="keyword">task</span>, T result) <span class="comment">// 假设返回对象Callable2</span></span><br></pre></td></tr></table></figure>

<p>当我们把一个Callable对象（比如上面的Callable1或Callable2）提交给 ThreadPoolExecutor或ScheduledThreadPoolExecutor执行时，submit（…）会向我们返回一个FutureTask对象。我们可以执行FutureTask.get()方法来等待任务执行完成。当任务成功完成后FutureTask.get()将返回该任务的结果。<strong>如果提交的是对象Callable1，FutureTask.get()方法将返回null；如果提交的是对象Callable2，FutureTask.get()方法将返回result对象</strong>。</p>
<h2 id="ThreadPoolExecutor详解"><a href="#ThreadPoolExecutor详解" class="headerlink" title="ThreadPoolExecutor详解"></a>ThreadPoolExecutor详解</h2><p>Executor框架最核心的类是ThreadPoolExecutor，它是线程池的实现类，主要由下列4个组件构成</p>
<ul>
<li>corePool：核心线程池的大小。</li>
<li>maximumPool：最大线程池的大小。</li>
<li>BlockingQueue：用来暂时保存任务的工作队列。</li>
<li>RejectedExecutionHandler：当ThreadPoolExecutor已经关闭或ThreadPoolExecutor已经饱和时（达到了最大线程池大小且工作队列已满），execute()方法将要调用Handler。 </li>
</ul>
<p>通过Executor框架的工具类Executors，可以创建3种类型的ThreadPoolExecutor：</p>
<ul>
<li>FixedThreadPool。</li>
<li>SingleThreadExecutor。</li>
<li>CachedThreadPool。</li>
</ul>
<h3 id="FixedThreadPool详解"><a href="#FixedThreadPool详解" class="headerlink" title="FixedThreadPool详解"></a>FixedThreadPool详解</h3><p><strong>FixedThreadPool被称为可重用固定线程数的线程池</strong>。下面是FixedThreadPool的源代码实现：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="number">0</span>L, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。*<em>当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止。这里把keepAliveTime设置为0L，意味着多余 *</em>。 </p>
<p>FixedThreadPool的execute()方法的运行示意图如图所示:</p>
<p><img src="https://wx2.sbimg.cn/2020/07/14/CKK0k.png" alt="CKK0k.png"></p>
<ul>
<li>如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。 &gt;- 在线程池完成预热之后（当前运行的线程数等于corePoolSize），将任务加入LinkedBlockingQueue。</li>
<li>线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行。<strong>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）</strong>。<strong>使用无界队列作为工作队列会对线程池带来如下影响</strong>:<blockquote>
<ul>
<li>当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。</li>
<li>由于1，使用无界队列时maximumPoolSize将是一个无效参数。</li>
<li>由于1和2，使用无界队列时keepAliveTime将是一个无效参数。</li>
<li>由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown()或shutdownNow()）不会拒绝任务（不会调用RejectedExecutionHandler.rejectedExecution方法）。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="SingleThreadExecutor详解"><a href="#SingleThreadExecutor详解" class="headerlink" title="SingleThreadExecutor详解"></a>SingleThreadExecutor详解</h3><p><strong>SingleThreadExecutor是使用单个worker线程的Executor</strong>。下面是SingleThreadExecutor的源代码实现： </p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span> (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>L, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SingleThreadExecutor的corePoolSize和maximumPoolSize被设置为1。其他参数与FixedThreadPool相同。<strong>SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。SingleThreadExecutor使用无界队列作为工作队列</strong>对线程池带来的影响与FixedThreadPool相同。</p>
<p>SingleThreadExecutor的运行示意图如图所示:<br><img src="https://wx1.sbimg.cn/2020/07/14/CKWsn.png" alt="CKWsn.png"></p>
<ul>
<li>如果当前运行的线程数少于corePoolSize（即线程池中无运行的线程），则创建一个新线程来执行任务。</li>
<li>在线程池完成预热之后（当前线程池中有一个运行的线程），将任务加入Linked-BlockingQueue。</li>
<li>线程执行完1中的任务后，会在一个无限循环中反复从LinkedBlockingQueue获取任务来执行。</li>
</ul>
<h3 id="CachedThreadPool详解"><a href="#CachedThreadPool详解" class="headerlink" title="CachedThreadPool详解"></a>CachedThreadPool详解</h3><p><strong>CachedThreadPool是一个会根据需要创建新线程的线程池</strong>。下面是创建CachedThread-Pool的源代码：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>L, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CachedThreadPool的corePoolSize被设置为0，即corePool为空；maximumPoolSize被设置为Integer.MAX_VALUE，即maximumPool是无界的。这里把keepAliveTime设置为60L，意味着CachedThreadPool中的空闲线程等待新任务的最长时间为60秒，空闲线程超过60秒后将会被终止。<strong>FixedThreadPool和SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的 工作队列</strong>。<strong>CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列</strong>，但CachedThreadPool的maximumPool是无界的。这意味着，如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU和内存资源。</p>
</blockquote>
<p>CachedThreadPool的execute()方法的执行示意图如图所示：<br><img src="https://wx2.sbimg.cn/2020/07/14/CKiTI.png" alt="CKiTI.png"></p>
<blockquote>
<ul>
<li>首先执行SynchronousQueue.offer（Runnable task）。如果当前maximumPool中有空闲线程正在执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS），那么主线程执行offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行，execute()方 法执行完成；否则执行下一步骤。</li>
<li>当初始maximumPool为空，或者maximumPool中当前没有空闲线程时，将没有线程执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS）。这种情况下，上一步骤将失败。此时CachedThreadPool会创建一个新线程执行任务，execute()方法执行完成。</li>
<li>在上一步骤中新创建的线程将任务执行完后，会执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS）。这个poll操作会让空闲线<br>程最多在SynchronousQueue中等待60秒钟。如果60秒钟内主线程提交了一个新任务（主线程执行步骤1）），那么这个空闲线程将执行主线程提交的新任务；否则，这个空闲线程将终止。由于空闲60秒的空闲线程会被终止，因此长时间保持空闲的CachedThreadPool不会使用任何资源。 </li>
</ul>
</blockquote>
<p><strong>SynchronousQueue是一个没有容量的阻塞队列。每个插入操作必须等待另一 个线程的对应移除操作，反之亦然</strong>。CachedThreadPool使用SynchronousQueue，把主线程提交的任务传递给空闲线程执行。CachedThreadPool中任务传递的示意图如图所示：<br><img src="https://wx1.sbimg.cn/2020/07/14/CKx3K.png" alt="CKx3K.png"></p>
<h2 id="ScheduledThreadPoolExecutor详解"><a href="#ScheduledThreadPoolExecutor详解" class="headerlink" title="ScheduledThreadPoolExecutor详解"></a>ScheduledThreadPoolExecutor详解</h2><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。<strong>它主要用来在给定的延迟之后运行任务，或者定期执行任务</strong>。ScheduledThreadPoolExecutor的功能与Timer类似，但ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而<strong>ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数</strong>。</p>
<h3 id="ScheduledThreadPoolExecutor运行机制"><a href="#ScheduledThreadPoolExecutor运行机制" class="headerlink" title="ScheduledThreadPoolExecutor运行机制"></a>ScheduledThreadPoolExecutor运行机制</h3><p>ScheduledThreadPoolExecutor的执行示意图（基于JDK 6）如图所示：</p>
<p><img src="https://wx1.sbimg.cn/2020/07/14/CWJlG.png" alt="CWJlG.png"></p>
<p>DelayQueue是一个无界队列，所以ThreadPoolExecutor的maximumPoolSize在Scheduled-ThreadPoolExecutor中没有什么意义。 </p>
<p>ScheduledThreadPoolExecutor的执行主要分为两大部分： </p>
<ul>
<li>当调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()方法或者scheduleWith-FixedDelay()方法时，会向ScheduledThreadPoolExecutor的DelayQueue添加一个实现了RunnableScheduledFutur接口的ScheduledFutureTask。</li>
<li>线程池中的线程从DelayQueue中获取ScheduledFutureTask，然后执行任务。</li>
</ul>
<p>ScheduledThreadPoolExecutor为了实现周期性的执行任务，对ThreadPoolExecutor做了如下的修改。</p>
<ul>
<li>使用DelayQueue作为任务队列。</li>
<li>获取任务的方式不同（见后文）。</li>
<li>执行周期任务后，增加了额外的处理（见后文）。</li>
</ul>
<h3 id="ScheduledThreadPoolExecutor的实现"><a href="#ScheduledThreadPoolExecutor的实现" class="headerlink" title="ScheduledThreadPoolExecutor的实现"></a>ScheduledThreadPoolExecutor的实现</h3><p>ScheduledThreadPoolExecutor会把待调度的任务（ScheduledFutureTask） 放到一个DelayQueue中。<strong>ScheduledFutureTask主要包含3个成员变量</strong>：</p>
<ul>
<li>long型成员变量time，表示这个任务将要被执行的具体时间。</li>
<li>long型成员变量sequenceNumber，表示这个任务被添加到ScheduledThreadPoolExecutor中的序号。</li>
<li>long型成员变量period，表示任务执行的间隔周期。 </li>
</ul>
<blockquote>
<p><strong>这个PriorityQueue会对队列中的Scheduled-FutureTask进行排序。排序时，time小的排在前面（时间早的任务将被先执行）。如果两个ScheduledFutureTask的time相同，就比较sequenceNumber，sequenceNumber小的排在前面</strong>首先，让我们看看ScheduledThreadPoolExecutor中的线程执行周期任务的过程。</p>
</blockquote>
<p>图是ScheduledThreadPoolExecutor中的线程1执行某个周期任务的4个步骤:<br><img src="https://wx2.sbimg.cn/2020/07/15/CZgNG.png" alt="CZgNG.png"></p>
<ul>
<li>线程1从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。到期任务是指ScheduledFutureTask的time大于等于当前时间。 </li>
<li>线程1执行这个ScheduledFutureTask。 </li>
<li>线程1修改ScheduledFutureTask的time变量为下次将要被执行的时间。 </li>
<li>线程1把这个修改time之后的ScheduledFutureTask放回DelayQueue中（Delay- Queue.add()）。 </li>
</ul>
<p>步骤1获取任务的过程。是DelayQueue.take()方法的源代码实现：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> throws InterruptedException </span>&#123; </span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 1 </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">            E first = q.<span class="built_in">peek</span>(); </span><br><span class="line">            <span class="keyword">if</span> (first == null) &#123; </span><br><span class="line">                <span class="built_in">available</span>.await(); <span class="comment">// 2.1 </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">long</span> <span class="built_in">delay</span> = first.getDelay(TimeUnit.NANOSECONDS); <span class="keyword">if</span> (<span class="built_in">delay</span> &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                    <span class="keyword">long</span> tl = <span class="built_in">available</span>.awaitNanos(<span class="built_in">delay</span>); <span class="comment">// 2.2 </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                    E x = q.poll(); <span class="comment">// 2.3.1 </span></span><br><span class="line">                    assert x != null; </span><br><span class="line">                    <span class="keyword">if</span> (q.<span class="built_in">size</span>() != <span class="number">0</span>) </span><br><span class="line">                        <span class="built_in">available</span>.signalAll(); <span class="comment">// 2.3.2 </span></span><br><span class="line">                        <span class="keyword">return</span> x; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">    &#125; finally &#123; </span><br><span class="line">        lock.unlock(); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://wx2.sbimg.cn/2020/07/15/CZJsw.png" alt="CZJsw.png"></p>
<p>步骤：</p>
<ul>
<li>获取Lock。 </li>
<li>获取周期任务。 <blockquote>
<ul>
<li>如果PriorityQueue为空，当前线程到Condition中等待；否则执行下面的2.2。 </li>
<li>如果PriorityQueue的头元素的time时间比当前时间大，到Condition中等待到time时间；否则执行下面的2.3。</li>
<li>获取PriorityQueue的头元素（2.3.1）；如果PriorityQueue不为空，则唤醒在Condition中等待的所有线程（2.3.2）。 </li>
</ul>
</blockquote>
</li>
<li>释放Lock。 ScheduledThreadPoolExecutor在一个循环中执行步骤2，直到线程从PriorityQueue获取到一个元素之后（执行2.3.1之后），才会退出无限循环（结束步骤2）。</li>
</ul>
<p>DelayQueue.add()的源代码实现:</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">offer</span>(<span class="params">E e</span>)</span> &#123; </span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>; </span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>(); <span class="comment">// 1 </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E first = q.peek();</span><br><span class="line">        q.offer(e); <span class="comment">// 2.1 </span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span> || e.compareTo(first) &lt; <span class="number">0</span>)</span><br><span class="line">            available.signalAll(); <span class="comment">// 2.2 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        ock.unlock(); <span class="comment">// 3 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://wx2.sbimg.cn/2020/07/15/CawYh.png" alt="CawYh.png"></p>
<p>步骤：</p>
<ul>
<li>获取Lock。 </li>
<li>添加任务。 <blockquote>
<ul>
<li>向PriorityQueue添加任务。</li>
<li>如果在上面2.1中添加的任务是PriorityQueue的头元素，唤醒在Condition中等待的所有线程。 </li>
</ul>
</blockquote>
</li>
<li>释放Lock。</li>
</ul>
<h2 id="FutureTask详解"><a href="#FutureTask详解" class="headerlink" title="FutureTask详解"></a>FutureTask详解</h2><p>Future接口和实现Future接口的FutureTask类，代表异步计算的结果。</p>
<h3 id="FutureTask简介"><a href="#FutureTask简介" class="headerlink" title="FutureTask简介"></a>FutureTask简介</h3><p>FutureTask除了实现Future接口外，还实现了Runnable接口。因此，<strong>FutureTask可以交给Executor执行，也可以由调用线程直接执行（FutureTask.run()）</strong>。根据FutureTask.run()方法被执行的时机，FutureTask可以处于下面3种状态：</p>
<ul>
<li>未启动。FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态。当创建一 个FutureTask，且没有执行FutureTask.run()方法之前，这个FutureTask处于未启动状态。</li>
<li>已启动。FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态。 </li>
<li>已完成。FutureTask.run()方法执行完后正常结束，或被取消（FutureTask.cancel（…）），或执行FutureTask.run()方法时抛出异常而异常结束，FutureTask处于已完成状态。</li>
</ul>
<p>FutureTask的状态迁移的示意图：<br><img src="https://wx1.sbimg.cn/2020/07/15/CazFM.png" alt="CazFM.png"></p>
<ul>
<li>当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞；</li>
<li>当FutureTask处于已完成状态时，执行FutureTask.get()方法将导致调用线程立即返回结果或抛出异常。执行FutureTask.cancel（…）方法将返回false </li>
<li>当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会被执行；</li>
<li>当FutureTask处于已启动状态时，执行FutureTask.cancel（true）方法将以中断执行此任务线程的方式来试图停止任务；执行FutureTask.cancel（false）方法将不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）； </li>
</ul>
<p>get方法和cancel方法的执行示意图：</p>
<h3 id="FutureTask的使用"><a href="#FutureTask的使用" class="headerlink" title="FutureTask的使用"></a>FutureTask的使用</h3><p>可以把FutureTask交给Executor执行；也可以通过ExecutorService.submit（…）方法返回一个FutureTask，然后执行FutureTask.get()方法或FutureTask.cancel（…）方法。除此以外，还可以单独使用FutureTask。<strong>当一个线程需要等待另一个线程把某个任务执行完后它才能继续执行，此时可以使用FutureTask。假设有多个线程执行若干任务，每个任务最多只能被执行一次。当多个线程试图 同时执行同一个任务时，只允许一个线程执行任务，其他线程需要等待这个任务执行完后才能继续执行</strong>。</p>
<p>对应的示例代码:</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;<span class="keyword">Object</span>, Future&lt;<span class="keyword">String</span>&gt;&gt; taskCache = <span class="keyword">new</span> ConcurrentHashMap&lt;<span class="keyword">Object</span>, Future&lt;<span class="keyword">String</span>&gt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">String</span> executionTask(<span class="keyword">final</span> <span class="keyword">String</span> taskName) <span class="keyword">throws</span> ExecutionException, InterruptedException &#123; </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">        Future&lt;<span class="keyword">String</span>&gt; future = taskCache.<span class="built_in">get</span>(taskName); <span class="comment">// 1.1,2.1 if (future == null) &#123; </span></span><br><span class="line">            Callable&lt;<span class="keyword">String</span>&gt; task = <span class="keyword">new</span> Callable&lt;<span class="keyword">String</span>&gt;() &#123; </span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">String</span> call() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">                    <span class="keyword">return</span> taskName; &#125; &#125;; <span class="comment">// 1.2创建任务</span></span><br><span class="line">                    FutureTask&lt;<span class="keyword">String</span>&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;<span class="keyword">String</span>&gt;(task); </span><br><span class="line">                    future = taskCache.putIfAbsent(taskName, futureTask); <span class="comment">// 1.3 </span></span><br><span class="line">                    <span class="keyword">if</span> (future == <span class="keyword">null</span>) &#123; </span><br><span class="line">                        future = futureTask; </span><br><span class="line">                        futureTask.run(); <span class="comment">// 1.4执行任务 </span></span><br><span class="line">                    &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> future.<span class="built_in">get</span>(); <span class="comment">// 1.5,2.2线程在此等待任务执行完成</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">        taskCache.remove(taskName, future); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示意图：<br><img src="https://wx2.sbimg.cn/2020/07/15/CaH9a.png" alt="CaH9a.png"></p>
<p>当两个线程试图同时执行同一个任务时，如果Thread 1执行1.3后Thread 2执行2.1，那么接下来Thread2将在2.2等待，直到Thread1执行完1.4后Thread 2才能从2.2（FutureTask.get()）返回。</p>
<h3 id="FutureTask的实现"><a href="#FutureTask的实现" class="headerlink" title="FutureTask的实现"></a>FutureTask的实现</h3><p>FutureTask的实现基于AbstractQueuedSynchronizer（AQS）。java.util.concurrent中的很多可阻塞类（比如ReentrantLock）都是基于AQS来实现的。AQS是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及维护被阻塞线程的队列。JDK6中AQS被广泛使用，基于AQS实现的同步器包括：ReentrantLock、Semaphore、ReentrantReadWriteLock、 CountDownLatch和FutureTask。每一个基于AQS实现的同步器都会包含两种类型的操作，如下：</p>
<ul>
<li><strong>至少一个acquire操作。这个操作阻塞调用线程，除非/直到AQS的状态允许这个线程继续执行。FutureTask的acquire操作为get()/get（long timeout，TimeUnit unit）方法调用</strong>。</li>
<li><strong>至少一个release操作。这个操作改变AQS的状态，改变后的状态可允许一个或多个阻塞 线程被解除阻塞。FutureTask的release操作包括run()方法和cancel（…）方法。</strong> </li>
</ul>
<p>基于“复合优先于继承”的原则，FutureTask声明了一个内部私有的继承于AQS的子类 Sync，对FutureTask所有公有方法的调用都会委托给这个内部子类。 AQS被作为“模板方法模式”的基础类提供给FutureTask的内部子类Sync，这个内部子类只 需要实现状态检查和状态更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具体来说，Sync实现了AQS的tryAcquireShared（int）方法和tryReleaseShared（int）方法，Sync通过这两个方法来检查和更新同步状态。<br>FutureTask的设计示意图如图所示：<br><img src="https://wx2.sbimg.cn/2020/07/15/CalrJ.png" alt="CalrJ.png"></p>
<p>如图所示，<strong>Sync是FutureTask的内部私有类，它继承自AQS</strong>。创建FutureTask时会创建内部私有的成员对象Sync，FutureTask所有的的公有方法都直接委托给了内部私有的Sync。FutureTask.get()方法会调用AQS.acquireSharedInterruptibly（int arg）方法，这个方法的执行过程如下：</p>
<ul>
<li>调用AQS.acquireSharedInterruptibly（int arg）方法，这个方法首先会回调在子类Sync中实现的tryAcquireShared()方法来判断acquire操作是否可以成功。acquire操作可以成功的条件为： state为执行完成状态RAN或已取消状态CANCELLED，且runner不为null。</li>
<li>如果成功则get()方法立即返回。如果失败则到线程等待队列中去等待其他线程执行release操作。</li>
<li>当其他线程执行release操作（比如FutureTask.run()或FutureTask.cancel（…））唤醒当前线程后，当前线程再次执行tryAcquireShared()将返回正值1，当前线程将离开线程等待队列并唤醒它的后继线程（这里会产生级联唤醒的效果）。</li>
<li>最后返回计算的结果或抛出异常。 </li>
</ul>
<p>FutureTask.run()的执行过程如下:</p>
<ul>
<li>执行在构造函数中指定的任务（Callable.call()）。</li>
<li>以原子方式来更新同步状态（调用AQS.compareAndSetState（int expect，int update），设置state为执行完成状态RAN）。如果这个原子操作成功，就设置代表计算结果的变量result的值为Callable.call()的返回值，然后调用AQS.releaseShared（int arg）。 </li>
<li>AQS.releaseShared（int arg）首先会回调在子类Sync中实现的tryReleaseShared（arg）来执行release操作（设置运行任务的线程runner为null，然会返回true）；AQS.releaseShared（int arg），然后唤醒线程等待队列中的第一个线程。</li>
<li>调用FutureTask.done()。 当执行FutureTask.get()方法时，如果FutureTask不是处于执行完成状态RAN或已取消状态 CANCELLED，当前执行线程将到AQS的线程等待队列中等待（见下图的线程A、B、C和D）。当某个线程执行FutureTask.run()方法或FutureTask.cancel（…）方法时，会唤醒线程等待队列的第一个线程（见图所示的线程E唤醒线程A）。</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/15/CaODm.png" alt="CaODm.png"></p>
<p>假设开始时FutureTask处于未启动状态或已启动状态，等待队列中已经有3个线程（A、B和 C）在等待。此时，线程D执行get()方法将导致线程D也到等待队列中去等待。 当线程E执行run()方法时，会唤醒队列中的第一个线程A。线程A被唤醒后，首先把自己从队列中删除，然后唤醒它的后继线程B，最后线程A从get()方法返回。线程B、C和D重复A线程的处理流程。最终，在队列中等待的所有线程都被级联唤醒并从get()方法返回。</p>
<p>参考：<br><strong>《Java并发编程的艺术》</strong></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】并发容器与框架</title>
    <url>/2020/07/10/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B8%8E%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(五）并发容器与框架含ConcurrentHashMap/ConcurrentLinkedQueue/阻塞队列/Fork/Join框架</strong></p>
<a id="more"></a>
<h2 id="ConcurrentHashMap的实现原理与使用"><a href="#ConcurrentHashMap的实现原理与使用" class="headerlink" title="ConcurrentHashMap的实现原理与使用"></a>ConcurrentHashMap的实现原理与使用</h2><p>线程不安全的HashMap：</p>
<blockquote>
<p>HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表 形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p>
</blockquote>
<p>效率低下的HashTable:</p>
<blockquote>
<p>为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同 步方法时，会进入阻塞或轮询状态。</p>
</blockquote>
<p>ConcurrentHashMap的锁分段技术:</p>
<blockquote>
<p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的 线程都必须竞争同一把锁，假如<strong>容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率</strong>，这就是ConcurrentHashMap所使用的<strong>锁分段技术</strong>。<strong>首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</strong>。</p>
</blockquote>
<h3 id="ConcurrentHashMap的结构"><a href="#ConcurrentHashMap的结构" class="headerlink" title="ConcurrentHashMap的结构"></a>ConcurrentHashMap的结构</h3><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重 入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里<strong>包含一个Segment数组</strong>。Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里<strong>包含一个HashEntry数组</strong>，每个HashEntry是一个链表结构的元 素，每个Segment守护着一个HashEntry数组里的元素，<strong>当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁</strong>，</p>
<p>类图如图所示：<br><img src="https://wx1.sbimg.cn/2020/07/10/Cck4h.png" alt="Cck4h.png"><br>结构如图所示：<br><img src="https://wx1.sbimg.cn/2020/07/10/Cc2Ha.png" alt="Cc2Ha.png"></p>
<h3 id="ConcurrentHashMap的初始化"><a href="#ConcurrentHashMap的初始化" class="headerlink" title="ConcurrentHashMap的初始化"></a>ConcurrentHashMap的初始化</h3><p>ConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的 HashEntry数组来实现的。</p>
<h4 id="初始化segments数组"><a href="#初始化segments数组" class="headerlink" title="初始化segments数组"></a>初始化segments数组</h4><p>源码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS) </span><br><span class="line">    concurrencyLevel = MAX_SEGMENTS; </span><br><span class="line"><span class="built_in">int</span> sshift = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">int</span> ssize = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift; </span><br><span class="line">    size &lt;&lt;= <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">segmentShift = <span class="number">32</span> - sshift; </span><br><span class="line">segmentMask = ssize - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br></pre></td></tr></table></figure>
<p>由上面的代码可知，segments数组的长度ssize是通过concurrencyLevel计算得出的。为了能 通过按位与的散列算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方），所以必须计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。<strong>假如concurrencyLevel等于14、15或16，ssize都会等于16，即容器里锁的个数也是16。concurrencyLevel的最大值是65535，这意味着segments数组的长度最大为65536， 对应的二进制是16位。</strong></p>
<h4 id="初始化segmentShift和segmentMask"><a href="#初始化segmentShift和segmentMask" class="headerlink" title="初始化segmentShift和segmentMask"></a>初始化segmentShift和segmentMask</h4><p><strong>这两个全局变量需要在定位segment时的散列算法里使用</strong>，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。segmentShift用于定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是散列运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p>
<h4 id="初始化每个segment"><a href="#初始化每个segment" class="headerlink" title="初始化每个segment"></a>初始化每个segment</h4><p>输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个segment。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY; </span><br><span class="line"><span class="built_in">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity) </span><br><span class="line">    ++c; </span><br><span class="line"><span class="built_in">int</span> cap = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span> (cap &lt; c) </span><br><span class="line">    cap &lt;&lt;= <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i) </span><br><span class="line">    <span class="keyword">this</span>.segments[i] = new Segment&lt;K,V&gt;(cap, loadFactor);</span><br></pre></td></tr></table></figure>
<p>上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝（int）cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。</p>
<h3 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h3><p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，<strong>那么在插入和获取元素的时候，必须先通过散列算法定位到Segment</strong>。可以看到ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode进行一次再散列。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="built_in">int</span> hash(<span class="built_in">int</span> h) &#123; </span><br><span class="line">    h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>; </span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">6</span>); </span><br><span class="line">    h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>); </span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>之所以进行再散列，目的是减少散列冲突，使元素能够均匀地分布在不同的Segment上， 从而提高容器的存取效率</strong> <strong>如果不进行再散列，散列冲突会非 常严重，因为只要低位一样，无论高位是什么数，其散列值总是一样。</strong></p>
<p>ConcurrentHashMap通过以下散列算法定位segment:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下segmentShift为28，segmentMask为15，再散列后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到散列运算中，（hash&gt;&gt;&gt;segmentShift）&amp;segmentMask的运算结果分别是4、15、7和8，可以看到散列值没有发生冲突。</p>
<h3 id="ConcurrentHashMap的操作"><a href="#ConcurrentHashMap的操作" class="headerlink" title="ConcurrentHashMap的操作"></a>ConcurrentHashMap的操作</h3><h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><p>Segment的get操作实现非常简单和高效。<strong>先经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素</strong>，代码如下：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123; </span><br><span class="line">    <span class="built_in">int</span> hash = hash(<span class="built_in">key</span>.hashCode()); </span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).<span class="built_in">get</span>(<span class="built_in">key</span>, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空才会加锁重读。原因是它的get方法里将要使用的共享变量都定义成volatile类型</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">hash &gt;&gt;&gt; segmentShift) &amp; segmentMask </span><br><span class="line"><span class="comment">// 定位Segment所使用的hash算法 </span></span><br><span class="line"><span class="type">int</span> <span class="keyword">index</span> = hash &amp; (tab.<span class="built_in">length</span> - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//定位HashEntry所使用的hash算法</span></span><br></pre></td></tr></table></figure>
<p>在定位元素的代码里我们可以发现，定位HashEntry和定位Segment的散列算法虽然一样， 都与数组的长度减去1再相“与”，但是相“与”的值不一样，<strong>定位Segment使用的是元素的hashcode通过再散列后得到的值的高位</strong>，而定位HashEntry直接使用的是再散列后的值。其目的是避免两次散列后的值一样，虽然元素在Segment里散列开了，但是却没有在HashEntry里散列开。</p>
<h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必 须加锁。put方法首先定位到Segment，然后在Segment里进行插入操作。<strong>插入操作需要经历两个步骤</strong>:</p>
<blockquote>
<ul>
<li>第一步判断是否需要对Segment里的HashEntry数组进行扩容：在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阈值，则对数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。在扩容的时候，首先会创建一个容量是原来容量两倍的数组，然后将原数组里的元素进行再散列后插入到新的数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而只 对某个segment进行扩容。</li>
<li>第二步定位添加元素的位置，然后将其放在HashEntry数组里</li>
</ul>
</blockquote>
<h4 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h4><p>因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以 ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>在并发编程中，有时候需要使用线程安全的队列。如果要实现一个线程安全的队列有两种方式：</p>
<blockquote>
<ul>
<li>一种是使用阻塞算法，</li>
<li>另一种是使用非阻塞算法。</li>
</ul>
</blockquote>
<p><strong>使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。非阻塞的实现方式则可以使用循环CAS了“wait-free”算法的方式来实现。</strong></p>
<p><strong>类图结构：</strong><br><img src="https://wx1.sbimg.cn/2020/07/10/CdjwR.png" alt="CdjwR.png"></p>
<h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><h4 id="入队列过程"><a href="#入队列过程" class="headerlink" title="入队列过程"></a>入队列过程</h4><p>注意的：如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点</p>
<p>多个线程同时进行入队的情况就变得更加复杂了，因为可能会出现其他线程插队的情况。如果有一个线程正在入队，那么它必须先获取尾节点，然后设置尾节点的下一个节点为入队节点，但这时可能有另外一个线程插队了，那么队列的尾节点就会发生变化，这时当前线程要暂停入队操作，然后重新获取尾节点。整个入队过程主要做两件事情：第一是定位出尾节点；第二是使用 CAS算法将入队节点设置成尾节点的next节点，如不成功则重试。</p>
<h4 id="定位尾结点"><a href="#定位尾结点" class="headerlink" title="定位尾结点"></a>定位尾结点</h4><p>tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点。尾节点可能 是tail节点，也可能是tail节点的next节点。获取tail节点的next节点需要注意的是<strong>p节点等于p的next节点</strong>的情况，只有一种可能就是<strong>p节点和p的next节点都等于空</strong>，表示这个队列刚初始化，正准备添加节点，所以需要返回head节点。</p>
<h4 id="设置入队节点为尾节点"><a href="#设置入队节点为尾节点" class="headerlink" title="设置入队节点为尾节点"></a>设置入队节点为尾节点</h4><p>p.casNext（null，n）方法用于将入队节点设置为当前队列尾节点的next节点，如果p是null，表示p是当前队列的尾节点，如果不为null，表示有其他线程更新了尾节点，则需要重新获取当 前队列的尾节点。</p>
<h4 id="HOPS的设计意图"><a href="#HOPS的设计意图" class="headerlink" title="HOPS的设计意图"></a>HOPS的设计意图</h4><blockquote>
<p>用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将tail节点更新成尾节点，而是当tail节点和尾节点的距离大于等于常量 HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长，使用CAS更新tail节点的次数就会越少，但是<strong>距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来看它通过增加对volatile变量的读操作来减少对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升</strong>。<strong>入队方法永远返回true，所以不要通过返回值判断入队是否成功。</strong></p>
</blockquote>
<h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><p>并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点。这种做法也是通过hops变量来减少使用CAS更新head节点的消耗，从而提高出队效率。</p>
<h2 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h2><h3 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法：</p>
<blockquote>
<ul>
<li><strong>支持阻塞的插入方法</strong>：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>
<li><strong>支持阻塞的移除方法</strong>：意思是在队列为空时，获取元素的线程会等待队列变为非空。 </li>
</ul>
</blockquote>
<p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。在阻塞队列不可用时，这两个附加操作提供了4种处理方式，如表所示:<br><img src="https://wx2.sbimg.cn/2020/07/10/ChQUj.png" alt="ChQUj.png"></p>
<blockquote>
<ul>
<li>抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queue full”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</li>
<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。 </li>
<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</li>
<li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</li>
</ul>
</blockquote>
<p>这两个附加操作的4种处理方式不方便记忆，所以我找了一下这几个方法的规律。<strong>put和take分别尾首含有字母t，offer和poll都含有字母o</strong>。 <strong>注意如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且使用offer方法时，该方法永远返回true</strong>。</p>
<h3 id="Java里的阻塞队列"><a href="#Java里的阻塞队列" class="headerlink" title="Java里的阻塞队列"></a>Java里的阻塞队列</h3><p>JDK 7提供了7个阻塞队列，如下。</p>
<blockquote>
<ul>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列:是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列;</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列:一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列:一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列:一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列:一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。 它支持公平访问队列。默认情况下线程采用非公平性策略访问队列.</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列:一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列:一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、 addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双 端队列的最后一个元素。</li>
</ul>
</blockquote>
<h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><p>一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<p>运行流程如图所示:<br><img src="https://wx1.sbimg.cn/2020/07/10/Ch1UT.png" alt="Ch1UT.png"></p>
<h3 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h3><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行</p>
<p>工作窃取的运行流程如图所示：<br><img src="https://wx2.sbimg.cn/2020/07/10/ChwKl.png" alt="ChwKl.png"></p>
<blockquote>
<ul>
<li>工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。</li>
<li>工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</li>
</ul>
</blockquote>
<h3 id="Fork-Join框架的设计"><a href="#Fork-Join框架的设计" class="headerlink" title="Fork/Join框架的设计"></a>Fork/Join框架的设计</h3><blockquote>
<ul>
<li><strong>步骤1 分割任务</strong>:首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。 </li>
<li><strong>步骤2 执行任务并合并结果</strong>。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</li>
</ul>
</blockquote>
<p>Fork/Join使用两个类来完成以上两件事情:</p>
<blockquote>
<ul>
<li>ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制。通常情况下，我们不需要直接继承ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了以下两个子类。 ·RecursiveAction：用于没有返回结果的任务。 ·RecursiveTask：用于有返回结果的任务。</li>
<li>ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行。任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</li>
</ul>
</blockquote>
<h3 id="使用Fork-Join框架"><a href="#使用Fork-Join框架" class="headerlink" title="使用Fork/Join框架"></a>使用Fork/Join框架</h3><p>一个简单的需求来使用Fork/Join框架，需求是：计算1+2+3+4的结果。 使用Fork/Join框架首先要考虑到的是如何分割任务，如果希望每个子任务最多执行两个 数的相加，那么我们设置分割的阈值是2，由于是4个数字相加，所以Fork/Join框架会把这个任务fork成两个子任务，子任务一负责计算1+2，子任务二负责计算3+4，然后再join两个子任务的结果。因为是有结果的任务，所以必须继承RecursiveTask，实现代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="title">extends</span> <span class="title">RecursiveTask</span>&lt;Integer&gt; &#123;</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>; <span class="comment">// 阈值 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="built_in">end</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.start = start; </span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">end</span> = <span class="built_in">end</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 如果任务足够小就计算任务 </span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (<span class="built_in">end</span> - start) &lt;= THRESHOLD; </span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; i++) &#123; </span><br><span class="line">                sum += i;</span><br><span class="line">                &#125; </span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算 </span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle); CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, <span class="built_in">end</span>); <span class="comment">// 执行子任务 </span></span><br><span class="line">            leftTask.fork(); </span><br><span class="line">            rightTask.fork(); </span><br><span class="line">            <span class="comment">// 等待子任务执行完，并得到其结果 int leftResult=leftTask.join(); </span></span><br><span class="line">            <span class="keyword">int</span> rightResult=rightTask.join(); </span><br><span class="line">            <span class="comment">// 合并子任务 </span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    <span class="comment">// 生成一个计算任务，负责计算1+2+3+4 </span></span><br><span class="line">    CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>); </span><br><span class="line">    <span class="comment">// 执行一个任务 Future&lt;Integer&gt; result = forkJoinPool.submit(task); </span></span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        System.out.<span class="built_in">println</span>(result.<span class="built_in">get</span>()); </span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123; </span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fork-Join框架的异常处理"><a href="#Fork-Join框架的异常处理" class="headerlink" title="Fork/Join框架的异常处理"></a>Fork/Join框架的异常处理</h3><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(task.is<span class="constructor">CompletedAbnormally()</span>) &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(task.get<span class="constructor">Exception()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p>
<p>参考：<br><strong>《Java并发编程的艺术》</strong></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】并发工具类</title>
    <url>/2020/07/12/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(七）并发工具类含等待多线程完成的CountDownLatch/同步屏障CyclicBarrier/控制并发线程数的Semaphore/线程间交换数据的Exchanger</strong></p>
<a id="more"></a>

<p>在JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和 Semaphore工具类提供了一种并发流程控制的手段，Exchanger工具类则提供了在线程间交换数 据的一种手段。</p>
<h2 id="等待多线程完成的CountDownLatch"><a href="#等待多线程完成的CountDownLatch" class="headerlink" title="等待多线程完成的CountDownLatch"></a>等待多线程完成的CountDownLatch</h2><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JoinCountDownLatchTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">				System.<span class="keyword">out</span>.println(<span class="string">"thread1 finish"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">				System.<span class="keyword">out</span>.println(<span class="string">"thread2 finish"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		thread1.start();</span><br><span class="line">		thread2.start();</span><br><span class="line">		thread1.<span class="keyword">join</span>();</span><br><span class="line">		thread2.<span class="keyword">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">thread1</span> <span class="string">finish</span></span><br><span class="line"><span class="attr">thread2</span> <span class="string">finish</span></span><br></pre></td></tr></table></figure>
<p><strong>join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远等待</strong>。其中，wait（0）表示永远等待下去。直到join线程中止后，线程的this.notifyAll()方法会被调用，调用notifyAll()方法是在JVM里实现的，在JDK1.5之后的并发包中提供的CountDownLatch也可以实现join的功能，并且比join的功能更多，如代码所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> CountDownLatch cdl = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="number">1</span>);</span><br><span class="line">				cdl.countDown();</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="number">2</span>);</span><br><span class="line">				cdl.countDown();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		cdl.await();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>CountDownLatch的构造函数接收一个int类型的参数作为计数器，<strong>如果你想等待N个点完成，这里就传入N</strong>。<strong>当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零</strong>。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个 CountDownLatch的引用传递到线程里即可。如果有某个解析sheet的线程处理得比较慢，我们不可能让主线程一直等待，所以可以使用另外一个带指定时间的await方法——await（long time，TimeUnit unit），这个方法等待特定时 间后，就会不再阻塞当前线程。join也有类似的方法。<br><strong>CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值</strong>。一个线程调用countDown方法happen-before，另外一个线程调用await方法。</p>
<h2 id="同步屏障CyclicBarrier"><a href="#同步屏障CyclicBarrier" class="headerlink" title="同步屏障CyclicBarrier"></a>同步屏障CyclicBarrier</h2><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：<strong>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</strong></p>
<h3 id="CyclicBarrier简介"><a href="#CyclicBarrier简介" class="headerlink" title="CyclicBarrier简介"></a>CyclicBarrier简介</h3><p>CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。示例代码所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					c.await();</span><br><span class="line">				&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			c.await();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>还有可能输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>因为主线程和子线程的调度是由CPU决定的，两个线程都有可能先执行，所以会产生两种输出.如果把new CyclicBarrier(2)修改成new CyclicBarrier(3)，则<strong>主线程和子线程会永远等待，因为没有第三个线程执行await方法，即没有第三个线程到达屏障</strong>，<strong>所以之前到达屏障的两个 线程都不会继续执行</strong>。</p>
<p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrier-Action），用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景，如代码所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> A());</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					c.await();</span><br><span class="line">				&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			c.await();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="number">3</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>因为CyclicBarrier设置了拦截线程的数量是2，所以必须等代码中的第一个线程和线程A都执行完之后，才会继续执行主线程，然后输出2</strong></p>
<h3 id="CyclicBarrier的应用场景"><a href="#CyclicBarrier的应用场景" class="headerlink" title="CyclicBarrier的应用场景"></a>CyclicBarrier的应用场景</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankWaterService</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span> </span><br><span class="line"><span class="comment">//创建4个屏障，处理完之后执行当前类的run方法</span></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, <span class="keyword">this</span>); </span><br><span class="line">    <span class="comment">//假设只有4个sheet，所以只启动4个线程 </span></span><br><span class="line">    <span class="keyword">private</span> Executor executor = Executors.newFixedThreadPool(<span class="number">4</span>); <span class="comment">//保存每个sheet计算出的银流结果</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;<span class="keyword">String</span>, Integer&gt;sheetBankWaterCount = <span class="keyword">new</span> ConcurrentHashMap&lt;<span class="keyword">String</span>, Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (inti = <span class="number">0</span>; i&lt; <span class="number">4</span>; i++) &#123; </span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">                publicvoid <span class="built_in">run</span>() &#123; </span><br><span class="line">                <span class="comment">// 计算当前sheet的银流数据，计算代码省略 sheetBankWaterCount.put(Thread.currentThread().getName(), 1); </span></span><br><span class="line">                <span class="comment">// 银流计算完成，插入一个屏障 </span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await(); </span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;);</span><br><span class="line">            &#125; </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        intresult = <span class="number">0</span>; <span class="comment">// 汇总每个sheet计算出的结果</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;<span class="keyword">String</span>, Integer&gt;sheet : sheetBankWaterCount.entrySet()) &#123; </span><br><span class="line">            result += sheet.getValue(); </span><br><span class="line">        &#125;<span class="comment">// 将结果输出</span></span><br><span class="line">        sheetBankWaterCount.<span class="built_in">put</span>(<span class="string">"result"</span>, result); System.out.<span class="built_in">println</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line">    BankWaterService bankWaterCount = <span class="keyword">new</span> BankWaterService(); bankWaterCount.count(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>使用线程池创建4个线程，分别计算每个sheet里的数据，每个sheet计算结果是1，再由BankWaterService线程汇总4个sheet计算出的结果。</p>
<h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><p><strong>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。</strong>例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。代码执行完之后会返回true，其中isBroken的使用代码如代码所示：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">importjava.util.concurrent.BrokenBarrierException; importjava.util.concurrent.CyclicBarrier; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CyclicBarrierTest3</span> &#123; </span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException， BrokenBarrierException</span> &#123; </span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c.<span class="keyword">await</span>(); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">    thread.start(); </span><br><span class="line">    thread.interrupt(); </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">    c.<span class="keyword">await</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(c.isBroken());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="控制并发线程数的Semaphore"><a href="#控制并发线程数的Semaphore" class="headerlink" title="控制并发线程数的Semaphore"></a>控制并发线程数的Semaphore</h2><p><strong>Semaphore（信号量）是用来控制同时访问特定资源的线程数量</strong>，它通过协调各个线程，以保证合理的使用公共资源。</p>
<p>Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制，如代码所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> &#123;</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorServicethreadPool = Executors.newFixedThreadPool(THREAD_COUNT); </span><br><span class="line">    <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (inti = <span class="number">0</span>; i&lt; THREAD_COUNT; i++) &#123; threadPool.execute(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123; </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s.acquire();</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"save data"</span>); </span><br><span class="line">                    s.<span class="built_in">release</span>(); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">        &#125; </span><br><span class="line">        threadPool.<span class="built_in">shutdown</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore（10）表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p>
<h3 id="2-其他方法"><a href="#2-其他方法" class="headerlink" title="2.其他方法"></a>2.其他方法</h3><p>Semaphore还提供一些其他方法，具体如下:</p>
<ul>
<li>intavailablePermits()：返回此信号量中当前可用的许可证数。</li>
<li>intgetQueueLength()：返回正在等待获取许可证的线程数。</li>
<li>booleanhasQueuedThreads()：是否有线程正在等待获取许可证。 </li>
<li>void reducePermits（int reduction）：减少reduction个许可证，是个protected方法。 </li>
<li>Collection getQueuedThreads()：返回所有等待获取许可证的线程集合，是个protected方法。</li>
</ul>
<h2 id="线程间交换数据的Exchanger"><a href="#线程间交换数据的Exchanger" class="headerlink" title="线程间交换数据的Exchanger"></a>线程间交换数据的Exchanger</h2><p>Exchanger（交换者）是一个<strong>用于线程间协作的工具类</strong>。<strong>Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据</strong>。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产 出来的数据传递给对方。 下面来看一下Exchanger的应用场景:</p>
<p>Exchanger可以用于<strong>遗传算法</strong>，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致，如代码所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> &#123;</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;<span class="keyword">String</span>&gt;exgr = <span class="keyword">new</span> Exchanger&lt;<span class="keyword">String</span>&gt;(); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorServicethreadPool = Executors.newFixedThreadPool(<span class="number">2</span>); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123; </span><br><span class="line">                <span class="keyword">try</span> &#123; </span><br><span class="line">                    <span class="keyword">String</span> A = <span class="string">"银行流水A"</span>; <span class="comment">// A录入银行流水数据</span></span><br><span class="line">                    exgr.exchange(A);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;); </span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123; </span><br><span class="line">                <span class="keyword">try</span> &#123; </span><br><span class="line">                    <span class="keyword">String</span> B = <span class="string">"银行流水B"</span>; <span class="comment">// B录入银行流水数据</span></span><br><span class="line">                    <span class="keyword">String</span> A = exgr.exchange(<span class="string">"B"</span>); System.out.<span class="built_in">println</span>(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span></span><br><span class="line">+ A + <span class="string">"，B录入是："</span> + B); </span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">                &#125; </span><br><span class="line">        &#125;); </span><br><span class="line">        threadPool.<span class="built_in">shutdown</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="keyword">A</span>和B数据是否一致：false，<span class="keyword">A</span>录入的是：银行流水<span class="keyword">A</span>，B录入是：银行流水B</span><br></pre></td></tr></table></figure>
<p>如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长。</p>
<p>参考：<br><strong>《Java并发编程的艺术》</strong></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】原子操作类</title>
    <url>/2020/07/11/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(六）原子操作类含原子更新基本类类型/更新数组/更新引用类型/更新字段类</strong></p>
<a id="more"></a>
<h2 id="原子更新基本类类型"><a href="#原子更新基本类类型" class="headerlink" title="原子更新基本类类型"></a>原子更新基本类类型</h2><p>使用原子的方式更新基本类型，Atomic包提供了以下3个类：</p>
<blockquote>
<ul>
<li>AtomicBoolean：原子更新布尔类型。 </li>
<li>AtomicInteger：原子更新整型。 </li>
<li>AtomicLong：原子更新长整型。 </li>
</ul>
</blockquote>
<p>以上3个类提供的方法几乎一模一样，所以以AtomicInteger为例进行讲解， AtomicInteger的常用方法如下:</p>
<blockquote>
<ul>
<li>int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的 value）相加，并返回结果。 </li>
<li>boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方 式将该值设置为输入的值。 </li>
<li>int getAndIncrement()：以原子方式将当前值加1，注意，<strong>这里返回的是自增前的值</strong>。 </li>
<li>void lazySet（int newValue）：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</li>
<li>int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。</li>
</ul>
</blockquote>
<p>AtomicInteger示例代码如代码所示:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(ai.getAndIncrement());</span><br><span class="line">		System.out.<span class="built_in">println</span>(ai.<span class="built_in">get</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>getAndIncrement实现原子操作的源码代码:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> final <span class="type">int</span> getAndIncrement() &#123; </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        <span class="type">int</span> <span class="keyword">current</span> = <span class="keyword">get</span>(); </span><br><span class="line">        <span class="type">int</span> next = <span class="keyword">current</span> + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(<span class="keyword">current</span>, next)) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">current</span>;</span><br><span class="line">            &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">public</span> final <span class="type">boolean</span> compareAndSet(<span class="type">int</span> expect, <span class="type">int</span> <span class="keyword">update</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(this, valueOffset, expect, <span class="keyword">update</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码中for循环体的第一步先取得AtomicInteger里存储的数值<br>第二步对AtomicInteger的当前数值进行加1操作，<br>关键的第三步调用compareAndSet方法来进行原子更新操作,该方法先检查当前数值是否等于current，等于意味着AtomicInteger的值没有被其他线程修改过，则将 AtomicInteger的当前数值更新成next的值，如果不等compareAndSet方法会返回false，程序会进入for循环重新进行compareAndSet操作。 </p>
<p>Atomic包提供了3种基本类型的原子更新，但是Java的基本类型里还有char、float和double等。Atomic包里的类基本都是使用Unsafe实现的，Unsafe的源码代码:</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果当前数值是expected，则原子的将Java变量更新成x </span></span><br><span class="line"><span class="comment">    * @return 如果更新成功则返回true </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="built_in">boolean</span> compareAndSwapObject(<span class="keyword">Object</span> o, <span class="keyword">long</span> offset, <span class="keyword">Object</span> expected, <span class="keyword">Object</span> x); </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="built_in">boolean</span> compareAndSwapInt(<span class="keyword">Object</span> o, <span class="keyword">long</span> offset, <span class="built_in">int</span> expected, <span class="built_in">int</span> x); </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="built_in">boolean</span> compareAndSwapLong(<span class="keyword">Object</span> o, <span class="keyword">long</span> offset, <span class="keyword">long</span> expected, <span class="keyword">long</span> x);</span><br></pre></td></tr></table></figure>
<p>Unsafe只提供了3种CAS方法：</p>
<blockquote>
<ul>
<li>compareAndSwapObject</li>
<li>compare- AndSwapInt</li>
<li>compareAndSwapLong，</li>
</ul>
</blockquote>
<p>再看AtomicBoolean源码，发现它是<strong>先把Boolean转换成整型，再使用compareAndSwapInt进行CAS</strong>，所以<strong>原子更新char、float和double变量也可以用类似 的思路来实现</strong>。</p>
<h2 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h2><p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下4个类：</p>
<blockquote>
<ul>
<li>AtomicIntegerArray：原子更新整型数组里的元素。</li>
<li>AtomicLongArray：原子更新长整型数组里的元素。</li>
<li>AtomicReferenceArray：原子更新引用类型数组里的元素</li>
</ul>
</blockquote>
<p>AtomicIntegerArray类主要是提供原子的方式更新数组里的整型，其常用方法如下: </p>
<blockquote>
<ul>
<li>int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。 </li>
<li>boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。 </li>
</ul>
</blockquote>
<p>以上几个类提供的方法几乎一样，所以仅以AtomicIntegerArray为例, AtomicIntegerArray的使用实例代码:</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AtomicIntegerArrayTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>[] <span class="keyword">value</span> = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="keyword">static</span> AtomicIntegerArray aia = <span class="keyword">new</span> AtomicIntegerArray(<span class="keyword">value</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		aia.getAndSet(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">		System.<span class="keyword">out</span>.println(aia.<span class="keyword">get</span>(<span class="number">0</span>));</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="keyword">value</span>[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<strong>数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组</strong>。</p>
<h2 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h2><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类：</p>
<blockquote>
<ul>
<li>AtomicReference：原子更新引用类型。</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li>
<li>AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，boolean initialMark）。 </li>
</ul>
</blockquote>
<p>以上几个类提供的方法几乎一样，所以仅以AtomicReference为例, AtomicReference的使用示例代码如代码:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> AtomicReference&lt;User&gt;  ar= <span class="keyword">new</span> AtomicReference&lt;User&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		User user = <span class="keyword">new</span> User(<span class="string">"Easonhe"</span>, <span class="number">22</span>);</span><br><span class="line">		ar.<span class="built_in">set</span>(user);</span><br><span class="line">		User update = <span class="keyword">new</span> User(<span class="string">"老贺"</span>, <span class="number">28</span>);</span><br><span class="line">		ar.compareAndSet(user, update);</span><br><span class="line">		System.out.<span class="built_in">println</span>(ar.<span class="built_in">get</span>().getName()+<span class="string">" "</span>+ar.<span class="built_in">get</span>().getAge());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>&#123;</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">String</span> name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">			<span class="keyword">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">老贺 <span class="number">28</span></span><br></pre></td></tr></table></figure>

<h2 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h2><p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新：</p>
<blockquote>
<ul>
<li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。 </li>
</ul>
</blockquote>
<p>要想原子地更新字段类需要两步:</p>
<blockquote>
<ul>
<li>第一步:因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</li>
<li><strong>第二步:更新类的字段（属性）必须使用public volatile修饰符</strong>。</li>
</ul>
</blockquote>
<p>以上3个类提供的方法几乎一样，所以仅以AstomicIntegerFieldUpdater为例进行讲解，AstomicIntegerFieldUpdater的示例代码如代码所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; aifu = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">"age"</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		User easonhe = <span class="keyword">new</span> User(<span class="string">"easonhe"</span>, <span class="number">20</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(aifu.getAndIncrement(easonhe));</span><br><span class="line">		System.out.<span class="built_in">println</span>(aifu.<span class="built_in">get</span>(easonhe));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>&#123;</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">String</span> name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">			<span class="keyword">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是更新字段类的第二步！！！</p>
<p>参考：<br><strong>《Java并发编程艺术》</strong></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】Java内存模型（上）</title>
    <url>/2020/07/06/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(一）内存模型（上）含Java内存模型基础/重排序/顺序一致性/volatile内存语义/锁的内存语义</strong></p>
<a id="more"></a>

<h2 id="内存模型基础"><a href="#内存模型基础" class="headerlink" title="内存模型基础"></a>内存模型基础</h2><h3 id="并发编程模型的两个关键问题"><a href="#并发编程模型的两个关键问题" class="headerlink" title="并发编程模型的两个关键问题"></a>并发编程模型的两个关键问题</h3><ol>
<li>线程之间如何通信？<blockquote>
<p>通信是指线程之间以何种机制来交换信息。在命令式编程 中，线程之间有两种通信机制：共享内存和消息传递   </p>
<ul>
<li>共享内存的并发模型：线程之间共享程序的公共状态，通过写-读内存中的公共状态进行<strong>隐式通信</strong>；</li>
<li>消息传递的并发模型：线程之间没有公共状态，线程之间必须通过发送消 息来进行<strong>显式通信</strong>。</li>
</ul>
</blockquote>
</li>
<li>线程之间如何同步？<blockquote>
<p>同步是指程序中用于控制不同线程间操作发生相对顺序的机制</p>
<ul>
<li>共享内存的并发模型：<strong>同步是显式进行</strong>的，程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行；</li>
<li>消息传递的并发模型：由于消息的发送必须在消息的接收之前，因此<strong>同步是隐式进行</strong>的。</li>
</ul>
</blockquote>
</li>
</ol>
<p>3.Java并发采用的机制</p>
<blockquote>
<p><strong>Java的并发</strong>采用的是<strong>共享内存模型</strong>，Java线程之间的通信总是隐式进行，<strong>整个通信过程对 程序员完全透明</strong>。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
</blockquote>
<h3 id="Java内存模型（JMM）的抽象结构"><a href="#Java内存模型（JMM）的抽象结构" class="headerlink" title="Java内存模型（JMM）的抽象结构"></a>Java内存模型（JMM）的抽象结构</h3><h4 id="1-JMM涵盖的范围"><a href="#1-JMM涵盖的范围" class="headerlink" title="1. JMM涵盖的范围"></a>1. JMM涵盖的范围</h4><blockquote>
<p>在Java中，所有实例域、静态域和数组元素（总体称之为共享元素）都存储在堆内存中，堆内存在线程之间共享。局部变量），方法定义参数和异常处理器参数不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
</blockquote>
<h4 id="2-JMM的描述"><a href="#2-JMM的描述" class="headerlink" title="2. JMM的描述"></a>2. JMM的描述</h4><blockquote>
<p>Java线程之间的通信由JMM控制，<strong>JMM决定一个线程对共享变量的写入何时对另一个线程可见</strong>。从抽象的角度来看，JMM定义了线程和主内存之间的<strong>抽象关系</strong>：线程之间的共享变量存储在主内存中，<strong>每个线程都有一个私有的本地内存</strong>，本地内存中存储了该线程以读/写共享变量的<strong>副本</strong>。本地内存是JMM的一个<strong>抽象概念</strong>，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。<br><img src="https://wx2.sbimg.cn/2020/07/06/C4hPK.png" alt="C4hPK.png"></p>
</blockquote>
<h4 id="3-线程间的通信过程"><a href="#3-线程间的通信过程" class="headerlink" title="3.线程间的通信过程"></a>3.线程间的通信过程</h4><p><img src="https://wx1.sbimg.cn/2020/07/06/C4s1G.png" alt="C4s1G.png"><br>由图可知线程<strong>AB之间的通信过程</strong>为：   </p>
<blockquote>
<ul>
<li>本地内存A和本地内存B由主内存中共享变量x的副本(默认为0）；   </li>
<li>线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1；   </li>
<li>当线程A和线程B需要通信时，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。     </li>
</ul>
<p><strong>总体来说就是线程A与线程B通过主内存来进行通信，而JMM就是通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证的。</strong></p>
</blockquote>
<h3 id="从源代码到指令序列的重排序"><a href="#从源代码到指令序列的重排序" class="headerlink" title="从源代码到指令序列的重排序"></a>从源代码到指令序列的重排序</h3><blockquote>
<p>在执行程序时，为了提高性能，编译器和处理器常常会对源代码指令做重排序。重排序分3种类型（<strong>实际中会分别按以下顺序进行从源代码到最终执行的指令序列做重排序</strong>）。</p>
</blockquote>
<ol>
<li><strong>编译器优化的重排序</strong>：编译器在不改变单线程程序语义的前提下，可以重新安排语句 的执行顺序；</li>
<li><strong>指令级并行的重排序</strong>：现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序；</li>
<li><strong>内存系统的重排序</strong>：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上 去可能是在乱序执行。<blockquote>
<p>上述的<strong>1属于编译器重排序</strong>，<strong>2和3属于处理器重排序</strong>。这些重排序可能会<strong>导致多线程程序出现内存可见性问题</strong>。对于编译器，JMM的编译器重排序规则会<strong>禁止特定类型的编译器重排序</strong>（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为 Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。 <strong>JMM属于语言级的内存模型</strong>，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
</blockquote>
</li>
</ol>
<h3 id="重排序所带来的问题与解决方案"><a href="#重排序所带来的问题与解决方案" class="headerlink" title="重排序所带来的问题与解决方案"></a>重排序所带来的问题与解决方案</h3><p><img src="https://wx1.sbimg.cn/2020/07/06/C41al.png" alt="C41al.png"></p>
<blockquote>
<p>在这个小程序的运行中，很可能结果会为a=b=0(因为拿处理器A来说，它执行的步骤为A1-&gt;A2-&gt;A3)。虽然处理器A执行内存操作的顺序为：A1→A2，但内存操作实际发生的顺序却是A2→A1。此时，处理器A的内存操作顺序被重排序了，这里的关键是，由于<strong>写缓冲区仅对自己的处理器可见</strong>，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此<strong>现代的处理器都会允许对写-读操作进行重排序</strong>。</p>
</blockquote>
<blockquote>
<p>为了<strong>保证内存可见性</strong>，Java编译器在<strong>生成指令序列的适当位置会插入内存屏障指令</strong>来<strong>禁止特定类型的处理器重排序</strong>。JMM把内存屏障指令分为4类:<br><img src="https://wx2.sbimg.cn/2020/07/06/C4w78.png" alt="C4w78.png"><br>其中StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他3个屏障的效果。现代的多处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（Buffer Fully Flush）。</p>
</blockquote>
<h3 id="happens-before简介"><a href="#happens-before简介" class="headerlink" title="happens-before简介"></a>happens-before简介</h3><blockquote>
<p>。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p>
</blockquote>
<p>一些有关happens-before的规则</p>
<blockquote>
<ul>
<li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before<strong>于</strong>该线程中的<strong>任意后续操作</strong>。</li>
<li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before<strong>于</strong>随后对这个锁的<strong>加锁</strong>。 </li>
<li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 </li>
<li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
</ul>
</blockquote>
<p><strong>注意</strong>：</p>
<blockquote>
<p> 两个操作之间具有happens-before关系，<strong>并不意味着前一个操作必须要在后一个操作之前执行</strong>！happens-before<strong>仅仅要求前一个操作（执行的结果）对后一个操作可见</strong>，<strong>且前一个操作按顺序排在第二个操作之前</strong>的定义很微妙，后文会具体说明happens-before为什么要这么定义。，一个happens-before规则对应于一个或多个编译器和处理器重排序规则。对 于Java程序员来说，happens-before规则简单易懂，它避免Java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法。</p>
</blockquote>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
</blockquote>
<h4 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><blockquote>
<p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间 就存在数据依赖性。<br><a href="https://sbimg.cn/image/CM2CD" target="_blank" rel="noopener"><img src="https://wx1.sbimg.cn/2020/07/06/CM2CD.png" alt="CM2CD.png"></a><br>这三种情况只要重新排序两个操作的执行顺序，执行结果就会发生改变<br>前编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器<strong>不会改变单个处理器中执行的指令序列和单个线程中执行的操作中存在数据依赖关系的两个操作的执行顺序不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑</strong></p>
</blockquote>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><blockquote>
<p>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义，也就是说存在数据依赖的操作的执行顺序不会被改变，但是不存在数据依赖的操作的执行顺序可能会被改变，如 1.int a=1;  2.int b=1; 3.int c = a+b;在这个情况中，1和2依赖3所以3不会在1 2之前执行，但是1和2并不一定顺序执行。由于结果是一样的，但是要注意<strong>单线程程序并不一定是按照程序的顺序执行的！</strong>as-if-serial把单线程程序保护了起来，使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
</blockquote>
<h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><blockquote>
<p>上面举例中的操作1的执行结果不需要对操作2可见；而且重排序操作1和操作1后的执行结果，与操作1和操作2按happens-before顺序执行的结果一致。在这种情况下，JMM会认为<strong>这种重排序并不非法</strong>，JMM允许这种重排，所以说在计算机中，软件技术和硬件技术有一个共同的目标：<strong>在不改变程序执行结果的前提下，尽可能提高并行度</strong>。编译器和处理器遵从这一目标，从happens-before的定义我们可以看出，JMM同样遵从这一目标。</p>
</blockquote>
<h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><blockquote>
<p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
</blockquote>
<h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><blockquote>
<p>顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语 言的内存模型都会以顺序一致性内存模型作为参照。</p>
</blockquote>
<h3 id="数据竞争与顺序一致性"><a href="#数据竞争与顺序一致性" class="headerlink" title="数据竞争与顺序一致性"></a>数据竞争与顺序一致性</h3><blockquote>
<p>当程序未正确同步时，就可能会存在数据竞争。Java内存模型规范对数据竞争的定义：在一个线程中写一个变量，在另一个线程读同一个变量，而且写和读<strong>没有通过同步来排序</strong>。当代码中包含数据竞争时，程序的执行往往产生错误结果。如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。JMM对正确同步的多线程程序的内存一致性做了如下保证: 如果程序是正确同步的，程序的执行将具有<strong>顺序一致性</strong>即<strong>程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同</strong>。马上我们就会看到，这对于程序员来说是一个极强的保证。这里的同步是指广义上的同步，包括对常用同步原语 （synchronized、volatile和final）的正确使用。</p>
</blockquote>
<h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p><img src="https://wx2.sbimg.cn/2020/07/06/CMBlI.png" alt="CMBlI.png"></p>
<blockquote>
<p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员<strong>提供了极强的内存可见性保证</strong>。当多个线程并发 执行时，图中的开关装置能把所有线程的所有内存读/写操作串行化（即在<strong>顺序一致性模型中，所有操作之间具有全序关系</strong>）。顺序一致性内存模型有两大特性:   </p>
<ul>
<li><strong>一个线程中的所有操作必须按照程序的顺序来执行</strong>。   </li>
<li><strong>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序</strong>,在顺序一致性内存模型中，<strong>每个操作都必须原子执行且立刻对所有线程可见</strong>。<br><img src="https://wx2.sbimg.cn/2020/07/06/CMdjG.png" alt="CMdjG.png"><br><img src="https://wx2.sbimg.cn/2020/07/06/CMsXw.png" alt="CMsXw.png"><br>但是，<strong>在JMM中就没有这个保证</strong>。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本没有被当前线程执行。只有当前线程把本地内存中写过的数据刷 新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其他线程看到的操作执行顺序将不一致。</li>
</ul>
</blockquote>
<h3 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h3><blockquote>
<p>对程序ReorderExample用锁来同步，看看正确同步的程序如何具有顺序 一致性。<br><img src="https://wx2.sbimg.cn/2020/07/06/CM1G2.png" alt="CM1G2.png"><br><img src="https://wx1.sbimg.cn/2020/07/06/CMqw8.png" alt="CMqw8.png"><br>从这里我们可以看到，JMM在具体实现上的基本方针为：<strong>在不改变（正确同步的）程序执行结果的前提下，尽可能地为编译器和处理器的优化打开方便之门。</strong></p>
</blockquote>
<h3 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h3><blockquote>
<p>未同步程序在JMM中的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有如下几个差异:</p>
<ul>
<li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行;</li>
<li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。</li>
<li>JMM不保证对64位的long型和double型变量的写操作具有原子性（因为32位处理器可能在总线执行机制中被拆分的两个事务其间穿插其他事务），而顺序一致性模型保证对所有的内存读/写操作都具有原子性。但从JDK5开始，仅仅只允许把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行，任意的读操作都必须具有原子性（即任意读操作必须要在单个读事务中执行）。</li>
</ul>
</blockquote>
<p>数据总线的执行机制：   </p>
<blockquote>
<p><img src="https://wx1.sbimg.cn/2020/07/06/CMWdY.png" alt="CMWdY.png"><br>在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步<br>骤称之为总线事务。总线事务包括读事务和写事务。每个事务会 读/写内存中一个或多个物理上连续的字。这里的关键是，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其他的处理器和I/O设备执行内存的读/写。假设处理器A，B和C同时向总线发起总线事务，这时总线仲裁（Bus Arbitration）会对竞争做出裁决。总线的这些工作机制可以把<strong>所有处理器对内存的访问以串行化的方式来执行</strong>。在任意时间点，最多只能有一个处理器可以访问内存。这个特性确保了单个总线事务之中的内存读/写 操作具有原子性。</p>
</blockquote>
<h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><h3 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h3><blockquote>
<ul>
<li>可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</li>
</ul>
</blockquote>
<h3 id="volatile写-读建立的happens-before关系"><a href="#volatile写-读建立的happens-before关系" class="headerlink" title="volatile写-读建立的happens-before关系"></a>volatile写-读建立的happens-before关系</h3><blockquote>
<p><strong>volatile变量的写-读可以实现线程之间的通信。从内存语义的角度来说，volatile的写-读与锁的释放-获取有相同的语义效果</strong>，例子：<br><img src="https://wx1.sbimg.cn/2020/07/06/CMVOR.png" alt="CMVOR.png"><br>1.根据程序次序规则，1happens-before2;3happens-before4。<br>2.根据volatile规则，2happens-before3。<br>3.根据happens-before的传递性规则，1 happens-before 4。<br>这里A线程写一个volatile变量后，B线程读同一个volatile变量。A线程在写volatile变量之前所有可见的共享变量，在B线程读同一个volatile变量后，将立即变得对B线程可见。</p>
</blockquote>
<h3 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h3><ul>
<li><strong>volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存</strong>。</li>
<li><strong>volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主 内存中读取共享变量。</strong>   </li>
</ul>
<p>也就是说：</p>
<ul>
<li>线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程 发出了（其对共享变量所做修改的）消息。</li>
<li>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile 变量之前对共享变量所做修改的）消息。</li>
<li>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
<h3 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h3><p>根据JMM针对编译器制定的bolatile重排序的规则表：<br><img src="https://wx2.sbimg.cn/2020/07/06/CXxH1.png" alt="CXxH1.png"></p>
<blockquote>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中<strong>插入内存屏障</strong>来禁止特定类型的处理器重排序,它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义：</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
</blockquote>
<blockquote>
<p>volatile写-读内存语义的常见使用模式是：一个 写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时， 选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里可以看到JMM 在实现上的一个特点：<strong>首先确保正确性，然后再去追求执行效率</strong>。</p>
</blockquote>
<p>一个例子：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">text</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> a;</span><br><span class="line">    volatile <span class="built_in">int</span> i;</span><br><span class="line">    volatile <span class="built_in">int</span> j;</span><br><span class="line">    <span class="built_in">void</span> readAndWrite()&#123;</span><br><span class="line">        <span class="built_in">int</span> v1 = i;    <span class="comment">//第一个volatile读</span></span><br><span class="line">        <span class="built_in">int</span> v2 = j;    <span class="comment">//第二个volatile读</span></span><br><span class="line">        a = v1 + v2;   <span class="comment">//第一个普通写</span></span><br><span class="line">        i = v1+<span class="number">1</span>;      <span class="comment">//第一个volatile写</span></span><br><span class="line">        j = v2+<span class="number">1</span>;      <span class="comment">//第二个volatile写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中对于readAndWrite，编译器在生成字节码时会做如下的优化：</p>
<blockquote>
<p><img src="https://wx1.sbimg.cn/2020/07/06/CXlNm.png" alt="CXlNm.png"><br>注意，<strong>最后的StoreLoad屏障不能省略。因为第二个volatile写之后，方法立即return</strong></p>
</blockquote>
<p>继续优化：</p>
<blockquote>
<p>上面的优化针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以X86处理器为例，<strong>除了最后的StoreLoad屏障外，其他的屏障都会被省略</strong>。因为X86处理器仅会对写-读操作做重排序。X86不会对读-读、读-写和写-写操作做重排序，因此在X86处理器中会省略掉这3种操作类型对应的内存屏障。在X86中，JMM仅需在volatile写后面插入一个StoreLoad屏障即可正确实现volatile写-读的内存语义。这意味着在X86处理器中，volatile写的开销比volatile读的开销会大很多（因为执行StoreLoad屏障开销会比较大）。<br><img src="https://wx1.sbimg.cn/2020/07/06/CXSsd.png" alt="CXSsd.png"></p>
</blockquote>
<h3 id="volatile小总结"><a href="#volatile小总结" class="headerlink" title="volatile小总结"></a>volatile小总结</h3><blockquote>
<p>由于volatile<strong>仅仅保证对单个volatile变量的读/写具有原子性</strong>，而<strong>锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性</strong>。<strong>在功能上，锁比volatile更强大</strong>；<strong>在可伸缩性和执行性能上，volatile更有优势</strong>。如果读者想在程序中用volatile代替锁，请一定谨慎，具体详情请参阅Brian Goetz的文章《Java理论与实践：正确使用Volatile变量》。</p>
</blockquote>
<h2 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h2><blockquote>
<p>众所周知，锁可以让临界区互斥执行。这里将介绍锁的另一个同样重要，但常常被忽视的功能：锁的内存语义。</p>
</blockquote>
<h3 id="锁的释放-获取建立的happens-before关系"><a href="#锁的释放-获取建立的happens-before关系" class="headerlink" title="锁的释放-获取建立的happens-before关系"></a>锁的释放-获取建立的happens-before关系</h3><blockquote>
<p>锁是Java并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。来看一个锁释放-获取的例子：</p>
</blockquote>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">clss text&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123; <span class="comment">//1</span></span><br><span class="line">        a++;                          <span class="comment">//2</span></span><br><span class="line">    &#125;                                 <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;  <span class="comment">//4</span></span><br><span class="line">        <span class="keyword">int</span> i = a;                    <span class="comment">//5</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;                                 <span class="comment">//6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类的代码中包含着三类happens-before关系：</p>
<blockquote>
<ul>
<li>程序次序规则：1 happens-before 2，2 happens-before 3;4 happens-before 5,5 happens- before 6。</li>
<li>监视器锁规则：3happens-before4</li>
<li>happens-before传递性：2 happens-before 5</li>
</ul>
</blockquote>
<p>综合来看：<br><img src="https://wx2.sbimg.cn/2020/07/06/CmDBn.png" alt="CmDBn.png"></p>
<blockquote>
<p>每一个箭头链接的两个节点，代表了一个happens-before关系。黑色箭头表示 程序顺序规则；橙色箭头表示监视器锁规则；蓝色箭头表示组合这些规则后提供的happens- before保证。<br><strong>图表示在线程A释放了锁之后，随后线程B获取同一个锁。在上图中，2 happens-before 5。因此，线程A在释放锁之前所有可见的共享变量，在线程B获取同一个锁之后，将立刻变得对B线程可见</strong>。</p>
</blockquote>
<h3 id="锁的释放和获取的内存语义"><a href="#锁的释放和获取的内存语义" class="headerlink" title="锁的释放和获取的内存语义"></a>锁的释放和获取的内存语义</h3><blockquote>
<ul>
<li><strong>线程释放锁</strong>时：JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。以上面的程序为例，A线程释放锁后，共享数据的状态就被刷新了；</li>
<li><strong>线程获取锁</strong>时：<strong>JMM会把该线程对应的本地内存置为无效</strong>。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。相当于线程A向线程B发送了消息</li>
</ul>
</blockquote>
<p>总结：</p>
<blockquote>
<ul>
<li>锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。 </li>
<li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</li>
<li>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。</li>
<li>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
</blockquote>
<h3 id="锁内存语义的实现"><a href="#锁内存语义的实现" class="headerlink" title="锁内存语义的实现"></a>锁内存语义的实现</h3><p>示例代码：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> &#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>; </span><br><span class="line">    ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>(); <span class="comment">// 获取锁 </span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a++; </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123; </span><br><span class="line">            <span class="keyword">lock</span>.unlock(); <span class="comment">// 释放锁 </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span> (<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>(); <span class="comment">// 获取锁 </span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = a; </span><br><span class="line">            …… </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">            <span class="keyword">lock</span>.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125; </span><br><span class="line">            </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在ReentrantLock中，调用lock()方法获取锁；调用unlock()方法释放锁。 ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronizer（简称之为AQS）。AQS使用一个整型的volatile变量（命名为state）来维护同步状态，这个volatile变量是ReentrantLock内存语义实现的关键。<br><img src="https://wx2.sbimg.cn/2020/07/06/CmbVh.png" alt="CmbVh.png"><br>ReentrantLock分为公平锁和非公平锁，逐一分析：</p>
</blockquote>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>使用公平锁时，<strong>加锁方法lock()调用轨迹如下</strong>：<br>1.ReentrantLock:lock()；<br>2.FairSync:lock()。<br>3.AbstractQueuedSynchronizer:acquire(int arg)。<br>4.ReentrantLock:tryAcquire(int acquires)。<br><strong>在第4步真正开始加锁</strong>，下面是该方法的源代码。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected final boolean <span class="keyword">try</span><span class="constructor">Acquire(<span class="params">int</span> <span class="params">acquires</span>)</span> &#123; </span><br><span class="line">    final Thread current = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>; </span><br><span class="line">    <span class="built_in">int</span> c = get<span class="constructor">State()</span>; <span class="comment">// 获取锁的开始，首先读volatile变量state if (c == 0) &#123; </span></span><br><span class="line">        <span class="keyword">if</span> (is<span class="constructor">First(<span class="params">current</span>)</span><span class="operator"> &amp;&amp; </span>compare<span class="constructor">AndSetState(0, <span class="params">acquires</span>)</span>)&#123;</span><br><span class="line">            set<span class="constructor">ExclusiveOwnerThread(<span class="params">current</span>)</span>; </span><br><span class="line">            return <span class="literal">true</span>; </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (current<span class="operator"> == </span>get<span class="constructor">ExclusiveOwnerThread()</span>) &#123; </span><br><span class="line">        <span class="built_in">int</span> nextc = c + acquires; </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) throw <span class="keyword">new</span> <span class="constructor">Error(<span class="string">"Maximum lock count exceeded"</span>)</span>; </span><br><span class="line">        set<span class="constructor">State(<span class="params">nextc</span>)</span>; </span><br><span class="line">        return <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面源代码中我们可以看出，加锁方法首先读volatile变量state。</p>
</blockquote>
<p>在使用公平锁时，<strong>解锁方法unlock()调用轨迹</strong>如下<br>1.ReentrantLock:unlock()。<br>2.AbstractQueuedSynchronizer:release(int arg)。<br>3.Sync:tryRelease(int releases)。<br>在<strong>第3步真正开始释放锁</strong>，下面是该方法的源代码:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected final boolean <span class="keyword">try</span><span class="constructor">Release(<span class="params">int</span> <span class="params">releases</span>)</span> &#123; </span><br><span class="line">    <span class="built_in">int</span> c = get<span class="constructor">State()</span> - releases; </span><br><span class="line">    <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span> != get<span class="constructor">ExclusiveOwnerThread()</span>)</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">IllegalMonitorStateException()</span>; </span><br><span class="line">    boolean free = <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">if</span> (c<span class="operator"> == </span><span class="number">0</span>) &#123; </span><br><span class="line">    free = <span class="literal">true</span>; </span><br><span class="line">    set<span class="constructor">ExclusiveOwnerThread(<span class="params">null</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    set<span class="constructor">State(<span class="params">c</span>)</span>; <span class="comment">// 释放锁的最后，写volatile变量state </span></span><br><span class="line">    return free; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面的源代码可以看出，在释放锁的最后写volatile变量state。 公平锁在释放锁的最后写volatile变量state，在获取锁时首先读这个volatile变量。根据 volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。</p>
</blockquote>
<h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>非公平锁的释放和公平锁完全一样，所以这里仅仅分析非公平锁的获取。使用非公平锁时，加锁方法lock()调用轨迹如下：<br>1.ReentrantLock:lock()。<br>2.NonfairSync:lock()。<br>3.AbstractQueuedSynchronizer:compareAndSetState(int expect,int update)。<br>在第3步真正开始加锁，下面是该方法的源代码。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected final boolean compare<span class="constructor">AndSetState(<span class="params">int</span> <span class="params">expect</span>, <span class="params">int</span> <span class="params">update</span>)</span> &#123; </span><br><span class="line">    return unsafe.compare<span class="constructor">AndSwapInt(<span class="params">this</span>, <span class="params">stateOffset</span>, <span class="params">expect</span>, <span class="params">update</span>)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该方法以原子操作的方式更新state变量，本文把Java的compareAndSet()方法调用简称为 CAS。JDK文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有volatile读和写的内存语义。</p>
</blockquote>
<h4 id="在常见的intel-X86处理器中，CAS是如何同时具有volatile读和volatile写的内存语义的"><a href="#在常见的intel-X86处理器中，CAS是如何同时具有volatile读和volatile写的内存语义的" class="headerlink" title="在常见的intel X86处理器中，CAS是如何同时具有volatile读和volatile写的内存语义的?"></a>在常见的intel X86处理器中，CAS是如何同时具有volatile读和volatile写的内存语义的?</h4><p>下面是sun.misc.Unsafe类的compareAndSwapInt()方法的源代码。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="built_in">boolean</span> compareAndSwapInt(<span class="keyword">Object</span> o, <span class="keyword">long</span> offset, <span class="built_in">int</span> expected)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到，这是一个本地方法调用。这个本地方法在openjdk中依次调用的c++代码为： unsafe.cpp，atomic.cpp和atomic_windows_x86.inline.hpp。这个本地方法的最终实现在openjdk的如下位置：openjdk-7-fcs-src-b147- 27_jun_2011\openjdk\hotspot\src\os_cpu\windows_x86\vm\atomic_windows_x86.inline.hpp（对应于Windows操作系统，X86处理器）。</p>
</blockquote>
<p>下面是对应于intel X86处理器的源代码的片段:</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">inlinej <span class="keyword">int</span> Atomic::<span class="keyword">cmpxchg</span> (jint exchange_value, volatile jint* dest, jint compare_value) </span><br><span class="line">&#123; // alternative for InterlockedCompareExchange </span><br><span class="line">    <span class="keyword">int</span> mp = os::is_MP()<span class="comment">;</span></span><br><span class="line">    __asm &#123; <span class="keyword">mov</span> <span class="built_in">edx</span>, dest <span class="keyword">mov</span> <span class="built_in">ecx</span>, exchange_value <span class="keyword">mov</span> <span class="built_in">eax</span>, compare_value LOCK_IF_MP(mp) <span class="keyword">cmpxchg</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>], <span class="built_in">ecx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如上面源代码所示，程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前 缀。如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（Lock Cmpxchg）。反之，如果程序是在单处理器上运行，就省略lock前缀（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障效果）。</p>
</blockquote>
<h4 id="intel的手册对lock前缀的说明"><a href="#intel的手册对lock前缀的说明" class="headerlink" title="intel的手册对lock前缀的说明"></a>intel的手册对lock前缀的说明</h4><ul>
<li>1.确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium4、Intel Xeon及P6处理器开始，Intel使用缓存锁定（Cache Locking） 来保证指令执行的原子性。缓存锁定将大大降低lock前缀指令的执行开销。     </li>
<li>2.禁止该指令，与之前和之后的读和写指令重排序。   </li>
<li>3.把写缓冲区中的所有数据刷新到内存中。</li>
</ul>
<p>上面的第2点和第3点所具有的内存屏障效果，足以同时实现volatile读和volatile写的内存语义。</p>
<h4 id="公平锁和非公平锁的内存语义总结"><a href="#公平锁和非公平锁的内存语义总结" class="headerlink" title="公平锁和非公平锁的内存语义总结"></a>公平锁和非公平锁的内存语义总结</h4><ul>
<li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。</li>
<li>公平锁获取时，首先会去读volatile变量。</li>
<li>非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile 写的内存语义。    </li>
</ul>
<p>从本文对ReentrantLock的分析可以看出，锁释放-获取的内存语义的实现至少有下面两种方式:</p>
<ul>
<li>1.利用volatile变量的写-读所具有的内存语义。</li>
<li>2.利用CAS所附带的volatile读和volatile写的内存语义。</li>
</ul>
<h3 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h3><p>由于Java的CAS同时具有volatile读和volatile写的内存语义，因此Java线程之间的通信现 在有了下面4种方式。</p>
<ul>
<li>1.A线程写volatile变量，随后B线程读这个volatile变量。</li>
<li>2.A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>3.A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。 </li>
<li>4.A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。 <blockquote>
<p>Java的CAS会使用现代处理器上提供的高效机器级别的原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式。首先，声明共享变量为volatile。 然后，使用CAS的原子条件更新来实现线程之间的同步。同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的 通信。AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。</p>
</blockquote>
</li>
</ul>
<p>从整体来看，concurrent包的实现示意图:<br><a href="https://sbimg.cn/image/Cp4cw" target="_blank" rel="noopener"><img src="https://wx1.sbimg.cn/2020/07/06/Cp4cw.png" alt="Cp4cw.png"></a></p>
<p>参考：<br>《Java并发编程的艺术》</p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】Java内存模型（下）</title>
    <url>/2020/07/07/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(二）内存模型（下）含final域的内存定义/happens-before/双重检查锁定与延迟初始化/Java内存模型综述</strong></p>
<a id="more"></a>
<h2 id="final域的内存定义"><a href="#final域的内存定义" class="headerlink" title="final域的内存定义"></a>final域的内存定义</h2><p>与前面介绍的锁和volatile相比，对final域的读和写更像是普通的变量访问。</p>
<h3 id="final域的重排序规则"><a href="#final域的重排序规则" class="headerlink" title="final域的重排序规则"></a>final域的重排序规则</h3><blockquote>
<ul>
<li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li>
</ul>
</blockquote>
<p>下面给出一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;                  <span class="comment">//普通变量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j;            <span class="comment">//final变量</span></span><br><span class="line">    <span class="keyword">static</span> FinalExample obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalExaple</span><span class="params">()</span></span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.i = <span class="number">1</span>;         <span class="comment">//写普通域</span></span><br><span class="line">        <span class="keyword">this</span>.j = <span class="number">2</span>;         <span class="comment">//写final域</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;    <span class="comment">//写方法 线程A执行</span></span><br><span class="line">        obj = <span class="keyword">new</span> FinalExample();<span class="comment">//写对象引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;     <span class="comment">//读方法 线程B执行</span></span><br><span class="line">        FinalExample object = obj;<span class="comment">//读对象引用</span></span><br><span class="line">        <span class="keyword">int</span> a = obj.i;      <span class="comment">//读普通变量</span></span><br><span class="line">        <span class="keyword">int</span> b = obj.j;      <span class="comment">//读final变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h3><blockquote>
<p>写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含下面2个方面:</p>
<ul>
<li>JMM禁止编译器把final域的写重排序到构造函数之外。</li>
<li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障 禁止处理器把final域的写重排序到构造函数之外   </li>
</ul>
</blockquote>
<blockquote>
<p>写普通域的操作被编译器重排序到了构造函数之外，读线程B错误地读取了普通变量i初始化之前的值。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确地读取了final变量初始化之后的值。 写final域的重排序规则可以确保：<strong>在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障</strong>。</p>
</blockquote>
<h3 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h3><blockquote>
<p>读final域的重排序规则是：在一个线程中，<strong>初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作</strong>（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。 初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器的。 </p>
</blockquote>
<blockquote>
<p>在时序图中读对象的普通域的操作被处理器重排序到读对象引用之前。<strong>读普通域时，该域还没有被写线程A写入</strong>，这是一个错误的读取操作。而读final域的重排序规则会把读对象final域的操作“限定”在读对象引用之后，此时该final域已经被A线程初始化过了，这是一个正确的读取操作。<br>读final域的重排序规则可以确保：<strong>在读一个对象的final域之前，一定会先读包含这个final域的对象的引用</strong>。</p>
</blockquote>
<h3 id="final域为引用类型"><a href="#final域为引用类型" class="headerlink" title="final域为引用类型"></a>final域为引用类型</h3><p>上面我们看到的final域是基础数据类型，如果final域是引用类型，将会有什么效果？示例代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">FinalReferenceExample</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span>[] <span class="built_in">array</span>int;              <span class="comment">//饮用类型的final</span></span><br><span class="line">    static FinalReferenceExample obj;</span><br><span class="line">    <span class="keyword">public</span> FinalReferenceExample()&#123;</span><br><span class="line">        <span class="built_in">array</span>int = new <span class="built_in">int</span>[<span class="number">1</span>];         <span class="comment">//1</span></span><br><span class="line">        <span class="built_in">array</span>int[<span class="number">0</span>] = <span class="number">1</span>;               <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> writeOne()&#123;            <span class="comment">//A执行的写操作</span></span><br><span class="line">        obj = new FinalReferenceExample();<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> writeTwo()&#123;            <span class="comment">//B执行的写操作</span></span><br><span class="line">        obj.<span class="built_in">array</span>int[<span class="number">0</span>] = <span class="number">2</span>;           <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> read()&#123;                <span class="comment">//C执行的读操作</span></span><br><span class="line">        <span class="keyword">if</span>(obj!=<span class="literal">null</span>)&#123;                 <span class="comment">//5</span></span><br><span class="line">            <span class="built_in">int</span> temp = obj.<span class="built_in">array</span>int[<span class="number">0</span>];<span class="comment">//6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本例final域为一个引用类型，它引用一个int型的数组对象。对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：<strong>在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序</strong>。 对上面的示例程序，1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。<br>JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写 入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看得到，也可能看不到。<strong>JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知</strong>。 <strong>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性</strong>。</p>
</blockquote>
<h3 id="为什么final引用不能从构造函数内“溢出”"><a href="#为什么final引用不能从构造函数内“溢出”" class="headerlink" title="为什么final引用不能从构造函数内“溢出”\"></a>为什么final引用不能从构造函数内“溢出”\</h3><blockquote>
<p>写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该 引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实，要得到这个效果，还需要一个保证：<strong>在构造函数内部，不能让这个被构造对象的引用为其他线程所见</strong>，也就是对象引用不能在构造函数中“溢出”。示例代码:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> i;</span><br><span class="line">    FinalReferenceExcapeExample obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceExcapeExample</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i = <span class="number">1</span>;                    <span class="comment">//1写final域</span></span><br><span class="line">        obj = <span class="keyword">this</span>                <span class="comment">//2this在此溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FinalReferenceExcapeExample();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj!=<span class="keyword">null</span>)&#123;            <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> temp = obj.i;     <span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的时序图可能将1放到最后</p>
<blockquote>
<p>假设一个线程A执行writer()方法，另一个线程B执行reader()方法。这里的操作2使得对象还未完成构造前就为线程B可见。即使这里的操作2是构造函数的最后一步，且在程序中操作2排在操作1后面，执行reader()方法的线程仍然可能无法看到final域被初始化后的值，因为<strong>这里的操作1和操作2之间可能被重排序</strong>。所以在构造函数返回前，被构造对象的引用不能为其他线程所见，<strong>因为此时的final域可能还没有被初始化</strong>。在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。</p>
</blockquote>
<h3 id="final语义在处理器中的实现"><a href="#final语义在处理器中的实现" class="headerlink" title="final语义在处理器中的实现"></a>final语义在处理器中的实现</h3><blockquote>
<p>写final域的重排序规则会要求编译器在final域的写之后，构造函数return之前插入一个StoreStore障屏。读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障。由于<strong>X86处理器不会对写-写操作做重排序</strong>，所以在X86处理器中，写final域需要的StoreStore障屏会被省略掉。同样，由于<strong>X86处理器不会对存在间接依赖关系的操作做重排序</strong>， 所以在X86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说，在X86处理器中，final域的读/写不会插入任何内存屏障</p>
</blockquote>
<h3 id="JSR-133为什么要增强final的语义"><a href="#JSR-133为什么要增强final的语义" class="headerlink" title="JSR-133为什么要增强final的语义"></a>JSR-133为什么要增强final的语义</h3><blockquote>
<p>在旧的Java内存模型中，一个最严重的缺陷就是线程可能看到final域的值会改变。比如， 一个线程当前看到一个整型final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为1（被某个线程初始化之后的值）。最常见的例子就是在旧的Java内存模型中，String的值可能会改变。为了修补这个漏洞，JSR-133专家组增强了final的语义。<strong>通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证</strong>：<strong>只要对象是正确构造的（被构造对象的引用在 构造函数中没有“溢出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</strong></p>
</blockquote>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>happens-before是JMM最核心的概念。对应Java程序员来说，理解happens-before是理解JMM的关键。</p>
<h3 id="JMM的设计"><a href="#JMM的设计" class="headerlink" title="JMM的设计"></a>JMM的设计</h3><blockquote>
<p>从JMM设计者的角度，在设计JMM时，需要考虑两个关键因素。 </p>
<ul>
<li>程序员对内存模型的使用。程序员希望内存模型易于理解、易于编程。<strong>程序员希望基于一个强内存模型来编写代码</strong>。</li>
<li>编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。<strong>编译器和处理器希望实现一个弱内存模型</strong>。</li>
</ul>
</blockquote>
<blockquote>
<p>由于这两个因素互相矛盾，所以JSR-133专家组在设计JMM时的核心目标就是找到一个好的平衡点：一方面，要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能地放松。我们来看JSR-133是如何实现这一目标的</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> pi = <span class="number">3.14</span>; <span class="comment">// A </span></span><br><span class="line"><span class="built_in">double</span> r = <span class="number">1.0</span>; <span class="comment">// B </span></span><br><span class="line"><span class="built_in">double</span> area = pi * r * r; <span class="comment">// C</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面计算圆的面积的示例代码存在3个happens-before关系，如下:</p>
<ul>
<li>A happens-before B;</li>
<li>B happens-before C;</li>
<li>A happens-before C。 </li>
</ul>
</blockquote>
<p>在3个happens-before关系中，2和3是必需的，但1是不必要的。因此，JMM把happens-before要求禁止的重排序分为了下面两类：</p>
<blockquote>
<ul>
<li>会改变程序执行结果的重排序;</li>
<li>不会改变程序执行结果的重排序。 </li>
</ul>
</blockquote>
<p>JMM对这两种不同性质的重排序，采取了不同的策略，如下：</p>
<blockquote>
<ul>
<li>对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。</li>
<li>对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种重排序）<br><img src="https://wx2.sbimg.cn/2020/07/07/C0RiD.png" alt="C0RiD.png"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>JMM向程序员提供的happens-before规则能满足程序员的需求。JMM的happens-before规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的A happens-before B;</li>
<li>JMM对编译器和处理器的束缚已经尽可能少。从上面的分析可以看出，JMM其实是在遵循一个基本原则：<strong>只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行</strong>。例如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个volatile变量只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li>
</ul>
</blockquote>
<h3 id="happens-before的定义"><a href="#happens-before的定义" class="headerlink" title="happens-before的定义"></a>happens-before的定义</h3><blockquote>
<ul>
<li>1.如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前;</li>
<li>2.两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>1.是JMM对程序员的承诺。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。注意，这只是Java内存模型向程序员做出的保证！</li>
<li>2.是JMM对编译器和处理器重排序的约束原则。正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。</li>
</ul>
</blockquote>
<p>happens-before关系本质上和as-if-serial语义是一回事。</p>
<blockquote>
<ul>
<li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</li>
<li>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。 </li>
</ul>
</blockquote>
<p>as-if-serial语义和happens-before这么做的目的，都是<strong>为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度</strong>。</p>
<h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><blockquote>
<ul>
<li>1.程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li>2.监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>3.volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 </li>
<li>4.传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li>5.start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的 ThreadB.start()操作happens-before于线程B中的任意操作。</li>
<li>6.join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before于线程A从ThreadB.join()操作成功返回。</li>
</ul>
</blockquote>
<p>这里的规则1、2、3和4前面都说过，这里再做个总结。由于2和3情况类似，这里只以1、3和4为例来说明。</p>
<p>volatile写-读建立的happens-before：<br><img src="https://wx2.sbimg.cn/2020/07/07/C0gRj.png" alt="C0gRj.png"></p>
<blockquote>
<ul>
<li>1 happens-before 2和3 happens-before 4由程序顺序规则产生。由于编译器和处理器都要遵守as-if-serial语义，也就是说，as-if-serial语义保证了程序顺序规则。因此，可以把程序顺序 规则看成是对as-if-serial语义的“封装”。</li>
<li>2 happens-before 3是由volatile规则产生。前面提到过，对一个volatile变量的读，总是能看到（任意线程）之前对这个volatile变量最后的写入。因此，volatile的这个特性可以保证实现 volatile规则。 </li>
<li>1 happens-before 4是由传递性规则产生的。这里的传递性是由volatile的内存屏障插入策略和volatile的编译器重排序规则共同来保证的。 </li>
</ul>
</blockquote>
<p>下面我们来看start()规则。假设线程A在执行的过程中，通过执行ThreadB.start()来启动线程B；同时，假设线程A在执行ThreadB.start()之前修改了一些共享变量，线程B在开始执行后会 读这些共享变量。该程序对应的happens-before关系图为：<br><img src="https://wx1.sbimg.cn/2020/07/07/C0hWk.png" alt="C0hWk.png"></p>
<blockquote>
<ul>
<li>1 happens-before 2由程序顺序规则产生，2 happens-before 4由start()规则产生。根据传递性，将有1 happens-before 4。这实意味着，线程A在执行ThreadB.start()之前对共享变量所做的修改，接下来在线程B开始执行后都将确保对线程B可见。 </li>
</ul>
</blockquote>
<p>下面我们来看join()规则。假设线程A在执行的过程中，通过执行ThreadB.join()来等待线 程B终止；同时，假设线程B在终止之前修改了一些共享变量，线程A从ThreadB.join()返回后会读这些共享变量。该程序对应的happens-before关系图为：<br><img src="https://wx2.sbimg.cn/2020/07/07/C0syn.png" alt="C0syn.png"></p>
<blockquote>
<ul>
<li>2 happens-before 4由join()规则产生；4 happens-before 5由程序顺序规则产生。 根据传递性规则，将有2 happens-before 5。这意味着，线程A执行操作ThreadB.join()并成功返回后，线程B中的任意操作都将对线程A可见。</li>
</ul>
</blockquote>
<h3 id="双重检查锁定与延迟初始化"><a href="#双重检查锁定与延迟初始化" class="headerlink" title="双重检查锁定与延迟初始化"></a>双重检查锁定与延迟初始化</h3><blockquote>
<p>在Java程序中，有时候可能<strong>需要推迟一些高开销的对象初始化操作</strong>，并且只有在<strong>使用这些对象时才进行初始化</strong>。此时，程序员可能会采用延迟初始化。但要正确实现线程安全的延迟初始化需要一些技巧，否则很容易出现问题。</p>
</blockquote>
<h4 id="双重检查锁定的由来"><a href="#双重检查锁定的由来" class="headerlink" title="双重检查锁定的由来"></a>双重检查锁定的由来</h4><p>下面是非线程安全的延迟初始化对象的示例代码</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public class UnsafeLazyInitialization&#123;</span><br><span class="line">    private static<span class="built_in"> Instance </span>instance;</span><br><span class="line">    public static<span class="built_in"> Instance </span>getInstance()&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="built_in"> instance </span>= new Instance();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双重检查锁定：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public class SafeLacyInitialization&#123;</span><br><span class="line">    private static<span class="built_in"> Instance </span>instance;</span><br><span class="line">    public static<span class="built_in"> Instance </span>getInstance()&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            synchronized (DoubleCheckedLoacking.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                   <span class="built_in"> instance </span>= new Instance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>双重检查锁定看起来似乎很完美，但这是一个错误的优化！在线程执行到第4行，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p>
</blockquote>
<h4 id="问题的根源"><a href="#问题的根源" class="headerlink" title="问题的根源"></a>问题的根源</h4><p>双重检查锁定示例代码的第7行（instance=new Singleton();）创建了一个对象。这一行代码可以分解为如下的3行伪代码。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">memory = allocata() //为对象分配内存区域</span><br><span class="line">ctorInstance(memory) //对象初始化</span><br><span class="line">instance = memory //设置instance指向刚分配的内存区域</span><br></pre></td></tr></table></figure>
<p>上面3行伪代码中的2和3之间，可能会被重排序<br><img src="https://wx2.sbimg.cn/2020/07/07/C0Zt1.png" alt="C0Zt1.png"></p>
<blockquote>
<p>这里A2和A3虽然重排序了，但Java内存模型的intra-thread semantics将确保A2一定会排在A4前面执行。因此，线程A的intra-thread semantics没有改变，但A2和A3的重排序，将导致线程B在B1处判断出instance不为空，线程B接下来将访问instance引用的对象。此时，线程B将会访 问到一个还未初始化的对象。在知晓了问题发生的根源之后，我们可以想出两个办法来实现线程安全的延迟初始化:</p>
<ul>
<li>不允许2和3重排序。</li>
<li>允许2和3重排序，但不允许其他线程“看到”这个重排序。</li>
</ul>
</blockquote>
<h4 id="基于volatile的解决方案"><a href="#基于volatile的解决方案" class="headerlink" title="基于volatile的解决方案"></a>基于volatile的解决方案</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public class SafeLazyInitilization&#123;</span><br><span class="line">    private volatile static<span class="built_in"> Instance </span>instance;</span><br><span class="line">    public static<span class="built_in"> Instance </span>getInstance()&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            synchronized(DoubleCheckedLocking.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                   <span class="built_in"> instance </span>= new Instance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当声明对象的引用为volatile后，3行伪代码中的2和3之间的重排序，在多线程环境中将会被禁止，保证了线程安全的延迟初始化。</p>
<h2 id="Java内存模型综述"><a href="#Java内存模型综述" class="headerlink" title="Java内存模型综述"></a>Java内存模型综述</h2><p>###处理器的内存模型<br>顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会以顺序一致性内存模型为<strong>参照</strong>。在设计时，JMM和处理器内存模型会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。根据对不同类型的读/写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为如下几种类型：</p>
<blockquote>
<ul>
<li>放松程序中写-读操作的顺序，由此产生了Total Store Ordering内存模型（简称为TSO）;</li>
<li>在上面的基础上，继续放松程序中写-写操作的顺序，由此产生了Partial Store Order内存模型（简称为PSO）;</li>
<li>在前面两条的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了Relaxed Memory Order内存模型（简称为RMO）和PowerPC内存模型。 </li>
</ul>
</blockquote>
<p>注意：这里处理器对读/写操作的放松，是<strong>以两个操作之间不存在数据依赖性为前提</strong>的（因为处理器要遵守as-if-serial语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。   </p>
<p>常见处理器内存模型的细节特征如下：<br><a href="https://sbimg.cn/image/C2LZd" target="_blank" rel="noopener"><img src="https://wx1.sbimg.cn/2020/07/07/C2LZd.png" alt="C2LZd.png"></a></p>
<blockquote>
<p><strong>所有处理器内存模型都允许写-读重排序</strong>，因为它们都使用了写缓存区。写缓存区可能导致写-读操作重排序。同时，我们可以看到这些处 理器内存模型都允许更早读到当前处理器的写，原因同样是因为写缓存区。由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己写缓存区中的写。</p>
</blockquote>
<p>表中的各种处理器内存模型，从上到下，<strong>模型由强变弱</strong>。越是追求性能的处理器，内存模型设计得会越弱。因为这些处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。由于常见的处理器内存模型比JMM要弱，Java编译器在生成字节码时，<strong>会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序</strong>。同时，由于各种处理器内存模型的强弱不同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不相同。   </p>
<p>图展示了JMM在不同处理器内存模型中需要插入的内存屏障的示意图。 JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。<br><img src="https://wx2.sbimg.cn/2020/07/07/C2jI4.png" alt="C2jI4.png"></p>
<h3 id="各种内存模型之间的关系"><a href="#各种内存模型之间的关系" class="headerlink" title="各种内存模型之间的关系"></a>各种内存模型之间的关系</h3><p><strong>JMM是一个语言级的内存模型</strong>，<strong>处理器内存模型是硬件级的内存模型</strong>，顺序一致性内存模型是一个理论参考模型。<strong>常见的4种处理器内存模型比常用的3中语言内存模型要弱</strong>，<strong>处理器内存模型和语言内存模型都比顺序一致性内存模型要弱</strong>。<strong>同处理器内存模型一样，越是追求执行性能的语言，内存模型设计得会越弱</strong>。<br><img src="https://wx2.sbimg.cn/2020/07/07/C2qzA.png" alt="C2qzA.png"></p>
<h3 id="JMM的内存可见性保证"><a href="#JMM的内存可见性保证" class="headerlink" title="JMM的内存可见性保证"></a>JMM的内存可见性保证</h3><p>按程序类型，Java程序的内存可见性保证可以分为下列3类。</p>
<blockquote>
<ul>
<li>单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li>
<li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li>
<li>未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）</li>
</ul>
</blockquote>
<p>注意:</p>
<blockquote>
<p>最小安全性保障与64位数据的非原子性写并不矛盾。它们是两个不同的概念，它们“发生”的时间点也不同。最小安全性保证对象默认初始化之后（设置成员域为0、null或false），才会被任意线程使用。最小安全性“发生”在对象被任意线程使用之前。64位数据的非原子性写“发生”在对象被多个线程使用的过程中（写共享变量）。当发生问题时（处理器B看到 仅仅被处理器A“写了一半”的无效值），这里虽然处理器B读取到一个被写了一半的无效值，但这个值仍然是处理器A写入的，只不过是处理器A还没有写完而已。最小安全性保证<strong>线程读取到的值，要么是之前某个线程写入的值，要么是默认值</strong>（0、null、false）。但<strong>最小安全性并不保证 线程读取到的值，一定是某个线程写完后的值</strong>。最小安全性保证线程读取到的值不会无中生有的冒出来，但并不保证线程读取到的值一定是正确的。 图展示了这3类程序在JMM中与在顺序一致性内存模型中的执行结果的异同。 只要多线程程序是正确同步的，JMM保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。<br><img src="https://wx2.sbimg.cn/2020/07/07/C2wD7.png" alt="C2wD7.png"></p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><strong>对于Java内存模型的解读比较全面。对Java内存模型的了解也比较深入同时，当然这也有助于解决在Java并发编程中经常遇到的各种内存可见性问题。</strong></p>
<p>参考：<br>《Java并发编程的艺术》</p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】并发编程基础</title>
    <url>/2020/07/08/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(三）Java并发编程基础含线程简介/启动与终止线程/线程间通信</strong></p>
<a id="more"></a>
<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><blockquote>
<p>现代操作系统在运行一个程序时，会为其创建一个<strong>进程</strong>。例如，启动一个Java程序，操作系统就会创建一个<strong>Java进程</strong>。<strong>现代操作系统调度的最小单元是线程</strong>，也叫<strong>轻量级进程</strong>，在<strong>一个进程里可以创建多个线程</strong>，这些<strong>线程都拥有各自的计数器、堆栈和局 部变量等属性</strong>，并且能够访问共享的内存变量。处理器在这些线程上<strong>高速切换</strong>，让使用者感觉到这些线程在同时执行。</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span>&#123;</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 获取Java线程管理MXBean </span></span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean(); </span><br><span class="line">        <span class="comment">// 不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息 </span></span><br><span class="line">        ThreadInfo[] threadInfos =     threadMXBean.dumpAllThreads(<span class="literal">false</span>, <span class="literal">false</span>); </span><br><span class="line">        <span class="comment">// 遍历线程信息，仅打印线程ID和线程名称信息</span></span><br><span class="line">        <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"["</span> + threadInfo.getThreadId() + <span class="string">"] "</span> + threadInfo. getThreadName()); </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[<span class="number">4</span>] Signal Dispatcher <span class="comment">// 分发处理发送给JVM信号的线程 </span></span><br><span class="line">[<span class="number">3</span>] Finalizer <span class="comment">// 调用对象finalize方法的线程 </span></span><br><span class="line">[<span class="number">2</span>] Reference Handler <span class="comment">// 清除Reference的线程 </span></span><br><span class="line">[<span class="number">1</span>] main <span class="comment">// main线程，用户程序入口</span></span><br></pre></td></tr></table></figure>
<p>可以看到，一个Java程序的运行不仅仅是main()方法的运行，而是main线程和多个其他线程的同时运行。</p>
<h3 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h3><ul>
<li>更多的处理器核心；</li>
<li>更快的响应时间；</li>
<li>更好的编程模型。</li>
</ul>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><blockquote>
<p>现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。</p>
</blockquote>
<blockquote>
<p>在Java线程中，通过一个<strong>整型成员变量priority</strong>来控制优先级，<strong>优先级的范围从1~10</strong>，在线程构建的时候<strong>可以通过setPriority(int)方法</strong>来修改优先级，<strong>默认优先级是5</strong>，优先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较 低的优先级，确保处理器不会被独占。在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定，如示例代码所示：</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Priority</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> notStart = <span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> notEnd = <span class="literal">true</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws Exception </span>&#123;</span><br><span class="line">        List&lt;Job&gt; jobs = <span class="keyword">new</span> ArrayList&lt;Job&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">            <span class="keyword">int</span> priority = i &lt; <span class="number">5</span> Thread.MIN_PRIORITY : Thread.MAX_PRIORITY; </span><br><span class="line">            Job job = <span class="keyword">new</span> Job(priority); </span><br><span class="line">            jobs.add(job); </span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(job, <span class="string">"Thread:"</span> + i); thread.setPriority(priority); </span><br><span class="line">            thread.start(); </span><br><span class="line">        &#125;</span><br><span class="line">        notStart = <span class="literal">false</span>; </span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>); </span><br><span class="line">        notEnd = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">for</span> (Job job : jobs) &#123; </span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"Job Priority : "</span> + job.priority + <span class="string">", Count : "</span> + job.jobCount);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span> </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> jobCount;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">this</span>.priority = priority; </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">while</span> (notStart) &#123; </span><br><span class="line">                Thread.<span class="built_in">yield</span>(); </span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">while</span> (notEnd) &#123; </span><br><span class="line">                Thread.<span class="built_in">yield</span>(); </span><br><span class="line">                jobCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Job Priority :</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1259592</span> </span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1260717</span> </span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1264510</span> </span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1251897</span> </span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1264060</span></span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">10</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1256938</span> </span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">10</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1267663</span> </span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">10</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1260637</span> </span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">10</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1261705</span> </span><br><span class="line"><span class="attr">Job Priority :</span> <span class="number">10</span><span class="string">,</span> <span class="attr">Count :</span> <span class="number">1259967</span></span><br></pre></td></tr></table></figure>
<p><strong>从输出可以看到线程优先级没有生效，优先级1和优先级10的Job计数的结果非常相近，没有明显差距。这表示程序正确性不能依赖线程的优先级高低。</strong></p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>Java线程在运行的生命周期中的某个时刻处于其中的一个状态：<br><img src="https://wx1.sbimg.cn/2020/07/07/CCsqM.png" alt="CCsqM.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> TimeWaiting(), <span class="string">"TimeWaitingThread"</span>).start(); </span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Waiting(), <span class="string">"WaitingThread"</span>).start(); <span class="comment">// 使用两个Blocked线程，一个获取锁成功，另一个被阻塞 </span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-1"</span>).start(); </span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-2"</span>).start(); </span><br><span class="line">	&#125;<span class="comment">// 该线程不断地进行睡眠 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWaiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; <span class="meta">@Override</span> </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				SleepUtils.second(<span class="number">100</span>); </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;<span class="comment">// 该线程在Waiting.class实例上等待 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">			<span class="keyword">synchronized</span> (Waiting<span class="class">.<span class="keyword">class</span>) </span>&#123; </span><br><span class="line">				<span class="keyword">try</span> &#123;Waiting<span class="class">.<span class="keyword">class</span>.<span class="title">wait</span>()</span>; </span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace(); </span><br><span class="line">					&#125; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">&#125;<span class="comment">// 该线程在Blocked.class实例上加锁后，不会释放该锁 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Blocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (Blocked<span class="class">.<span class="keyword">class</span>) </span>&#123; </span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					SleepUtils.second(<span class="number">100</span>); </span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepUtils</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(<span class="keyword">long</span> seconds)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(seconds); </span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该示例，打开终端或者命令提示符，键入“jps”，输出如下:</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">611 </span></span><br><span class="line"><span class="symbol">935 </span>Jps </span><br><span class="line"><span class="symbol">929 </span>ThreadState </span><br><span class="line"><span class="number">270</span></span><br></pre></td></tr></table></figure>
<p>可以看到运行示例对应的进程ID是929，接着再键入“jstack 929”（这里的进程ID需要和读<br>者自己键入jps得出的ID一致），部分输出如下所示:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BlockedThread-2线程阻塞在获取Blocked.class示例的锁上</span></span><br><span class="line"><span class="string">"BlockedThread-2"</span> prio=<span class="number">5</span> tid=<span class="number">0</span>x00007feacb05d000 nid=<span class="number">0</span>x5d03 waiting <span class="keyword">for</span> monitor </span><br><span class="line">entry [<span class="number">0</span>x000000010fd58000] </span><br><span class="line">    java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: BLOCKED (on <span class="selector-tag">object</span> monitor) </span><br><span class="line"><span class="comment">// BlockedThread-1线程获取到了Blocked.class的锁 </span></span><br><span class="line"><span class="string">"BlockedThread-1"</span> prio=<span class="number">5</span> tid=<span class="number">0</span>x00007feacb05a000 nid=<span class="number">0</span>x5b03 waiting on condition </span><br><span class="line">[<span class="number">0</span>x000000010fc55000] </span><br><span class="line">    java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: TIMED_WAITING (sleeping) </span><br><span class="line"><span class="comment">// WaitingThread线程在Waiting实例上等待 </span></span><br><span class="line"><span class="string">"WaitingThread"</span> prio=<span class="number">5</span> tid=<span class="number">0</span>x00007feacb059800 nid=<span class="number">0</span>x5903 <span class="keyword">in</span> Object.wait() </span><br><span class="line">[<span class="number">0</span>x000000010fb52000] </span><br><span class="line">    java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: WAITING (on <span class="selector-tag">object</span> monitor) </span><br><span class="line"><span class="comment">// TimeWaitingThread线程处于超时等待 </span></span><br><span class="line"><span class="string">"TimeWaitingThread"</span> prio=<span class="number">5</span> tid=<span class="number">0</span>x00007feacb058800 nid=<span class="number">0</span>x5703 waiting on condition </span><br><span class="line">[<span class="number">0</span>x000000010fa4f000] </span><br><span class="line">    java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: TIMED_WAITING (sleeping)</span><br></pre></td></tr></table></figure>
<p>通过示例，我们了解到Java程序运行中线程状态的具体含义。线程在自身的生命周期中，并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变迁如图所示：</p>
<p><img src="https://wx2.sbimg.cn/2020/07/07/CCuhI.png" alt="CCuhI.png"></p>
<h3 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h3><p>Daemon线程是一种<strong>支持型线程</strong>，因为它<strong>主要被用作程序中后台调度以及支持性工作</strong>。这意味着，当一个Java虚拟机中<strong>不存在非Daemon线程的时候，Java虚拟机将会退出</strong>。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。注意Daemon属性需要在启动线程之前设置，不能在启动线程之后设置。 Daemon线程被用作完成支持性工作，<strong>但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行</strong>，示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daemon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonRunner(), <span class="string">"RaemonRunner"</span>);</span><br><span class="line">		thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				SleepUtils.second(<span class="number">10</span>);</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"DaemonRunner finally run"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果终端上没有任何输出。main线程在启动了线程DaemonRunner之后<strong>随着main方法执行完毕而终止</strong>，而此时Java虚拟机中已经没有非Daemon线程，虚拟机需要退出。Java虚拟机中的所有Daemon线程都需要立即终止，因此DaemonRunner立即终止，但是DaemonRunner中的finally块并没有执行。注意：<strong>在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑</strong>。</p>
<h2 id="启动和终止线程"><a href="#启动和终止线程" class="headerlink" title="启动和终止线程"></a>启动和终止线程</h2><h3 id="构造线程"><a href="#构造线程" class="headerlink" title="构造线程"></a>构造线程</h3><p>在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。代码摘自java.lang.Thread中对线程进行初始化的部分。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable <span class="keyword">target</span>, String name,<span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程就是该线程的父线程 </span></span><br><span class="line">    Thread parent = currentThread(); </span><br><span class="line">    <span class="keyword">this</span>.group = g; </span><br><span class="line">    <span class="comment">// 将daemon、priority属性设置为父线程的对应属性 this.daemon = parent.isDaemon(); </span></span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority(); </span><br><span class="line">    <span class="keyword">this</span>.name = name.toCharArray(); </span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>; setPriority(priority);</span><br><span class="line">    <span class="comment">//将父线程的InheritableThreadLocal复制过来 </span></span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>) <span class="keyword">this</span>.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent. inheritableThreadLocals); </span><br><span class="line">    <span class="comment">// 分配一个线程ID </span></span><br><span class="line">    tid = nextThreadID(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一个新构造的线程对象是由其parent线程来进行空间分配的</strong>，而<strong>child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal</strong>，同时<strong>还会分配一个唯一的ID来标识这个child线程</strong>。至此，一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。</p>
<h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><blockquote>
<p>线程对象在初始化完成之后，调用start()方法就可以启动这个线程。线程start()方法的含义是：<strong>当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程</strong>。注意:启动一个线程前，最好为这个线程设置线程名称，因为这样在使用jstack分析程 序或者进行问题排查时，就会给开发人员提供一些提示，自定义的线程最好能够起个名字。</p>
</blockquote>
<h3 id="理解中断"><a href="#理解中断" class="headerlink" title="理解中断"></a>理解中断</h3><p>中断可以理解为线程的一个<strong>标识位属性</strong>，它表示一个运行中的线程是否被其他线程进行了中断操作。其他线程通过调用该线程的interrupt() 方法对其进行中断操作。处于终结状态的线程，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。从Java的API中可以看到，许多声明抛出InterruptedException的方法（例如Thread.sleep(long millis)方法）这些方法在<strong>抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除</strong>，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。代码例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupted</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//不停进行休眠的线程</span></span><br><span class="line">		Thread sleepthread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SleepRunner(), <span class="string">"sleepthread"</span>);</span><br><span class="line">		sleepthread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">//不停进行工作的线程</span></span><br><span class="line">		Thread busythread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> BusyRunner(), <span class="string">"busythread"</span>);</span><br><span class="line">		busythread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		</span><br><span class="line">		sleepthread.start();</span><br><span class="line">		busythread.start();</span><br><span class="line">		<span class="comment">//休眠五秒，让两个线程充分运行</span></span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">		sleepthread.interrupt();</span><br><span class="line">		busythread.interrupt();</span><br><span class="line">		System.out.println(<span class="string">"SleepThread interrupted is: "</span>+sleepthread.isInterrupted());</span><br><span class="line">		System.out.println(<span class="string">"BusyThread interrupted is: "</span>+busythread.isInterrupted());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">				SleepUtils.second(<span class="number">10</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusyRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">SleepThread <span class="built_in">int</span>errupted <span class="keyword">is</span>: <span class="literal">false</span></span><br><span class="line">BusyThread <span class="built_in">int</span>errupted <span class="keyword">is</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>从结果可以看出，<strong>抛出InterruptedException的线程SleepThread，其中断标识位被清除了，而一直忙碌运作的线程BusyThread，中断标识位没有被清除。</strong></p>
<h3 id="过期的suspend-、resume-、stop"><a href="#过期的suspend-、resume-、stop" class="headerlink" title="过期的suspend()、resume()、stop()"></a>过期的suspend()、resume()、stop()</h3><p>暂停、恢复和停止操作对应在线程Thread的API就是suspend()、resume()和stop()。对应的实例</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line">import java.text.DateFormat;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> Delayed &#123;</span><br><span class="line">	public static void main(String<span class="literal">[]</span> args) throws InterruptedException &#123;</span><br><span class="line">	DateFormat format = <span class="keyword">new</span> <span class="constructor">SimpleDateFormat(<span class="string">"HH:MM:SS"</span>)</span>;</span><br><span class="line">	Thread thread = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">new</span> Runner()</span>, <span class="string">"PrintThread"</span>);</span><br><span class="line">	thread.set<span class="constructor">Daemon(<span class="params">true</span>)</span>;</span><br><span class="line">	thread.start<span class="literal">()</span>;</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">TimeUnit</span>.</span><span class="module"><span class="identifier">SECONDS</span>.</span></span>sleep(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//将Thread进行暂停，输出工作内容后停止</span></span><br><span class="line">	thread.suspend<span class="literal">()</span>;</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(thread.get<span class="constructor">Name()</span>+<span class="string">" run at "</span>+format.format(<span class="keyword">new</span> <span class="constructor">Date()</span>));</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">TimeUnit</span>.</span><span class="module"><span class="identifier">SECONDS</span>.</span></span>sleep(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//将Thread进行恢复，输出工作内容后恢复</span></span><br><span class="line">	thread.resume<span class="literal">()</span>;</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(thread.get<span class="constructor">Name()</span>+<span class="string">" resume at "</span>+format.format(<span class="keyword">new</span> <span class="constructor">Date()</span>));</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">TimeUnit</span>.</span><span class="module"><span class="identifier">SECONDS</span>.</span></span>sleep(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//将Thread进行停止，输出工作内容后停止</span></span><br><span class="line">	thread.stop<span class="literal">()</span>;</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(thread.get<span class="constructor">Name()</span>+<span class="string">" stop at "</span>+format.format(<span class="keyword">new</span> <span class="constructor">Date()</span>));</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">TimeUnit</span>.</span><span class="module"><span class="identifier">SECONDS</span>.</span></span>sleep(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	static <span class="keyword">class</span> Runner implements Runnable&#123;</span><br><span class="line">		public void run<span class="literal">()</span> &#123;</span><br><span class="line">			DateFormat format = <span class="keyword">new</span> <span class="constructor">SimpleDateFormat(<span class="string">"HH:MM:SS"</span>)</span>;</span><br><span class="line">			<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">" run at "</span>+format.format(<span class="keyword">new</span> <span class="constructor">Date()</span>));</span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">SleepUtils</span>.</span></span>second(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">PrintThread run at <span class="number">15</span>:<span class="number">07</span>:<span class="number">676</span></span><br><span class="line">PrintThread run at <span class="number">15</span>:<span class="number">07</span>:<span class="number">681</span></span><br><span class="line">PrintThread run at <span class="number">15</span>:<span class="number">07</span>:<span class="number">681</span></span><br><span class="line">PrintThread run at <span class="number">15</span>:<span class="number">07</span>:<span class="number">679</span></span><br><span class="line">PrintThread run at <span class="number">15</span>:<span class="number">07</span>:<span class="number">684</span></span><br><span class="line">PrintThread resume at <span class="number">15</span>:<span class="number">07</span>:<span class="number">684</span></span><br><span class="line">PrintThread run at <span class="number">15</span>:<span class="number">07</span>:<span class="number">689</span></span><br><span class="line">PrintThread run at <span class="number">15</span>:<span class="number">07</span>:<span class="number">693</span></span><br><span class="line">PrintThread stop at <span class="number">15</span>:<span class="number">07</span>:<span class="number">690</span></span><br></pre></td></tr></table></figure>
<p>在执行过程中，PrintThread运行了3秒，随后被暂停，3秒后恢复，最后经过3秒被终止。 通过示例的输出可以看到，suspend()、resume()和stop()方法完成了线程的暂停、恢复和终止工作，<strong>但是这些API是过期的，也就是不建议使用的</strong>。不建议使用的原因主要有：</p>
<ul>
<li>以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。</li>
<li>stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。 </li>
</ul>
<p>注意：正因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法，而<strong>暂停和恢复操作可以等待/通知机制来替代</strong>。</p>
<h3 id="安全地终止线程"><a href="#安全地终止线程" class="headerlink" title="安全地终止线程"></a>安全地终止线程</h3><p>中断状态是线程的一个标识位，而<strong>中断操作是一种简便的线程间交互方式</strong>，而这种交互方式最适合用来取消或停止任务。除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。实例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutDown</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Runner one = <span class="keyword">new</span> Runner();</span><br><span class="line">		Runner two = <span class="keyword">new</span> Runner();</span><br><span class="line">		Thread onethread = <span class="keyword">new</span> Thread(one, <span class="string">"onethread"</span>);</span><br><span class="line">		onethread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		onethread.start();</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		onethread.interrupt();</span><br><span class="line">		</span><br><span class="line">		Thread twothread = <span class="keyword">new</span> Thread(two, <span class="string">"twothread"</span>);</span><br><span class="line">		twothread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		twothread.start();</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		two.cancel();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"Count i = "</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			on = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Count i = <span class="number">466312256</span></span><br><span class="line">Count i = <span class="number">481484154</span></span><br></pre></td></tr></table></figure>
<p>示例在执行过程中，main线程通过中断操作和cancel()方法均可使thread得以终止。这种通过标识位或者中断操作的方式能够<strong>使线程在终止时有机会去清理资源，而不是武断地将线程停止</strong>，因此这种终止线程的做法显得更加安全。</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，这将会带来巨大的价值。</p>
<h3 id="volatile与synchronized关键字"><a href="#volatile与synchronized关键字" class="headerlink" title="volatile与synchronized关键字"></a>volatile与synchronized关键字</h3><p>Java支持多个线程同时访问一个对象或者对象的成员变量，由于每个线程可以拥有这个 变量的拷贝（虽然对象以及成员变量分配的内存是在共享内存中的，但是<strong>每个执行的线程还是可以拥有一份拷贝</strong>，这样做的目的是加速程序的执行，这是现代多核处理器的一个显著特性），所以程序在执行过程中，一个线程看到的变量并不一定是最新的。</p>
<ul>
<li>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。 </li>
</ul>
<p>举个例子：定义一个表示程序是否运行的成员变量boolean on=true，那么另一个线程可能对它执行关闭动作（on=false），这里涉及多个线程对变量的访问，因此需要将其定义成为 volatile boolean on＝true，这样其他线程对它进行改变时，可以让所有线程感知到变化，因为所有对on变量的访问和修改都需要以共享内存为准。但是，过多地使用volatile是不必要的，因为它会降低程序执行的效率。 </p>
<ul>
<li>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</li>
</ul>
<p>使用了同步块和同步方法，通过使用javap工具查看生成的class文件信息来分析synchronized关键字的实现细节，示例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronized</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//对synchronized加锁</span></span><br><span class="line">		<span class="keyword">synchronized</span> (Synchronized<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//同步静态方法，对该class的对象进行加锁</span></span><br><span class="line">		s();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Synchronized.class同级目录执行javap –v Synchronized.class，部分相关输出如下所示:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">1</span>                  <span class="comment">// class Second/Synchronized</span></span><br><span class="line">         <span class="number">2</span>: dup</span><br><span class="line">         <span class="number">3</span>: monitorenter</span><br><span class="line">         <span class="number">4</span>: monitorexit</span><br><span class="line">         <span class="number">5</span>: invokestatic  #<span class="number">16</span>                 <span class="comment">// Method s:()V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">5</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> static synchronized <span class="built_in">void</span> s();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0029</span>) ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>上面class信息中，对于同步块的实现使用了monitorenter和monitorexit指令，而同步方法则是依靠方法修饰符上的ACC_SYNCHRONIZED来完成的。无论采用哪种方式，其本质是<strong>对一个对象的监视器（monitor）进行获取</strong>，而这个获取过程是排他的，也就是<strong>同一时刻只能有一个线程获取到由synchronized所保护对象的监视器</strong>。任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器（执行该方法）的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED 状态。下图描述了对象、对象的监视器、同步队列和执行线程之间的关系：<br><img src="https://wx2.sbimg.cn/2020/07/08/C3tn2.png" alt="C3tn2.png"></p>
<h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h3><blockquote>
<p>一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程<strong>开始于一个线程，而最终执行又是另一个线程</strong>。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），在功能层面上实现了解耦体系结构上具备了良好的伸缩性，但是在Java语言中如何实现类似的功能呢？<br>等待/通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类java.lang.Object上，方法和描述如表所示：<br><a href="https://sbimg.cn/image/C3NYe" target="_blank" rel="noopener"><img src="https://wx2.sbimg.cn/2020/07/08/C3NYe.png" alt="C3NYe.png"></a></p>
</blockquote>
<p>等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同<strong>开关信号</strong>一样，用来完成等待方和通知方之间的交互工作。</p>
<p>实例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> WaitNotify &#123;</span><br><span class="line"></span><br><span class="line">	static boolean flag = <span class="literal">true</span>;</span><br><span class="line">	static Object lock = <span class="keyword">new</span> <span class="constructor">Object()</span>;</span><br><span class="line">	public static void main(String<span class="literal">[]</span> args) throws InterruptedException &#123;</span><br><span class="line">		Thread wait = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">new</span> Wait()</span>, <span class="string">"waitThread"</span>);</span><br><span class="line">		wait.start<span class="literal">()</span>;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">TimeUnit</span>.</span><span class="module"><span class="identifier">SECONDS</span>.</span></span>sleep(<span class="number">2</span>);</span><br><span class="line">		Thread Notify = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">new</span> Notify()</span>, <span class="string">"notifyThred"</span>);</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Notify</span>.</span></span>start<span class="literal">()</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	static <span class="keyword">class</span> Wait implements Runnable&#123;</span><br><span class="line">		public void run<span class="literal">()</span> &#123;</span><br><span class="line">			<span class="comment">//加锁的monitor</span></span><br><span class="line">			synchronized(lock) &#123;</span><br><span class="line">				<span class="comment">//条件不足时，继续wait 释放锁</span></span><br><span class="line">				<span class="keyword">while</span>(flag) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>+<span class="string">"flag is true, wait on "</span>+<span class="keyword">new</span> <span class="constructor">SimpleDateFormat(<span class="string">"HH:MM:SS"</span>)</span>.format(<span class="keyword">new</span> <span class="constructor">Date()</span>));</span><br><span class="line">						lock.wait<span class="literal">()</span>;</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//条件满足时完成任务</span></span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>+<span class="string">"flag is false, wait on "</span>+<span class="keyword">new</span> <span class="constructor">SimpleDateFormat(<span class="string">"HH:MM:SS"</span>)</span>.format(<span class="keyword">new</span> <span class="constructor">Date()</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	static <span class="keyword">class</span> Notify implements Runnable&#123;</span><br><span class="line">		public void run<span class="literal">()</span> &#123;</span><br><span class="line">			<span class="comment">//拥有加锁的monitor</span></span><br><span class="line">			synchronized(lock) &#123;</span><br><span class="line">				<span class="comment">//获取lock的锁然后进行通知，通知时不会释放lock的锁</span></span><br><span class="line">				<span class="comment">//知道线程释放了lock之后 Wait线程才能从wait方法中返回</span></span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>+<span class="string">"Hold lock notify "</span>+<span class="keyword">new</span> <span class="constructor">SimpleDateFormat(<span class="string">"HH:MM:SS"</span>)</span>.format(<span class="keyword">new</span> <span class="constructor">Date()</span>));</span><br><span class="line">				lock.notify<span class="constructor">All()</span>;</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">SleepUtils</span>.</span></span>second(<span class="number">5</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//再次加锁</span></span><br><span class="line">			synchronized(lock) &#123;</span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>+<span class="string">"Hold lock again and sleep"</span>+<span class="keyword">new</span> <span class="constructor">SimpleDateFormat(<span class="string">"HH:MM:SS"</span>)</span>.format(<span class="keyword">new</span> <span class="constructor">Date()</span>));</span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">SleepUtils</span>.</span></span>second(<span class="number">5</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行的结果如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Thread[waitThread,<span class="number">5</span>,main]flag <span class="keyword">is</span> <span class="literal">true</span>, wait on <span class="number">20</span>:<span class="number">07</span>::<span class="number">698</span></span><br><span class="line">Thread[notifyThred,<span class="number">5</span>,main]Hold lock notify <span class="number">20</span>:<span class="number">07</span>:<span class="number">596</span></span><br><span class="line">Thread[notifyThred,<span class="number">5</span>,main]Hold lock again <span class="keyword">and</span> sleep20:<span class="number">07</span>:<span class="number">601</span></span><br><span class="line">Thread[waitThread,<span class="number">5</span>,main]flag <span class="keyword">is</span> <span class="literal">false</span>, wait on <span class="number">20</span>:<span class="number">07</span>:<span class="number">605</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述第3行和第4行输出的顺序可能会互换，而上述例子主要说明了调用wait()、notify()以 及notifyAll()时需要注意的细节，如下:</p>
<ul>
<li>使用wait()、notify()和notifyAll()时需要先对调用对象加锁。</li>
<li>调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。</li>
<li>notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。</li>
<li>notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为获得了调用对象的锁。</li>
</ul>
</blockquote>
<blockquote>
<p>从上述细节中可以看到，等待/通知机制依托于同步机制，其目的就是确保等待线程从wait()方法返回时能够感知到通知线程对变量做出的修改。</p>
</blockquote>
<p>过程图：<br><a href="https://sbimg.cn/image/C9GsM" target="_blank" rel="noopener"><img src="https://wx1.sbimg.cn/2020/07/08/C9GsM.png" alt="C9GsM.png"></a><br>WaitThread首先获取了对象的锁，然后调用对象的wait()方法，从而放弃了锁并进入了对象的等待队列WaitQueue中，进入等待状态。由于WaitThread释放了对象的锁，NotifyThread随后获取了对象的锁，并调用对象的notify()方法，将WaitThread从WaitQueue移到SynchronizedQueue中，此时WaitThread的状态变为阻塞状态。NotifyThread释放了锁之后，WaitThread再次获取到锁并从wait()方法返回继续执行。</p>
<h3 id="等待-通知的基本范式"><a href="#等待-通知的基本范式" class="headerlink" title="等待/通知的基本范式"></a>等待/通知的基本范式</h3><p>等待/通知的经典范式，该范式分为两部分，分别针对等待方（消费者）和通知方（生产者）。<br><strong>等待方遵循如下原则：</strong>   </p>
<blockquote>
<ul>
<li>获取对象的锁;</li>
<li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</li>
<li>条件满足则执行对应的逻辑。 </li>
</ul>
</blockquote>
<p>对应的伪代码如下:</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">synchronized</span>(对象)&#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不满足)&#123;</span><br><span class="line">        对象.<span class="built_in">wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通知方遵循如下原则:</strong> </p>
<blockquote>
<ul>
<li>获得对象的锁。 </li>
<li>改变条件。 </li>
<li>通知所有等待在对象上的线程。</li>
</ul>
</blockquote>
<p>对应的伪代码如下:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">    改变条件<span class="comment">;</span></span><br><span class="line">    对象.notifyAll()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入/输出流"></a>管道输入/输出流</h3><p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它<strong>主要用于线程之间的数据传输，而传输的媒介为内存</strong>。管道输入/输出流主要包括了如下4种具体实现：<strong>PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter，前两种面向字节，而后两种面向字符</strong>。 </p>
<p>实例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">		PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">		PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">		<span class="comment">//将输入输出流进行连接，否则会抛出IOException</span></span><br><span class="line">		out.<span class="built_in">connect</span>(in);</span><br><span class="line">		Thread printthread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">"PrintThread"</span>);</span><br><span class="line">		printthread.start();</span><br><span class="line">		<span class="keyword">int</span> received = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span>((received = System.in.<span class="built_in">read</span>())!=<span class="number">-1</span>) &#123;</span><br><span class="line">				out.<span class="built_in">write</span>(received);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			out.<span class="built_in">close</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line">		PipedReader in;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.in = in;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> received = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">while</span>((received = in.<span class="built_in">read</span>())!=<span class="number">-1</span>) &#123;</span><br><span class="line">					System.out.<span class="built_in">print</span>((<span class="keyword">char</span>)received);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">catch</span>(IOException e) &#123;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Easonhe</span></span><br><span class="line"><span class="attribute">Easonhe</span></span><br></pre></td></tr></table></figure>
<p>例子中创建了printThread，它用来接受main线程的输入，任何main线程的输入均通过PipedWriter写入，而printThread在另一端通过PipedReader将内容读出并打印。对于Piped类型的流，<strong>必须先要进行绑定</strong>，也就是调用connect()方法，如果没有将输入/输出流绑定起来，对于该流的访问将会抛出异常。</p>
<h3 id="Thread-join-的使用"><a href="#Thread-join-的使用" class="headerlink" title="Thread.join()的使用"></a>Thread.join()的使用</h3><p>如果一个线程A执行了thread.join()语句，其含义是：<strong>当前线程A等待thread线程终止之后才从thread.join()返回</strong>。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。这两个超时方法表示，<strong>如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回</strong>。 </p>
<p>实例代码如下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="keyword">Join</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">	Thread <span class="keyword">previous</span> = Thread.currentThread();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">		Thread domino = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Domino(<span class="keyword">previous</span>), String.valueOf(i));</span><br><span class="line">		domino.start();</span><br><span class="line">		<span class="keyword">previous</span> = domino;			</span><br><span class="line">	&#125;</span><br><span class="line">	TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">	System.out.<span class="keyword">println</span>(Thread.currentThread().getName()+<span class="string">" terminate"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> Domino <span class="keyword">implements</span> Runnable&#123;</span><br><span class="line">	    <span class="comment">//每一个线程拥有前一个线程的引用，需要等待前一个线程的终止才能从wait中返回</span></span><br><span class="line">		Thread <span class="keyword">previous</span>;</span><br><span class="line">		<span class="keyword">public</span> Domino(Thread <span class="keyword">previous</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.<span class="keyword">previous</span> = <span class="keyword">previous</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">previous</span>.<span class="keyword">join</span>();</span><br><span class="line">			&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.<span class="keyword">println</span>(Thread.currentThread().getName()+<span class="string">" terminate"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果如下：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">main <span class="keyword">terminate</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">terminate</span></span><br><span class="line"><span class="number">9</span> <span class="keyword">terminate</span></span><br></pre></td></tr></table></figure>
<p>从上述输出可以看到，每个线程终止的前提是前驱线程的终止，每个线程等待前驱线程终止后，才从join()方法返回，这里涉及了等待/通知机制（等待前驱线程结束，接收前驱线程结束通知）。</p>
<p>JDK中Thread.join()方法的源码（进行了部分调整）:</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁当前线程对象 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;     <span class="comment">// 条件不满足，继续等待 </span></span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123; </span><br><span class="line">        wait(<span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件符合，方法返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当线程终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程。可以看到join()方法的逻辑结构与等待/通知经典范式一致，即加锁、循环和处理逻辑3个步骤。</p>
<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>ThreadLocal，即<strong>线程变量</strong>，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p>
<p>实例代码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		TIME_THREADLOCAL.<span class="built_in">set</span>(System.currentTimeMillis());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.<span class="built_in">get</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;</span><br><span class="line">		Profiler.<span class="built_in">begin</span>();</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"cost : "</span>+Profiler.<span class="built_in">end</span>()+<span class="string">" mills."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cost :</span> <span class="number">1003</span> <span class="string">mills.</span></span><br></pre></td></tr></table></figure>
<p>Profiler可以被复用在方法调用耗时统计的功能上，在方法的入口前执行begin()方法，在方法调用后执行end()方法，好处是两个方法的调用不用在一个方法或者类中，比如在AOP（面向方面编程）中，可以在方法调用前的切入点执行begin()方法，而在方法调用后的切入点执行end()方法，这样依旧可以获得方法的执行耗时。</p>
<h2 id="线程应用实例"><a href="#线程应用实例" class="headerlink" title="线程应用实例"></a>线程应用实例</h2><h3 id="等待超时模式"><a href="#等待超时模式" class="headerlink" title="等待超时模式"></a>等待超时模式</h3><p><strong>经典问题</strong>：调用一个方法时等待一段时间（一般来说是给定一个时间段），如果该方法能够在给定的时间段之内得到结果，那么将结果立刻返回，反之，超时返回默认结果。前面的章节介绍了等待/通知的经典范式，即加锁、条件循环和处理逻辑3个步骤，而这种范式无法做到超时等待。，只需要对经典范式做出非常小的改动，就能实现超时等待的加入。</p>
<p><strong>改动内容</strong><br>假设超时时间段是T，那么可以推断出在当前时间now+T之后就会超时。定义如下变量：<strong>等待持续时间：REMAINING=T</strong>。<strong>超时时间：FUTURE=now+T</strong>。 <strong>这时仅需要wait(REMAINING)即可，在wait(REMAINING)返回之后会将执行： REMAINING=FUTURE–now。如果REMAINING小于等于0，表示已经超时，直接退出，否则将 继续执行wait(REMAINING)。</strong></p>
<p>等待超时模式的伪代码如下：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对当前对象加锁 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">Object</span> <span class="built_in">get</span>(<span class="keyword">long</span> mills) <span class="keyword">throws</span> InterruptedException &#123; </span><br><span class="line">    <span class="keyword">long</span> future = System.currentTimeMillis() + mills; </span><br><span class="line">    <span class="keyword">long</span> remaining = mills<span class="comment">//当超时大于0并且result返回值不满足要求</span></span><br><span class="line">    <span class="keyword">while</span> ((result == <span class="keyword">null</span>) &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wait(remaining);</span><br><span class="line">    remaining = future - System.currentTimeMillis(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，等待超时模式就是在等待/通知范式基础上增加了超时控制，这使得该模式相比原有范式更具有灵活性，因为即使方法执行时间过长，也不会“永久”阻塞调用者，而是会按照调用者的要求“按时”返回。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>多线程技术带来了好处有很多，并且讲述了如何启动和终止线程以及线程的状态，详细阐述了多线程之间进行通信的基本方式和等待/通知经典范式</strong>。</p>
<p><strong>参考</strong>：    </p>
<p>《Java并发编程的艺术》</p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】锁</title>
    <url>/2020/07/09/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E9%94%81/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(四）锁含Lock接口/队列同步器/重入锁/读写锁/LockSupport工具/Condition接口</strong></p>
<a id="more"></a>
<h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p><strong>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）</strong>。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了<strong>锁获取与释放的可操作性、可中断的获取锁以 及超时获取锁</strong>等多种synchronized关键字所不具备的同步特性。使用synchronized关键字将会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先 获取再释放。当然，这种方式简化了同步的管理，可是<strong>扩展性没有显示的锁获取和释放来的好</strong>。例如，针对一个场景，手把手进行锁获取和释放，先获得锁A，然后再获取锁B，当锁B获得后，释放锁A同时获取锁C，当锁C获得后，再释放B同时获取锁D，以此类推。这种场景下，synchronized关键字就不那么容易实现了，而使用Lock却容易许多。</p>
<p>实例代码：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Lock</span> <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock()<span class="comment">;</span></span><br><span class="line"><span class="keyword">lock</span>.<span class="keyword">lock</span>()<span class="comment">;</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    <span class="keyword">lock</span>.unlock()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放</strong>。 不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放**。</p>
<p>Lock接口提供的synchronized关键字所不具备的主要特性如表所示:<br><img src="https://wx2.sbimg.cn/2020/07/09/CB0in.png" alt="CB0in.png"></p>
<p>Lock是一个接口，它定义了锁获取和释放的基本操作，Lock的API如表所示:<br><img src="https://wx1.sbimg.cn/2020/07/09/CBCMh.png" alt="CBCMh.png"><br>Lock接口的实现基本都是通过聚合了一个同步器的子类来完成线程访问控制的。</p>
<h2 id="队列同步器"><a href="#队列同步器" class="headerlink" title="队列同步器"></a>队列同步器</h2><p>队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来<strong>构建锁或者其他同步组件的基础框架</strong>，<strong>它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作</strong>，并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。</p>
<p><strong>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态</strong>，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3 个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操 作，因为它们能够保证状态的改变是安全的。<strong>子类推荐被定义为自定义同步组件的静态内部类</strong>，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，<strong>同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态</strong>，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。 </p>
<p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，<strong>利用同步器实现锁的语义</strong>。可以这样理解二者之间的关系：</p>
<ul>
<li>锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；</li>
<li>同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</li>
</ul>
<h3 id="队列同步器的接口与示例"><a href="#队列同步器的接口与示例" class="headerlink" title="队列同步器的接口与示例"></a>队列同步器的接口与示例</h3><p>同步器的设计是<strong>基于模板方法模式</strong>的，也就是说，<strong>使用者需要继承同步器并重写指定的方法</strong>，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。重写同步器指定的方法时，<strong>需要使用同步器提供的如下3个方法来访问或修改同步状态</strong>。 </p>
<blockquote>
<p>1 .getState()：获取当前同步状态。<br>2 .setState(int newState)：设置当前同步状态。<br>3 .compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态 设置的原子性。 </p>
</blockquote>
<p>同步器可重写的方法与描述如表所示:<br><img src="https://wx2.sbimg.cn/2020/07/09/CBA2T.png" alt="CBA2T.png"><br><strong>实现自定义同步组件时，将会调用同步器提供的模板方法</strong>，这些（部分）模板方法与描述如表所示:<br><img src="https://wx2.sbimg.cn/2020/07/09/CBRno.png" alt="CBRno.png"><br>同步器提供的模板方法基本上分为3类：</p>
<ul>
<li>独占式获取与释放同步状态</li>
<li>共享式获取与释放</li>
<li>同步状态和查询同步队列中的等待线程情况</li>
</ul>
<p>自定义同步组件将使用同步器提供的模板方法来实现自己的同步语义。</p>
<p>实例代码展示独占锁：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 静态内部类，自定义同步器 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123; <span class="comment">// 是否处于占用状态 </span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当状态为0的时候获取锁 </span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread()); <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放锁，将状态设置为0 </span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(); setExclusiveOwnerThread(<span class="keyword">null</span>); </span><br><span class="line">            setState(<span class="number">0</span>); </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列 </span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 仅需要将操作代理到Sync上即可 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; sync.acquire(<span class="number">1</span>); &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123; <span class="function"><span class="keyword">return</span> sync.<span class="title">tryAcquire</span><span class="params">(<span class="number">1</span>)</span></span>; &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; sync.release(<span class="number">1</span>); &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="function"><span class="keyword">return</span> sync.<span class="title">newCondition</span><span class="params">()</span></span>; &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="function"><span class="keyword">return</span> sync.<span class="title">isHeldExclusively</span><span class="params">()</span></span>; &#125; <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; <span class="function"><span class="keyword">return</span> sync.<span class="title">hasQueuedThreads</span><span class="params">()</span></span>; &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; sync.acquireInterruptibly(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout)); &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述示例中，独占锁Mutex是一个自定义同步组件，它在<strong>同一时刻只允许一个线程占有锁</strong>。Mutex中定义了一个静态内部类，该内部类继承了同步器并实现了独占式获取和释放同步状态。在tryAcquire(int acquires)方法中，如果经过CAS设置成功（同步状态设置为1），则代表获 取了同步状态，而在tryRelease(int releases)方法中只是将同步状态重置为0。用户使用Mutex时并不会直接和内部同步器的实现打交道，而是调用Mutex提供的方法，在Mutex的实现中，以获取锁的lock()方法为例，只需要在方法实现中调用同步器的模板方法acquire(int args)即可，当前线程调用该方法获取同步状态失败后会被加入到同步队列中等待，这样就大大降低了实现一个可靠自定义同步组件的门槛。</p>
<h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对 资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。这里提到一个锁获取的公平性问题，<strong>如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的</strong>，反之，是不公平的。公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。事实上，公平的锁机制往往没有非公平的效率高，但是，并不是任何场景都是以TPS作为唯一的指标，公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。</p>
<h3 id="实现重进入"><a href="#实现重进入" class="headerlink" title="实现重进入"></a>实现重进入</h3><p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题：</p>
<ul>
<li>线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</li>
<li>锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。</li>
</ul>
<p><strong>锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。 ReentrantLock是通过组合自定义同步器来实现锁的获取与释放，以非公平性（默认的）实现为例</strong>，</p>
<p>获取同步状态的实例代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">final boolean nonfair<span class="constructor">TryAcquire(<span class="params">int</span> <span class="params">acquires</span>)</span> &#123; </span><br><span class="line">    final Thread current = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>; </span><br><span class="line">    <span class="built_in">int</span> c = get<span class="constructor">State()</span>; </span><br><span class="line">    <span class="keyword">if</span> (c<span class="operator"> == </span><span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> (compare<span class="constructor">AndSetState(0, <span class="params">acquires</span>)</span>) &#123;</span><br><span class="line">            set<span class="constructor">ExclusiveOwnerThread(<span class="params">current</span>)</span>; </span><br><span class="line">            return <span class="literal">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current<span class="operator"> == </span>get<span class="constructor">ExclusiveOwnerThread()</span>) &#123; </span><br><span class="line">        <span class="built_in">int</span> nextc = c + acquires; </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) throw <span class="keyword">new</span> <span class="constructor">Error(<span class="string">"Maximum lock count exceeded"</span>)</span>; </span><br><span class="line">            set<span class="constructor">State(<span class="params">nextc</span>)</span>; </span><br><span class="line">            return <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。</p>
</blockquote>
<p>成功获取锁的线程再次获取锁，只是增加了同步状态值，这也就要求ReentrantLock在释放同步状态时减少同步状态值，该方法的代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected final boolean <span class="keyword">try</span><span class="constructor">Release(<span class="params">int</span> <span class="params">releases</span>)</span> &#123; </span><br><span class="line">    <span class="built_in">int</span> c = get<span class="constructor">State()</span> - releases; </span><br><span class="line">    <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span> != get<span class="constructor">ExclusiveOwnerThread()</span>) throw <span class="keyword">new</span> <span class="constructor">IllegalMonitorStateException()</span>; </span><br><span class="line">    boolean free = <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">if</span> (c<span class="operator"> == </span><span class="number">0</span>) &#123; </span><br><span class="line">        free = <span class="literal">true</span>; </span><br><span class="line">        set<span class="constructor">ExclusiveOwnerThread(<span class="params">null</span>)</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    set<span class="constructor">State(<span class="params">c</span>)</span>; </span><br><span class="line">    return free; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。公平锁代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected final boolean <span class="keyword">try</span><span class="constructor">Acquire(<span class="params">int</span> <span class="params">acquires</span>)</span> &#123; </span><br><span class="line">    final Thread current = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>; </span><br><span class="line">    <span class="built_in">int</span> c = get<span class="constructor">State()</span>; </span><br><span class="line">    <span class="keyword">if</span> (c<span class="operator"> == </span><span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> (!has<span class="constructor">QueuedPredecessors()</span><span class="operator"> &amp;&amp; </span>compare<span class="constructor">AndSetState(0, <span class="params">acquires</span>)</span>) &#123; </span><br><span class="line">            set<span class="constructor">ExclusiveOwnerThread(<span class="params">current</span>)</span>;</span><br><span class="line">            return <span class="literal">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current<span class="operator"> == </span>get<span class="constructor">ExclusiveOwnerThread()</span>) &#123; </span><br><span class="line">        <span class="built_in">int</span> nextc = c + acquires; </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) throw <span class="keyword">new</span> <span class="constructor">Error(<span class="string">"Maximum lock count exceeded"</span>)</span>;</span><br><span class="line">        set<span class="constructor">State(<span class="params">nextc</span>)</span>; </span><br><span class="line">        return <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为<strong>判断条件多了 hasQueuedPredecessors()方法</strong>，即加入了同步队列中当前节点<strong>是否有前驱节点</strong>的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p>
<p>公平和非公平锁在获取锁时的区别的代码实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairAndUnfairTest</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock fairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">true</span>); <span class="keyword">private</span> <span class="keyword">static</span> Lock unfairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">false</span>); <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fair</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        testLock(fairLock); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfair</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        testLock(unfairLock); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">(Lock lock)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 启动5个Job（略） </span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">        <span class="keyword">private</span> Lock lock; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(Lock lock)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 连续2次打印当前的Thread和等待队列中的Thread（略） </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock2</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock2</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(fair);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        List&lt;Thread&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="keyword">super</span>. getQueuedThreads()); </span><br><span class="line">        Collections.reverse(arrayList); </span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：<br><img src="https://wx2.sbimg.cn/2020/07/10/CRQQ6.png" alt="CRQQ6.png"><br>在测试中公平性锁与非公平性锁相比，总耗时是其94.3倍，总切换次数是其133倍。可以 看出，公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>之前提到锁（如Mutex和ReentrantLock）基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而<strong>读写锁在同一时刻可以允许多个读线程访问</strong>，但是<strong>在写线程访问时，所有的读线程和其他写线程均被阻塞</strong>。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p>
<p>一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在<strong>读多于写的情况下</strong>，<strong>读写锁能够提供比排它锁更好的并发性和吞吐量</strong>。Java并发包提供读写锁的实现是ReentrantReadWriteLock，它提供的特性如表所示：<br><img src="https://wx1.sbimg.cn/2020/07/10/CRAzO.png" alt="CRAzO.png"></p>
<h3 id="读写锁的接口与示例"><a href="#读写锁的接口与示例" class="headerlink" title="读写锁的接口与示例"></a>读写锁的接口与示例</h3><p>ReadWriteLock仅定义了获取读锁和写锁的两个方法，即readLock()方法和writeLock()方 法，而其实现——ReentrantReadWriteLock，除了接口方法之外，还提供了一些便于外界监控其内部工作状态的方法，这些方法以及描述如表所示。<br><img src="https://wx2.sbimg.cn/2020/07/10/CRBOe.png" alt="CRBOe.png"><br>读写锁的实例代码：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.<span class="keyword">HashMap</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Cache &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span> , <span class="keyword">Object</span>&gt;();</span><br><span class="line">	<span class="keyword">static</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">	<span class="keyword">static</span> Lock r = lock.readLock();</span><br><span class="line">	<span class="keyword">static</span> Lock w = lock.writeLock();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span> <span class="built_in">get</span>(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">		r.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			r.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置key所对应的value并返回旧的value</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span> <span class="built_in">set</span>(<span class="keyword">String</span> <span class="built_in">key</span>, <span class="keyword">Object</span> obj) &#123;</span><br><span class="line">		w.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">map</span>.put(<span class="built_in">key</span>, obj);</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			w.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//清空所有内容</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="built_in">clear</span>() &#123;</span><br><span class="line">		w.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="built_in">map</span>.<span class="built_in">clear</span>();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			w.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述示例中，Cache组合一个非线程安全的HashMap作为缓存的实现，同时使用读写锁的读锁和写锁来保证Cache是线程安全的。<strong>Cache使用读写锁提升读操作的并发性，也保证每次写操作对所有的读写操作的可见性，同时简化了编程方式。</strong></p>
</blockquote>
<h2 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h2><p>当需要阻塞或唤醒一个线程的时候，都会使用LockSupport工具类来完成相应工作。LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。</p>
<p>LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread) 方法来唤醒一个被阻塞的线程。Park有停车的意思，假设线程为车辆，那么park方法代表着停车，而unpark方法则是指车辆启动离开，这些方法以及描述如表所示。<br><img src="https://wx2.sbimg.cn/2020/07/10/CRduN.png" alt="CRduN.png"></p>
<blockquote>
<p>LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos) 和parkUntil(Object blocker,long deadline)3个方法，用于实现阻塞当前线程的功能，其中参数blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和系统监控。 下面的示例中，将对比parkNanos(long nanos)方法和parkNanos(Object blocker,long nanos)方 法来展示阻塞对象blocker的用处，代码片段和线程dump（部分）如表5-11所示。 从表的线程dump结果可以看出，代码片段的内容都是阻塞当前线程10秒，但从线程 dump结果可以看出，有阻塞对象的parkNanos方法能够传递给开发人员更多的现场信息。这是 由于在Java 5之前，当线程阻塞（使用synchronized关键字）在一个对象上时，通过线程dump能够查看到该线程的阻塞对象，方便问题定位，而Java 5推出的Lock等并发工具时却遗漏了这一点，致使在线程dump时无法提供阻塞对象的信息。因此，在Java 6中，LockSupport新增了上述3个含有阻塞对象的park方法，用以替代原有的park方法。<br><img src="https://wx1.sbimg.cn/2020/07/10/CRg8j.png" alt="CRg8j.png"></p>
</blockquote>
<h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以<strong>实现等待/通知模式</strong>。Condition接口也提供了类似Object的监视器方法，与<strong>Lock配合可以实现等待/通知模式</strong>，但是这两者在使用方式以及功能特性上还是有差别的。通过对比Object的监视器方法和Condition接口，可以更详细地了解Condition的特性，对比项与结果如表所示:<br><img src="https://wx2.sbimg.cn/2020/07/10/CRspk.png" alt="CRspk.png"></p>
<h3 id="Condition接口与实例"><a href="#Condition接口与实例" class="headerlink" title="Condition接口与实例"></a>Condition接口与实例</h3><p>Condition的使用方式比较简单，需要注意在调用方法前获取锁，使用方式如代码所示：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line">Condition condition = <span class="keyword">lock</span>.newCondition(); </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionWait</span>(<span class="params"></span>) throws InterruptedException</span> &#123;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>(); </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        condition.<span class="keyword">await</span>(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="keyword">lock</span>.unlock(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span>(<span class="params"></span>) throws InterruptedException</span> &#123;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>(); </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        condition.signal(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如示例所示，一般都会将Condition对象作为成员变量。当调用await()方法后，当前线程会<strong>释放锁并在此等待</strong>，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p>
</blockquote>
<p>Condition定义的（部分）方法以及描述如表所示:<br><img src="https://wx1.sbimg.cn/2020/07/10/CRJgn.png" alt="CRJgn.png"><br>获取一个Condition必须通过Lock的newCondition()方法。下面通过一个有界队列的示例来深入了解Condition的使用方式:</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">public class BoundedQueue&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] <span class="built_in">items</span>; <span class="comment">//添加的下标，删除的下标和数组当前数量 </span></span><br><span class="line">    <span class="keyword">private</span> int addIndex, removeIndex, <span class="built_in">count</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">Lock</span> <span class="built_in">lock</span> = new ReentrantLock(); </span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = <span class="built_in">lock</span>.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition notFull = <span class="built_in">lock</span>.newCondition(); </span><br><span class="line">    public BoundedQueue(int <span class="built_in">size</span>) &#123; </span><br><span class="line">        <span class="built_in">items</span> = new Object[<span class="built_in">size</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加一个元素，如果数组满，则添加线程进入等待状态，直到有"空位" </span></span><br><span class="line">    public void add(T t) throws InterruptedException &#123;</span><br><span class="line">        <span class="built_in">lock</span>.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">count</span> == <span class="built_in">items</span>.length) </span><br><span class="line">            notFull.await(); </span><br><span class="line">        <span class="built_in">items</span>[addIndex] = t;</span><br><span class="line">        <span class="keyword">if</span> (++addIndex == <span class="built_in">items</span>.length)</span><br><span class="line">            addIndex = <span class="number">0</span>;</span><br><span class="line">        ++<span class="built_in">count</span>; </span><br><span class="line">        notEmpty.signal(); </span><br><span class="line">        &#125; finally &#123; </span><br><span class="line">            <span class="built_in">lock</span>.unlock(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素 </span></span><br><span class="line">    public T remove() throws InterruptedException &#123;</span><br><span class="line">        <span class="built_in">lock</span>.<span class="built_in">lock</span>(); </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">count</span> == <span class="number">0</span>) </span><br><span class="line">                    notEmpty.await(); </span><br><span class="line">                Object x = <span class="built_in">items</span>[removeIndex]; </span><br><span class="line">                <span class="keyword">if</span> (++removeIndex == <span class="built_in">items</span>.length) </span><br><span class="line">                    removeIndex = <span class="number">0</span>; </span><br><span class="line">                --<span class="built_in">count</span>; </span><br><span class="line">                notFull.signal(); </span><br><span class="line">                return (T) x; </span><br><span class="line">            &#125; finally &#123; </span><br><span class="line">                <span class="built_in">lock</span>.unlock(); </span><br><span class="line">            &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述示例中，BoundedQueue通过add(T t)方法添加一个元素，通过remove()方法移出一个 元素。以添加方法为例。首先需要获得锁，目的是确保数组修改的可见性和排他性。当数组数量等于数组长度时，表示数组已满，则调用notFull.await()，当前线程随之释放锁并进入等待状态。如果数组数量不等于数组长度，表示数组未满，则添加元素到数组中，同时通知等待在notEmpty上的线程，数 组中已经有新元素可以获取。在添加和删除方法中使用while循环而非if判断，目的是防止过早或意外的通知，只有条件符合才能够退出循环。回想之前提到的等待/通知的经典范式，二者是非常类似的。</p>
<p>参考：<br><strong>《Java并发编程的艺术》</strong></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】线程池</title>
    <url>/2020/07/14/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(八）线程池含线程池的原理及使用</strong></p>
<a id="more"></a>
<p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序 都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处：</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 </li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 </li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>
</ul>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p><img src="https://wx2.sbimg.cn/2020/07/14/CHV1j.png" alt="CHV1j.png"></p>
<p>从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下：</p>
<ul>
<li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作 线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li>
<li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这 个工作队列里。如果工作队列满了，则进入下个流程。 </li>
<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程 来执行任务。如果已经满了，则交给饱和策略来处理这个任务。 </li>
</ul>
<p>ThreadPoolExecutor执行execute()方法的示意图，如图所示：</p>
<p><img src="https://wx1.sbimg.cn/2020/07/14/CK5vM.png" alt="CK5vM.png"></p>
<ul>
<li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤 需要获取全局锁）。</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue</li>
<li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</li>
<li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用 RejectedExecutionHandler.rejectedExecution()方法。 </li>
</ul>
<p>ThreadPoolExecutor采取上述步骤的总体设计思路，是为了<strong>在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）</strong>。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p>
<p>通过源代码来看看是如何实现的，线程池执行任务的方法如下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">execute</span>(Runnable command) &#123; </span><br><span class="line">    <span class="selector-tag">if</span> (command == null) <span class="selector-tag">throw</span> <span class="selector-tag">new</span> <span class="selector-tag">NullPointerException</span>(); </span><br><span class="line">    <span class="comment">// 如果线程数小于基本线程数，则创建线程并执行当前任务</span></span><br><span class="line">    <span class="selector-tag">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123; </span><br><span class="line">    <span class="comment">// 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。</span></span><br><span class="line">    <span class="selector-tag">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123; </span><br><span class="line">        <span class="selector-tag">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">            <span class="selector-tag">ensureQueuedTaskHandled</span>(command); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量,则创建一个线程执行任务。 </span></span><br><span class="line">    <span class="selector-tag">else</span> <span class="selector-tag">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">    <span class="comment">// 抛出RejectedExecutionException异常 </span></span><br><span class="line">        <span class="selector-tag">reject</span>(command); <span class="comment">// is shutdown or saturated </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作线程</strong>：线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行。Worker类的run()方法:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Runnable <span class="keyword">task</span> = firstTask; </span><br><span class="line">        firstTask = <span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">task</span> != <span class="keyword">null</span> || (<span class="keyword">task</span> = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            runTask(<span class="keyword">task</span>);</span><br><span class="line">            <span class="keyword">task</span> = <span class="keyword">null</span>; </span><br><span class="line">            &#125; </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        workerDone(<span class="keyword">this</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadPoolExecutor执行任务的示意图：</p>
<p><img src="https://wx1.sbimg.cn/2020/07/14/CKmAR.png" alt="CKmAR.png"></p>
<p>线程池中的线程执行任务分两种情况：</p>
<ul>
<li>在execute()方法中创建一个线程时，会让这个线程执行当前任务。</li>
<li>这个线程执行完上图中1的任务后，会反复从BlockingQueue获取任务来执行。</li>
</ul>
<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>我们可以通过ThreadPoolExecutor来创建一个线程池</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">ThreadPoolExecutor(<span class="params">corePoolSize</span>, <span class="params">maximumPoolSize</span>, <span class="params">keepAliveTime</span>, <span class="params">milliseconds</span>,<span class="params">runnableTaskQueue</span>, <span class="params">handler</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>创建一个线程池时需要输入几个参数，如下:</p>
<ul>
<li>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</li>
<li>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列:<blockquote>
<ul>
<li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原 则对元素进行排序</li>
<li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通 常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用 移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li>
</ul>
</blockquote>
</li>
<li>maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。 </li>
<li>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线 程设置有意义的名字，代码如下:<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">ThreadFactoryBuilder</span>()<span class="selector-class">.setNameFormat</span>(<span class="string">"XX-task-%d"</span>)<span class="selector-class">.build</span>();</span><br></pre></td></tr></table></figure></li>
<li>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略<strong>默认情况下是AbortPolicy</strong>，表示无法处理新任务时抛出异常。在JDK1.5中Java线程池框架提供了以下4种策略：<blockquote>
<ul>
<li>AbortPolicy：直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
<li>也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。</li>
</ul>
</blockquote>
</li>
<li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</li>
<li>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟 （MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</li>
</ul>
<h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为<strong>execute()和submit()方法</strong>。 execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">threadPool.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功</strong>，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">Future&lt;Object&gt; <span class="built_in">future</span> = executor.submit(harReturnValuetask); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    Object s = <span class="built_in">future</span>.<span class="built_in">get</span>(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">    <span class="comment">// 处理中断异常 </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123; </span><br><span class="line">    <span class="comment">// 处理无法执行任务异常</span></span><br><span class="line">&#125; </span><br><span class="line">finally &#123; </span><br><span class="line">    <span class="comment">// 关闭线程池 </span></span><br><span class="line">    executor.<span class="built_in">shutdown</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是<strong>遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止</strong>。但是它们存在一定的区别：</p>
<ul>
<li>shutdownNow首先将线程池的状态设置成STOP，然后<strong>尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表</strong>；</li>
<li>shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程</li>
</ul>
<p>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。<strong>当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true</strong>。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，<strong>通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法</strong>。</p>
<h3 id="合理地配置线程池"><a href="#合理地配置线程池" class="headerlink" title="合理地配置线程池"></a>合理地配置线程池</h3><p>要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析：</p>
<ul>
<li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</li>
<li>任务的优先级：高、中和低。 ·任务的执行时间：长、中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。 </li>
</ul>
<p>性质不同的任务可以用不同规模的线程池分开处理。<strong>CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解</strong>，可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行。执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。<strong>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU</strong>。</p>
<p><strong>建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千</strong>。实例：我们系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然，我们的系统所有的任务是用单独的服务器部署的，我们使用不同规模的线程池完成不同类型的任务，但是出现这样问题时也会影响到其他任务。</p>
<h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性：</p>
<ul>
<li>taskCount：线程池需要执行的任务数量。 </li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li>
<li>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是 否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。 </li>
<li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</li>
<li>getActiveCount：获取活动的线程数。 </li>
</ul>
<p>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的 beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>参考：<br><strong>《Java并发编程的艺术》</strong></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】串的深度学习</title>
    <url>/2020/08/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%B8%B2%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>数据结构再度学习（详细注释版）：串&lt;常规操作，模式匹配&gt;</strong></p>
<a id="more"></a>
<h2 id="串的常规操作与模式匹配"><a href="#串的常规操作与模式匹配" class="headerlink" title="串的常规操作与模式匹配"></a>串的常规操作与模式匹配</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  StringList</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Eason on 2020/8/3.</span></span><br><span class="line"><span class="comment">//  Copyright © 2020 Eason. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> <span class="keyword">String</span>[MAXSIZE+<span class="number">1</span>];  <span class="comment">//串的存储结构，第一个位置存储长度信息所以实际数组要比定义的MAXSIZE+1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用c值初始化一个串(S为空，c为一个串）</span></span><br><span class="line"><span class="function">Status <span class="title">initString</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">char</span> *c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(c)&gt;MAXSIZE)&#123;   <span class="comment">//判断用来初始化的串是否超出了串本身的存储范围</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"初始值过大，无法初始化\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;   <span class="comment">//未超出范围，继续进行</span></span><br><span class="line">        S[<span class="number">0</span>]=<span class="built_in">strlen</span>(c);   <span class="comment">//S串的长度置为c串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=S[<span class="number">0</span>];i++)&#123;   <span class="comment">//循环将c串的字符一个个存入S串中</span></span><br><span class="line">            S[i] = *c;   <span class="comment">//存入</span></span><br><span class="line">            c+=<span class="number">1</span>;   <span class="comment">//切换到下一个字符，循环继续</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空串</span></span><br><span class="line"><span class="function">Status <span class="title">isEmpty</span><span class="params">(<span class="keyword">String</span> S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S[<span class="number">0</span>]==<span class="number">0</span>)&#123;   <span class="comment">//S[0]为串的长度，若为0则表示串为空</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断串是否已满</span></span><br><span class="line"><span class="function">Status <span class="title">isFull</span><span class="params">(<span class="keyword">String</span> S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S[<span class="number">0</span>]==MAXSIZE)&#123;   <span class="comment">//S[0]为串的长度，若为MAXSIZE则表示串已满</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空串</span></span><br><span class="line"><span class="function">Status <span class="title">clearString</span><span class="params">(<span class="keyword">String</span> S)</span></span>&#123;</span><br><span class="line">    S[<span class="number">0</span>]=<span class="number">0</span>;   <span class="comment">//将串的长度置0即将串清空了</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取串的长度（方法返回的即是长度值）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(<span class="keyword">String</span> S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S[<span class="number">0</span>];   <span class="comment">//将串的长度S[0]的数据返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制串（将串C的内容复制到串S中）</span></span><br><span class="line"><span class="function">Status <span class="title">copyString</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(C))&#123;   <span class="comment">//判断要进行拷贝的串是否为空</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"需要复制的串为空，无法复制\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(C[<span class="number">0</span>]&gt;MAXSIZE)&#123;   <span class="comment">//判断拷贝的串是不是超出了粘贴串的长度MAXSIZE</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"需要复制的串过长，无法完全复制\n"</span>);  <span class="comment">//若超出了长度，则只能复制MAXSIZE前的内容</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=C[<span class="number">0</span>];i++)&#123;   <span class="comment">//循环存入</span></span><br><span class="line">            S[i] = C[i];   <span class="comment">//存入</span></span><br><span class="line">        &#125;</span><br><span class="line">        S[<span class="number">0</span>]=C[<span class="number">0</span>];   <span class="comment">//S串的长度置为拷贝来的串的长度C[0]</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=C[<span class="number">0</span>];i++)&#123;   <span class="comment">//如果没有超出长度则可以完全进行循环存储</span></span><br><span class="line">        S[i]=C[i];  <span class="comment">//存储</span></span><br><span class="line">    &#125;</span><br><span class="line">    S[<span class="number">0</span>]=C[<span class="number">0</span>];   <span class="comment">//S串的长度置为拷贝来的串的长度C[0]</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串的比较（若串S与C相等则返回0，不想等则返回S-C）</span></span><br><span class="line"><span class="function">Status <span class="title">compareString</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = S[<span class="number">0</span>]&lt;=C[<span class="number">0</span>]?S[<span class="number">0</span>]:C[<span class="number">0</span>];   <span class="comment">//比较两个串的长度，按照短的进行比较</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;   <span class="comment">//整个长度的串逐个进行比较</span></span><br><span class="line">        <span class="keyword">if</span>(S[i]!=C[i])&#123;   <span class="comment">//若现在位置的串的两个字符不想等，则表示串不想等</span></span><br><span class="line">            <span class="keyword">return</span> S[i]-C[i];   <span class="comment">//不想等则返回当前字符的S-C差值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计较完成，即短的串与长串中前短串长度的内容都想等</span></span><br><span class="line">    <span class="keyword">if</span>(S[<span class="number">0</span>]==C[<span class="number">0</span>])&#123;   <span class="comment">//若两个串的长度也想等，则说明两个串完全相等，则返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;   <span class="comment">//如果只是短串想等，则返回两个串的长度S-C差值</span></span><br><span class="line">        <span class="keyword">return</span> S[<span class="number">0</span>]-C[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串的连接（S1串在前，S2串在后，连接后的串为New）</span></span><br><span class="line"><span class="function">Status <span class="title">connectString</span><span class="params">(<span class="keyword">String</span> S1, <span class="keyword">String</span> S2, <span class="keyword">String</span> New)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S1[<span class="number">0</span>]+S2[<span class="number">0</span>]&gt;MAXSIZE)&#123;   <span class="comment">//若连个串连接的总长度超过了最大存储长度，则只能存储MAXSIZE长度的串，多余的内容摒弃</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"字符串连接过长，尽力连接\n"</span>);</span><br><span class="line">        New[<span class="number">0</span>] = MAXSIZE;   <span class="comment">//因为已经超过总长度了，所以长度只能是MAXSIZE了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=S1[<span class="number">0</span>];i++)&#123;   <span class="comment">//先用循环存储的方式将S串的内容添加至新串中</span></span><br><span class="line">            New[i] = S1[i];   <span class="comment">//存入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">1</span>;   <span class="comment">//S2串当前需要存储位置的计数器</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=S1[<span class="number">0</span>]+<span class="number">1</span>;i&lt;=New[<span class="number">0</span>];i++)&#123;   <span class="comment">//在S1存储完成后的位置再开始存储S2串</span></span><br><span class="line">            New[i] = S2[p];   <span class="comment">//存入到对应位置</span></span><br><span class="line">            p++;   <span class="comment">//S2需存储位置向后移一位，继续循环进行存储</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若总长度未超过MAXSIZE则按照如下连接</span></span><br><span class="line">    New[<span class="number">0</span>] = S1[<span class="number">0</span>]+S2[<span class="number">0</span>];  <span class="comment">//新串的长度等于两个字串长度之和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=S1[<span class="number">0</span>];i++)&#123;   <span class="comment">//现将子串S1的内容存储到新串中</span></span><br><span class="line">        New[i] = S1[i];   <span class="comment">//存入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">1</span>;   <span class="comment">//S2串当前需要存储位置的计数器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=S1[<span class="number">0</span>]+<span class="number">1</span>;i&lt;=New[<span class="number">0</span>];i++)&#123;   <span class="comment">//在S1存储完成后之后的位置再开始存储S2串的内容</span></span><br><span class="line">        New[i] = S2[p];   <span class="comment">//存入</span></span><br><span class="line">        p++;   <span class="comment">//S2的位置向后走一位，循环继续存入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串的插入（在S串的第l位置前插入串N）</span></span><br><span class="line"><span class="function">Status <span class="title">insertString</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">int</span> l, <span class="keyword">String</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;<span class="number">1</span> || l&gt;S[<span class="number">0</span>]+<span class="number">1</span>)&#123;   <span class="comment">//判断插入位置是否合法</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"插入位置不合法，无法插入"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S[<span class="number">0</span>]+N[<span class="number">0</span>]&gt;MAXSIZE)&#123;   <span class="comment">//判断是否可以完全插入，如果超出最大存储容量则丢失一部分</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"插入过长，丢失一部分插入\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = MAXSIZE;   <span class="comment">//串S向后移动的计位器</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=S[<span class="number">0</span>];i&gt;=l;i-- )&#123;   <span class="comment">//从串的最后一个位置开始向后移动到插入后的位置，为插入的元素腾出位置</span></span><br><span class="line">            S[temp] = S[i];   <span class="comment">//移动到对应位置存入</span></span><br><span class="line">            temp--;   <span class="comment">//计位器-1，一直到插入位置的元素也移动完毕为止</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = MAXSIZE-S[<span class="number">0</span>];   <span class="comment">//腾出来位置的长度</span></span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">1</span>;   <span class="comment">//串N计位器</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;MAXSIZE-(S[<span class="number">0</span>]-l);i++)&#123;   <span class="comment">//从插入位置开始插入，到腾出来的位置的末尾</span></span><br><span class="line">            S[i] = N[t];   <span class="comment">//找到对应位置并存入</span></span><br><span class="line">            t++;   <span class="comment">//串向下走继续执行插入操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        S[<span class="number">0</span>] = MAXSIZE;   <span class="comment">//由于是不完全插入，所以最终S串达到了最大的长度</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若插入后的长度不超过最大存储容量则完全插入执行以下步骤</span></span><br><span class="line">    <span class="keyword">int</span> newlength = S[<span class="number">0</span>]+N[<span class="number">0</span>];   <span class="comment">//插入后的总长度</span></span><br><span class="line">    <span class="keyword">int</span> t = newlength;   <span class="comment">//移动目标位置计位器即移动到的最后位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=S[<span class="number">0</span>];i&gt;=l;i--)&#123;   <span class="comment">//从最后位置开始移动到指定的位置</span></span><br><span class="line">        S[t] = S[i];   <span class="comment">//找到对应的位置并存入</span></span><br><span class="line">        t--;   <span class="comment">//移动目标位置-1，因为是从后往前移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d=<span class="number">1</span>;   <span class="comment">//N串的临时计位器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;l+N[<span class="number">0</span>];i++)&#123;   <span class="comment">//从要插入的位置开始插入</span></span><br><span class="line">        S[i] = N[d];   <span class="comment">//从N的第一个元素插到指定位置开始向后存入</span></span><br><span class="line">        d++;   <span class="comment">//N串的计位器+1，即向后挪动一位继续执行插入操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    S[<span class="number">0</span>] = newlength;   <span class="comment">//新串的长度为总长度</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串的删除（删除串S的第i个位置开始长度为length的串）</span></span><br><span class="line"><span class="function">Status <span class="title">deleteString</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;MAXSIZE || length&lt;<span class="number">0</span>)&#123;   <span class="comment">//判断要删除位置与长度信息是否合法</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除信息不合法，无法删除\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=i+length;n&lt;=S[<span class="number">0</span>];n++)&#123;   <span class="comment">//将删除完成后删除串的末尾后的一个元素开始向前移动一直到删除后半截的元素都向前移动完毕</span></span><br><span class="line">        S[n-length] = S[n];   <span class="comment">//找到移动到的对应位置存入</span></span><br><span class="line">    &#125;</span><br><span class="line">    S[<span class="number">0</span>] =S[<span class="number">0</span>]-length;   <span class="comment">//新串的长度为老串长度减去删掉的对应长度</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//串的截取（将S串l位置开始向后长度为length的串截取下来存入N（即截取的串））</span></span><br><span class="line"><span class="function">Status <span class="title">subString</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">int</span> l, <span class="keyword">int</span> length, <span class="keyword">String</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;<span class="number">1</span> || length&lt;<span class="number">0</span> || l&gt;S[<span class="number">0</span>])&#123;   <span class="comment">//判断要截取子串的长度与位置是否合法</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入截取信息不合法，无法截取"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">1</span>;   <span class="comment">//S串当前位置计位器</span></span><br><span class="line">    N[<span class="number">0</span>] = length;   <span class="comment">//截取的串的长度即为指定的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;l+length;i++)&#123;   <span class="comment">//从指定的位置开始直到length个元素后结束</span></span><br><span class="line">        N[n] = S[i];   <span class="comment">//找到指定的截取元素并赋给N</span></span><br><span class="line">        n++;   <span class="comment">//继续向下判断是否也应该截取</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子串的定位（查找S串的第l位置后第一次出现L串的位置信息）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">localString</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> L, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L[<span class="number">0</span>]&gt;S[<span class="number">0</span>])&#123;   <span class="comment">//判断要查找的字串的长度是否合法</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"字串过大，定位不合法\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">String</span> sub;   <span class="comment">//定义一个临时的截取片段的串容器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=S[<span class="number">0</span>]-L[<span class="number">0</span>]+<span class="number">1</span>;i++)&#123;   <span class="comment">//从指定的位置开始截取直到最后只剩子串L的长度为止</span></span><br><span class="line">        subString(S,i,L[<span class="number">0</span>],sub);   <span class="comment">//从当前位置截取子串长度的子串</span></span><br><span class="line">        <span class="keyword">if</span>(compareString(sub, L)==<span class="number">0</span>)&#123;   <span class="comment">//如果当前截取的字串与指定的字串想等，则返回当前位置</span></span><br><span class="line">            <span class="keyword">return</span> i;   <span class="comment">//返回当前位置i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子串的替换（将串S中出现C字串的地方将C字串替换成R串）</span></span><br><span class="line"><span class="function">Status <span class="title">replaceString</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> C, <span class="keyword">String</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(C))&#123;   <span class="comment">//判断要替换的字串是否为空</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"替换的串为空，不合法"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">1</span>;   <span class="comment">//开始位置标志一下</span></span><br><span class="line">    <span class="keyword">int</span> i;   <span class="comment">//当前匹配到的C字串在S串的位置信息</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        i = localString(S, C, n);   <span class="comment">//从第1个位置开始查找第一次出现C字串的位置信息赋给i</span></span><br><span class="line">        <span class="keyword">if</span>(i)&#123;   <span class="comment">//如果i存在，即查找到了对应的字串位置信息</span></span><br><span class="line">            deleteString(S, i, C[<span class="number">0</span>]);   <span class="comment">//将出现位置开始删除C串长度的串，即将C字串从S串中删除掉</span></span><br><span class="line">            insertString(S, i, R);   <span class="comment">//再将要替换上的字串插入到删除字串的位置</span></span><br><span class="line">            n+=R[<span class="number">0</span>];   <span class="comment">//从查找到的字串后继续开始查找是否还有C字串的存在</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(i);   <span class="comment">//如果i为0了说明找不到C字串的位置了，即所有C字串已经被替换完成</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串的打印</span></span><br><span class="line"><span class="function">Status <span class="title">printString</span><span class="params">(<span class="keyword">String</span> S)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"字符串为："</span>);</span><br><span class="line">    <span class="keyword">if</span>(S[<span class="number">0</span>]==<span class="number">0</span>)&#123;   <span class="comment">//判断要打印的字串是否为空，若为空则输出：空</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"空\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=S[<span class="number">0</span>];i++)&#123;   <span class="comment">//从第一个元素的位置开始直到串的最后一个位置结束</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]);   <span class="comment">//输出对应位置的元素信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------模式匹配部分-----------------------</span></span><br><span class="line"><span class="comment">//朴素模式匹配(查询S串第l个位置之后串N首次出现的位置）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">normalFind</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> N, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l;   <span class="comment">//S的位置计数器 初始从第l个位置开始比较</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;   <span class="comment">//N串的位置计数器 初始从第一个开始比较</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S[<span class="number">0</span>] &amp;&amp; n&lt;=N[<span class="number">0</span>])&#123;   <span class="comment">//若两个串都还没匹配完毕则继续循环进行，若匹配完毕则推出循环</span></span><br><span class="line">        <span class="keyword">if</span>(S[i]==N[n])&#123;   <span class="comment">//如果当前串位置的元素等的话就进入</span></span><br><span class="line">            i++;   <span class="comment">//S串位置向下走一格</span></span><br><span class="line">            n++;   <span class="comment">//N串的位置也向下走一格然后继续比较</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i = i-n+<span class="number">2</span>;   <span class="comment">//若当前位置不一样则重新从S串本次匹配开始的地方的下一个位置为首再进行匹配操作</span></span><br><span class="line">            n = <span class="number">1</span>;   <span class="comment">//N串还是从第一个位置开始比较</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;N[<span class="number">0</span>])&#123;   <span class="comment">//若n的值大于N串的总长度了，说明N串已经全部匹配成功了，则说明找到了对应的N字串</span></span><br><span class="line">        <span class="keyword">return</span> i-N[<span class="number">0</span>];   <span class="comment">//返回S串当前所在位置减去N串的长度，即回到了开始的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;   <span class="comment">//如果不是n大于N字串的总长度说明S串全部匹配完也没找到对应的完整N字串的位置，则返回ERROR</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通版KMP算法：</span></span><br><span class="line"><span class="comment">//获取字串的next数组值</span></span><br><span class="line"><span class="function">Status <span class="title">getNext</span><span class="params">(<span class="keyword">String</span> N, <span class="keyword">int</span> *next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;   <span class="comment">//表示串味指针</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;   <span class="comment">//表示串头部指针</span></span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;   <span class="comment">//第一个元素前肯定无元素与之匹配，故next数组的第一个值永远为0</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=N[<span class="number">0</span>])&#123;   <span class="comment">//即将N串的元素全部进行操作</span></span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || N[i]==N[j])&#123;</span><br><span class="line">            <span class="comment">//如果已经达到表头或者当前所指的元素想等则继续向下走且为next复制</span></span><br><span class="line">            i++;   <span class="comment">//串尾向后走一格</span></span><br><span class="line">            j++;   <span class="comment">//串头向后走一格</span></span><br><span class="line">            next[i] = j;   <span class="comment">//当前next[i]值即为j的长度值</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];   <span class="comment">//如果j！=0并且当前元素也不想等，则回溯到j匹配成功的表头</span></span><br><span class="line">        &#125;   <span class="comment">//next[j]存放的就是j对应位置头部有几个元素是相等的，则直接回溯到相等的元素之后进行匹配就可以了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通KMP</span></span><br><span class="line"><span class="function">Status <span class="title">normalKMP</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> N, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=l;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">11</span>];   <span class="comment">//定义一个int数组next用来存放字串的next值</span></span><br><span class="line">    getNext(N, next);   <span class="comment">//获取串N的next值</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S[<span class="number">0</span>] &amp;&amp; j&lt;=N[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == N[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];  <span class="comment">//本质上就这里不相同，若此时元素不想等，则j回溯到next指定的位置（因为这个位置前的都是相等的，不需要再进行比较了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;N[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> i-N[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印next值</span></span><br><span class="line"><span class="function">Status <span class="title">printNext</span><span class="params">(<span class="keyword">int</span> next[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=length;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改良后的KMP算法</span></span><br><span class="line"><span class="comment">//获取nextval值</span></span><br><span class="line"><span class="function">Status <span class="title">getNextval</span><span class="params">(<span class="keyword">String</span> N, <span class="keyword">int</span> *nextval)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;N[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || N[i]==N[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(N[i]!=N[j])&#123;   <span class="comment">//与求next值只差这一点，为了避免有大量重复的元素同样占用时间，则进行一个新的比较</span></span><br><span class="line">                nextval[i] = j;   <span class="comment">//若当前两值是不想等的话则nextval值就与next值相同</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nextval[i] = nextval[j];   <span class="comment">//但如果此时位置的元素是相等的话，nextval值就等于next对应的元素位置的值的nextval值想等</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进后的KMP算法</span></span><br><span class="line"><span class="function">Status <span class="title">newKMP</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> N, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=l;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextval[<span class="number">21</span>];</span><br><span class="line">    getNextval(N, nextval);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S[<span class="number">0</span>] &amp;&amp; j&lt;=N[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i]==N[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = nextval[j];  <span class="comment">//同普通KMP算法，这里只是更换成了nextval值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;N[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> i-N[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印nextval值</span></span><br><span class="line"><span class="function">Status <span class="title">printNextval</span><span class="params">(<span class="keyword">int</span> *nextval, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=length;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, nextval[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">String</span> S1, S2, S3;</span><br><span class="line">    initString(S1, <span class="string">"abcbcf"</span>);</span><br><span class="line">    initString(S2, <span class="string">"bc"</span>);</span><br><span class="line">    initString(S3, <span class="string">"gg"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"S1"</span>);</span><br><span class="line">    printString(S1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"S1的长度为：%d\n"</span>, getLength(S1));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"S2"</span>);</span><br><span class="line">    printString(S2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"S2的长度为：%d\n"</span>, getLength(S2));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"S3"</span>);</span><br><span class="line">    printString(S3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"S3的长度为：%d\n"</span>, getLength(S3));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"将S1中与S2相同的串替换为S3可得S1：\n"</span>);</span><br><span class="line">    replaceString(S1, S2, S3);</span><br><span class="line">    printString(S1);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除S1第一个位置后长度为3的串后得S1：\n"</span>);</span><br><span class="line">    deleteString(S1, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    printString(S1);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"寻找S1中与S3首个相同的串开始的位置，无则返回0：%d\n"</span>, localString(S1, S3, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"比较S1与S3，若相同返回0，不同则返回S1-S3的值：%d\n"</span>, compareString(S1, S3));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"向S2串的第二个位置插入S3串后可得S2串：\n"</span>);</span><br><span class="line">    insertString(S2, <span class="number">2</span>, S3);</span><br><span class="line">    printString(S2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"清除S3串后得S3串为：\n"</span>);</span><br><span class="line">    clearString(S3);</span><br><span class="line">    printString(S3);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"将S2串复制给S3后可得S3串为：\n"</span>);</span><br><span class="line">    copyString(S3, S2);</span><br><span class="line">    printString(S3);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n-------------以下测试模式匹配算法------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化两个串S4与S5，他们对应为：\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"S4串为：\n"</span>);</span><br><span class="line">    <span class="keyword">String</span> S4,S5;</span><br><span class="line">    initString(S4, <span class="string">"aaaabcdbc"</span>);</span><br><span class="line">    initString(S5, <span class="string">"aabcd"</span>);</span><br><span class="line">    <span class="keyword">int</span> *next, *nextval;</span><br><span class="line">    <span class="keyword">int</span> l = S5[<span class="number">0</span>];</span><br><span class="line">    next = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((l+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    nextval = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((l+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    printString(S4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"S5串为：\n"</span>);</span><br><span class="line">    printString(S5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"根据KMP算法我们可以得到S5对应的next值与nextval值：\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"next值：\n"</span>);</span><br><span class="line">    getNext(S5, next);</span><br><span class="line">    printNext(next, getLength(S5));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nextval值：\n"</span>);</span><br><span class="line">    getNextval(S5, nextval);</span><br><span class="line">    printNextval(nextval, getLength(S5));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"使用普通匹配算法可得位置为：%d\n"</span>, normalFind(S4, S5, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"使用KMS算法可得位置为：%d\n"</span>, normalKMP(S4, S5, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"使用改进版KMS算法可得位置为：%d\n"</span>, newKMP(S4, S5, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发编程】并发编程实践</title>
    <url>/2020/07/16/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><strong>Java并发/多线程编程系列blog(十）并发编程实践含生产者和消费者模式/线上问题定位/性能测试/异步任务池</strong></p>
<a id="more"></a>
<h2 id="生产者和消费者模式"><a href="#生产者和消费者模式" class="headerlink" title="生产者和消费者模式"></a>生产者和消费者模式</h2><p><strong>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题</strong>。该模式通过平衡生产线程和消费线程的工作能力来提高程序整体处理数据的速度。在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这种生产消费能力不均衡的问题，便有了生产者和消费者模式。</p>
<p><strong>生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。 这个阻塞队列就是用来给生产者和消费者解耦的。纵观大多数设计模式，都会找一个第 三者出来进行解耦，如工厂模式的第三者是工厂类，模板模式的第三者是模板类。在学习一些 设计模式的过程中，先找到这个模式的第三者，能帮助我们快速熟悉一个设计模式。</strong></p>
<h3 id="生产者消费者模式场景"><a href="#生产者消费者模式场景" class="headerlink" title="生产者消费者模式场景"></a>生产者消费者模式场景</h3><p>在多核时代，多线程并发处理速度比单线程处理速度更快，所以可以使用多个线程来生 产数据，同样可以使用多个消费线程来消费数据。而更复杂的情况是，消费者消费的数据，有可能需要继续处理，于是消费者处理完数据之后，它又要作为生产者把数据放在新的队列里，交给其他消费者继续处理，如图所示：<br><img src="https://wx2.sbimg.cn/2020/07/16/CUkT2.png" alt="CUkT2.png"></p>
<p>我们在一个长连接服务器中使用了这种模式，生产者1负责将所有客户端发送的消息存放 在阻塞队列1里，消费者1从队列里读消息，然后通过消息ID进行散列得到N个队列中的一个，然后根据编号将消息存放在到不同的队列里，每个阻塞队列会分配一个线程来消费阻塞队列里的数据。如果消费者2无法消费消息，就将消息再抛回到阻塞队列1中，交给其他消费者处理。</p>
<p><strong>消息总队列的代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//总消息队列管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgQueueManager</span> <span class="keyword">implements</span> <span class="title">IMsgQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MsgQueueManager<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">    <span class="comment">//消息总队列 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> BlockingQueue&lt;Message&gt; messageQueue; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MsgQueueManager</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        messageQueue = <span class="keyword">new</span> LinkedTransferQueue&lt;Message&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Message msg)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messageQueue.put(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">take</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> messageQueue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>启动一个消息分发线程。在这个线程里子队列自动去总队列里获取消息代码：</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分发消息，负责把消息从大队列塞到小队列里</span></span><br><span class="line">static <span class="keyword">class</span> DispatchMessageTask implements Runnable &#123; </span><br><span class="line">    public void run<span class="literal">()</span> &#123; </span><br><span class="line">        BlockingQueue&lt;Message&gt; subQueue;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">    <span class="comment">//如果没有数据，则阻塞在这里</span></span><br><span class="line">        Message msg = <span class="module-access"><span class="module"><span class="identifier">MsgQueueFactory</span>.</span></span>get<span class="constructor">MessageQueue()</span>.take<span class="literal">()</span>; </span><br><span class="line">        <span class="comment">//如果为空，则表示没有Session机器连接上来， </span></span><br><span class="line">        <span class="comment">//需要等待，直到有Session机器连接上来 </span></span><br><span class="line">        <span class="keyword">while</span> ((subQueue = get<span class="constructor">Instance()</span>.get<span class="constructor">SubQueue()</span>)<span class="operator"> == </span>null) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>); </span><br><span class="line">            &#125; catch (InterruptedException e)&#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.interrupt<span class="literal">()</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把消息放到小队列里 </span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subQueue.put(msg); </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.interrupt<span class="literal">()</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用散列（hash）算法获取一个子队列代码:</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//均衡获取一个子队列 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BlockingQueue&lt;Message&gt; <span class="title">getSubQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> errorCount = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        <span class="keyword">if</span> (subMsgQueues.isEmpty()) &#123; </span><br><span class="line">            <span class="keyword">return</span> null; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> index = (<span class="keyword">int</span>) (System.nanoTime() % subMsgQueues.<span class="built_in">size</span>()); </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subMsgQueues.<span class="built_in">get</span>(index); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 出现错误表示，在获取队列大小之后，队列进行了一次删除操作 </span></span><br><span class="line">        LOGGER.error(<span class="string">"获取子队列出现错误"</span>, e);</span><br><span class="line">        <span class="keyword">if</span> ((++errorCount) &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用的时候往总队列里发消息：</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 往消息队列里添加一条消息</span></span><br><span class="line">IMsgQueue messageQueue = <span class="module-access"><span class="module"><span class="identifier">MsgQueueFactory</span>.</span></span>get<span class="constructor">MessageQueue()</span>;</span><br><span class="line">Packet msg = <span class="module-access"><span class="module"><span class="identifier">Packet</span>.</span></span>create<span class="constructor">Packet(Packet64FrameType. TYPE_DATA, <span class="string">"&#123;&#125;"</span>.<span class="params">getBytes</span>()</span>, (short) <span class="number">1</span>); </span><br><span class="line">messageQueue.put(msg);</span><br></pre></td></tr></table></figure>

<h3 id="生产者和消费者模式与线程池"><a href="#生产者和消费者模式与线程池" class="headerlink" title="生产者和消费者模式与线程池"></a>生产者和消费者模式与线程池</h3><p>Java中的线程池类其实就是一种生产者和消费者模式的实现方式，但是我觉得其实现方 式更加高明。生产者把任务丢给线程池，线程池创建线程并处理任务，<strong>果将要运行的任务数大于线程池的基本线程数就把任务扔到阻塞队列里，这种做法比只使用一个阻塞队列来实现生产者和消费者模式显然要高明很多</strong>，因为消费者能够处理直接就处理掉了，这样速度更快，而生产者先存，消费者再取这种方式显然慢一些。 </p>
<p>我们的系统也可以使用线程池来实现多生产者和消费者模式。例如，创建N个不同规模的 Java线程池来处理不同性质的任务，比如线程池1将数据读到内存之后，交给线程池2里的线程继续处理压缩数据。线程池1主要处理IO密集型任务，线程池2主要处理CPU密集型任务。 </p>
<p>我们可以在平时的工作中思考一下哪些场景可以使用生产者消费者模式，我相信这种场景应该非常多，特别是需要处理任务时间比较长的场景，比如上传附件并处理，用户把文件上传到系统后，系统把文件丢到队列里，然 后立刻返回告诉用户上传成功，最后消费者再去队列里取出文件处理。再如，调用一个远程接口查询数据，如果远程服务接口查询时需要几十秒的时间，那么它可以提供一个申请查询的接口，这个接口把要申请查询任务放数据库中，然后该接口立刻返回。然后服务器端用线程轮询并获取申请任务进行处理，处理完之后发消息给调用方，让调用方再来调用另外一个接口取数据。</p>
<h2 id="线上问题定位"><a href="#线上问题定位" class="headerlink" title="线上问题定位"></a>线上问题定位</h2><p>有时候，有很多问题只有在线上或者预发环境才能发现，而线上又不能调试代码，所以<strong>线上问题定位就只能看日志、系统状态和dump线程</strong>，这里简单地介绍一些常用的工具，帮助大家定位线上问题。 </p>
<ul>
<li><p>在Linux命令行下使用TOP命令查看每个进程的情况，显示如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">top - <span class="number">22</span>:<span class="number">27</span>:<span class="number">25</span> up <span class="number">463</span> days, <span class="number">12</span>:<span class="number">46</span>, <span class="number">1</span> user, load average: <span class="number">11.80</span>, <span class="number">12.19</span>, <span class="number">11.79</span></span><br><span class="line">Tasks: <span class="number">113</span> total, <span class="number">5</span> running, <span class="number">108</span> sleeping, <span class="number">0</span> stopped, <span class="number">0</span> zombie</span><br><span class="line">Cpu(s): <span class="number">62.0</span>%us, <span class="number">2.8</span>%sy, <span class="number">0.0</span>%ni, <span class="number">34.3</span>%id, <span class="number">0.0</span>%wa, <span class="number">0.0</span>%hi, <span class="number">0.7</span>%si, <span class="number">0.2</span>%st</span><br><span class="line">Mem: <span class="number">7680000</span>k total, <span class="number">7665504</span>k used, <span class="number">14496</span>k free, <span class="number">97268</span>k buffers</span><br><span class="line">Swap: <span class="number">2096472</span>k total, <span class="number">14904</span>k used, <span class="number">2081568</span>k free, <span class="number">3033060</span>k cached</span><br><span class="line">PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND</span><br><span class="line"><span class="number">31177</span> admin <span class="number">18</span> <span class="number">0</span> <span class="number">5351</span>m <span class="number">4.0</span>g <span class="number">49</span>m S <span class="number">301.4</span> <span class="number">54.0</span> <span class="number">935</span>:<span class="number">02.08</span> java</span><br><span class="line"><span class="number">31738</span> admin <span class="number">15</span> <span class="number">0</span> <span class="number">36432</span> <span class="number">12</span>m <span class="number">1052</span> S <span class="number">8.7</span> <span class="number">0.2</span> <span class="number">11</span>:<span class="number">21.05</span> nginx-proxy</span><br></pre></td></tr></table></figure>
<p>我们的程序是Java应用，所以<strong>只需要关注COMMAND是Java的性能数据</strong>，COMMAND表示启动当前进程的命令，在Java进程这一行里可以看到CPU利用率是300%，不用担心，这个是 当前机器所有核加在一起的CPU利用率。</p>
</li>
<li><p>使用top的交互命令数字1查看每个CPU的性能数据。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">top - <span class="number">22</span>:<span class="number">24</span>:<span class="number">50</span> up <span class="number">463</span> days, <span class="number">12</span>:<span class="number">43</span>, <span class="number">1</span> user, load average: <span class="number">12.55</span>, <span class="number">12.27</span>, <span class="number">11.73</span></span><br><span class="line">Tasks: <span class="number">110</span> total, <span class="number">3</span> running, <span class="number">107</span> sleeping, <span class="number">0</span> stopped, <span class="number">0</span> zombie</span><br><span class="line">Cpu0 : <span class="number">72.4</span>%us, <span class="number">3.6</span>%sy, <span class="number">0.0</span>%ni, <span class="number">22.7</span>%id, <span class="number">0.0</span>%wa, <span class="number">0.0</span>%hi, <span class="number">0.7</span>%si, <span class="number">0.7</span>%st</span><br><span class="line">Cpu1 : <span class="number">58.7</span>%us, <span class="number">4.3</span>%sy, <span class="number">0.0</span>%ni, <span class="number">34.3</span>%id, <span class="number">0.0</span>%wa, <span class="number">0.0</span>%hi, <span class="number">2.3</span>%si, <span class="number">0.3</span>%st </span><br><span class="line">Cpu2 : <span class="number">53.3</span>%us, <span class="number">2.6</span>%sy, <span class="number">0.0</span>%ni, <span class="number">34.1</span>%id, <span class="number">0.0</span>%wa, <span class="number">0.0</span>%hi, <span class="number">9.6</span>%si, <span class="number">0.3</span>%st </span><br><span class="line">Cpu3 : <span class="number">52.7</span>%us, <span class="number">2.7</span>%sy, <span class="number">0.0</span>%ni, <span class="number">25.2</span>%id, <span class="number">0.0</span>%wa, <span class="number">0.0</span>%hi, <span class="number">19.5</span>%si, <span class="number">0.0</span>%st </span><br><span class="line">Cpu4 : <span class="number">59.5</span>%us, <span class="number">2.7</span>%sy, <span class="number">0.0</span>%ni, <span class="number">31.2</span>%id, <span class="number">0.0</span>%wa, <span class="number">0.0</span>%hi, <span class="number">6.6</span>%si, <span class="number">0.0</span>%st </span><br><span class="line">Mem: <span class="number">7680000</span>k total, <span class="number">7663152</span>k used, <span class="number">16848</span>k free, <span class="number">98068</span>k buffers </span><br><span class="line">Swap: <span class="number">2096472</span>k total, <span class="number">14904</span>k used, <span class="number">2081568</span>k free, <span class="number">3032636</span>k cached</span><br></pre></td></tr></table></figure>
<p>命令行显示了CPU4，说明这是一个5核的虚拟机，平均每个CPU利用率在60%以上。如果 这里显示CPU利用率100%，则很有可能程序里写了一个死循环。这些参数的含义，可以对比下表来查看：<br><img src="https://wx2.sbimg.cn/2020/07/16/CUgNe.png" alt="CUgNe.png"></p>
</li>
<li><p>使用top的交互命令H查看每个线程的性能信息。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">PID    USER PR NI VIRT RES  SHR S %CPU %MEM TIME+   COMMAND </span><br><span class="line"><span class="number">31558</span> admin <span class="number">15</span> <span class="number">0</span> <span class="number">5351</span>m <span class="number">4.0</span>g <span class="number">49</span>m S <span class="number">12.2</span> <span class="number">54.0</span> <span class="number">10</span>:<span class="number">08.31</span> java </span><br><span class="line"><span class="number">31561</span> admin <span class="number">15</span> <span class="number">0</span> <span class="number">5351</span>m <span class="number">4.0</span>g <span class="number">49</span>m R <span class="number">12.2</span> <span class="number">54.0</span> <span class="number">9</span>:<span class="number">45.43</span> java </span><br><span class="line"><span class="number">31626</span> admin <span class="number">15</span> <span class="number">0</span> <span class="number">5351</span>m <span class="number">4.0</span>g <span class="number">49</span>m S <span class="number">11.9</span> <span class="number">54.0</span> <span class="number">13</span>:<span class="number">50.21</span> java </span><br><span class="line"><span class="number">31559</span> admin <span class="number">15</span> <span class="number">0</span> <span class="number">5351</span>m <span class="number">4.0</span>g <span class="number">49</span>m S <span class="number">10.9</span> <span class="number">54.0</span> <span class="number">5</span>:<span class="number">34.67</span> java </span><br><span class="line"><span class="number">31612</span> admin <span class="number">15</span> <span class="number">0</span> <span class="number">5351</span>m <span class="number">4.0</span>g <span class="number">49</span>m S <span class="number">10.6</span> <span class="number">54.0</span> <span class="number">8</span>:<span class="number">42.77</span> java </span><br><span class="line"><span class="number">31555</span> admin <span class="number">15</span> <span class="number">0</span> <span class="number">5351</span>m <span class="number">4.0</span>g <span class="number">49</span>m S <span class="number">10.3</span> <span class="number">54.0</span> <span class="number">13</span>:<span class="number">00.55</span> java </span><br><span class="line"><span class="number">31630</span> admin <span class="number">15</span> <span class="number">0</span> <span class="number">5351</span>m <span class="number">4.0</span>g <span class="number">49</span>m R <span class="number">10.3</span> <span class="number">54.0</span> <span class="number">4</span>:<span class="number">00.75</span> java </span><br><span class="line"><span class="number">31646</span> admin <span class="number">15</span> <span class="number">0</span> <span class="number">5351</span>m <span class="number">4.0</span>g <span class="number">49</span>m S <span class="number">10.3</span> <span class="number">54.0</span> <span class="number">3</span>:<span class="number">19.92</span> java </span><br><span class="line"><span class="number">31653</span> admin <span class="number">15</span> <span class="number">0</span> <span class="number">5351</span>m <span class="number">4.0</span>g <span class="number">49</span>m S <span class="number">10.3</span> <span class="number">54.0</span> <span class="number">8</span>:<span class="number">52.90</span> java </span><br><span class="line"><span class="number">31607</span> admin <span class="number">15</span> <span class="number">0</span> <span class="number">5351</span>m <span class="number">4.0</span>g <span class="number">49</span>m S <span class="number">9.9</span> <span class="number">54.0</span> <span class="number">14</span>:<span class="number">37.82</span> java</span><br></pre></td></tr></table></figure>
<p>在这里可能会出现3种情况: </p>
<blockquote>
<ul>
<li>第一种情况，某个线程CPU利用率一直100%，则说明是这个线程有可能有死循环，那么请记住这个PID。</li>
<li>第二种情况，某个线程一直在TOP10的位置，这说明这个线程可能有性能问题。 </li>
<li>第三种情况，CPU利用率高的几个线程在不停变化，说明并不是由某一个线程导致CPU偏高。</li>
</ul>
</blockquote>
</li>
</ul>
<p>如果是第一种情况，也有可能是GC造成，可以用jstat命令看一下GC情况，看看是不是因为持久代或年老代满了，产生FullGC，导致CPU利用率持续飙高，命令和回显如下:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sudo /opt/java/bin/jstat -gcutil <span class="number">31177</span> <span class="number">1000</span> <span class="number">5</span> </span><br><span class="line">S0 S1 E O P YGC YGCT FGC FGCT GCT</span><br><span class="line"><span class="number">0.00</span> <span class="number">1.27</span> <span class="number">61.30</span> <span class="number">55.57</span> <span class="number">59.98</span> <span class="number">16040</span> <span class="number">143.775</span> <span class="number">30</span> <span class="number">77.692</span> <span class="number">221.467</span> </span><br><span class="line"><span class="number">0.00</span> <span class="number">1.27</span> <span class="number">95.77</span> <span class="number">55.57</span> <span class="number">59.98</span> <span class="number">16040</span> <span class="number">143.775</span> <span class="number">30</span> <span class="number">77.692</span> <span class="number">221.467</span> </span><br><span class="line"><span class="number">1.37</span> <span class="number">0.00</span> <span class="number">33.21</span> <span class="number">55.57</span> <span class="number">59.98</span> <span class="number">16041</span> <span class="number">143.781</span> <span class="number">30</span> <span class="number">77.692</span> <span class="number">221.474</span> </span><br><span class="line"><span class="number">1.37</span> <span class="number">0.00</span> <span class="number">74.96</span> <span class="number">55.57</span> <span class="number">59.98</span> <span class="number">16041</span> <span class="number">143.781</span> <span class="number">30</span> <span class="number">77.692</span> <span class="number">221.474</span> </span><br><span class="line"><span class="number">0.00</span> <span class="number">1.59</span> <span class="number">22.14</span> <span class="number">55.57</span> <span class="number">59.98</span> <span class="number">16042</span> <span class="number">143.789</span> <span class="number">30</span> <span class="number">77.692</span> <span class="number">221.481</span></span><br></pre></td></tr></table></figure>
<p>还可以把线程dump下来，看看究竟是哪个线程、执行什么代码造成的CPU利用率高。执行以下命令，把线程dump到文件dump17里。执行如下命令:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo -u admin <span class="regexp">/opt/</span>taobao<span class="regexp">/java/</span>bin<span class="regexp">/jstack 31177 &gt; /</span>home<span class="regexp">/tengfei.fangtf/</span>dump17</span><br></pre></td></tr></table></figure>
<p>dump出来内容的类似下面内容:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">"http-0.0.0.0-7001-97"</span> daemon prio=<span class="number">10</span> tid=<span class="number">0</span>x000000004f6a8000 nid=<span class="number">0</span>x555e <span class="keyword">in</span> Object. </span><br><span class="line"><span class="function"><span class="title">wait</span><span class="params">()</span></span> [<span class="number">0</span>x0000000052423000] </span><br><span class="line">    java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: WAITING (on <span class="selector-tag">object</span> monitor) </span><br><span class="line">        at java<span class="selector-class">.lang</span><span class="selector-class">.Object</span>.wait(Native Method) </span><br><span class="line">        - waiting on (aorg<span class="selector-class">.apache</span><span class="selector-class">.tomcat</span><span class="selector-class">.util</span><span class="selector-class">.net</span>.AprEndpoint<span class="variable">$Worker</span>) </span><br><span class="line">        at java<span class="selector-class">.lang</span><span class="selector-class">.Object</span>.wait(Object<span class="selector-class">.java</span>:<span class="number">485</span>) </span><br><span class="line">        at org<span class="selector-class">.apache</span><span class="selector-class">.tomcat</span><span class="selector-class">.util</span><span class="selector-class">.net</span>.AprEndpoint<span class="variable">$Worker</span>.await(AprEndpoint<span class="selector-class">.java</span>:<span class="number">1464</span>) </span><br><span class="line">        - locked (<span class="selector-tag">a</span> org<span class="selector-class">.apache</span><span class="selector-class">.tomcat</span><span class="selector-class">.util</span><span class="selector-class">.net</span>.AprEndpoint<span class="variable">$Worker</span>) </span><br><span class="line">        at org<span class="selector-class">.apache</span><span class="selector-class">.tomcat</span><span class="selector-class">.util</span><span class="selector-class">.net</span>.AprEndpoint<span class="variable">$Worker</span>.run(AprEndpoint<span class="selector-class">.java</span>:<span class="number">1489</span>) </span><br><span class="line">        at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span>.run(Thread<span class="selector-class">.java</span>:<span class="number">662</span>)</span><br></pre></td></tr></table></figure>
<p>dump出来的线程ID（nid）是十六进制的，而我们用TOP命令看到的线程ID是十进制的，所以要用printf命令转换一下进制。然后用十六进制的ID去dump里找到对应的线程:</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">printf <span class="string">"%x<span class="subst">\n</span>"</span> <span class="number">31558</span></span><br></pre></td></tr></table></figure>
<p>输出：7b46。</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>因为要支持某个业务，有同事提出需求，希望系统的某个接口能够支持2万的QPS，因为我们的应用部署在多台机器上，要支持两万的QPS，我们必须先要知道该接口在单机上能支持多少QPS，如果单机能支持1千QPS，我们需要20台机器才能支持2万的QPS。需要注意的是，<strong>要支持的2万的QPS必须是峰值，而不能是平均值</strong>，比如一天当中有23个小时QPS不足1万，只有一个小时的QPS达到了2万，我们的系统也要支持2万的QPS。我们先进行性能测试。我们使用公司同事开发的性能测试工具进行测试，该工具的原理 是，<strong>用户写一个Java程序向服务器端发起请求，这个工具会启动一个线程池来调度这些任务，可以配置同时启动多少个线程、发起请求次数和任务间隔时长</strong>。将这个程序部署在多台机器上执行，统计出QPS和响应时长。我们在10台机器上部署了这个测试程序，每台机器启动了 100个线程进行测试，压测时长为半小时。注意不能压测线上机器，我们压测的是开发服务器。测试开始后，首先登录到服务器里查看当前有多少台机器在压测服务器，因为程序的端口是12200，所以使用netstat命令查询有多少台机器连接到这个端口上。命令如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ netstat -nat | grep <span class="number">12200</span> -c</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>通过这个命令可以知道已经有10台机器在压测服务器。QPS达到了1400，程序开始报错获取不到数据库连接，因为我们的数据库端口是3306，用netstat命令查看已经使用了多少个数据库连接。命令如下:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ netstat -nat | grep <span class="number">3306</span> –c </span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>增加数据库连接到20，QPS没上去，但是响应时长从平均1000毫秒下降到700毫秒，使用TOP命令观察CPU利用率，发现已经90%多了，于是升级CPU，将2核升级成4核，和线上的机器保持一致。再进行压测，CPU利用率下去了达到了75%，QPS上升到了1800。执行一段时间后响应时长稳定在200毫秒。增加应用服务器里线程池的核心线程数和最大线程数到1024，通过ps命令查看下线程数是否增长了，执行的命令如下:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">ps</span> -eLf | <span class="keyword">grep</span> java -<span class="keyword">c</span> </span><br><span class="line"><span class="number">1520</span></span><br></pre></td></tr></table></figure>
<p>再次压测，QPS并没有明显的增长，单机QPS稳定在1800左右，响应时长稳定在200毫秒。<br>性能测试之前先优化了程序的SQL语句。使用了如下命令统计执行最慢的SQL，左边的是执行时长，单位是毫秒，右边的是执行的语句，可以看到系统执行最慢的SQL是 queryNews和queryNewIds，优化到几十毫秒:</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">$ grep Y /home/admin/logs/xxx/monitor/dal-rw-monitor.log |awk -F',' '&#123;print $<span class="number">7</span>$<span class="number">5</span>&#125;' | </span><br><span class="line">sort -nr|head <span class="number">-20</span> </span><br><span class="line"><span class="number">1811</span> queryNews </span><br><span class="line"><span class="number">1764</span> queryNews </span><br><span class="line"><span class="number">1740</span> queryNews </span><br><span class="line"><span class="number">1697</span> queryNews </span><br><span class="line"><span class="number">679</span> queryNewIds</span><br></pre></td></tr></table></figure>

<h3 id="性能测试中使用的其他命令"><a href="#性能测试中使用的其他命令" class="headerlink" title="性能测试中使用的其他命令"></a>性能测试中使用的其他命令</h3><h4 id="查看网络流量"><a href="#查看网络流量" class="headerlink" title="查看网络流量:"></a>查看网络流量:</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ cat /proc/net/dev </span><br><span class="line">Inter-| Receive | Transmit </span><br><span class="line">face |bytes packets errs drop fifo frame compressed multicast|bytes packets </span><br><span class="line">errs drop fifo colls carrier compressed </span><br><span class="line">lo:<span class="number">242953548208</span> <span class="number">231437133</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">242953548208</span> <span class="number">231437133</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">eth0:<span class="number">153060432504</span> <span class="number">446365779</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">108596061848</span> <span class="number">479947142</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">bond0:<span class="number">153060432504</span> <span class="number">446365779</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">108596061848</span> <span class="number">479947142</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="查看系统平均负载"><a href="#查看系统平均负载" class="headerlink" title="查看系统平均负载:"></a>查看系统平均负载:</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ cat /proc/loadavg </span><br><span class="line"><span class="number">0.00</span> <span class="number">0.04</span> <span class="number">0.85</span> <span class="number">1</span>/<span class="number">1266</span> <span class="number">22459</span></span><br></pre></td></tr></table></figure>

<h4 id="查看系统内存情况"><a href="#查看系统内存情况" class="headerlink" title="查看系统内存情况:"></a>查看系统内存情况:</h4><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">$ cat /<span class="keyword">proc</span>/meminfo </span><br><span class="line">MemTotal: 4106756<span class="title"> kB</span> </span><br><span class="line">MemFree: 71196<span class="title"> kB</span> </span><br><span class="line">Buffers: 12832<span class="title"> kB</span> </span><br><span class="line">Cached: 2603332<span class="title"> kB</span> </span><br><span class="line">SwapCached: 4016<span class="title"> kB</span> </span><br><span class="line">Active: 2303768<span class="title"> kB</span> </span><br><span class="line">Inactive: 1507324<span class="title"> kB</span> </span><br><span class="line">Active(anon): 996100<span class="title"> kB</span></span><br><span class="line"><span class="title">...</span></span><br></pre></td></tr></table></figure>

<h4 id="查看CPU的利用率"><a href="#查看CPU的利用率" class="headerlink" title="查看CPU的利用率:"></a>查看CPU的利用率:</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">cat /proc/stat cpu <span class="number">167301886</span> <span class="number">6156</span> <span class="number">331902067</span> <span class="number">17552830039</span> <span class="number">8645275</span> <span class="number">13082</span> <span class="number">1044952</span> <span class="number">33931469</span> <span class="number">0</span> </span><br><span class="line">cpu0 <span class="number">45406479</span> <span class="number">1992</span> <span class="number">75489851</span> <span class="number">4410199442</span> <span class="number">7321828</span> <span class="number">12872</span> <span class="number">688837</span> <span class="number">5115394</span> <span class="number">0</span> </span><br><span class="line">cpu1 <span class="number">39821071</span> <span class="number">1247</span> <span class="number">132648851</span> <span class="number">4319596686</span> <span class="number">379255</span> <span class="number">67</span> <span class="number">132447</span> <span class="number">11365141</span> <span class="number">0</span> </span><br><span class="line">cpu2 <span class="number">40912727</span> <span class="number">1705</span> <span class="number">57947971</span> <span class="number">4418978718</span> <span class="number">389539</span> <span class="number">78</span> <span class="number">110994</span> <span class="number">8342835</span> <span class="number">0</span> </span><br><span class="line">cpu3 <span class="number">41161608</span> <span class="number">1211</span> <span class="number">65815393</span> <span class="number">4404055191</span> <span class="number">554651</span> <span class="number">63</span> <span class="number">112672</span> <span class="number">9108097</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="异步任务池"><a href="#异步任务池" class="headerlink" title="异步任务池"></a>异步任务池</h2><p>Java中的线程池设计得非常巧妙，可以高效并发执行多个任务，但是在某些场景下需要对线程池进行扩展才能更好地服务于系统。例如，如果一任务进线程池之后，运行线程池的程序重启了，那么线程池里的任务就会丢失。另外，线程池只能处理本机的任务，在集群环境下不能有效地调度所有机器的任务。所以，需要结合线程池开发一个异步任务处理池。</p>
<p>图为异步任务池设计图：<br><img src="https://wx1.sbimg.cn/2020/07/16/CULUj.png" alt="CULUj.png"></p>
<p>任务池的主要处理流程是：<strong>每台机器会启动一个任务池，每个任务池里有多个线程池，当某台机器将一个任务交给任务池后，任务池会先将这个任务保存到数据中，然后某台机器上的任务池会从数据库中获取待执行的任务，再执行这个任务</strong>。</p>
<p>每个任务有几种状态：分别是创建（NEW）、执行中（EXECUTING）、RETRY（重试）、挂起 （SUSPEND）、中止（TEMINER）和执行完成（FINISH）</p>
<ul>
<li>创建：提交给任务池之后的状态。</li>
<li>执行中：任务池从数据库中拿到任务执行时的状态。</li>
<li>重试：当执行任务时出现错误，程序显式地告诉任务池这个任务需要重试，并设置下一次执行时间。</li>
<li>挂起：当一个任务的执行依赖于其他任务完成时，可以将这个任务挂起，当收到消息后，再开始执行。</li>
<li>中止：任务执行失败，让任务池停止执行这个任务，并设置错误消息告诉调用端。 </li>
<li>执行完成：任务执行结束。</li>
</ul>
<p><strong>任务池的任务隔离</strong>：异步任务有很多种类型，比如抓取网页任务、同步数据任务等，不同类型的任务优先级不一样，但是系统资源是有限的，如果低优先级的任务非常多，高优先级的任务就可能得不到执行，所以必须对任务进行隔离执行。使用不同的线程池处理不同的任务，或者不同的线程池处理不同优先级的任务，<strong>如果任务类型非常少，建议用任务类型来隔离，如果任务类型非常多，比如几十个，建议采用优先级的方式来隔离</strong>。</p>
<p><strong>任务池的重试策略</strong>：根据不同的任务类型设置不同的重试策略，有的任务对实时性要求高，那么每次的重试间隔就会非常短，如果对实时性要求不高，可以采用默认的重试策略，重试间隔随着次数的增加，时间不断增长，比如间隔几秒、几分钟到几小时。每个任务类型可以设置执行该任务类型线程池的最小和最大线程数、最大重试次数。</p>
<p><strong>使用任务池的注意事项</strong>：任务必须无状态：任务不能在执行任务的机器中保存数据，比如某个任务是处理上传的文件，任务的属性里有文件的上传路径，如果文件上传到机器1，机器2获取到了任务则会处理失败，所以上传的文件必须存在其他的集群里，比如OSS或SFTP。 </p>
<p><strong>异步任务的属性</strong>：包括任务名称、下次执行时间、已执行次数、任务类型、任务优先级和执行时的报错信息（用于快速定位问题）。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>目前只是对Java并发编程的浅尝辄止，今后若有需要将继续深入学习Java并发编程</p>
<p>参考：<br><strong>《Java并发编程的艺术》</strong></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】栈的深度学习</title>
    <url>/2020/08/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>数据结构再度学习（详细注释版）：栈&lt;顺序栈，链栈，共享空间栈&gt;</strong></p>
<a id="more"></a>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  SequenceStack</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Eason on 2020/8/1.</span></span><br><span class="line"><span class="comment">//  Copyright © 2020 Eason. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> State;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>   <span class="comment">//顺序栈的存储结构</span></span><br><span class="line">    ElemType data[MAXSIZE];   <span class="comment">//用数组存放数据，最大为MAXSIZE，作为栈满条件</span></span><br><span class="line">    <span class="keyword">int</span> top;   <span class="comment">//用作栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化顺序栈</span></span><br><span class="line"><span class="function">State <span class="title">initStack</span><span class="params">(SqStack *S)</span></span>&#123;</span><br><span class="line">    S-&gt;top = <span class="number">-1</span>;   <span class="comment">//将栈顶指针置为-1，即将栈作为还是空的时候</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得顺序栈的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S.top)+<span class="number">1</span>;   <span class="comment">//根据数组下标的规则，数组中的长度为指针+1个元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空顺序栈</span></span><br><span class="line"><span class="function">State <span class="title">clearStack</span><span class="params">(SqStack *S)</span></span>&#123;</span><br><span class="line">    S-&gt;top = <span class="number">-1</span>;   <span class="comment">//将栈顶指针重新设置为-1，即此时表示栈空</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断顺序栈是否为空</span></span><br><span class="line"><span class="function">State <span class="title">isEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;   <span class="comment">//如果此时栈顶指针为-1表示栈此时为空，非-1则表示非空</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function">State <span class="title">push</span><span class="params">(SqStack *S, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top==MAXSIZE<span class="number">-1</span>)&#123;   <span class="comment">//根据数组下标的特点，当指针指向最后一个元素时为MAXSIZE-1，此时栈满</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈满，无法入栈\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;   <span class="comment">//栈满说明空间已满已经不可以再入栈</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;    <span class="comment">//如果栈非满则执行添加过程</span></span><br><span class="line">        S-&gt;top++;   <span class="comment">//栈顶指针+1指向一个新的顶部空间</span></span><br><span class="line">        S-&gt;data[S-&gt;top]=e;   <span class="comment">//将现在指向的这个新的空的栈顶空间元素置为指定元素（后进先出）</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function">State <span class="title">pop</span><span class="params">(SqStack *S, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top==<span class="number">-1</span>)&#123;   <span class="comment">//当栈顶指针指向-1，说明栈空，则无法出栈</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈空，无法出栈\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;   <span class="comment">//如果栈非空则执行出栈程序</span></span><br><span class="line">        *e = S-&gt;data[S-&gt;top];   <span class="comment">//将当前栈顶元素的指针赋给可供返回查看的e</span></span><br><span class="line">        S-&gt;top--;   <span class="comment">//栈顶元素出栈后，栈顶指针向下走一格，表示新的栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取栈顶元素（只供查看，不出栈）</span></span><br><span class="line"><span class="function">State <span class="title">getTop</span><span class="params">(SqStack S, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;   <span class="comment">//当栈顶指针指向-1，说明栈空，栈顶元素为空</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈空，无栈顶元素\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;   <span class="comment">//当栈非空的时候，则将栈顶元素赋值给可供返回查看的e，但是栈顶元素并不出栈</span></span><br><span class="line">        *e = S.data[S.top];   <span class="comment">//将栈顶元素赋值给e，栈顶指针top不变</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历打印顺序栈</span></span><br><span class="line"><span class="function">State <span class="title">printStack</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;   <span class="comment">//当栈顶指针指向-1，说明栈空，无栈元素可供打印</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈空\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;   <span class="comment">//计数器，记录当前是第几个元素</span></span><br><span class="line">    <span class="keyword">while</span>(S.top!=<span class="number">-1</span>)&#123;</span><br><span class="line">        i++;   <span class="comment">//栈顶指针还未到-1，则说明当前栈顶指针有元素，计数器+1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈顶向下第%d个元素为：%d\n"</span>, i, S.data[S.top]);  <span class="comment">//当前栈顶指针的元素打印出</span></span><br><span class="line">        S.top--;   <span class="comment">//栈顶指针向下走一格，继续进行循环打印</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    initStack(&amp;S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化后的线性栈的长度为：%d\n"</span>, getLength(S));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"将1-5元素依次入栈可得：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        push(&amp;S, i);</span><br><span class="line">    &#125;</span><br><span class="line">    printStack(S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"此时顺序栈的长度为：%d\n"</span>, getLength(S));</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    pop(&amp;S, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"出栈：%d\n"</span>, e);</span><br><span class="line">    pop(&amp;S, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"出栈：%d\n"</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"现在顺序栈的长度为：%d\n"</span>, getLength(S));</span><br><span class="line">    getTop(S, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"获取栈顶元素：%d\n"</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"现在顺序栈的长度为：%d\n"</span>, getLength(S));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"现在顺序栈的为：\n"</span>);</span><br><span class="line">    printStack(S);</span><br><span class="line">    clearStack(&amp;S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"清空顺序栈后的栈为：\n"</span>);</span><br><span class="line">    printStack(S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"长度为：%d"</span>, getLength(S));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共享空间栈"><a href="#共享空间栈" class="headerlink" title="共享空间栈"></a>共享空间栈</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  ShareStack</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Eason on 2020/8/1.</span></span><br><span class="line"><span class="comment">//  Copyright © 2020 Eason. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> State;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>   <span class="comment">//定义共享栈的存储结构</span></span><br><span class="line">    ElemType data[MAXSIZE];   <span class="comment">//用数组存储共享栈的数据，并设定最大值判断栈满</span></span><br><span class="line">    <span class="keyword">int</span> lefttop;   <span class="comment">//左栈的栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> righttop;   <span class="comment">//右栈的栈顶指针</span></span><br><span class="line">&#125;SharedStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化共享栈</span></span><br><span class="line"><span class="function">State <span class="title">initStack</span><span class="params">(SharedStack *S)</span></span>&#123;</span><br><span class="line">    S-&gt;lefttop = <span class="number">-1</span>;   <span class="comment">//将左栈与右栈的栈顶指针指向空栈时的默认值，即初始化成功</span></span><br><span class="line">    S-&gt;righttop = MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取共享栈的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(SharedStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MAXSIZE-(S.righttop-S.lefttop<span class="number">-1</span>);   <span class="comment">//根据共享栈的与数组的特性可得，用栈最大存储量减去未存储量即为当前栈的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断共享栈是否为空</span></span><br><span class="line"><span class="function">State <span class="title">isEmpty</span><span class="params">(SharedStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.lefttop==<span class="number">-1</span> &amp;&amp; S.righttop==MAXSIZE)&#123;   <span class="comment">//如果左栈右栈的栈顶指针均在初始位置即共享栈为空</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断共享栈是否已满</span></span><br><span class="line"><span class="function">State <span class="title">isFull</span><span class="params">(SharedStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.lefttop+<span class="number">1</span>==S.righttop)&#123;   <span class="comment">//根据共享栈的特性，当左栈的栈顶指针与右栈栈顶指针相邻的时候则表明当前栈已经没有存储空间了</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空共享栈</span></span><br><span class="line"><span class="function">State <span class="title">clearStack</span><span class="params">(SharedStack *S)</span></span>&#123;</span><br><span class="line">    S-&gt;lefttop=<span class="number">-1</span>;</span><br><span class="line">    S-&gt;righttop=MAXSIZE;   <span class="comment">//即将共享栈的左右栈顶指针置为初始值则可以代表已经清空了共享栈</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈（i=0表示入左栈，i=1表示入右栈）</span></span><br><span class="line"><span class="function">State <span class="title">push</span><span class="params">(SharedStack *S, <span class="keyword">int</span> i, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isFull(*S))&#123;   <span class="comment">//判断是否栈满</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈满，无法入栈"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; i!=<span class="number">1</span>)&#123;   <span class="comment">//判断输入的判断左右栈的标志是否有误</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入有误！请输入插入左栈的代表数字0或右栈代表数字1！"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;   <span class="comment">//如果i=0则表示进入左栈</span></span><br><span class="line">        S-&gt;lefttop++;  <span class="comment">//入栈时栈顶指针向上走一格指向新的空的栈元素位置</span></span><br><span class="line">        S-&gt;data[S-&gt;lefttop]=e;  <span class="comment">//将该新的栈顶位置给予特定值e</span></span><br><span class="line">        <span class="keyword">return</span> OK;  <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;   <span class="comment">//如果i=1则表示进入右栈</span></span><br><span class="line">        S-&gt;righttop--;  <span class="comment">//入栈时栈顶指针向上走一格指向新的空的栈元素位置</span></span><br><span class="line">        S-&gt;data[S-&gt;righttop]=e;  <span class="comment">//将该新的栈顶位置给予特定值e</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈（i=0表示入左栈，i=1表示入右栈）</span></span><br><span class="line"><span class="function">State <span class="title">pop</span><span class="params">(SharedStack *S, <span class="keyword">int</span> i, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(*S))&#123;   <span class="comment">//判断当前共享栈是否栈空，若栈空则无元素可出栈</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈空，无法出栈"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; i!=<span class="number">1</span>)&#123;   <span class="comment">//判断输入的判断左右栈的标志是否有误</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入有误！请输入插入左栈的代表数字0或右栈代表数字1！"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;   <span class="comment">//如果i=0则表示想要左栈出栈</span></span><br><span class="line">        *e = S-&gt;data[S-&gt;lefttop];   <span class="comment">//将左栈的栈顶元素出栈赋给可供返回查看的e</span></span><br><span class="line">        S-&gt;lefttop--;   <span class="comment">//出栈完成后栈顶指针向下走一格（即向左走一格）指向新的栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;   <span class="comment">//如果i=1则表示想要右栈出栈</span></span><br><span class="line">        *e = S-&gt;data[S-&gt;righttop];   <span class="comment">//将右栈的栈顶元素出栈赋给可供返回查看的e</span></span><br><span class="line">        S-&gt;righttop++;   <span class="comment">//出栈完成后栈顶指针向下走一格（即向外右一格）指向新的栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取栈顶元素（i=0表示入左栈，i=1表示入右栈）</span></span><br><span class="line"><span class="function">State <span class="title">getTop</span><span class="params">(SharedStack S, <span class="keyword">int</span> i, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(S))&#123;   <span class="comment">//判断是否为空栈，若为空栈则无栈顶元素可供查看</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈空，无栈顶元素"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; i!=<span class="number">1</span>)&#123;   <span class="comment">//判断输入的判断左右栈的标志是否有误</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入有误！请输入插入左栈的代表数字0或右栈代表数字1！"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;   <span class="comment">//如果i=0则表示想要获取左栈栈顶元素</span></span><br><span class="line">        *e = S.data[S.lefttop];   <span class="comment">//将左栈的栈顶元素出栈赋给可供返回查看的e（仅获取，栈顶指针无需移动）</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;   <span class="comment">// //如果i=1则表示想要获取右栈栈顶元素</span></span><br><span class="line">        *e = S.data[S.righttop];   <span class="comment">//将右栈的栈顶元素出栈赋给可供返回查看的e（仅获取，栈顶指针无需移动）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印共享栈（i=0表示入左栈，i=1表示入右栈，i=3表示全栈打印）</span></span><br><span class="line"><span class="function">State <span class="title">printStack</span><span class="params">(SharedStack S, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(S))&#123;   <span class="comment">//判断是否为空栈，若为空栈则无栈元素可打印</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈空"</span>);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; i!=<span class="number">1</span> &amp;&amp; i!=<span class="number">3</span>)&#123;   <span class="comment">//判断输入的判断左右以及全栈的标志是否有误</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入有误！请输入插入左栈的代表数字0或右栈代表数字1代表全栈的数字3！"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;   <span class="comment">//如果i=0则表示想要打印左栈元素</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;   <span class="comment">//当前元素位置计数器</span></span><br><span class="line">        <span class="keyword">while</span>(S.lefttop!=<span class="number">-1</span>)&#123;   <span class="comment">//判断当前栈顶指针是否为初始值，若不是则进行打印</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"左栈栈顶向下第%d个元素为：%d\n"</span>, i, S.data[S.lefttop]);   <span class="comment">//打印当前左栈栈顶元素的数据</span></span><br><span class="line">            S.lefttop--;   <span class="comment">//栈顶元素向下走一格继续循环遍历进行打印（向左走一格）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;   <span class="comment">//如果i=0则表示想要打印右栈元素</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;   <span class="comment">//当前元素位置计数器</span></span><br><span class="line">        <span class="keyword">while</span>(S.righttop!=MAXSIZE)&#123;   <span class="comment">//判断当前栈顶指针是否为初始值，若不是则进行打印</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"右栈栈顶向下第%d个元素为：%d\n"</span>, i, S.data[S.righttop]);   <span class="comment">//打印当前右栈栈顶元素的数据</span></span><br><span class="line">            S.righttop++;   <span class="comment">//栈顶元素向下走一格继续循环遍历进行打印（向右走一格）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>)&#123;   <span class="comment">//如果i=3则表示想要打印全栈元素</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(S.lefttop!=<span class="number">-1</span>)&#123;   <span class="comment">//同左栈打印步骤</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"左栈栈顶向下第%d个元素为：%d\n"</span>, i, S.data[S.lefttop]);</span><br><span class="line">            S.lefttop--;</span><br><span class="line">        &#125;</span><br><span class="line">        i=<span class="number">1</span>;  <span class="comment">//左栈元素打印完毕，计数器初始化</span></span><br><span class="line">        <span class="keyword">while</span>(S.righttop!=MAXSIZE)&#123;   <span class="comment">//同右栈打印步骤</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"右栈栈顶向下第%d个元素为：%d\n"</span>, i, S.data[S.righttop]);</span><br><span class="line">            S.righttop++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SharedStack S;</span><br><span class="line">    initStack(&amp;S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化一个共享栈，长度为：%d\n"</span>, getLength(S));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"将1-5顺序入左栈得：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        push(&amp;S, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    printStack(S, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"将11-15顺序入右栈得：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">11</span>;i&lt;=<span class="number">15</span>;i++)&#123;</span><br><span class="line">        push(&amp;S, <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    printStack(S, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"全栈为：\n"</span>);</span><br><span class="line">    printStack(S, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前共享栈是否为空（0非空1空)：%d\n"</span>, isEmpty(S));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前共享栈是否为满（0非满1满)：%d\n"</span>, isFull(S));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前共享栈的长度为：%d\n"</span>, getLength(S));</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    pop(&amp;S, <span class="number">0</span>, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"左栈出栈元素：%d\n"</span>, e);</span><br><span class="line">    pop(&amp;S, <span class="number">0</span>, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"左栈出栈元素：%d\n"</span>, e);</span><br><span class="line">    pop(&amp;S, <span class="number">1</span>, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"右栈出栈元素：%d\n"</span>, e);</span><br><span class="line">    getTop(S, <span class="number">0</span>, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"获取当前左栈的栈顶元素：%d\n"</span>, e);</span><br><span class="line">    getTop(S, <span class="number">1</span>, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"获取当前右栈的栈顶元素：%d\n"</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"现在共享栈的元素为：\n"</span>);</span><br><span class="line">    printStack(S, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"现在共享栈的长度为：%d\n"</span>, getLength(S));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  LinkStack</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Eason on 2020/8/1.</span></span><br><span class="line"><span class="comment">//  Copyright © 2020 Eason. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>&#123;</span>   <span class="comment">//链栈的结点存储结构</span></span><br><span class="line">    ElemType data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域</span></span><br><span class="line">&#125;*StackNodePtr,StackNode;   <span class="comment">//StackNodePtr 即struct StackNode &#123;&#125;*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>   <span class="comment">//链栈头指针的存储结构</span></span><br><span class="line">    StackNodePtr top;   <span class="comment">//链栈头指针</span></span><br><span class="line">    <span class="keyword">int</span> count;   <span class="comment">//链栈的元素数量计数器</span></span><br><span class="line">&#125;LinkedStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化链栈</span></span><br><span class="line"><span class="function">Status <span class="title">initStack</span><span class="params">(LinkedStack *L)</span></span>&#123;</span><br><span class="line">    L-&gt;top = (StackNodePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));   <span class="comment">//为头结点分配内存空间</span></span><br><span class="line">    <span class="keyword">if</span>(!L-&gt;top)&#123;   <span class="comment">//判断内存空间是否分配成功</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;top = <span class="literal">NULL</span>;   <span class="comment">//空链栈的头结点指针指向空</span></span><br><span class="line">    L-&gt;count = <span class="number">0</span>;   <span class="comment">//链栈内的结点数量初始为0</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断链栈是否为空</span></span><br><span class="line"><span class="function">Status <span class="title">isEmpty</span><span class="params">(LinkedStack L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.count==<span class="number">0</span>)&#123;   <span class="comment">//若此时链栈头结点中的计数器为0则说明链栈为空</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空链栈</span></span><br><span class="line"><span class="function">Status <span class="title">clearStack</span><span class="params">(LinkedStack *L)</span></span>&#123;</span><br><span class="line">    StackNodePtr p, q;   <span class="comment">//定义临时链栈结点</span></span><br><span class="line">    p = L-&gt;top;   <span class="comment">//将p作为首个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;   <span class="comment">//如果p存在的话则继续循环执行循环体</span></span><br><span class="line">        q=p;   <span class="comment">//将p赋给q</span></span><br><span class="line">        p=p-&gt;next;   <span class="comment">//p向下继续进行</span></span><br><span class="line">        <span class="built_in">free</span>(q);   <span class="comment">//将q释放掉，即完成了p区域的清理，然后继续循环判断</span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;count=<span class="number">0</span>;   <span class="comment">//将链栈头结点中的计数器归零</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取链栈的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(LinkedStack L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.count;   <span class="comment">//链栈的长度就是头结点中的计数器数值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链栈的入栈</span></span><br><span class="line"><span class="function">Status <span class="title">push</span><span class="params">(LinkedStack *L, ElemType *e)</span></span>&#123;</span><br><span class="line">    StackNodePtr p = (StackNodePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));  <span class="comment">//为入栈元素分配内存空间</span></span><br><span class="line">    p-&gt;data=e;  <span class="comment">//将新元素的数据域置为指定值</span></span><br><span class="line">    p-&gt;next = L-&gt;top;   <span class="comment">//将目前的首个结点置为新结点的下一个结点</span></span><br><span class="line">    L-&gt;top = p;   <span class="comment">//然后将首个结点设置为p</span></span><br><span class="line">    L-&gt;count++;   <span class="comment">//入栈成功，头结点的计数器+1</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链栈的出栈</span></span><br><span class="line"><span class="function">Status <span class="title">pop</span><span class="params">(LinkedStack *L, ElemType *e)</span></span>&#123;</span><br><span class="line">    StackNodePtr p;   <span class="comment">//定义临时结点</span></span><br><span class="line">    <span class="keyword">if</span>(isEmpty(*L))&#123;   <span class="comment">//出栈先判断当前栈是否为空，为空则没有栈顶元素可以出栈</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"链栈为空，无法出栈\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    p = L-&gt;top;   <span class="comment">//将p作为链栈的首个结点，即栈顶结点</span></span><br><span class="line">    *e = p-&gt;data;   <span class="comment">//将栈顶结点的值赋给e以供返回查看</span></span><br><span class="line">    L-&gt;top = p-&gt;next;   <span class="comment">//将首个结点的下个结点作为头结点的下个结点（即重新设置首个结点）</span></span><br><span class="line">    <span class="built_in">free</span>(p);   <span class="comment">//将老的栈顶结点p释放掉</span></span><br><span class="line">    L-&gt;count--;   <span class="comment">//出栈成功，头结点的计数器-1</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取链栈的栈顶元素</span></span><br><span class="line"><span class="function">Status <span class="title">getTop</span><span class="params">(LinkedStack L, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(L))&#123;   <span class="comment">//要获取栈顶元素首先判断当前链栈是否为空栈，若为空栈则无栈顶元素可供获取</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"链栈为空，无栈顶元素\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = L.top-&gt;data;   <span class="comment">//链栈不为空，则将此时的栈顶元素的数据赋给e以供返回查看</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链栈的打印</span></span><br><span class="line"><span class="function">Status <span class="title">printStack</span><span class="params">(LinkedStack L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(L))&#123;   <span class="comment">//判断链栈是否为空，若为空则无元素可供打印</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"链栈为空，无元素可打印\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    StackNodePtr p;   <span class="comment">//定义临时结点p</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//当前位置计数器</span></span><br><span class="line">    p=L.top;   <span class="comment">//将p设置为首个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;   <span class="comment">//若p存在的话则执行循环体</span></span><br><span class="line">        i++;   <span class="comment">//若存在则说明当前位置要+1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"链栈由栈顶向下的第%d个元素为：%d\n"</span>, i, p-&gt;data);   <span class="comment">//将当前结点（即栈顶元素）输出</span></span><br><span class="line">        p = p-&gt;next;   <span class="comment">//栈顶位置继续向下，循环到p不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    LinkedStack L;</span><br><span class="line">    initStack(&amp;L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化链栈后链栈L的长度为：%d\n"</span>, getLength(L));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"此时链栈为空为吗？(1为是，0为否）：%d\n"</span>, isEmpty(L));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"将1-8顺序入栈得：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)&#123;</span><br><span class="line">        push(&amp;L, i);</span><br><span class="line">    &#125;</span><br><span class="line">    printStack(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"此时的链栈长度为：%d\n"</span>, getLength(L));</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    getTop(L, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"此时的栈顶元素为：%d\n"</span>, e);</span><br><span class="line">    pop(&amp;L, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"出栈：%d\n"</span>, e);</span><br><span class="line">    pop(&amp;L, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"出栈：%d\n"</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"现在的链栈内容为：\n"</span>);</span><br><span class="line">    printStack(L);</span><br><span class="line">    getTop(L, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"现在的栈顶元素为：%d\n"</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"现在链栈的长度为：%d\n"</span>, getLength(L));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"清空链栈后的链栈为：\n"</span>);</span><br><span class="line">    clearStack(&amp;L);</span><br><span class="line">    printStack(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【生活区】一点感想</title>
    <url>/2020/07/27/%E3%80%90%E7%94%9F%E6%B4%BB%E5%8C%BA%E3%80%91%E4%B8%80%E7%82%B9%E6%84%9F%E6%83%B3/</url>
    <content><![CDATA[<p><strong>最近肝的有点猛了。。。</strong></p>
<a id="more"></a>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>最近一直日更，发现飞的有点猛了，平稳落地都是个问题了（狗头）所以最近还是先把之前学的这个并发编程和计算机网络好好复习梳理一下，做做题，最近重心放在了英语上边，所以这两天暂时停更，不得不说，计算机网络这一块需要记忆的还有并发编程方面需要理解的都很多，所以我还是给自己点时间多消化消化，感<br>觉自己有点太着急了…..害，一口吃不成个胖子，还是慢慢来吧～ </p>
<h2 id="预知"><a href="#预知" class="headerlink" title="预知"></a>预知</h2><p>等过了这段时间会开始操作系统这个新的内容，哎，最近吃的太多，力不从心了。。加油加油，大家也要加油啊～～</p>
]]></content>
      <categories>
        <category>生活区</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】线性表的深度学习</title>
    <url>/2020/07/31/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>数据结构再度学习(详细注释版）：线性表&lt;顺序表，单链表&gt;</strong></p>
<a id="more"></a>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  SQList</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Eason on 2020/7/28.</span></span><br><span class="line"><span class="comment">//  Copyright © 2020 Eason. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#define OK 1</span></span><br><span class="line"><span class="comment">#define ERROR 0</span></span><br><span class="line"><span class="comment">#define TRUE 1</span></span><br><span class="line"><span class="comment">#define FALSE 0</span></span><br><span class="line"><span class="comment">#define maxsize 100</span></span><br><span class="line">typedef <span class="keyword">int</span> Status;</span><br><span class="line">typedef <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="comment">//线性表的存储结构</span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    <span class="keyword">int</span> data[maxsize];  <span class="comment">//数据存储</span></span><br><span class="line">    <span class="keyword">int</span> length;         <span class="comment">//目前线性表的长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//创建线性表</span></span><br><span class="line">Status CreatList(SqList *L)&#123;</span><br><span class="line">    <span class="keyword">int</span> tempdata;  <span class="comment">//临时数据，用来保存输入的值</span></span><br><span class="line">    L-&gt;length=<span class="number">0</span>;  <span class="comment">//初始长度为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxsize;i++)&#123;</span><br><span class="line">        printf(<span class="string">"请输入第%d个元素的值，-1结束\n"</span>, i+<span class="number">1</span>);</span><br><span class="line">        scanf(<span class="string">"%d"</span>, &amp;tempdata);   <span class="comment">//接受控制台的输入，并保存在临时数据中</span></span><br><span class="line">        <span class="keyword">if</span>(tempdata==<span class="number">-1</span>)&#123;   <span class="comment">//判断是否为输入结束语句</span></span><br><span class="line">            <span class="keyword">return</span> OK;   <span class="comment">//若为输入结束语句，则直接结束方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;data[i] = tempdata;   <span class="comment">//若不是结束语句则将临时数据存放在对应位置中</span></span><br><span class="line">        L-&gt;length++;   <span class="comment">//每放入一个数据，则长度length+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取线性表的长度</span></span><br><span class="line">Status getLength(SqList *L)&#123;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入线性表</span></span><br><span class="line">Status insertList(SqList *L, <span class="keyword">int</span> i, ElemType e)&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length==maxsize)&#123;  <span class="comment">//判断线性表是否已满</span></span><br><span class="line">        printf(<span class="string">"目前线性表的长度已满，不可再插入元素"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length+<span class="number">1</span>)&#123;   <span class="comment">//判断插入位置是否合法</span></span><br><span class="line">        printf(<span class="string">"您输入的插入位置有误"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i!=L-&gt;length+<span class="number">1</span>)&#123;   <span class="comment">//判断是否是插在线性表的最后，如果不是的话要进行线性表的元素后移操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=i;i&lt;L-&gt;length;i++)&#123;</span><br><span class="line">            L-&gt;data[i]=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>]=e;   <span class="comment">//如果是插在线性表的最后，则直接写入就可。如果不是最后则已经后移完成，将插入元素写入对应位置即可</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印线性表</span></span><br><span class="line">Status printList(SqList *L)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L-&gt;length;i++)&#123;   <span class="comment">//for循环遍历的方式访问线性表的元素并进行打印</span></span><br><span class="line">        printf(<span class="string">"\n第%d个元素为%d"</span>, i+<span class="number">1</span>, L-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除线性表</span></span><br><span class="line">Status deleteList(SqList *L, <span class="keyword">int</span> i, <span class="keyword">int</span> *e)&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length==<span class="number">0</span>)&#123;   <span class="comment">//判断目前的顺序表是否为空，若为空则不可进行删除操作</span></span><br><span class="line">        printf(<span class="string">"线性表的长度为0，不可进行删除操作"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>||i&gt;L-&gt;length)&#123;</span><br><span class="line">        printf(<span class="string">"您输入的删除位置有误，不可进行删除操作"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    e = L-&gt;data[i<span class="number">-1</span>];  <span class="comment">//将要删除位置的元素存储起来</span></span><br><span class="line">    <span class="keyword">if</span>(i!=L-&gt;length)&#123;  <span class="comment">//如果要删除的位置不在最后，那么要进行顺序表的前移操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=i;n&lt;L-&gt;length;n++)&#123;</span><br><span class="line">            L-&gt;data[n<span class="number">-1</span>] = L-&gt;data[n];</span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;length--;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">//如果要删除的位置在最后，那么直接将最后一个元素置0</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并线性表（集合相并）</span></span><br><span class="line">Status Union(SqList *LA, SqList *LB)&#123;</span><br><span class="line">    <span class="keyword">int</span> lengtha = LA-&gt;length;</span><br><span class="line">    <span class="keyword">int</span> lengthb = LB-&gt;length;</span><br><span class="line">    <span class="keyword">int</span> isEqual = <span class="number">0</span>;   <span class="comment">//判断是否存在相同元素的标志</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lengthb;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(searchList(LA, LB-&gt;data[i]))&#123;   <span class="comment">//判断LA中是否含有与制定元素相等的元素</span></span><br><span class="line">            isEqual = <span class="number">1</span>;   <span class="comment">//若含有，则判断置1（TRUE）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isEqual)&#123;    <span class="comment">//若判断为！1（0）即不想等的时候执行插入操作，并将LA的长度+1</span></span><br><span class="line">            insertList(LA, ++lengtha, LB-&gt;data[i]);</span><br><span class="line">            LA-&gt;length++;</span><br><span class="line">        &#125;</span><br><span class="line">        isEqual = <span class="number">0</span>;   <span class="comment">//判断完一个后再次循环判断下一个，对应的判断标志初始化为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线性表查找元素</span></span><br><span class="line">Status searchList(SqList *LA, <span class="keyword">int</span> e)&#123;</span><br><span class="line">    <span class="keyword">int</span> lengtha = LA-&gt;length;  <span class="comment">//线性表的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lengtha;i++)&#123;   <span class="comment">//遍历线性表</span></span><br><span class="line">        <span class="keyword">if</span>(LA-&gt;data[i]==e)&#123;   <span class="comment">//比较当前线性表元素是否相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除线性表中指定的元素</span></span><br><span class="line">Status deleteValue(SqList *L, <span class="keyword">int</span> e)&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;  <span class="comment">//循环遍历的计数位</span></span><br><span class="line">    <span class="keyword">while</span>(L-&gt;data[i]!=e&amp;&amp;i&lt;L-&gt;length)&#123;  <span class="comment">//循环要么找到相同元素要么全部遍历</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;L-&gt;length)&#123;   <span class="comment">//如果不是全部遍历，则表明是找到了相同的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=i;n&lt;L-&gt;length;n++)&#123;  <span class="comment">//按照线性表删除元素的做法进行遍历向前移动</span></span><br><span class="line">            L-&gt;data[n]=L-&gt;data[n+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;length--;  <span class="comment">//进行删除操作后将线性表的长度-1</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"线性表中没有对应的元素，无法删除"</span>);  <span class="comment">//如果是全部遍历，则表明线性表中没有指定的元素</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相交线性表（两集合的交集）</span></span><br><span class="line">Status mergeList(SqList *LA, SqList *LB)&#123;</span><br><span class="line">    <span class="keyword">int</span> lengthb = LB-&gt;length;  <span class="comment">//遍历循环使用B线性表的长度</span></span><br><span class="line">    <span class="keyword">int</span> isEqual = <span class="number">0</span>;  <span class="comment">//判断是否相等的标志位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lengthb;i++)&#123;   <span class="comment">//循环便利线性表B中的元素线性表A进行比较</span></span><br><span class="line">        <span class="keyword">if</span>(searchList(LA, LB-&gt;data[i]))&#123;   <span class="comment">//判断当前A中是否有这个B中的元素</span></span><br><span class="line">            isEqual = <span class="number">1</span>;   <span class="comment">//如果有的话，标识位置1（true）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isEqual)&#123;   <span class="comment">//如果相等则需要进行删除操作</span></span><br><span class="line">            deleteValue(LA,LB-&gt;data[i]);   <span class="comment">//将匹配到的与B中的元素相等的元素进行删除</span></span><br><span class="line">        &#125;</span><br><span class="line">        isEqual = <span class="number">0</span>;  <span class="comment">//新的一轮将标识位初始化置0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    SqList sqlistA;</span><br><span class="line">    SqList sqlistB;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    printf(<span class="string">"请输入线性表A的内容：\n"</span>);</span><br><span class="line">    CreatList(&amp;sqlistA);</span><br><span class="line">    printList(&amp;sqlistA);</span><br><span class="line">    printf(<span class="string">"\n请输入线性表B的内容：\n"</span>);</span><br><span class="line">    CreatList(&amp;sqlistB);</span><br><span class="line">    printList(&amp;sqlistB);</span><br><span class="line">    printf(<span class="string">"\n目前线性表A的长度为%d"</span>, getLength(&amp;sqlistA));</span><br><span class="line">    printf(<span class="string">"\n目前线性表B的长度为%d"</span>, getLength(&amp;sqlistB));</span><br><span class="line">    Union(&amp;sqlistA, &amp;sqlistB);</span><br><span class="line">    printf(<span class="string">"\n合并后的线性表A的长度为%d, 线性表A的内容为："</span>, getLength(&amp;sqlistA));</span><br><span class="line">    printList(&amp;sqlistA);</span><br><span class="line">    mergeList(&amp;sqlistA, &amp;sqlistB);</span><br><span class="line">    printf(<span class="string">"\n再与线性表B进行相交的线性表A的变成了："</span>);</span><br><span class="line">    printList(&amp;sqlistA);</span><br><span class="line">    insertList(&amp;sqlistA, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">    printf(<span class="string">"\n向线性表A中的第二个位置插入元素9操作后得："</span>);</span><br><span class="line">    printList(&amp;sqlistA);</span><br><span class="line">    deleteList(&amp;sqlistA, <span class="number">2</span>, e);</span><br><span class="line">    printf(<span class="string">"\n将线性表A的中第二个位置元素删除操作后得："</span>);</span><br><span class="line">    printList(&amp;sqlistA);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  LinkedList</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Eason on 2020/7/29.</span></span><br><span class="line"><span class="comment">//  Copyright © 2020 Eason. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> State;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>   <span class="comment">//结点的存储结构</span></span><br><span class="line">    ElemType data;   <span class="comment">//结点的数据部分</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>   <span class="comment">//指向结点的下一结点</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span>  <span class="comment">//定义LinkList（其实也就是头结点）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化单链表</span></span><br><span class="line"><span class="function">State <span class="title">InitLinkList</span><span class="params">(LinkList *L)</span></span>&#123;</span><br><span class="line">    *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//为头结点分配内存</span></span><br><span class="line">    <span class="keyword">if</span>(!*L)&#123;   <span class="comment">//如果头结点不存在，即分配内存失败则返回ERROR</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;   <span class="comment">//如果头结点存在则说明初始化成功</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//初始单链表头结点的指针域为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单链表是否为空</span></span><br><span class="line"><span class="function">State <span class="title">isEmpty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next)&#123;   <span class="comment">//判断头结点的指针域是否为空</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;   <span class="comment">//头结点的指针域非空则返回FALSE；</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;   <span class="comment">//头结点指针域为空则返回TRUE；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得单链表的长度</span></span><br><span class="line"><span class="function">State <span class="title">listLength</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;  <span class="comment">//计数器，初始为0</span></span><br><span class="line">    LinkList p;  <span class="comment">//定义临时结点</span></span><br><span class="line">    p = L-&gt;next;  <span class="comment">//单链表的首个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;   <span class="comment">//如果此结点存在则计数器+1，并且指向下一结点，循环遍历</span></span><br><span class="line">        i++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;  <span class="comment">//返回单链表的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单链表的插入</span></span><br><span class="line"><span class="function">State <span class="title">insertList</span><span class="params">(LinkList *L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    LinkList p;  <span class="comment">//定义临时结点</span></span><br><span class="line">    p = *L;   <span class="comment">//临时结点指向头结点</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;   <span class="comment">//位置计数器</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i)&#123;  <span class="comment">//因为单链表的插入是要插入到当前结点的后方，所以计数器初始为1</span></span><br><span class="line">        p = p-&gt;next;  <span class="comment">//如果还没有到指定位置的前方，则继续向下进行</span></span><br><span class="line">        j++;  <span class="comment">//位置计数器+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;  <span class="comment">//如果p不存在了说明链表中的结点数达不到插入结点的条件，无法插入，如果存在则继续向下进行</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList q;  <span class="comment">//定义结点q</span></span><br><span class="line">    q = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//为结点q分配内存空间</span></span><br><span class="line">    q-&gt;data = e;  <span class="comment">//为q结点的数据域赋指定值</span></span><br><span class="line">    q-&gt;next = p-&gt;next;  <span class="comment">//结点插入的经典方式，现将自身的next指向前结点的next结点</span></span><br><span class="line">    p-&gt;next = q;  <span class="comment">//将自身设为前结点的next结点</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单链表的删除</span></span><br><span class="line"><span class="function">State <span class="title">deleteList</span><span class="params">(LinkList *L, <span class="keyword">int</span> i, ElemType *e)</span></span>&#123;</span><br><span class="line">    LinkList p;  <span class="comment">//定义临时结点</span></span><br><span class="line">    p = *L;  <span class="comment">//将临时结点指向头结点</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;  <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i)&#123;  <span class="comment">//判断p结点是否存在，并且计数器不能大于要删除结点的位置</span></span><br><span class="line">        p=p-&gt;next;  <span class="comment">//满足条件，继续向下走</span></span><br><span class="line">        j++;  <span class="comment">//计数器+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;   <span class="comment">//如果p不存在说明单链表的结点数不够所要删除的位置，无法删除，如果存在则继续向下进行</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList q;  <span class="comment">//定义临时结点</span></span><br><span class="line">    q = p-&gt;next;  <span class="comment">//将要删除的结点赋给q</span></span><br><span class="line">    p-&gt;next = q-&gt;next;  <span class="comment">//将要删除结点的下一结点赋给要删除结点的上一结点，这样就避开了要删除的结点</span></span><br><span class="line">    *e = q-&gt;data;  <span class="comment">//将要删除的结点的数据域赋值给e用以备份返回</span></span><br><span class="line">    <span class="built_in">free</span>(q);  <span class="comment">//释放q结点的内存区域，即删除了指定的结点</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除单链表</span></span><br><span class="line"><span class="function">State <span class="title">clearList</span><span class="params">(LinkList *L)</span></span>&#123;</span><br><span class="line">    LinkList p, q;  <span class="comment">//定义两个临时结点</span></span><br><span class="line">    p = (*L)-&gt;next;  <span class="comment">//将p当前作为头结点的下一结点</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;  <span class="comment">//如果p存在（即还没有删除完成）</span></span><br><span class="line">        q = p-&gt;next;  <span class="comment">//则将q作为p结点的下一结点，然后将p删除后再将q赋给p这样的话就相当于p一直再向后删除</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//全部删除后，将头结点的指针域置空，则表明单链表为空了</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单链表中某个位置的元素</span></span><br><span class="line"><span class="function">State <span class="title">getElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType *e)</span></span>&#123;</span><br><span class="line">    LinkList p;  <span class="comment">//定义临时结点</span></span><br><span class="line">    p = L-&gt;next;   <span class="comment">//将p设置为首个结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;  <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i)&#123;   <span class="comment">//在还不到对应的位置且p存在的情况下继续循环</span></span><br><span class="line">        p = p-&gt;next;   <span class="comment">//沿着链表向下进行</span></span><br><span class="line">        j++;   <span class="comment">//计数器+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;   <span class="comment">//如果跳出循环是因为p不存在了，则说明此位置没有结点，返回ERROR</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = p-&gt;data;   <span class="comment">//将对应位置上的元素的赋值给e用于返回</span></span><br><span class="line">    <span class="keyword">return</span> *e;   <span class="comment">//返回指定位置上的数据域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单链表中是否含有某个元素,如果有，返回它所在的位置信息</span></span><br><span class="line"><span class="function">State <span class="title">localElem</span><span class="params">(LinkList L, ElemType *e)</span></span>&#123;</span><br><span class="line">    LinkList p;  <span class="comment">//定义临时结点</span></span><br><span class="line">    p = L-&gt;next;  <span class="comment">//将临时结点设为首个结点</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;  <span class="comment">//计数器，因为当前为首个结点，所以计数器的初始值为1</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;   <span class="comment">//如果p存在则循环向下进行判断</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==e)&#123;   <span class="comment">//如果找到了对应的数值则将对应的计数器数值返回即为对应位置信息</span></span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;  <span class="comment">//如果不是对应数值则继续向下寻找</span></span><br><span class="line">        j++;  <span class="comment">//计数器+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;  <span class="comment">//一直p为空了跳出循环，则说明没有对应的数值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建单链表（前插法）</span></span><br><span class="line"><span class="function">State <span class="title">headCreatList</span><span class="params">(LinkList *L)</span></span>&#123;</span><br><span class="line">    *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//创建单链表首先为头结点分配内存</span></span><br><span class="line">    (*L)-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//空链表头结点的指针域为空</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">9</span>;i++)&#123;   <span class="comment">//将1-9按照前插法的方式插入单链表</span></span><br><span class="line">        LinkList p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//新建结点且为其分配内存</span></span><br><span class="line">        p-&gt;data = i; <span class="comment">//将新建结点的数据域设置为i的值</span></span><br><span class="line">        p-&gt;next = (*L)-&gt;next;  <span class="comment">//插队到头结点的下一结点，即头插法</span></span><br><span class="line">        (*L)-&gt;next = p;  <span class="comment">//将头结点的指针域设置为新新结点，头插完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建单链表（后插法）</span></span><br><span class="line"><span class="function">State <span class="title">tailCreatList</span><span class="params">(LinkList *L)</span></span>&#123;</span><br><span class="line">    (*L) = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//创建单链表首先为头结点分配内存</span></span><br><span class="line">    LinkList t;  <span class="comment">//设置临时结点表示尾指针</span></span><br><span class="line">    t = (*L);  <span class="comment">//尾指针指向头结点，说明此时还为空链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i&lt;<span class="number">14</span>;i++)&#123;   <span class="comment">//将5-14数值按照尾插法插入单链表</span></span><br><span class="line">        LinkList p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//新建结点并分配内存</span></span><br><span class="line">        p-&gt;data = i;  <span class="comment">//将新建结点的数据域设置为当前i值</span></span><br><span class="line">        t-&gt;next = p;  <span class="comment">//尾指针指向新建结点</span></span><br><span class="line">        t = p;  <span class="comment">//将新建结点设置为尾结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//尾结点的指针域为空</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单链表的打印</span></span><br><span class="line"><span class="function">State <span class="title">printLinkList</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LinkList p;  <span class="comment">//定义临时结点</span></span><br><span class="line">    p = L-&gt;next;  <span class="comment">//将p设置为首个结点</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;  <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;  <span class="comment">//判断当前结点是否存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"第%d个结点的元素值为%d\n"</span>, i, p-&gt;data);  <span class="comment">//如果存在则将数据域进行打印</span></span><br><span class="line">        p = p-&gt;next;  <span class="comment">//向下继续进行</span></span><br><span class="line">        i++;  <span class="comment">//计数器+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList L1, L2;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"使用头插法创建单链表可得结果L1：\n"</span>);</span><br><span class="line">    headCreatList(&amp;L1);</span><br><span class="line">    printLinkList(L1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"使用尾插法创建单链表可得结果L2：\n"</span>);</span><br><span class="line">    tailCreatList(&amp;L2);</span><br><span class="line">    printLinkList(L2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其中L1的长度为%d, L2的长度为%d\n"</span>,listLength(L1), listLength(L2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"向单链表L1的第三个位置插入一个666元素可得：\n"</span>);</span><br><span class="line">    insertList(&amp;L1, <span class="number">3</span>, <span class="number">666</span>);</span><br><span class="line">    printLinkList(L1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"将单链表L2的第三个位置的元素删除可得：\n"</span>);</span><br><span class="line">    deleteList(&amp;L2, <span class="number">3</span>, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除的元素为：%d\n"</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"现在的单链表L2为：\n"</span>);</span><br><span class="line">    printLinkList(L2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"单链表是否存在元素666？存在则返回其位置，不存在则返回0:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"单链表L1中666元素的位置为：%d\n"</span>, localElem(L1, <span class="number">666</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"单链表L2中666元素的位置为：%d\n"</span>, localElem(L2, <span class="number">666</span>));</span><br><span class="line">    getElem(L1, <span class="number">8</span>, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"获得L1中的第8个元素为：%d\n"</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"清空单链表可得L1: \n"</span>);</span><br><span class="line">    clearList(&amp;L1);</span><br><span class="line">    printLinkList(L1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】队列的深度学习</title>
    <url>/2020/08/02/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E9%98%9F%E5%88%97%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>数据结构再度学习（详细注释版）：队列&lt;顺序（循环实现）队列，链队列&gt;</strong></p>
<a id="more"></a>
<h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  SequenceQueue</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Eason on 2020/8/2.</span></span><br><span class="line"><span class="comment">//  Copyright © 2020 Eason. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 21  <span class="comment">//采用循环队列的方式，充分利用空间，但是会有一个单元的浪费，实际容量为最大容量-1，因为要区分空与满</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>   <span class="comment">//顺序队列的存储结构</span></span><br><span class="line">    ElemType data[MAXSIZE];   <span class="comment">//队列元素的数据</span></span><br><span class="line">    <span class="keyword">int</span> front, rear;   <span class="comment">//头指针与尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化顺序队列</span></span><br><span class="line"><span class="function">Status <span class="title">initQueue</span><span class="params">(SqQueue *Q)</span></span>&#123;</span><br><span class="line">    Q-&gt;front=<span class="number">0</span>;   <span class="comment">//初始时头指针与为指针均指向0</span></span><br><span class="line">    Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断顺序队列是否为空</span></span><br><span class="line"><span class="function">Status <span class="title">isEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;   <span class="comment">//当头指针与尾指针指向相同的单元时表示队列为空</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断顺序队列是否已满</span></span><br><span class="line"><span class="function">Status <span class="title">isFull</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MAXSIZE==Q.front)&#123;   <span class="comment">//循环队列头指针可能在前也可能在后，头指针在前尾指针在最后差1时为满，头指针在后尾指针与头指针差1时为满，则用差值取余的方式可判断当前是否已满</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取顺序队列的长度</span></span><br><span class="line"><span class="function">Status <span class="title">getLength</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear-Q.front+MAXSIZE)%MAXSIZE;   <span class="comment">//根据循环队列的特点，即长度为差值加最大容量与最大容量的取模运算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空顺序队列</span></span><br><span class="line"><span class="function">Status <span class="title">clearQueue</span><span class="params">(SqQueue *Q)</span></span>&#123;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear;   <span class="comment">//根据队列为空的判断条件，即将头指针指向尾指针时两指针指向同一单元时队列为空。不能颠倒，因为尾指针指向的是空单元</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function">Status <span class="title">enter</span><span class="params">(SqQueue *Q, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isFull(*Q))&#123;   <span class="comment">//判断队列是否还可以再入队元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列已满，无法入队\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    Q-&gt;data[Q-&gt;rear]=e;   <span class="comment">//将当前尾指针指向的空白单元入值</span></span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;   <span class="comment">//将尾指针向后走一格，因为有可能是从队尾到队头，所以使用取模的方式判断尾指针接下来的位置</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function">Status <span class="title">leave</span><span class="params">(SqQueue *Q, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(*Q))&#123;   <span class="comment">//判断队列是否有元素可以出队</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空，不可出队\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = Q-&gt;data[Q-&gt;front];   <span class="comment">//将当前队首元素出队给e供返回与查看</span></span><br><span class="line">    Q-&gt;front = (Q-&gt;front+<span class="number">1</span>)%MAXSIZE;   <span class="comment">//将头指针向后走一格，因为有可能是从队尾到队头，所以使用取模的方式判断头指针接下来的位置</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取队首元素</span></span><br><span class="line"><span class="function">Status <span class="title">getHead</span><span class="params">(SqQueue Q, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(Q))&#123;   <span class="comment">//判断队列是否有元素可供查看</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空，无队首元素\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = Q.data[Q.front];   <span class="comment">//将当前队头元素返回给e供返回并查看</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印队列</span></span><br><span class="line"><span class="function">Status <span class="title">printQueue</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(Q))&#123;   <span class="comment">//判断队列当前是否有元素可供打印</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空，无队元素可供打印\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;   <span class="comment">//当前元素数量计数器</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        i++;   <span class="comment">//不为空说明当前有元素可供打印，则计数器+1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"从队首至队尾的第%d个元素为：%d\n"</span>, i, Q.data[Q.front]);   <span class="comment">//打印当前队首元素</span></span><br><span class="line">        Q.front = (Q.front+<span class="number">1</span>)%MAXSIZE;   <span class="comment">//将头指针向后走一格，因为有可能是从队尾到队头，所以使用取模的方式判断头指针接下来的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    initQueue(&amp;Q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化队列Q后队列的长度为：%d,是否为空？（是1否0）：%d\n"</span>, getLength(Q), isEmpty(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"将1-18顺序的入队后队列变为：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">18</span>;i++)&#123;</span><br><span class="line">        enter(&amp;Q, i);</span><br><span class="line">    &#125;</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"此时队列的长度为：%d\n"</span>, getLength(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"队列的最大长度为20，检验再依次入队3个元素后得：\n"</span>);</span><br><span class="line">    enter(&amp;Q, <span class="number">19</span>);</span><br><span class="line">    enter(&amp;Q, <span class="number">20</span>);</span><br><span class="line">    enter(&amp;Q, <span class="number">21</span>);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----验证循环队列-----\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    leave(&amp;Q, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"出队列：%d\n"</span>, e);</span><br><span class="line">    enter(&amp;Q, <span class="number">21</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"入队列：21\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"此时的队列内容为：\n"</span>);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"此时队列的长度为：%d，是否已满？（1是0否）：%d\n"</span>, getLength(Q), isFull(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"清空队列后队列为：\n"</span>);</span><br><span class="line">    clearQueue(&amp;Q);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  LinkedQueue</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Eason on 2020/8/2.</span></span><br><span class="line"><span class="comment">//  Copyright © 2020 Eason. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;   <span class="comment">//注意：头指针始终指向头结点（不存放数据）头结点的下一结点才是链队的队头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>&#123;</span>   <span class="comment">//链队结点的存储结构</span></span><br><span class="line">    ElemType data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> *<span class="title">next</span>;</span>   <span class="comment">//指针域</span></span><br><span class="line">&#125;QueueNode, *QueueNodePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>   <span class="comment">//链队头结点的存储结构</span></span><br><span class="line">    QueueNodePtr front, rear;   <span class="comment">//头指针与尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化链队</span></span><br><span class="line"><span class="function">Status <span class="title">initQueue</span><span class="params">(LinkQueue *Q)</span></span>&#123;</span><br><span class="line">    Q-&gt;front = (QueueNodePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));   <span class="comment">//初始化为首位指针分配内存</span></span><br><span class="line">    Q-&gt;rear = (QueueNodePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q-&gt;front || !Q-&gt;rear)&#123;   <span class="comment">//若不存在则说明内存分配失败无法初始化</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"初始化内存分配失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear;   <span class="comment">//空队的条件 队头指针=队尾指针 均指向头结点</span></span><br><span class="line">    Q-&gt;front-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//头结点的下一结点，即首个结点为空</span></span><br><span class="line">    <span class="keyword">return</span> OK;   <span class="comment">//这里要注意，初始的时候首位指针均指向头结点，是不存放数据的，链队此时为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断链队是否为空</span></span><br><span class="line"><span class="function">Status <span class="title">isEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;   <span class="comment">//链队为空的条件为头指针=尾指针，即都指向头结点</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取链队的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    QueueNodePtr p;   <span class="comment">//定义临时结点指针</span></span><br><span class="line">    p = Q.front-&gt;next;   <span class="comment">//将临时结点置为链队的首个结点</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;   <span class="comment">//链队长度计数器</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;   <span class="comment">//如果此时链队结点存在的话就继续向下进行</span></span><br><span class="line">        i++;   <span class="comment">//计数器+1</span></span><br><span class="line">        p = p-&gt;next;   <span class="comment">//链队指针继续向下移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;   <span class="comment">//返回链队计数器i即长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function">Status <span class="title">enter</span><span class="params">(LinkQueue *Q, ElemType *e)</span></span>&#123;</span><br><span class="line">    QueueNodePtr p = (QueueNodePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));   <span class="comment">//为新入队的结点分配内存空间</span></span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;   <span class="comment">//验证是否为新结点内存分配成功</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"新结点内存分配失败，无法入队"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;data = e;   <span class="comment">//将新结点的数据域置为指定值</span></span><br><span class="line">    Q-&gt;rear-&gt;next = p;   <span class="comment">//还未入队的此时队尾的下一结点指向p</span></span><br><span class="line">    Q-&gt;rear = p;   <span class="comment">//这时队尾指针指向p，即p成为了新的队尾结点</span></span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//队尾结点的指针域为空</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function">Status <span class="title">leave</span><span class="params">(LinkQueue *Q, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(*Q))&#123;   <span class="comment">//判断链队是否为空，若为空则无链队元素可供出队</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"链队为空，无队元素可出列\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNodePtr p;   <span class="comment">//定义临时结点指针p</span></span><br><span class="line">    p = Q-&gt;front-&gt;next;   <span class="comment">//将p置为链队的首个结点</span></span><br><span class="line">    *e = p-&gt;data;   <span class="comment">//将首个结点p的数据域赋给e以供返回与查看</span></span><br><span class="line">    Q-&gt;front-&gt;next = p-&gt;next;   <span class="comment">//将老首个结点的下一结点设置为首个结点</span></span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear == p)&#123;   <span class="comment">//若此时p也为尾结点，说明队列为空了</span></span><br><span class="line">        Q-&gt;rear = Q-&gt;front;   <span class="comment">//如果队列为空则将队尾指针重新指向头结点表示链队为空了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);   <span class="comment">//将出队的p结点释放掉</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取链队的队头元素</span></span><br><span class="line"><span class="function">Status <span class="title">getHead</span><span class="params">(LinkQueue Q, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(Q))&#123;   <span class="comment">//判断链队是否为空，若为空则无链队的队头元素可供查看</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"链队为空，无队头元素\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = Q.front-&gt;next-&gt;data;   <span class="comment">//若链队不为空，则将链队的首个结点的数据域赋给e供返回与查看</span></span><br><span class="line">    <span class="keyword">return</span> OK;   <span class="comment">//仅查看队头元素，指针不发生移动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空链队</span></span><br><span class="line"><span class="function">Status <span class="title">clearQueue</span><span class="params">(LinkQueue *Q)</span></span>&#123;</span><br><span class="line">    QueueNodePtr p, q;   <span class="comment">//定义临时结点pq</span></span><br><span class="line">    p = Q-&gt;front-&gt;next;   <span class="comment">//将p结点置为链队的首个结点</span></span><br><span class="line">    Q-&gt;rear = Q-&gt;front;   <span class="comment">//将队尾指针指向头结点与头指针相同，这样则表示此时链队为空</span></span><br><span class="line">    Q-&gt;front-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//将头结点的指针域置空，即无首个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;   <span class="comment">//若p存在则继续执行循环体</span></span><br><span class="line">        q = p;   <span class="comment">//将p赋给q</span></span><br><span class="line">        p = p-&gt;next;   <span class="comment">//p继续向下进行</span></span><br><span class="line">        <span class="built_in">free</span>(q);   <span class="comment">//释放q，一直循环直到p结点不再存在，即此时链队的结点都被释放掉了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印链队</span></span><br><span class="line"><span class="function">Status <span class="title">printQueue</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(Q))&#123;   <span class="comment">//判断链队是否为空，若为空则无链队元素可供打印</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"当前链队无元素可供打印\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNodePtr p;   <span class="comment">//定义临时结点p</span></span><br><span class="line">    p = Q.front-&gt;next;   <span class="comment">//将p赋为链队的首个结点</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;   <span class="comment">//此时链队元素位置计数器</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;   <span class="comment">//如果此时p存在的话则继续执行循环体</span></span><br><span class="line">        i++;   <span class="comment">//p存在则计数器+1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"从队首至队尾的第%d个元素为：%d\n"</span>, i, p-&gt;data);   <span class="comment">//打印当前p结点的数据域</span></span><br><span class="line">        p = p-&gt;next;   <span class="comment">//p指针继续向下移动，直到p为空，即链队的所有结点都打印完毕</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    initQueue(&amp;Q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化队列Q后队列的长度为：%d\n此时的链队是否为空？（1是0否）：%d\n"</span>, getLength(Q), isEmpty(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"将1-6按顺序入队后可得链队：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)&#123;</span><br><span class="line">        enter(&amp;Q, i);</span><br><span class="line">    &#125;</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"此时队列的长度为：%d\n"</span>, getLength(Q));</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    getHead(Q, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"此时队列的队头为：%d\n"</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"队列出队两个元素：\n"</span>);</span><br><span class="line">    leave(&amp;Q, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"出队：%d\n"</span>, e);</span><br><span class="line">    leave(&amp;Q, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"出队：%d\n"</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"现在的链队为：\n"</span>);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"现在的链队长度为：%d\n"</span>, getLength(Q));</span><br><span class="line">    getHead(Q, &amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"现在链队的队头为：%d\n"</span>, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"清空链队后得链队为：\n"</span>);</span><br><span class="line">    clearQueue(&amp;Q);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【看法分享】浅谈考研</title>
    <url>/2020/06/30/%E3%80%90%E7%94%9F%E6%B4%BB%E5%8C%BA%E3%80%91%E6%9C%AC%E7%A7%91%E5%9C%A8%E8%AF%BB%E7%94%9F%E6%B5%85%E8%B0%88%E8%80%83%E7%A0%94/</url>
    <content><![CDATA[<p><strong>本科毕业考研一定是个不错的选择吗？我到底适不适合考研？大家都在互劝考研之时，本科在读生与你分享一些对考研的认知和建议，给你不一样的声音（●&gt;∀&lt;●）</strong></p>
<a id="more"></a>
<hr>
<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p><strong>最近恶补JVM的深入理解搞的有点头晕目眩，这会就偷懒一下写一点关于我对考研这条路的理解，希望能和大家一起交流，这仅仅代表我个人看法，不建议作为大家的决定参考。</strong></p>
<hr>
<h2 id="大家怎么说？"><a href="#大家怎么说？" class="headerlink" title="大家怎么说？"></a>大家怎么说？</h2><p>考研这个问题呢相信是在看这篇blog的你我都很关注的问题，我在很多很多场合和很多很多朋友都有交流过类似的问题，这些问题都有个通常的开头：你准备考研吗？我通常的回答：我大概率是不考研的。大家这时候往往开始用一些我们都听出茧的理由diss我，比如：<br><img src="https://wx1.sbimg.cn/2020/06/30/2tegO.png" alt="2tegO.png"><br>稍微做个总结把：</p>
<blockquote>
<ol>
<li>感觉不考研就找不到工作</li>
<li>感觉大家都考研了 不考就落下了</li>
<li>本科学的很鸡肋 需要考个研补一补</li>
<li>全村的希望 学历越高越牛X</li>
<li>想要找个好工作</li>
<li>靠 不知道本科毕了业能干什么<br>。。。   </li>
</ol>
</blockquote>
<p>所以针对这些普遍的疑问，就几个方面谈一谈我的理解吧</p>
<hr>
<h2 id="考研的目的"><a href="#考研的目的" class="headerlink" title="考研的目的"></a>考研的目的</h2><h3 id="研究生毕业真有那么香？"><a href="#研究生毕业真有那么香？" class="headerlink" title="研究生毕业真有那么香？"></a>研究生毕业真有那么香？</h3><p>暂且不谈论考研能否上岸问题，就考研的目的来讲只有很少数人是想从事科研方向才选择考研的，而大部分人是想利用研究生这个敲门砖走进自己理想工作的大门的，这个目的好吗？当然没错，没有人不想找到好工作，更没有人不想拿到更高的文凭。<br><strong>那么问题就来了！读研后真的能找到更好的工作？我拿一位已经毕业工作多年的华中科技大学的学长的经历跟大家分享一下：</strong></p>
<blockquote>
<p>这位学长自己导师手下毕业的小伙伴共5个，有两个去了某互联网厂做开发，有一个去了某通信厂的销服岗，另外一个也去了某通信厂，不过也是做开发，<strong>有且仅有一个</strong>小伙伴去了某算法研究院继续做图像相关的算法。   </p>
</blockquote>
<p>这段历程表面能看到的就是这样算下来，从事老本行图像相关算法研究的也只有一个，不严谨的计算也就是只有20%的比例。是的20%，并且唯一的20%是作为研究型人才的成神道路。也就是说每个人还是一样在IT基层做起了开发工作，<strong>并且比本科生要晚了3年</strong>。你能想象这三年本科生在这个技术岗上积累了多少东西了吗？面个试就盯你文凭？兄弟醒醒了</p>
<h3 id="鱼与熊掌整一套？"><a href="#鱼与熊掌整一套？" class="headerlink" title="鱼与熊掌整一套？"></a>鱼与熊掌整一套？</h3><p>我现在大二刚刚结业，也拿到了大三的课程信息，当我看见的第一眼便心里暗自发问：C#？What fuck？合着大一C++、大二Java、到了大三又拿起了C#？这是学校带着我们集体摸鱼？大四学什么？Python？学了一年的Java突然来了C语言版的数据结构？所以对于学校课程的安排我心里只能默念我<strong><strong>***</strong></strong>，没办法，学校有学校自己的理由，我们不得不去接受，所以按照学校的步伐我的简历可以怎么写呢：<br>1.了解C++；<br>2.了解Java；<br>3.了解C#；<br>4.了解Python；<br>所以，到底会干嘛？我甚至还没有校外培训班的同学们会的多？学这么多语言还都是了解级别的，我教大家初识变成语言？我不知道考上研之后的课程是怎样的我也不敢多想，所以我想说：<strong>文凭和技术真的不能兼得</strong>（我不否认神级别的大牛能做到，但是不抬杠，仅仅个人想法，Peace）但是作为计算机专业的人来讲，<strong>因为学校不会教你Git SVN Maven Gradle怎么用，不会教你什么是Spring开发框架 什么是Nginx Tomcat Jetty Undertow，什么是中间件缓存技术，什么是Rocket消息队列，什么是RPC框架，什么数据库的链接是Druid，ORM层数据库框架，什么是MyCat分库分表，什么是分布式/微服务熔断降级网关服务调用负载均衡分布式事务链路追踪和监控日志分析容器技术容器排版技术</strong>你说你研究生再学完？那我瑞斯拜！<br><strong>大家都知道，搞开发是一碗青春饭，这碗饭过了青春就某的吃了，中年危机不是危言耸听，大家可以去了解一下很多中年程序员的经历分享你就有答案了。更不容忽略的是，搞开发真的看文凭吗？根据众多领英的人才分享来看，开发真的重点看技术能力，而不是你是不是研究生的学历。</strong></p>
<hr>
<h2 id="考研的难度"><a href="#考研的难度" class="headerlink" title="考研的难度"></a>考研的难度</h2><h3 id="扩招了研究生好考了？"><a href="#扩招了研究生好考了？" class="headerlink" title="扩招了研究生好考了？"></a>扩招了研究生好考了？</h3><p>给数据：<br><img src="https://wx2.sbimg.cn/2020/06/30/2tO1l.jpg" alt="2tO1l.jpg"><br><img src="https://wx1.sbimg.cn/2020/06/30/2tSE1.jpg" alt="2tSE1.jpg"><br>官方数据及预测：</p>
<blockquote>
<p>2019年考研报名人数为290万人，报录比预计为3.6：1，较2018年有明显的提升。<br>2020年考研报名人数再次上涨，共计 341万，特殊原因大幅扩招，报录比为3.4：1，勉强和去年持平。<br>预测：根据今年情况，预测2021年研究生报考人数有望突破400w，但招生人数涨幅应该不会太大。在这一情况下，2021年的考研报录比很可能会飙升至4:1!将创历史新高！</p>
</blockquote>
<h3 id="我不怕？"><a href="#我不怕？" class="headerlink" title="我不怕？"></a>我不怕？</h3><p><strong>你想，你仔细想，你以为你好好肝个一年就能肝考上清北考上华科考上复旦同济了？现在数据流通这么强，很多很多的同学越来越早的准备考研了，甚至于大一就开始了一门心思的考研，所以说这个竞争力一点点都不亚于高考。越早准备读研你就越早将你的赌注放到了这个上面，如果失利，你失去的要比你看到的多得多。具体参考上一章节鱼与熊掌来一套。</strong></p>
<h3 id="二战？三战？"><a href="#二战？三战？" class="headerlink" title="二战？三战？"></a>二战？三战？</h3><p><strong>赌注挺大，直接赌上了一切了，你要考不上清北感觉完全亏了昂，这个时间成本要是会算账的话自己心里悄悄算一下就知道亏了多少了，对于这种情况我只能Good luck！</strong></p>
<h3 id="祝福"><a href="#祝福" class="headerlink" title="祝福"></a>祝福</h3><p><strong>这里也希望正在考研或者准备考研的同学顺利上岸！！</strong><br><img src="https://wx2.sbimg.cn/2020/06/30/2wmoY.jpg" alt="2wmoY.jpg"></p>
<hr>
<h2 id="我到底适不适合读研"><a href="#我到底适不适合读研" class="headerlink" title="我到底适不适合读研"></a>我到底适不适合读研</h2><h3 id="什么样的人适合读研"><a href="#什么样的人适合读研" class="headerlink" title="什么样的人适合读研"></a>什么样的人适合读研</h3><p><strong>首先</strong></p>
<blockquote>
<p>我认为最适合读研的就是热衷于科技研究有着把自己专业深挖创新突破的人，这也是我很尊重的一类人，乐于把精力奉献在科研工作的人都很值得敬仰。</p>
</blockquote>
<p><strong>其次</strong></p>
<blockquote>
<p>你的大学文凭真的阻挡住了你进入理想工作大门的人，比如很多企业要求要985 211 双一流毕业的学生，如果真的是这样好好读个研也是个不错的选择，因为这样你才能跨过门槛离理想更进一步不是？</p>
</blockquote>
<p><strong>再者</strong></p>
<blockquote>
<p>你对更好的院校充满向往，你的生活中心并非在就业，而是期望得到更牛X的文凭，这种也适合继续考研，而且加油吧哈哈</p>
</blockquote>
<p><strong>还有</strong></p>
<blockquote>
<p>你的专业非常需要更高的文凭，比如要硕士博士以上，例如我知道的医学哈哈那么也别犹豫了 继续考吧加油</p>
</blockquote>
<p><strong>最后</strong></p>
<blockquote>
<p>看完本篇blog或者无论是看过怎样的踩坑经验都仍然觉得考研才能找到好工作的，那我就拜拜，加油考</p>
</blockquote>
<h3 id="什么样的人不适合读研"><a href="#什么样的人不适合读研" class="headerlink" title="什么样的人不适合读研"></a>什么样的人不适合读研</h3><p><strong><em>首先要说我绝不会因为考研非易而鼓励大家不去考研！！！</em></strong>   </p>
<p><strong>首先</strong></p>
<blockquote>
<p>我认为厌学的人就最不适合读研了，厌学还要苦苦的逼着自己考研，到头来考个一般院校研究生，或者二战三战的真的没有必要兄弟，尽早的进入社会说不定能找到你热爱的事业</p>
</blockquote>
<p><strong>其次</strong></p>
<blockquote>
<p>如果你和我一样是一个热衷于技术的人那么你是否考研也要三思了，花多年的时间专心搞技术结果不是更好吗</p>
</blockquote>
<p><strong>再者</strong></p>
<blockquote>
<p>如果你和我专业计算机性质一样，都是技术至上的专业，那么我也劝不读研，何必赌这一把呢</p>
</blockquote>
<p><strong>最后</strong></p>
<blockquote>
<p>如果你的家庭真的不太能支撑你读研究生，你的工作能为家庭作出卓越贡献，这样我也劝不读研，读研真的不一定能带给你什么</p>
</blockquote>
<hr>
<h2 id="写在结尾"><a href="#写在结尾" class="headerlink" title="写在结尾"></a>写在结尾</h2><p><strong>本篇blog我也基本阐明了我对于考研的一些浅薄的看法，希望能对大家纠结的问题提供一些解答的思路，我始终觉得，任何决定都是应该三思而后行的，不要被身边的言论所左右，不要被眼前的一些趋势一些现象蒙蔽了双眼，多看一看外面的世界是怎样的，你周围之外的言论又是什么样的？</strong></p>
<blockquote>
<p>再次声明本篇blog仅代表个人看法不希望作为决定标准，还有期间言论如有得罪还望海涵，希望能与你一起成长！瑞斯拜！<br><img src="https://wx2.sbimg.cn/2020/06/30/2wkEV.jpg" alt="2wkEV.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>生活区</category>
      </categories>
      <tags>
        <tag>生活区</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机网络】Internet上的音/视频与无线网络</title>
    <url>/2020/07/24/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91Internet%E4%B8%8A%E7%9A%84%E9%9F%B3%E9%A2%91%E8%A7%86%E9%A2%91%E4%B8%8E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p><strong>计算机网络不看后悔系列blog(终篇）Internet上的音频与无线网络/超详细！！=≡Σ((( つ•̀ω•́)つ</strong></p>
<a id="more"></a>
<h2 id="8-1-Internet上传输音频视频的一些问题"><a href="#8-1-Internet上传输音频视频的一些问题" class="headerlink" title="8.1 Internet上传输音频视频的一些问题"></a>8.1 Internet上传输音频视频的一些问题</h2><ul>
<li>占用带宽高，要求网速恒定延迟低。而数据信息，对带宽要求低，网速不稳定，延迟高也没事。</li>
<li>延迟：发送时延，传播时延，排队时延，处理时延(路由的路径选择)，不过对于非交互式的音频视频的影响会小一些。</li>
<li>带宽不稳定。需要在接收端设置缓存(看电影时可以弥补数据包没按顺序接收到的问题)。</li>
</ul>
<h2 id="Internet上提供的音频-视频服务的类型"><a href="#Internet上提供的音频-视频服务的类型" class="headerlink" title="Internet上提供的音频/视频服务的类型"></a>Internet上提供的音频/视频服务的类型</h2><ul>
<li>流式存储音频/视频——边下载边播放。(节省客户端硬盘空间，不用下载；保护视频版权（只能特定的服务器可以提供下载）)</li>
<li>流式实况音频/视频——边录制边发送。(网络直播)</li>
<li>交互式音频/视频——实时交互式通信。(流式：streaming)</li>
</ul>
<h3 id="流式实况音频-视频"><a href="#流式实况音频-视频" class="headerlink" title="流式实况音频/视频"></a>流式实况音频/视频</h3><p><img src="https://wx2.sbimg.cn/2020/07/24/DrCDY.png" alt="DrCDY.png"></p>
<p><img src="https://wx2.sbimg.cn/2020/07/24/DrPxV.png" alt="DrPxV.png"></p>
<p><strong>mms（流媒体服务协议）</strong></p>
<h2 id="IP电话"><a href="#IP电话" class="headerlink" title="IP电话"></a>IP电话</h2><ul>
<li>狭义的IP电话：IP网络上打点电话。“IP网络”指“使用IP协议的分组交换网”的简称。</li>
<li>广义的IP电话：不仅仅是电话通信，而且还可以是在IP网络上进行交互式多媒体实时通信(包括话音/视像等)，甚至还包括即时传信IM(Instant Messaging)(QQ聊天/视频)。</li>
</ul>
<h3 id="IP电话网关的机中连接方法"><a href="#IP电话网关的机中连接方法" class="headerlink" title="IP电话网关的机中连接方法"></a>IP电话网关的机中连接方法</h3><p><img src="https://wx1.sbimg.cn/2020/07/24/Dr9ZO.png" alt="Dr9ZO.png"></p>
<h3 id="IP电话的通话质量"><a href="#IP电话的通话质量" class="headerlink" title="IP电话的通话质量"></a>IP电话的通话质量</h3><p>决定因素：</p>
<ul>
<li>通话双方端到端的时延和时延抖动。</li>
<li>话音分组的丢失率。</li>
</ul>
<blockquote>
<p>但是这两个因素是不确定的，是取决于当时网络上的通信量。<br>经验证明，在电话交谈中，端到端的时延不应超过250ms，否则交谈者就能感受到不自然。</p>
</blockquote>
<h3 id="改进网络层“尽最大努力交付”的服务"><a href="#改进网络层“尽最大努力交付”的服务" class="headerlink" title="改进网络层“尽最大努力交付”的服务"></a>改进网络层“尽最大努力交付”的服务</h3><ul>
<li><p>注意，网络层的目的就是“尽最大努力交付”，他不关心数据包是什么，谁着急。但是音频/视频就应该优先级更高，所以需要改进网络层“尽最大努力交付”的服务(QoS)。</p>
</li>
<li><p>服务质量QoS是服务性能的总效果，此效果决定了一个用户对服务的满意程度。因此在最简单的意义上，有服务质量的服务就是能够满足用户的应用需求的服务。</p>
</li>
<li><p>服务质量可用若干基本的性能指标来描述，包括可用性，差错率，响应时间，吞吐量，分组丢失率，连接建立时间，故障检测和改正时间等。服务提供者可向其用户保证某一种等级的服务质量。</p>
</li>
</ul>
<h3 id="服务器如何实现优先传输音频-视频数据包"><a href="#服务器如何实现优先传输音频-视频数据包" class="headerlink" title="服务器如何实现优先传输音频/视频数据包"></a>服务器如何实现优先传输音频/视频数据包</h3><p>QoS的一些手段：</p>
<ul>
<li>基于标记的优先级确认</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/24/DrROj.png" alt="DrROj.png"></p>
<blockquote>
<p>(H1-&gt;H3是实时音频通信，H2-&gt;H4是文件传输)需要给不同性质的分组打上不同的”标记”。当H1和H2的分组进入R1时，R1应能识别实时数据分组，并使这些分组以高优先级进入输出队列，而仅在队列有多余空间时才准许低优先级的FTP数据分组进入。</p>
</blockquote>
<ul>
<li>基于分类的优先级确认</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/24/DrdPk.png" alt="DrdPk.png"></p>
<blockquote>
<p>应当使路由器增加分类(Classification)机制，即路由器根据某些准则(例如根据发送数据的地址)对输入分组进行分类，然后对不同类别的通信量给予不同的优先级。</p>
</blockquote>
<ul>
<li>流量管制机制</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/24/Drgun.png" alt="Drgun.png"></p>
<blockquote>
<p>路由器应能对数据流进行通信量的管制(policing)，使该数据流不影响其它正常数据流在网络中通过。例如可将H1的数据率限定为1Mb/s。R1不停地监视H1的数据率。只要其数据率超过规定的1Mb/s，R1就将其中的某些分组丢弃。</p>
</blockquote>
<ul>
<li>调度机制</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/24/Drh8h.png" alt="Drh8h.png"></p>
<blockquote>
<p>应在路由器中再增加调度(scheduling)机制。利用调度功能给实时音频分配1.0Mb/s的带宽,给文教传送分配0.5Mb/s的带宽(相当于在带宽为1.5Mb/s的链路中划分出两个逻辑链路)，因而对这两种应用都有相应的服务质量保证。</p>
</blockquote>
<p>(5)呼叫接纳</p>
<p><img src="https://wx1.sbimg.cn/2020/07/24/DrJpM.png" alt="DrJpM.png"></p>
<p>总数据率已经超过1.5Mb/s链路的带宽。比较合理的做法是让一个数据流通过1.5Mb/s的链路，而组织另一个数据流的通过。这就需要呼叫接纳(call admission)机制。数据流要预先声明所需的服务质量，然后要么被准许进入网络，要么被拒绝进入。</p>
<h2 id="无线网络间的对比"><a href="#无线网络间的对比" class="headerlink" title="无线网络间的对比"></a>无线网络间的对比</h2><p><img src="https://wx2.sbimg.cn/2020/07/24/DrLga.png" alt="DrLga.png"></p>
<ul>
<li>PAN：个人局域网</li>
<li>LAN：无线局域网</li>
<li>MAN：无线城域网</li>
<li>WAN：无线广域网</li>
</ul>
<h2 id="无线局域网的组成"><a href="#无线局域网的组成" class="headerlink" title="无线局域网的组成"></a>无线局域网的组成</h2><ul>
<li>重点讨论LAN。思路是设备的无线网卡和无线路由的AP连接，组成无线局域网，无线AP给无线设备分配IP。</li>
<li>基本服务集内的基站叫做接入点AP(Access Point)。</li>
<li>当网络管理员安装AP时，必须为该AP分配一个不超过32字节的 服务集标识符SSID 和 一个信道。</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/24/DrqQK.png" alt="DrqQK.png"></p>
<blockquote>
<p>两个无线IP通过网线连接，这样两个无线局域网可以看成一个整体的网络，<strong>两个AP类似于集线器</strong>。</p>
</blockquote>
<h2 id="无线路由"><a href="#无线路由" class="headerlink" title="无线路由"></a>无线路由</h2><p>###传统的ADSL拨号上网</p>
<p><img src="https://wx1.sbimg.cn/2020/07/24/Dre7G.png" alt="Dre7G.png"></p>
<blockquote>
<p>电话线接入分离器，与猫(调制解调器)的ADSL连接(分离器出来的另一条线连接电话)，LAN是接网线的口，与电脑的网卡连接，然后在电脑上创建ADSL拨号连接，输入账号密码，获得一个公网连接的IP地址，从而连入网络。这种方式只能连接一个电脑。</p>
</blockquote>
<h3 id="无线路由-1"><a href="#无线路由-1" class="headerlink" title="无线路由"></a>无线路由</h3><p><img src="https://wx2.sbimg.cn/2020/07/24/DrtOT.png" alt="DrtOT.png"></p>
<blockquote>
<p>为了实现给家庭内多个设备接入网络，需要一个无线路由((1)中相同原理)，与猫连接(下图白色标记方框)，此时无线路由扮演一个路由的作用；蓝色方框(相当于交换机)是给家庭内需要有线上网的设备连接；无线路由的天线(相当于AP)是给室内手机和笔记本进行无线通信。</p>
</blockquote>
<p><img src="https://wx1.sbimg.cn/2020/07/24/DrzPw.png" alt="DrzPw.png"></p>
<p>实际上无线路由相当于集合了路由，AP和交换机三个设备的功能。室内的无线和有线设备都在一个网络里，使用的是无线路由的路由部分的网关。</p>
<h2 id="移动自组网络"><a href="#移动自组网络" class="headerlink" title="移动自组网络"></a>移动自组网络</h2><blockquote>
<p>自组网络是没有固定基础设施的(即没有AP)的无线局域网。这种网络由一些处于平等状态的移动站之间相互通信组成的临时网络。</p>
</blockquote>
<p><img src="https://wx2.sbimg.cn/2020/07/24/Dr71o.png" alt="Dr71o.png"></p>
<h2 id="3G-4G技术"><a href="#3G-4G技术" class="headerlink" title="3G/4G技术"></a>3G/4G技术</h2><blockquote>
<p>移动运营商在全国有很多基站，不同的手机会自动向最近的基站进行注册，手机通话时，连接顺序是手机A-基站A-基站B-手机B，如果手机移动位置的时候，会更改注册的基站，并更改数据库。</p>
</blockquote>
<p>参考：<br>韩立刚老师《计算机网络》课程<br><a href="https://blog.csdn.net/iwanderu/article/details/103813011" target="_blank" rel="noopener">https://blog.csdn.net/iwanderu/article/details/103813011</a>      </p>
<p>完结撒花ㄟ(◑‿◐ )ㄏ</p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>【生活区】吐血安利数十款宝藏网站</title>
    <url>/2020/07/04/%E3%80%90%E7%94%9F%E6%B4%BB%E5%8C%BA%E3%80%91%E5%90%90%E8%A1%80%E5%AE%89%E5%88%A9%E6%95%B0%E5%8D%81%E6%AC%BE%E5%AE%9D%E8%97%8F%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p><strong>不会吧!不会吧!不会真的有人不知道这些网站吧？自从收藏夹里有了这些网站，上网幸福指数直线上升啊！(｡◕ˇ∀ˇ◕）</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>今儿个周六，按照计划今天是对前几天写的技术博客的回顾温习，所以今天搞完计划还剩很多时间，所以就突发奇想，把我Chrome里面私藏的宝贝给大家分享一下，也希望其中能有些能对你们有用。当今Web技术极度成熟了，所以很多的网址的内容做的相当棒，所以我这里按照网站类型对这些网址进行了分类，大家可以利用目录（手机用户通过点击文章里左下角的菜单按钮即可查看目录）直接定位自己感兴趣的类别，分为以下三类：</p>
</blockquote>
<ul>
<li>究极休闲类</li>
<li>办公学习类</li>
<li>程序猿私享   </li>
</ul>
<p><strong>废话不多说 Here we go~</strong></p>
<h2 id="究极休闲类"><a href="#究极休闲类" class="headerlink" title="究极休闲类"></a>究极休闲类</h2><h3 id="Pexels（免费相片影片库）"><a href="#Pexels（免费相片影片库）" class="headerlink" title="Pexels（免费相片影片库）"></a>Pexels（免费相片影片库）</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2S5WD.png" alt="2S5WD.png"></p>
<blockquote>
<p>超级强大的高分辨率图和影片的合辑网站，这面入驻有很多的专业摄影师和模特，不仅能白嫖下载当屏保还能当艺术品欣赏，在这里面浏览久了感觉自己艺术品位都提升了呢（手动狗头）<a href="https://www.pexels.com/zh-tw/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.pexels.com/zh-tw/" target="_blank" rel="noopener">https://www.pexels.com/zh-tw/</a>)</p>
</blockquote>
<h3 id="豆瓣读书"><a href="#豆瓣读书" class="headerlink" title="豆瓣读书"></a>豆瓣读书</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2S4Re.png" alt="2S4Re.png"></p>
<blockquote>
<p>有的时候想读一些非专业知识的好书就很苦于哪里寻找，豆瓣读书是我找书用的最多的一个来源了，页面很友好，还有年度榜单这种大众认可的好书，可以说省了很多的时间去挑书，而且还有配套的书店和电子书，这么好的资源都放在这了，你确定不盘几本品品？<a href="https://book.douban.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://book.douban.com/" target="_blank" rel="noopener">https://book.douban.com/</a>)</p>
</blockquote>
<h3 id="偶书"><a href="#偶书" class="headerlink" title="偶书"></a>偶书</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SMyN.png" alt="2SMyN.png"></p>
<blockquote>
<p>这个本身其实我不太想分享给你们的，这是一款很强的白嫖图书电子版的网站，你也可以在里面求书还可以找一找读一读那些热门推荐里面的书籍，之所以说本来不想推荐主要是因为里面有很多的资源都属于盗版，但是后来想想不读要比读盗版更可怕，答应我，如果书对你有帮助，即便你读完了也要去买本正版支持作者！让更多的好书得以问世<a href="https://obook.cc/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://obook.cc/" target="_blank" rel="noopener">https://obook.cc/</a>)</p>
</blockquote>
<h3 id="马可菠萝"><a href="#马可菠萝" class="headerlink" title="马可菠萝"></a>马可菠萝</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2Skbn.png" alt="2Skbn.png"></p>
<blockquote>
<p>这是一款可以下载于Mac上的App合集网站，鉴于Mac上的Store实在太过于鸡肋，所以想要好的软件体验还是少不了第三方的提供，这里有很多的精品软件包括游戏办公美化等等吧，大家自行探索<a href="https://www.macbl.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.macbl.com/" target="_blank" rel="noopener">https://www.macbl.com/</a>)</p>
</blockquote>
<h2 id="办公学习区"><a href="#办公学习区" class="headerlink" title="办公学习区"></a>办公学习区</h2><h3 id="必应"><a href="#必应" class="headerlink" title="必应"></a>必应</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2S22h.png" alt="2S22h.png"></p>
<blockquote>
<p>为什么推荐bing呢？主要是因为百度的这个广告是在是太多了，百度一下整个第一页搜索结果全是广告，这也导致搜索幸福指数直线下降，所以bing这清爽又艺术的页面就让人赏心悦目，最主要的是他广告少呀，这才是搜索引擎应该有的亚子！不得不说百度某些产品的开发表现实在是越来越令人失望了，不过作为国产搜索引擎之光还是要多努力啊<a href="https://cn.bing.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://cn.bing.com/" target="_blank" rel="noopener">https://cn.bing.com/</a>)</p>
</blockquote>
<h3 id="ProcessOn"><a href="#ProcessOn" class="headerlink" title="ProcessOn"></a>ProcessOn</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2SCLM.png" alt="2SCLM.png"></p>
<blockquote>
<p>作为一个免费的在线作图的软件，ProcessOn的表现真的是非常棒了，相较于visio它更加的易于操作，相较于某些疯狂打广告自称免费的作图app不知道要好上多少倍，虽然它在某些非常强的功能上可以付费，但是免费功能足够日常使用了，至少导出不用充会员（叹息），在我的博客里面作图我都是用的这个ProcessOn很好用很友好！<br><a href="https://www.processon.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.processon.com/" target="_blank" rel="noopener">https://www.processon.com/</a>)</p>
</blockquote>
<h3 id="简书"><a href="#简书" class="headerlink" title="简书"></a>简书</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SDia.png" alt="2SDia.png"></p>
<blockquote>
<p>简书真的是本百科全书，它的涉及领域十分广泛，我是通过专业问题摸到了这个上面来的，接触久了才发现这里面有很多不同领域的作者写了很多满满干货文章，有时候你会发现很多领域的问题都可以在这找到答案，有点文章版的知乎的意思，闲下来的时候这里面的文章也是够探索的，总之很舒服，很有意思！<br><a href="https://www.jianshu.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.jianshu.com/" target="_blank" rel="noopener">https://www.jianshu.com/</a>)</p>
</blockquote>
<h3 id="Converto（在线文件格式转换器）"><a href="#Converto（在线文件格式转换器）" class="headerlink" title="Converto（在线文件格式转换器）"></a>Converto（在线文件格式转换器）</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2SoMR.png" alt="2SoMR.png"></p>
<blockquote>
<p>可以看到页面十分简洁并且功能强大的在线文件格式转换器，不管是图片还是视频以及文档等等都是可以在这里找到转换格式列表，并且免费！唯一不足的地方是很大的文件格式转换速度比较慢，不过也可以接受，办公学习日常免不了文件格式转换，线上直换省时又省力<br><a href="https://convertio.co/zh/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://convertio.co/zh/" target="_blank" rel="noopener">https://convertio.co/zh/</a>)</p>
</blockquote>
<h3 id="慕课"><a href="#慕课" class="headerlink" title="慕课"></a>慕课</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2S3RI.png" alt="2S3RI.png"></p>
<blockquote>
<p>这个想必大家都不陌生，作为一个大学学习网站，MOOC做的真的是特别优秀了，不仅是很多名校的加入让Mooc课程内容含金量满满，而且多用才发现它真的是个很强的学习宝库，所以还是希望大家多多探索它，畅游在知识的海洋～<br><a href="https://www.icourse163.org/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.icourse163.org/" target="_blank" rel="noopener">https://www.icourse163.org/</a>)</p>
</blockquote>
<h3 id="江下科技在线应用"><a href="#江下科技在线应用" class="headerlink" title="江下科技在线应用"></a>江下科技在线应用</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2S9VG.png" alt="2S9VG.png"></p>
<blockquote>
<p>这个网站是我最近才发掘的，我是在一次需要图片压缩的时候意外找到的，使用后体验很不错，首先很重要的是它免费！并且它对于图片压缩的性能有着不俗的表现，不仅速度快而且下载也很快，总之是一款效率很高功能很强大的在线办公应用！<br><a href="https://www.onlinedo.cn/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.onlinedo.cn/" target="_blank" rel="noopener">https://www.onlinedo.cn/</a>)</p>
</blockquote>
<h3 id="盲打在线学习课程"><a href="#盲打在线学习课程" class="headerlink" title="盲打在线学习课程"></a>盲打在线学习课程</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SQ6T.png" alt="2SQ6T.png"></p>
<blockquote>
<p>我真的特别感谢这个网站，因为在刚寒假的时候就接触到了它，然后按照这个网站的的课程一步一步的让我充分掌握了盲打技术，自从学会了盲打，电脑学习工作的体验简直不要太爽～关于盲打我真的觉得大家都可以学一学，因为面不了电脑办公，掌握盲打肯定让你效率高涨，我只学了大概两周就已经掌握的不错了，大家学起来吧（首次加载有些慢，不要着急慢慢等待）<br><a href="https://www.typingstudy.com/zh/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.typingstudy.com/zh/" target="_blank" rel="noopener">https://www.typingstudy.com/zh/</a>)</p>
</blockquote>
<h3 id="Removebg（抠图）"><a href="#Removebg（抠图）" class="headerlink" title="Removebg（抠图）"></a>Removebg（抠图）</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SBlo.png" alt="2SBlo.png"></p>
<blockquote>
<p>一款在线图片背景消除工具，简单理解就是抠图，可能日常生活不太需要，但是偶尔还是很可能会用一用的，这款工具对于图片处理萌新来说操作十分友好，很简单很清爽，并且免费，收藏起来吧～<br><a href="https://www.remove.bg/zh" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.remove.bg/zh" target="_blank" rel="noopener">https://www.remove.bg/zh</a>)</p>
</blockquote>
<h3 id="我要自学网"><a href="#我要自学网" class="headerlink" title="我要自学网"></a>我要自学网</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2Sc2l.png" alt="2Sc2l.png"></p>
<blockquote>
<p>全能自学网站！这个网站自学的领域范围真的是令人赞赏，看图就可以感受到它究竟有多么强大了，即便你不知道你对什么技术有兴趣，在里面游览一番说不定也能找到你喜欢的课程从此踏上人间巅峰了呢（呲牙）我在这里学习的竟然就是简单的电脑维修技术，的确不错，很香～<br><a href="https://www.51zxw.net/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.51zxw.net/" target="_blank" rel="noopener">https://www.51zxw.net/</a>)</p>
</blockquote>
<h3 id="优品PPT"><a href="#优品PPT" class="headerlink" title="优品PPT"></a>优品PPT</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2Sgn2.png" alt="2Sgn2.png"></p>
<blockquote>
<p>免费的PPT模版下载网址，众所周知PPT自我制作的步骤还是十分繁琐的，并且要做出好的PPT还需要很多精细的操作，现在大多的PPT模版的下载网址大都收费，所以像这种种类繁多又免费的PPT网站的存在实属不易，作为办公老朋友的PPT模版还是白嫖模版比较香～<br><a href="http://www.ypppt.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="http://www.ypppt.com/" target="_blank" rel="noopener">http://www.ypppt.com/</a>)</p>
</blockquote>
<h3 id="adddog（网址导航）"><a href="#adddog（网址导航）" class="headerlink" title="adddog（网址导航）"></a>adddog（网址导航）</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SsM8.png" alt="2SsM8.png"></p>
<blockquote>
<p>有了它即使你没有之前安利的那么多网址也没关系，因为它为你准备了各种行业领域或技术领域可以使用的干活网站，相比于其他网址导航满满的广告，这个导航就良心太多了，网站摆酷快快进收藏夹吃土吧～<br><a href="https://www.addog.vip/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.addog.vip/" target="_blank" rel="noopener">https://www.addog.vip/</a>)</p>
</blockquote>
<h3 id="北京大学视频公开课"><a href="#北京大学视频公开课" class="headerlink" title="北京大学视频公开课"></a>北京大学视频公开课</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2SJcJ.png" alt="2SJcJ.png"></p>
<blockquote>
<p>这个网站标题看着就有内味了，我在这个上面看过一些计算机专业的相关课感觉还不错，名校教师真是名不虚传，很多疑难的点居然在课上就可以提出解决了，不足之处就是很多种类的课程年代比较老画质不咋滴，并且很多课程在这个上面找不到，不过也还好，以后更新了说不定就更齐全了～<br><a href="http://opencourse.pku.edu.cn/course/opencourse/index.html" target="_blank" rel="noopener">戳我直达</a>(<a href="http://opencourse.pku.edu.cn/course/opencourse/index.html" target="_blank" rel="noopener">http://opencourse.pku.edu.cn/course/opencourse/index.html</a>)</p>
</blockquote>
<h3 id="公益图床"><a href="#公益图床" class="headerlink" title="公益图床"></a>公益图床</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SLYm.png" alt="2SLYm.png"></p>
<blockquote>
<p>如果你和我一样也在写博客的话图床是肯定离不开的，当下在线图床工具不算少比如七牛云等等但是要么得冲币要么不稳定要么就是操作不友好，这个公益图床是我的blog一直在用的在线图床工具，用了一段时间感觉还不错，页面很美观很简洁，操作也很友好，但是作为免费用户只能上传2M以下的图，不过可以接受，这个图床工具我也不敢恭维它，小问题不断不过总体下来作为免费图床工具已经是很不错的了<br><a href="https://sbimg.cn/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://sbimg.cn/" target="_blank" rel="noopener">https://sbimg.cn/</a>)</p>
</blockquote>
<h2 id="程序猿私享"><a href="#程序猿私享" class="headerlink" title="程序猿私享"></a>程序猿私享</h2><h3 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2SjVU.png" alt="2SjVU.png"></p>
<blockquote>
<p>这个是我非常喜欢的一个在线学习网站，里面涵盖了几乎所有的计算机知识，并且对于基础知识来说更是非常的多，它最大的特点就是将某种知识区循序渐进的一步步的教授，让人学起来觉得非常的有趣非常的轻松，今天下午我还刚刚简单的学习完了前端开发的HTML CSS和JavaScript，总是特别棒特别香墙裂推荐～<br><a href="https://www.runoob.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com/</a>)</p>
</blockquote>
<h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2S19d.png" alt="2S19d.png"></p>
<blockquote>
<p>GitHub想必不用我多说，感觉程序员应该没有不用的，作为一个全球最大的开源项目集结地，GitHub在计算机专业的地位毋庸置疑，里面大量的开源项目分享简直就是程序员的宝库！<br><a href="https://github.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://github.com/)、" target="_blank" rel="noopener">https://github.com/)、</a></p>
</blockquote>
<h3 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2Sqw4.png" alt="2Sqw4.png"></p>
<blockquote>
<p>这个应该更不用我介绍了，CSDN是面向国内最大的程序员社区了，是国内标杆般的存在，我很多很多学习的计算机知识大都来自于CSDN，当然我也在CSDN建立了blog，希望能和大家一起加入CSDN～<br><a href="https://www.csdn.net/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.csdn.net/" target="_blank" rel="noopener">https://www.csdn.net/</a>)</p>
</blockquote>
<h3 id="Gitee码云"><a href="#Gitee码云" class="headerlink" title="Gitee码云"></a>Gitee码云</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SelY.png" alt="2SelY.png"></p>
<blockquote>
<p>Gitee码云虽然创立的较晚但是它做的功能真的是已经很棒了，完全可以成为国内版GitHub了，正是因为它位于国内，才让它对于GitHub来说有了加载速度快的绝对优势，想必大家都有从GitHub上好不容易找到了好的开源项目但是git clone到本地的时候速度简直不要太感人，很好的解决方式就是将GitHub上的仓库地址直接先导入Gitee上然后再git clone那速度，快到飞起～<br><a href="https://gitee.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a>)</p>
</blockquote>
<h3 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2SwCA.png" alt="2SwCA.png"></p>
<blockquote>
<p>牛客网真是个善后的存在，自从在牛客刷了些面试题后我才惊喜的发现我遗漏了哪些关键位置知识点，牛客本身的功能就很强大，我把它当作一个量足的题库，很多编程题目都可以在上面找到诸多解决思路，用起来啦～<br><a href="https://www.nowcoder.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a>)</p>
</blockquote>
<h3 id="简单教程"><a href="#简单教程" class="headerlink" title="简单教程"></a>简单教程</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SzLV.png" alt="2SzLV.png"></p>
<blockquote>
<p>类似于菜鸟教程，我在这个简单教程学了设计模式，感觉还不错，页面很清爽，讲解也很细致，节奏也比较慢，是个学开发的不可多得的在线学习网站<br><a href="https://www.twle.cn/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.twle.cn/" target="_blank" rel="noopener">https://www.twle.cn/</a>)</p>
</blockquote>
<h3 id="虫部落"><a href="#虫部落" class="headerlink" title="虫部落"></a>虫部落</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SZFD.png" alt="2SZFD.png"></p>
<blockquote>
<p>很强大万物集结地，这里边个个都是人才哈哈，这里有很多破解修改的软件或者脚本之类的有创意的资源，我在里面能泡一天～<br><a href="https://www.chongbuluo.com/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.chongbuluo.com/" target="_blank" rel="noopener">https://www.chongbuluo.com/</a>)</p>
</blockquote>
<h3 id="Java教程"><a href="#Java教程" class="headerlink" title="Java教程"></a>Java教程</h3><p><img src="https://wx2.sbimg.cn/2020/07/04/2SywT.png" alt="2SywT.png"></p>
<blockquote>
<p>专注的Java教程网站，在这里学Java开发很有意思，它将很多的知识点以及知识区块都用游戏的方式呈现出来，并且有很多有意思小应用，对于Java语言的系统学习很有意思～<br><a href="https://how2j.cn/?p=61135" target="_blank" rel="noopener">戳我直达</a>(<a href="https://how2j.cn/?p=61135" target="_blank" rel="noopener">https://how2j.cn/?p=61135</a>)</p>
</blockquote>
<h3 id="OSCHINA"><a href="#OSCHINA" class="headerlink" title="OSCHINA"></a>OSCHINA</h3><p><img src="https://wx1.sbimg.cn/2020/07/04/2SVrw.png" alt="2SVrw.png"></p>
<blockquote>
<p>中国专注于开源项目的很不错的网站，相比于GitHub他对国内的程序员更加友好，虽然没有GiyHub那么丰富的资源，但是作为国内开源网站，集结的开源项目也是非常值得肯定的！<br><a href="https://www.oschina.net/" target="_blank" rel="noopener">戳我直达</a>(<a href="https://www.oschina.net/" target="_blank" rel="noopener">https://www.oschina.net/</a>)</p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><strong>本以为这篇博客半小时就能写完，没想到写下来用了两个多小时（狂哭）当然如果这些安利里面有可以帮到你的我也算值了～本次大约安利了将近30款在线网址，不过究极休闲区安利的很少，因为我本身也很少去使用这类的网址，希望大家如果有什么好的在线网址也可以安利给我，我也会及时更新分享给大家哒～还是那句话，希望可以和大家一起成长，请立即加油喔</strong></p>
]]></content>
      <categories>
        <category>生活区</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>好物</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机网络】干货知识总结</title>
    <url>/2020/07/17/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E5%B9%B2%E8%B4%A7%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>全文背诵٩(//̀Д/۶́)涵盖了计算机网络五层协议的内部干货可以作为预习也可以作为复习用/本文参考众多文章后总结但并不详细/后期逐渐更新更为详细的计算机网络知识的博客</strong></p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><h4 id="计算机网络（网络）"><a href="#计算机网络（网络）" class="headerlink" title="计算机网络（网络）"></a>计算机网络（网络）</h4><blockquote>
<p>网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。</p>
</blockquote>
<h4 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h4><blockquote>
<p>Internet Service Provider <strong>互联网服务提供商</strong>：ISP可以从互联网管理机构获得许多IP地址，同时拥有通信线路以及路由器等联网设备，个人或机构向ISP缴纳一定的费用就可以接入互联网。目前的互联网是一种多层次ISP结构，ISP根据覆盖面积的大小分为主干 ISP、地区 ISP 和本地 ISP。</p>
</blockquote>
<h4 id="IXP"><a href="#IXP" class="headerlink" title="IXP"></a>IXP</h4><blockquote>
<p>Internet eXchange Point:互联网交换点IXP的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</p>
</blockquote>
<h4 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h4><blockquote>
<p>Request For Comments:意思是“请求评议”，包含了关于Internet几乎所有的重要的文字资料。</p>
</blockquote>
<h4 id="WAN"><a href="#WAN" class="headerlink" title="WAN"></a>WAN</h4><blockquote>
<p>广域网（Wide Area Network）：任务是通过长距离运送主机发送的数据</p>
</blockquote>
<h4 id="MAN"><a href="#MAN" class="headerlink" title="MAN"></a>MAN</h4><blockquote>
<p>城域网（Metropolitan Area Network）:用来讲多个局域网进行互连</p>
</blockquote>
<h4 id="LAN"><a href="#LAN" class="headerlink" title="LAN"></a>LAN</h4><blockquote>
<p>局域网（Local Area Network）:学校或企业大多拥有多个互连的局域网<br><strong>局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</strong></p>
</blockquote>
<h4 id="WLAN"><a href="#WLAN" class="headerlink" title="WLAN"></a>WLAN</h4><blockquote>
<p>无限局域网</p>
</blockquote>
<h4 id="PAN"><a href="#PAN" class="headerlink" title="PAN"></a>PAN</h4><blockquote>
<p>个人区域网（Personal Area Network）:在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络  </p>
</blockquote>
<h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><blockquote>
<p>主机：连接在因特网上的计算机</p>
</blockquote>
<h4 id="end-system"><a href="#end-system" class="headerlink" title="end system"></a>end system</h4><blockquote>
<p>端系统：处在因特网边缘的部分即是连接在因特网上的所有的主机.</p>
</blockquote>
<h4 id="packet："><a href="#packet：" class="headerlink" title="packet："></a>packet：</h4><blockquote>
<p>分组：因特网中传送的数据单元。由首部header和数据段组成。分组又称为包，首部可称为包头。</p>
</blockquote>
<h4 id="bandwidth："><a href="#bandwidth：" class="headerlink" title="bandwidth："></a>bandwidth：</h4><blockquote>
<p>宽带：在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为b/s。</p>
</blockquote>
<h4 id="throughput："><a href="#throughput：" class="headerlink" title="throughput："></a>throughput：</h4><blockquote>
<p>吞吐量：表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。</p>
</blockquote>
<h3 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h3><h4 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h4><blockquote>
<p>边缘部分：所有连接在互联网上的主机，用户可以直接使用；<br>核心部分：由大量的网络和连接这些网络的路由器组成，为边缘部分的主机提供服务。</p>
</blockquote>
<h4 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h4><blockquote>
<ul>
<li>客户 - 服务器（C/S）<br>客户即是服务请求方，服务器是服务提供方。</li>
<li>对等（P2P）<br>不区分客户和服务器。</li>
</ul>
</blockquote>
<p><strong>客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方</strong>。</p>
<h4 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h4><ul>
<li>电路交换电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</li>
<li>报文交换<br>报文交换用于邮局通信系统，邮局接收到一份报文之后，先存储下来，然后把相同目的地的报文一起转发到下一个目的地，这个过程就是存储转发过程。</li>
<li>分组交换<br>分组交换也使用了存储转发，但是转发的是分组而不是报文。把整块数据称为一个报文，由于一个报文可能很长，需要先进行切分，来满足分组能处理的大小。在每个切分的数据前面加上首部之后就成为了分组，首部包含了目的地址和源地址等控制信息。</li>
</ul>
<blockquote>
<p>存储转发允许在一条传输线路上传送多个主机的分组，因此不需要占用端到端的线路资源。相比于报文交换，由于分组比报文更小，存储转发的速度也就更快。</p>
</blockquote>
<h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</p>
<ul>
<li>发送时延:<br>主机或路由器发送数据帧所需要的时间。l/v(其中l 表示数据帧的长度，v 表示发送速)。</li>
<li>传播时延:<br>电磁波在信道中传播一定的距离需要花费的时间，电磁波传播速度接近光速。l/v (其中l表示信道长度,v表示电磁波在信道上的传播速率)。</li>
<li>处理时延:<br>主机或路由器收到分组时进行处理所需要的时间，例如分析首部，从分组中提取数据部分等。</li>
<li>排队时延:<br>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。<br>计算机网络体系结构*</li>
</ul>
<h4 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h4><p><img src="https://wx2.sbimg.cn/2020/07/17/CnUo2.png" alt="CnUo2.png"></p>
<ul>
<li>七层协议<br>其中表示层和会话层用途如下：   <blockquote>
<ul>
<li>表示层：信息的语法语义以及它们的关联，如加密解密、转换翻译、压缩解压缩；   </li>
<li>会话层：不同机器上的用户之间建立及管理会话。</li>
</ul>
</blockquote>
</li>
<li>五层协议<blockquote>
<ul>
<li>应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。   </li>
<li>运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。</li>
<li>网络层：为主机之间提供服务，而不是像运输层协议那样是为主机中的进程提供服务。网络层把运输层产生的报文段或者用户数据报封装成分组来进行传输。</li>
<li>数据链路层：网络层针对的还是主机之间，而主机之间可以有很多链路，链路层协议就是为相邻结点之间提供服务。数据链路层把网络层传来的分组封装成帧。</li>
<li>物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使物理层上的数据链路层感觉不到这些差异。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>运输层最主要的协议是TCP和UDP协议，网络层最重要的协议是IP协议</strong>。</p>
<h4 id="数据在各层之间的传递过程"><a href="#数据在各层之间的传递过程" class="headerlink" title="数据在各层之间的传递过程"></a>数据在各层之间的传递过程</h4><p><strong>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部</strong>。路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。</p>
<h4 id="互联网名词"><a href="#互联网名词" class="headerlink" title="互联网名词"></a>互联网名词</h4><ul>
<li>小写字母i开头的internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。</li>
<li>大写字母I开头的Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用TCP/IP协议作为通信规则，其前身为ARPANET。Internet的推荐译名为因特网，现在一般流行称为互联网。</li>
</ul>
<h4 id="路由器与分组交换"><a href="#路由器与分组交换" class="headerlink" title="路由器与分组交换"></a>路由器与分组交换</h4><blockquote>
<p><strong>路由器是实现分组交换的关键构件，其任务是转发受到的分组，这是网络核心部分最重要的功能</strong>。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后在进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据端的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组有称为包。<strong>分组是在互联网中传送的数据单元，正式由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点</strong>。</p>
</blockquote>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</p>
<h4 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h4><p>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="相关术语-1"><a href="#相关术语-1" class="headerlink" title="相关术语"></a>相关术语</h3><h4 id="数据（data）"><a href="#数据（data）" class="headerlink" title="数据（data）"></a>数据（data）</h4><blockquote>
<p>运送消息的实体。</p>
</blockquote>
<h4 id="信号（signal）："><a href="#信号（signal）：" class="headerlink" title="信号（signal）："></a>信号（signal）：</h4><blockquote>
<p>数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。</p>
</blockquote>
<h4 id="码元（-code）："><a href="#码元（-code）：" class="headerlink" title="码元（ code）："></a>码元（ code）：</h4><blockquote>
<p>在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。</p>
</blockquote>
<h4 id="单工（simplex-）："><a href="#单工（simplex-）：" class="headerlink" title="单工（simplex ）："></a>单工（simplex ）：</h4><blockquote>
<p>只能有一个方向的通信而没有反方向的交互。</p>
</blockquote>
<h4 id="半双工（half-duplex-）："><a href="#半双工（half-duplex-）：" class="headerlink" title="半双工（half duplex ）："></a>半双工（half duplex ）：</h4><blockquote>
<p>通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</p>
</blockquote>
<h4 id="全双工（full-duplex）："><a href="#全双工（full-duplex）：" class="headerlink" title="全双工（full duplex）："></a>全双工（full duplex）：</h4><blockquote>
<p>通信的双方可以同时发送和接收信息。</p>
</blockquote>
<h4 id="奈氏准则："><a href="#奈氏准则：" class="headerlink" title="奈氏准则："></a>奈氏准则：</h4><blockquote>
<p>在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。</p>
</blockquote>
<h4 id="基带信号（baseband-signal）："><a href="#基带信号（baseband-signal）：" class="headerlink" title="基带信号（baseband signal）："></a>基带信号（baseband signal）：</h4><blockquote>
<p>来自信源的信号。指没有经过调制的数字信号或模拟信号。</p>
</blockquote>
<h4 id="带通（频带）信号（bandpass-signal）："><a href="#带通（频带）信号（bandpass-signal）：" class="headerlink" title="带通（频带）信号（bandpass signal）："></a>带通（频带）信号（bandpass signal）：</h4><blockquote>
<p>把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。</p>
</blockquote>
<h4 id="调制（modulation-）："><a href="#调制（modulation-）：" class="headerlink" title="调制（modulation ）："></a>调制（modulation ）：</h4><blockquote>
<p>对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。</p>
</blockquote>
<h4 id="信噪比（signal-to-noise-ratio-）："><a href="#信噪比（signal-to-noise-ratio-）：" class="headerlink" title="信噪比（signal-to-noise ratio ）："></a>信噪比（signal-to-noise ratio ）：</h4><blockquote>
<p>指信号的平均功率和噪声的平均功率之比，记为S/N。信噪比（dB）=10*log10（S/N）</p>
</blockquote>
<h4 id="信道复用（channel-multiplexing-）："><a href="#信道复用（channel-multiplexing-）：" class="headerlink" title="信道复用（channel multiplexing ）："></a>信道复用（channel multiplexing ）：</h4><blockquote>
<p>指多个用户共享同一个信道。（并不一定是同时）</p>
</blockquote>
<h4 id="比特率（bit-rate-）："><a href="#比特率（bit-rate-）：" class="headerlink" title="比特率（bit rate ）："></a>比特率（bit rate ）：</h4><blockquote>
<p>单位时间（每秒）内传送的比特数。</p>
</blockquote>
<h4 id="波特率（baud-rate）："><a href="#波特率（baud-rate）：" class="headerlink" title="波特率（baud rate）："></a>波特率（baud rate）：</h4><blockquote>
<p>单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。</p>
</blockquote>
<h4 id="复用（multiplexing）："><a href="#复用（multiplexing）：" class="headerlink" title="复用（multiplexing）："></a>复用（multiplexing）：</h4><blockquote>
<p>共享信道的方法</p>
</blockquote>
<h4 id="ADSL（Asymmetric-Digital-Subscriber-Line-）："><a href="#ADSL（Asymmetric-Digital-Subscriber-Line-）：" class="headerlink" title="ADSL（Asymmetric Digital Subscriber Line ）："></a>ADSL（Asymmetric Digital Subscriber Line ）：</h4><blockquote>
<p>非对称数字用户线。</p>
</blockquote>
<h4 id="光纤同轴混合网（HFC网）"><a href="#光纤同轴混合网（HFC网）" class="headerlink" title="光纤同轴混合网（HFC网）:"></a>光纤同轴混合网（HFC网）:</h4><blockquote>
<p>在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网</p>
</blockquote>
<h3 id="知识点总结-1"><a href="#知识点总结-1" class="headerlink" title="知识点总结"></a>知识点总结</h3><h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式:"></a>通信方式:</h4><ul>
<li>单向通信，又称为单工通信；</li>
<li>双向交替通信，又称为半双工通信；</li>
<li>双向同时通信，又称为全双工通信。</li>
</ul>
<h4 id="带通调制"><a href="#带通调制" class="headerlink" title="带通调制"></a>带通调制</h4><blockquote>
<p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p>
</blockquote>
<h4 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h4><ul>
<li>频分复用:频分复用的所有用户在相同的时间占用不同的频率带宽资源；</li>
<li>时分复用:所有用户在不同的时间占用相同的频率带宽资源。</li>
</ul>
<p><strong>使用这两种方式进行通信，在通信的过程中用户会一直占用一部分信道资源。但是由于计算机数据的突发性质，没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高</strong>。</p>
<ul>
<li>统计时分复用:是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成时分复用帧然后发送。</li>
<li>波分复用:光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</li>
<li>码分复用:为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 $\vec{S}$ 和 $\vec{T}$ 有(这里S的与T头均有箭头)    <blockquote>
<p>S*T=0    </p>
</blockquote>
</li>
</ul>
<p>为了方便，取 m=8，设码片$\vec{S}$为00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0时就发送该码片的反码11100100。</p>
<p>在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到</p>
<blockquote>
<p>1/m* S <em>S=1<br>1/m</em> S *S’=-1<br>$\vec{S’}$为$\vec{S}$的反码。</p>
</blockquote>
<p>利用上面的式子我们知道，当接收端使用码片$\vec{S}$对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特1，结果为-1的是用户发送的比特0。码分复用需要发送的数据量为原先的 m 倍。</p>
<h4 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h4><blockquote>
<p>透明地传送比特流。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能能的各种可能事件的出现顺序）。</p>
</blockquote>
<h4 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h4><ul>
<li>导引型传输媒体（双绞线，同轴电缆，光纤）</li>
<li>非导引型传输媒体（无线，红外，大气激光）。</li>
</ul>
<h4 id="数据通信系统的组成"><a href="#数据通信系统的组成" class="headerlink" title="数据通信系统的组成"></a>数据通信系统的组成</h4><blockquote>
<p>一个数据通信系统可划分为三大部分，即<strong>源系统，传输系统，目的系统</strong>。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</p>
</blockquote>
<h3 id="通信目的消息与信号"><a href="#通信目的消息与信号" class="headerlink" title="通信目的消息与信号"></a>通信目的消息与信号</h3><blockquote>
<p>通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电器或电磁的表现。</p>
</blockquote>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="相关术语-2"><a href="#相关术语-2" class="headerlink" title="相关术语"></a>相关术语</h3><h4 id="链路（link）"><a href="#链路（link）" class="headerlink" title="链路（link）"></a>链路（link）</h4><blockquote>
<p>一个结点到相邻结点的一段物理链路</p>
</blockquote>
<h4 id="数据链路（data-link）"><a href="#数据链路（data-link）" class="headerlink" title="数据链路（data link）"></a>数据链路（data link）</h4><blockquote>
<p>把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路</p>
</blockquote>
<h4 id="循环冗余检验CRC（Cyclic-Redundancy-Check）："><a href="#循环冗余检验CRC（Cyclic-Redundancy-Check）：" class="headerlink" title="循环冗余检验CRC（Cyclic Redundancy Check）："></a>循环冗余检验CRC（Cyclic Redundancy Check）：</h4><blockquote>
<p>为了保证数据传输的可靠性，CRC是数据链路层广泛使用的一种检错技术</p>
</blockquote>
<h4 id="帧（frame）"><a href="#帧（frame）" class="headerlink" title="帧（frame）"></a>帧（frame）</h4><blockquote>
<p>一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。</p>
</blockquote>
<h4 id="MTU（Maximum-Transfer-Uint-）"><a href="#MTU（Maximum-Transfer-Uint-）" class="headerlink" title="MTU（Maximum Transfer Uint ）"></a>MTU（Maximum Transfer Uint ）</h4><blockquote>
<p>最大传送单元。帧的数据部分的的长度上限。</p>
</blockquote>
<h4 id="误码率BER（Bit-Error-Rate-）"><a href="#误码率BER（Bit-Error-Rate-）" class="headerlink" title="误码率BER（Bit Error Rate ）"></a>误码率BER（Bit Error Rate ）</h4><blockquote>
<p>在一段时间内，传输错误的比特占所传输比特总数的比率。</p>
</blockquote>
<h4 id="MAC地址（Media-Access-Control或者Medium-Access-Control）"><a href="#MAC地址（Media-Access-Control或者Medium-Access-Control）" class="headerlink" title="MAC地址（Media Access Control或者Medium Access Control）"></a>MAC地址（Media Access Control或者Medium Access Control）</h4><blockquote>
<p>意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在OSI模型中，第三层网络层负责IP地址，第二层数据链路层则负 MAC地址。因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址  。地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处”</p>
</blockquote>
<h4 id="网桥（bridge）"><a href="#网桥（bridge）" class="headerlink" title="网桥（bridge）"></a>网桥（bridge）</h4><blockquote>
<p>一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备</p>
</blockquote>
<h4 id="交换机（switch-）"><a href="#交换机（switch-）" class="headerlink" title="交换机（switch ）"></a>交换机（switch ）</h4><blockquote>
<p>广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥</p>
</blockquote>
<h3 id="知识点总结-2"><a href="#知识点总结-2" class="headerlink" title="知识点总结"></a>知识点总结</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><blockquote>
<p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p>
</blockquote>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><blockquote>
<p>透明表示一个实际存在的事物看起来好像不存在一样。帧中有首部和尾部，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据中出现首部尾部相同的内容前面插入转义字符，如果需要传输的内容正好就是转义字符，那么就在转义字符前面再加个转义字符，在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p>
</blockquote>
<h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><blockquote>
<p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p>
</blockquote>
<h4 id="点对点信道-PPP-协议"><a href="#点对点信道-PPP-协议" class="headerlink" title="点对点信道 - PPP 协议"></a>点对点信道 - PPP 协议</h4><blockquote>
<p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议就是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p>
</blockquote>
<p><img src="https://wx2.sbimg.cn/2020/07/17/CnOHA.png" alt="CnOHA.png"></p>
<p>在 PPP 的帧中，F 字段为帧的定界符，A 和 C 暂时没有意义。FCS 是使用 CRC 的检验序列。信息部分的长度不超过 1500。<br><img src="https://wx1.sbimg.cn/2020/07/17/Cx4sD.png" alt="Cx4sD.png"></p>
<blockquote>
<p>点对点协议PPP是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议.</p>
</blockquote>
<h4 id="广播信道-CSMA-CD-协议"><a href="#广播信道-CSMA-CD-协议" class="headerlink" title="广播信道 - CSMA/CD 协议*"></a>广播信道 - CSMA/CD 协议*</h4><p>在广播信道上，同一时间只能允许一台计算机发送数据。<br>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p>
<p><strong>多点接入</strong>:</p>
<blockquote>
<p>说明这是总线型网络，许多计算机以多点的方式连接到总线上。载波监听：每个站都必须不停地检听信道。在发送前，如果检听信道正在使用，就必须等待。碰撞检测：在发送中，如果检听信道已有其它站正在发送数据，就表示发生了碰撞。虽然每一个站在发送数据之前都已经检听信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</p>
</blockquote>
<p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，<strong>称2τ为争用期</strong>。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用<strong>截断二进制指数退避算法</strong>来确定，从离散的整数集合{0,1,..,(2k-1)}中随机取出一个数，记作 r，然后取r倍的争用期作为重传等待时间。</p>
<h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><blockquote>
<p>从表面上看，使用集线器的局域网在物理上是一个星型网。但是集线器使用电子器件来模拟实际缆线的工作，逻辑上仍是一个总线网，整个系统仍像一个传统以太网那样运行。</p>
</blockquote>
<h4 id="MAC层"><a href="#MAC层" class="headerlink" title="MAC层"></a>MAC层</h4><blockquote>
<p>MAC 地址是 6 字节（48位）的地址，<strong>用于唯一表示网络适配器（网卡）</strong>，<strong>一台主机拥有多少个适配器就有多少个MAC地址</strong>，例如笔记本电脑普遍存在无线网络适配器和有线网络适配器。帧用类型字段来标记上层使用什么协议；数据字段长度在 46-1500 之间，如果太小则需要填充；FCS 为帧检验序列，使用的是CRC检验方法；前面插入的前同步码只是为了计算 FCS 临时加入的，计算结束之后会丢弃。</p>
</blockquote>
<h4 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h4><blockquote>
<p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到广播信息，例如 (A1, A2, A3, A4)属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4收到，而其它站点收不到。</p>
</blockquote>
<h4 id="链路与数据链路"><a href="#链路与数据链路" class="headerlink" title="链路与数据链路"></a>链路与数据链路</h4><blockquote>
<p>链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p>
</blockquote>
<h4 id="计算机与外接局域网通信"><a href="#计算机与外接局域网通信" class="headerlink" title="计算机与外接局域网通信"></a>计算机与外接局域网通信</h4><blockquote>
<p>需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的ROM中</strong>。</p>
</blockquote>
<h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><blockquote>
<p>以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</p>
</blockquote>
<blockquote>
<p>以太网采用的协议是具有冲突检测的载波监听多点接入CSMA/CD。协议的特点是：发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。因此，每一个站点在自己发送数据之后的一小段时间内，存在这遭遇碰撞的可能性。以太网上的各站点平等的争用以太网信道</p>
</blockquote>
<blockquote>
<p>以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</p>
</blockquote>
<blockquote>
<p>使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</p>
</blockquote>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="相关术语-3"><a href="#相关术语-3" class="headerlink" title="相关术语"></a>相关术语</h3><h4 id="虚电路（Virtual-Circuit）："><a href="#虚电路（Virtual-Circuit）：" class="headerlink" title="虚电路（Virtual Circuit）："></a>虚电路（Virtual Circuit）：</h4><blockquote>
<p>在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</p>
</blockquote>
<h4 id="IP（Internet-Protocol-）："><a href="#IP（Internet-Protocol-）：" class="headerlink" title="IP（Internet Protocol ）："></a>IP（Internet Protocol ）：</h4><blockquote>
<p>网际协议 IP 是 TCP/IP体系中两个最主要的协议之一，是TCP/IP体系结构网际层的核心。配套的有ARP，RARP，ICMP，IGMP。</p>
</blockquote>
<h4 id="ARP（Address-Resolution-Protocol）："><a href="#ARP（Address-Resolution-Protocol）：" class="headerlink" title="ARP（Address Resolution Protocol）："></a>ARP（Address Resolution Protocol）：</h4><blockquote>
<p>地址解析协议</p>
</blockquote>
<h4 id="ICMP（Internet-Control-Message-Protocol-）："><a href="#ICMP（Internet-Control-Message-Protocol-）：" class="headerlink" title="ICMP（Internet Control Message Protocol ）："></a>ICMP（Internet Control Message Protocol ）：</h4><blockquote>
<p>网际控制报文协议 （ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。）</p>
</blockquote>
<h4 id="子网掩码（subnet-mask-）："><a href="#子网掩码（subnet-mask-）：" class="headerlink" title="子网掩码（subnet mask ）："></a>子网掩码（subnet mask ）：</h4><blockquote>
<p>它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。</p>
</blockquote>
<h4 id="CIDR（-Classless-Inter-Domain-Routing-）："><a href="#CIDR（-Classless-Inter-Domain-Routing-）：" class="headerlink" title="CIDR（ Classless Inter-Domain Routing ）："></a>CIDR（ Classless Inter-Domain Routing ）：</h4><blockquote>
<p>无分类域间路由选择（特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）</p>
</blockquote>
<h4 id="默认路由（default-route）："><a href="#默认路由（default-route）：" class="headerlink" title="默认路由（default route）："></a>默认路由（default route）：</h4><blockquote>
<p>当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。</p>
</blockquote>
<h4 id="路由选择算法（Virtual-Circuit）："><a href="#路由选择算法（Virtual-Circuit）：" class="headerlink" title="路由选择算法（Virtual Circuit）："></a>路由选择算法（Virtual Circuit）：</h4><p>路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。</p>
<h3 id="知识点总结-3"><a href="#知识点总结-3" class="headerlink" title="知识点总结"></a>知识点总结</h3><h4 id="网际协议IP概述"><a href="#网际协议IP概述" class="headerlink" title="网际协议IP概述"></a>网际协议IP概述</h4><p><strong>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务</strong>。使用IP协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。与IP协议配套使用的还有三个协议：</p>
<blockquote>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>
</ul>
</blockquote>
<h4 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h4><ul>
<li>版本: 有 4（IPv4）和 6（IPv6）两个值；</li>
<li>首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20字节，因此该值最小为 5。如果可选部分的长度不是 4字节的整数倍，就用尾部的填充部分来填充。</li>
<li>区分服务 : 用来获得更好的服务，一般情况下不使用。</li>
<li>总长度 : 包括首部长度和数据部分长度。</li>
<li>标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li>片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>
<li>生存时间 ：TTL，它的存在为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>
<li>协议：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>
<li>首部检验和：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>
</ul>
<h4 id="IP-地址编址"><a href="#IP-地址编址" class="headerlink" title="IP 地址编址"></a>IP 地址编址</h4><p>IP 地址的编址方式经历了三个历史阶段：</p>
<blockquote>
<ul>
<li>分类的 IP 地址；</li>
<li>子网的划分；</li>
<li>构成超网。</li>
</ul>
</blockquote>
<ul>
<li><strong>分类的IP地址</strong>:由两部分组成，网络号和主机号，其中不同类别具有不同的网络号长度，并且是固定的。<blockquote>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>
</blockquote>
</li>
<li><strong>划分子网</strong>:通过在网络号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。注意，外部网络看不到子网的存在。<blockquote>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>
</blockquote>
</li>
</ul>
<p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 000000，也就是 255.255.192.0。</p>
<ul>
<li><strong>无分类编址 CIDR（构成超网）</strong>:CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</li>
</ul>
<blockquote>
<p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>
</blockquote>
<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为构成超网。在路由表中每个项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配。</p>
<h4 id="IP-地址和-MAC-地址"><a href="#IP-地址和-MAC-地址" class="headerlink" title="IP 地址和 MAC 地址"></a>IP 地址和 MAC 地址</h4><blockquote>
<p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p>
</blockquote>
<h4 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h4><blockquote>
<p><strong>实现由 IP 地址得到 MAC 地址。</strong>每个主机都有一个 ARP 高速缓存，存放映射表。如果一个 IP 地址 到 MAC 地址的映射不在该表中，主机通过广播的方式发送 ARP 请求分组，匹配 IP 地址的主机会发送 ARP 响应分组告知 MAC 地址。</p>
</blockquote>
<h4 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h4><blockquote>
<ul>
<li>路由器从功能上可以划分为两大部分：路由选择和分组转发。    </li>
<li>分组转发部分由三部分组成：交换结构、一组输入端口和一组输出端口。</li>
</ul>
</blockquote>
<h4 id="交换机与路由器的区别"><a href="#交换机与路由器的区别" class="headerlink" title="交换机与路由器的区别"></a>交换机与路由器的区别</h4><blockquote>
<p>交换机工作于数据链路层，能识别 MAC 地址，根据 MAC 地址转发链路层数据帧。具有自学机制来维护 IP 地址与 MAC 地址的映射。</p>
</blockquote>
<blockquote>
<p>路由器位于网络层，能识别 IP 地址并根据 IP 地址转发分组。维护着路由表，根据路由表选择最佳路线。</p>
</blockquote>
<h4 id="路由器分组转发流程"><a href="#路由器分组转发流程" class="headerlink" title="路由器分组转发流程"></a>路由器分组转发流程</h4><blockquote>
<ul>
<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。（路由表项是网络号而不是 IP 地址，这样做大大减少了路由表条目数量）</li>
<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ul>
</blockquote>
<h4 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h4><blockquote>
<p>互联网使用的路由选择协议都是自适应的，能随着网络通信量和拓扑变化而自适应地进行调整。互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p>
</blockquote>
<p>可以把路由选择协议划分为两大类：</p>
<blockquote>
<ul>
<li>内部网关协议 IGP（Interior Gateway Protocol）在自治系统内部使用，如 RIP 和 OSPF。</li>
<li>外部网关协议 EGP（External Gateway Protocol） 在自治系统之间使用，如 BGP。</li>
</ul>
</blockquote>
<h4 id="内部网关协议-RIP"><a href="#内部网关协议-RIP" class="headerlink" title="内部网关协议 RIP:"></a>内部网关协议 RIP:</h4><p>RIP 是一种分布式的基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1，跳数最多为 15，超过 15 表示不可达。<br>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<p><strong>距离向量算法</strong>：</p>
<ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：<blockquote>
<ul>
<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>
</ul>
</blockquote>
</li>
</ul>
<p>RIP 协议实现简单，开销小，但是 RIP 能使用的最大距离为15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
<h4 id="内部网关协议-OSPF"><a href="#内部网关协议-OSPF" class="headerlink" title="内部网关协议 OSPF"></a>内部网关协议 OSPF</h4><p><strong>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的</strong>。开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先是因为使用了 Dijkstra 提出的最短路径算法 SPF。</p>
<p><strong>OSPF 具有以下特点</strong>：</p>
<blockquote>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li>
<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>
<li>只有当链路状态发生变化时，路由器才会发送信息。</li>
</ul>
</blockquote>
<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p>
<h4 id="外部网关协议-BGP"><a href="#外部网关协议-BGP" class="headerlink" title="外部网关协议 BGP"></a>外部网关协议 BGP</h4><blockquote>
<p>AS 之间的路由选择很困难，主要是互联网规模很大。并且各个 AS 内部使用不同的路由选择协议，就无法准确定义路径的度量。并且 AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。BGP 只能寻找一条比较好的路由，而不是最佳路由。它采用路径向量路由选择协议。每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
</blockquote>
<h4 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h4><blockquote>
<p>ICMP是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。ICMP 报文分为差错报告报文和询问报文。</p>
</blockquote>
<h4 id="分组网间探测-PING"><a href="#分组网间探测-PING" class="headerlink" title="分组网间探测 PING"></a>分组网间探测 PING</h4><blockquote>
<p>PING 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>
</blockquote>
<p>PING 的过程：</p>
<blockquote>
<ul>
<li>PING 同一个网段的主机，查找目的主机的 MAC 地址，然后直接交付。如果无法查找到 MAC 地址，就要进行一次 ARP 请求。</li>
<li>PING 不同网段的主机，就发送给网关让其进行转发。同样要发送给网关也需要通过查找网关的 MAC 地址，根据 MAC 地址进行转发。</li>
</ul>
</blockquote>
<h4 id="IP-多播"><a href="#IP-多播" class="headerlink" title="IP 多播"></a>IP 多播</h4><blockquote>
<p>在一对多的通信中，多播不需要将分组复制多份，从而大大节约网络资源。</p>
</blockquote>
<h4 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h4><blockquote>
<p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>
</blockquote>
<p><strong>有三个专用地址块</strong>：</p>
<blockquote>
<ul>
<li>10.0.0.0 ~ 10.255.255.255</li>
<li>172.16.0.0 ~ 172.31.255.255</li>
<li>192.168.0.0 ~ 192.168.255.255</li>
</ul>
</blockquote>
<p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指“好像是”，而实际上并不是，它有经过公用的互联网。</p>
<p>场景：场所 A 和 B 的通信部经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p>
<h4 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h4><blockquote>
<p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p>
</blockquote>
<blockquote>
<p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也用上了，这样可以使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p>
</blockquote>
<h4 id="互联网交付"><a href="#互联网交付" class="headerlink" title="互联网交付"></a>互联网交付</h4><blockquote>
<p>在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</p>
</blockquote>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="相关术语-4"><a href="#相关术语-4" class="headerlink" title="相关术语"></a>相关术语</h3><h4 id="进程（process）"><a href="#进程（process）" class="headerlink" title="进程（process）"></a>进程（process）</h4><blockquote>
<p>指计算机中正在运行的程序实体</p>
</blockquote>
<h4 id="应用进程互相通信"><a href="#应用进程互相通信" class="headerlink" title="应用进程互相通信"></a>应用进程互相通信</h4><blockquote>
<p>一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）</p>
</blockquote>
<h4 id="传输层的复用与分用"><a href="#传输层的复用与分用" class="headerlink" title="传输层的复用与分用"></a>传输层的复用与分用</h4><blockquote>
<p>复用指发送方不同的进程都可以通过统一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。 </p>
</blockquote>
<h4 id="TCP（Transmission-Control-Protocol）"><a href="#TCP（Transmission-Control-Protocol）" class="headerlink" title="TCP（Transmission Control Protocol）"></a>TCP（Transmission Control Protocol）</h4><blockquote>
<p>传输控制协议</p>
</blockquote>
<h4 id="UDP（User-Datagram-Protocol）"><a href="#UDP（User-Datagram-Protocol）" class="headerlink" title="UDP（User Datagram Protocol）"></a>UDP（User Datagram Protocol）</h4><blockquote>
<p>用户数据报协议</p>
</blockquote>
<h4 id="端口（port）"><a href="#端口（port）" class="headerlink" title="端口（port）"></a>端口（port）</h4><blockquote>
<p>端口的目的是为了确认对方机器是那个进程在于自己进行交互，比如MSN和QQ的端口不同，如果没有端口就可能出现QQ进程和MSN交互错误。端口又称协议端口号。 </p>
</blockquote>
<h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><blockquote>
<p>指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。</p>
</blockquote>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><blockquote>
<p>就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</p>
</blockquote>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><blockquote>
<p>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p>
</blockquote>
<h3 id="知识点总结-4"><a href="#知识点总结-4" class="headerlink" title="知识点总结"></a>知识点总结</h3><p><strong>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。</strong>运输层提供了应用进程间的逻辑通信。运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看见的好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p>
<h4 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点"></a>UDP 和 TCP 的特点</h4><p><strong>用户数据包协议 UDP（User Datagram Protocol）传输控制协议 TCP（Transmission Control Protocol）</strong></p>
<ul>
<li>UDP 是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。</li>
<li>TCP 是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）</li>
</ul>
<h4 id="UDP-首部格式"><a href="#UDP-首部格式" class="headerlink" title="UDP 首部格式"></a>UDP 首部格式</h4><blockquote>
<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和而临时添加的。</p>
</blockquote>
<h4 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h4><blockquote>
<p>序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
</blockquote>
<blockquote>
<p>确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
</blockquote>
<blockquote>
<p>数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p>
</blockquote>
<blockquote>
<p>确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
</blockquote>
<blockquote>
<p>同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p>
</blockquote>
<blockquote>
<p>终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。</p>
</blockquote>
<blockquote>
<p>窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
</blockquote>
<h4 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h4><p>假设 A 为客户端，B 为服务器端。</p>
<blockquote>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 x。</li>
<li>B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li>
<li>A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
</blockquote>
<p>####TCP 的四次挥手<br>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<blockquote>
<ul>
<li>A 发送连接释放报文段，FIN=1；</li>
<li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据；</li>
<li>当 B 要不再需要连接时，发送连接释放请求报文段，FIN=1；</li>
<li>A 收到后发出确认，此时连接释放。</li>
</ul>
</blockquote>
<h4 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间。这么做有两个理由：</p>
<blockquote>
<ul>
<li>确保最后一个确认报文段能够到达。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>可能存在“已失效的连接请求报文段”，为了防止这种报文段出现在本次连接之外，需要等待一段时间。</li>
</ul>
</blockquote>
<h4 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h4><blockquote>
<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
</blockquote>
<blockquote>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
</blockquote>
<blockquote>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 32, 34, 35}，其中 {31, 32} 按序到达，而 {34, 35} 就不是，因此只对字节 32 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
</blockquote>
<h4 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h4><p><strong>流量控制是为了控制发送方发送速率，保证接收方来得及接收</strong>。</p>
<blockquote>
<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。例如将窗口字段设置为 0，则发送方不能发送数据。</p>
</blockquote>
<h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h4><blockquote>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。</p>
</blockquote>
<p><strong>TCP 主要通过四种算法来进行拥塞控制</strong>：</p>
<ul>
<li>慢开始</li>
<li>拥塞避免</li>
<li>快重传</li>
<li>快恢复<blockquote>
<p>发送方需要维护有一个叫做拥塞窗口（cwnd）的状态变量。注意拥塞窗口与发送方窗口的区别，拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>假设：   </p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>
</ul>
</blockquote>
<h4 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h4><blockquote>
<p>发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段为：2、4、8 …</p>
</blockquote>
<blockquote>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
</blockquote>
<blockquote>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>
</blockquote>
<h4 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h4><blockquote>
<p>在接收方，要求每次接收到报文段都应该发送对已收到有序报文段的确认，例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p>
</blockquote>
<blockquote>
<p>在发送方，如果收到三个重复确认，那么可以确认下一个报文段丢失，例如收到三个 M2 ，则 M3 丢失。此时执行快重传，立即重传下一个报文段。</p>
</blockquote>
<blockquote>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
</blockquote>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="相关术语-5"><a href="#相关术语-5" class="headerlink" title="相关术语"></a>相关术语</h3><h4 id="域名系统（DNS）："><a href="#域名系统（DNS）：" class="headerlink" title="域名系统（DNS）："></a>域名系统（DNS）：</h4><blockquote>
<p>DNS（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。<br>通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。在RFC文档中RFC 2181对DNS有规范说明，RFC 2136对DNS的动态更新进行说明，RFC 2308对DNS查询的反向缓存进行说明。</p>
</blockquote>
<h4 id="文件传输协议（FTP）："><a href="#文件传输协议（FTP）：" class="headerlink" title="文件传输协议（FTP）："></a>文件传输协议（FTP）：</h4><blockquote>
<p>FTP 是File TransferProtocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。<br>基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：”下载（Download）和”上传”（Upload）。<br>“下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</p>
</blockquote>
<h4 id="简单文件传输协议（TFTP）："><a href="#简单文件传输协议（TFTP）：" class="headerlink" title="简单文件传输协议（TFTP）："></a>简单文件传输协议（TFTP）：</h4><blockquote>
<p>TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。</p>
</blockquote>
<h4 id="远程终端协议（TELENET）："><a href="#远程终端协议（TELENET）：" class="headerlink" title="远程终端协议（TELENET）："></a>远程终端协议（TELENET）：</h4><blockquote>
<p>Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。<br>在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。<br>可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。</p>
</blockquote>
<h4 id="万维网（WWW）："><a href="#万维网（WWW）：" class="headerlink" title="万维网（WWW）："></a>万维网（WWW）：</h4><blockquote>
<p>WWW是环球信息网的缩写，（亦作“Web”、“WWW”、“’W3’”，英文全称为“World Wide Web”），中文名字为“万维网”，”环球网”等，常简称为Web。分为Web客户端和Web服务器程序。WWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。<br>万维网联盟（英语：World Wide Web Consortium，简称W3C），又称W3C理事会。1994年10月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。<br>万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务.</p>
</blockquote>
<h4 id="统一资源定位符（URL）："><a href="#统一资源定位符（URL）：" class="headerlink" title="统一资源定位符（URL）："></a>统一资源定位符（URL）：</h4><blockquote>
<p>统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 </p>
</blockquote>
<h4 id="超文本传输协议（HTTP）："><a href="#超文本传输协议（HTTP）：" class="headerlink" title="超文本传输协议（HTTP）："></a>超文本传输协议（HTTP）：</h4><blockquote>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。<br>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。</p>
</blockquote>
<h4 id="代理服务器（Proxy-Server）"><a href="#代理服务器（Proxy-Server）" class="headerlink" title="代理服务器（Proxy Server）"></a>代理服务器（Proxy Server）</h4><blockquote>
<p>代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。<br> 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按URL的地址再次去互联网访问该资源。<br> 代理服务器可在客户端或服务器工作，也可以在中间系统工作。 </p>
</blockquote>
<h4 id="http请求头："><a href="#http请求头：" class="headerlink" title="http请求头："></a>http请求头：</h4><blockquote>
<p>http请求头，HTTP客户程序（例如浏览器），向服务器发送请求的时候必须指明请求类型（一般是GET或者POST）。如有必要，客户程序还可以选择发送其他的请求头。</p>
</blockquote>
<ul>
<li>Accept：浏览器可接受的MIME类型。</li>
<li>Accept-Charset：浏览器可接受的字符集。</li>
<li>Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。</li>
<li>Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。</li>
<li>Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。</li>
<li>Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。</li>
<li>Content-Length：表示请求消息正文的长度。</li>
<li>Cookie：这是最重要的请求头信息之一</li>
<li>From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。</li>
<li>Host：初始URL中的主机和端口。</li>
<li>If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。</li>
<li>Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。</li>
<li>Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</li>
<li>User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。</li>
</ul>
<h4 id="简单邮件传输协议-SMTP-："><a href="#简单邮件传输协议-SMTP-：" class="headerlink" title="简单邮件传输协议(SMTP)："></a>简单邮件传输协议(SMTP)：</h4><blockquote>
<p>SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。<br> SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。<br> 通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。</p>
</blockquote>
<h4 id="搜索引擎："><a href="#搜索引擎：" class="headerlink" title="搜索引擎："></a>搜索引擎：</h4><blockquote>
<p>搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。 搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。</p>
</blockquote>
<h4 id="全文索引："><a href="#全文索引：" class="headerlink" title="全文索引："></a>全文索引：</h4><blockquote>
<p>全文索引技术是目前搜索引擎的关键技术。<br>试想在1M大小的文件中搜索一个词，可能需要几秒，在100M的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。<br>所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。</p>
</blockquote>
<h4 id="目录索引："><a href="#目录索引：" class="headerlink" title="目录索引："></a>目录索引：</h4><blockquote>
<p>目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。</p>
</blockquote>
<h4 id="垂直搜索引擎："><a href="#垂直搜索引擎：" class="headerlink" title="垂直搜索引擎："></a>垂直搜索引擎：</h4><blockquote>
<p>垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。<br>垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。<br>其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。</p>
</blockquote>
<h3 id="知识点总结-5"><a href="#知识点总结-5" class="headerlink" title="知识点总结"></a>知识点总结</h3><h4 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h4><blockquote>
<ul>
<li>把主机名解析为 IP 地址。</li>
<li>被设计成分布式系统。</li>
</ul>
</blockquote>
<ul>
<li><p>层次结构<br>一个域名由多个层次构成，从上层到下层分别为顶级域名、二级域名、三级域名以及四级域名。所有域名可以画成一颗域名树。</p>
</li>
<li><p>域名服务器可以分为以下四类：</p>
<blockquote>
<ul>
<li>根域名服务器：解析顶级域名；</li>
<li>顶级域名服务器：解析二级域名；</li>
<li>权限域名服务器：解析区内的域名；</li>
<li>本地域名服务器：也称为默认域名服务器。可以在其中配置高速缓存。</li>
</ul>
</blockquote>
</li>
<li><p>解析过程</p>
<blockquote>
<p>主机向本地域名服务器解析的过程采用递归，而本地域名服务器向其它域名服务器解析可以使用递归和迭代两种方式。<br>迭代的方式下，本地域名服务器向一个域名服务器解析请求解析之后，结果返回到本地域名服务器，然后本地域名服务器继续向其它域名服务器请求解析；而递归地方式下，结果不是直接返回的，而是继续向前请求解析，最后的结果才会返回。</p>
</blockquote>
</li>
</ul>
<h4 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议 FTP"></a>文件传输协议 FTP</h4><blockquote>
<p>FTP 在运输层使用 TCP，并且需要建立两个并行的 TCP 连接：控制连接和数据连接。控制连接在整个会话期间一直保持打开，而数据连接在数据传送完毕之后就关闭。控制连接使用端口号 21，数据连接使用端口号 20。</p>
</blockquote>
<h4 id="远程终端协议-TELNET"><a href="#远程终端协议-TELNET" class="headerlink" title="远程终端协议 TELNET"></a>远程终端协议 TELNET</h4><blockquote>
<p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。<br>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p>
</blockquote>
<h4 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h4><blockquote>
<p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件发送协议和读取协议。其中发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p>
</blockquote>
<h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><blockquote>
<p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。</p>
</blockquote>
<h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><blockquote>
<p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不去手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。IMAP 协议也支持创建自定义的文件夹。</p>
</blockquote>
<h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><blockquote>
<p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主题的结构，定义了非 ASCII 码的编码规则。</p>
</blockquote>
<h4 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h4><blockquote>
<p>DHCP 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。</p>
</blockquote>
<blockquote>
<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、默认路由器 IP 地址、域名服务器的 IP 地址。</p>
</blockquote>
<blockquote>
<p>工作方式如下：需要 IP 地址的主机广播发送 DHCP 发现报文（将目的地址置为全 1，即 255.255.255.255:67，源地址设置为全 0，即 0.0.0.0:68），DHCP 服务器收到发现报文之后，则在 IP 地址池中取一个地址，发送 DHCP 提供报文给该主机。</p>
</blockquote>
<h4 id="点对点传输-P2P"><a href="#点对点传输-P2P" class="headerlink" title="点对点传输 P2P"></a>点对点传输 P2P</h4><blockquote>
<p>把某个文件分发的所有对等集合称为一个洪流。文件的数据单元称为文件块，它的大小是固定的。一个新的对等方加入某个洪流，一开始并没有文件块，但是能够从其它对等方中逐渐地下载到一些文件块，与此同时，它也为别的对等方上传一些文件块。</p>
</blockquote>
<blockquote>
<p>每个洪流都有一个基础设施，称为追踪器。当一个对等方加入洪流时，必须向追踪器登记，并周期性地通知追踪器它仍在洪流中。可以在任何时间加入和退出某个洪流。</p>
</blockquote>
<blockquote>
<p>一个新的对等方加入洪流时，追踪器会随机从洪流中选择若干个对等方，并让新对等方与这些对等方建立连接，把这些对等方称为相邻对等方。接收和发送文件块都是在相邻对等方中进行。</p>
</blockquote>
<blockquote>
<p>当一个对等方需要很多文件块时，通过使用最稀有优先的策略来取得文件块，也就是一个文件块在相邻对等方中副本最少，那么就优先请求这个文件块。</p>
</blockquote>
<blockquote>
<p>当很多对等方向同一个对等方请求文件块时，该对等方优先选择以最高速率向其发送文件块的对等方。</p>
</blockquote>
<blockquote>
<p>P2P 是一个分布式系统，任何时候都有对等方加入或者退出。使用分布式散列表 DHT，可以查找洪流中的资源和 IP 地址映射。</p>
</blockquote>
<h4 id="Web-页面请求过程"><a href="#Web-页面请求过程" class="headerlink" title="Web 页面请求过程"></a>Web 页面请求过程</h4><ul>
<li>向 DNS 服务器发送 DNS 查询报文来解析域名。</li>
<li>开始进行 HTTP 会话，需要先建立 TCP 连接。</li>
<li>在运输层的传输过程中，HTTP 报文被封装进 TCP 中。HTTP 请求报文使用端口号 80，因为服务器监听的是 80 端口。连接建立之后，服务器会随机分配一个端口号给特定的客户端，之后的 TCP 传输都是用这个分配的端口号。</li>
<li>在网络层的传输过程中，TCP 报文段会被封装进 IP 分组中，IP 分组经过路由选择，最后到达目的地。</li>
<li>在链路层，IP 分组会被封装进 MAC 帧中，IP 地址解析成 MAC 地址需要使用 ARP。</li>
<li>客户端发送 HTTP 请求报文，请求获取页面。</li>
<li>服务器发送 HTTP 相应报文，客户端从而获取该页面。</li>
<li>浏览器得到页面内容之后，解析并渲染，向用户展示页面。</li>
</ul>
<h4 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h4><p><img src="https://wx1.sbimg.cn/2020/07/17/Cxs0J.png" alt="Cxs0J.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md</a>    </p>
</li>
<li><p><a href="https://blog.csdn.net/qq_34337272/article/details/79778645?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159488213019725247622898%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159488213019725247622898&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-79778645.ecpm_v3_rank_business_v1&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">CSDN文章</a></p>
</li>
<li><p>计算机网络 第七版</p>
</li>
<li><p>自顶向下计算机网络</p>
</li>
<li><p><a href="https://blog.csdn.net/HuoqilinHeiqiji/article/details/89703358" target="_blank" rel="noopener">https://blog.csdn.net/HuoqilinHeiqiji/article/details/89703358</a></p>
</li>
<li><p>PPP协议：<a href="https://blog.csdn.net/u011857683/article/details/84703473" target="_blank" rel="noopener">https://blog.csdn.net/u011857683/article/details/84703473</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机网络】传输层</title>
    <url>/2020/07/22/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<p><strong>计算机网络不看后悔系列blog(五）传输层/超详细！！ℰ⋆‿⋆ℰ</strong></p>
<a id="more"></a>
<h2 id="传输层两个协议的应用场景"><a href="#传输层两个协议的应用场景" class="headerlink" title="传输层两个协议的应用场景"></a>传输层两个协议的应用场景</h2><ul>
<li>TCP：可靠传输，分段，编号，流量控制（如果丢包则可再传相应的数据报），建立会话（服务器与用户间需要建立连接，确保网络畅通），netstat -n查看会话（QQ传文件，一个包一个包的传。访问网站）</li>
<li>UDP：非可靠传输，一个包就能搞定数据通信，不需要再分段编号，不建立会话。（QQ聊天发消息，看电视节目）</li>
</ul>
<h2 id="传输层和应用层之间的关系"><a href="#传输层和应用层之间的关系" class="headerlink" title="传输层和应用层之间的关系"></a>传输层和应用层之间的关系</h2><ul>
<li>http=TCP+80（应用层协议http在运输层使用TCP协议+80端口来表示一个应用层协议）</li>
<li>https=TCP+443（Web服务用的协议端口）</li>
<li>ftp=TCP+21（文件传输用的协议端口）</li>
<li>SMTP=TCP+25（发邮件用的协议端口）</li>
<li>POP3=TCP+110（收邮件用的协议端口）</li>
<li>RDP=TCP—+3389（远程桌面用的协议端口）</li>
<li>TCP+445（共享文件夹用的协议端口）</li>
<li>SQL=TCP+1433（微软数据库用的协议端口）</li>
<li>DNS=UDP+53 or</li>
<li>TCP+53（少用）（网站解析用的协议端口）</li>
</ul>
<h2 id="应用层协议和服务之间的关系"><a href="#应用层协议和服务之间的关系" class="headerlink" title="应用层协议和服务之间的关系"></a>应用层协议和服务之间的关系</h2><p>Web服务<br>ftp服务<br>smtp服务<br>pop3服务</p>
<blockquote>
<p>假设每个服务都打开了，那么它们就会在某个特定的端口侦听数据。端口代表服务<br>(用IP地址来定位计算机，用端口来定位服务。)</p>
</blockquote>
<h2 id="更改端口增加服务器安全"><a href="#更改端口增加服务器安全" class="headerlink" title="更改端口增加服务器安全"></a>更改端口增加服务器安全</h2><p>更改端口会让侵入的人不知道这个端口的服务是什么，或者说对正常的端口猜测错误，攻击不成</p>
<h2 id="TCP-IP筛选实现服务器安全"><a href="#TCP-IP筛选实现服务器安全" class="headerlink" title="TCP/IP筛选实现服务器安全"></a>TCP/IP筛选实现服务器安全</h2><p>虽然可能计算机上添加了很多服务端口，但是可以使用防火墙尽让部分端口开放，也就是网卡只允许某些端口可以对外连接，这样也就实现了一定的服务器安全</p>
<h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><h3 id="传送的数据格式"><a href="#传送的数据格式" class="headerlink" title="传送的数据格式"></a>传送的数据格式</h3><p>两个对等运输实体再通信时传送的数据单位叫做<strong>运输协议数据单元</strong></p>
<ul>
<li>TCP传送的协议数据单元是TCP报文段</li>
<li>UDP传送的协议数据单元是UDP报文或用户数据报</li>
</ul>
<h3 id="一些区别"><a href="#一些区别" class="headerlink" title="一些区别"></a>一些区别</h3><ul>
<li>UDP在传送数据之前不需要先建立连接，对方的运输层在收到UDP报文后，不需要给出任何确认，虽然UDP不提供可靠交付，但在某些情况下UDP是一种最有效的工作方式</li>
<li>TCP则提供面向连接的服务，TCP不提供广播或多播服务。由于TCP要提供可靠的、面向连接的运输服务，因此不可避免的增加了许多的开销。这不进使协议数据单元的首部增大很多，还要占用许多的处理机资源。</li>
</ul>
<p>SYN攻击：不断的给一个计算机发起建立会话的请求，但是请求的端口位置不正确，就导致大量的同意连接请求得不到相应从而占用大量的资源，达到了攻击的目的</p>
<p>land攻击：大量的让目标地址与自己建立会话占用大量资源</p>
<h2 id="OSI和DoD模型"><a href="#OSI和DoD模型" class="headerlink" title="OSI和DoD模型"></a>OSI和DoD模型</h2><p><img src="https://wx1.sbimg.cn/2020/07/22/DUN8e.png" alt="DUN8e.png"></p>
<p>传输层最大数据包是65535字节，而网络层数据最大只有1480字节。所以需要分段，但是只要分段，就有可能丢包，因为网络层不负责可靠传输。所以要求服务器和客户端保持会话，直到数据传输完成。</p>
<p>-&gt;TCP(Transmission Control Protocol)传输控制协议<br>应用场景：需要将要传输的文件分段传输时；就需要TCP协议来建立会话实现可靠传输；同时也有流量控制功能。(例如QQ传文件)<br>查看会话 netstat -n<br>查看建立会话的进程 netstat -nb</p>
<p>-&gt;UDP(User Data Protocol)用户数据报协议<br>应用场景：一个数据包就能完成数据通信；不需要建立会话和流量控制；多播/广播；是一种不可靠传输。(例如QQ聊天，屏幕广播)</p>
<h2 id="传输层协议与应用层协议的关系"><a href="#传输层协议与应用层协议的关系" class="headerlink" title="传输层协议与应用层协议的关系"></a>传输层协议与应用层协议的关系</h2><p><img src="https://wx2.sbimg.cn/2020/07/22/DUlpD.png" alt="DUlpD.png"></p>
<p>(1)TCP和UDP协议和不同的端口即可对应一个应用层的协议。注意，53大部分是与UDP相连。<br>(2)熟知数值一般为0-1023，登记端口号数值1024-49151，客户端口号数值为49152-65535.<br>(3)常用的应用层协议使用的端口(号)：<br>http = TCP + 80<br>Https = TCP + 443<br>RDP = TCP + 3389<br>ftp = TCP + 21<br>共享文件夹 = TCP + 445<br>SMTP = TCP + 25<br>POP3 = TCP + 110<br>telnet = TCP + 23<br>SQL = TCP + 1433<br>DNS = UDP + 53</p>
<h2 id="服务和应用层协议的关系"><a href="#服务和应用层协议的关系" class="headerlink" title="服务和应用层协议的关系"></a>服务和应用层协议的关系</h2><p>防火墙是基于网卡的，只打开必要的端口，不必要的端口不允许接收数据，不影响服务的运行和监听。<br>服务使用TCP或UDP的端口侦听客户端请求；<br>客户端使用IP地址定位服务器，使用目标端口，定位服务；<br>可以在服务器网卡上设置只开放必要的端口，实现服务器网络安全。</p>
<h2 id="如何查看服务器侦听端口"><a href="#如何查看服务器侦听端口" class="headerlink" title="如何查看服务器侦听端口"></a>如何查看服务器侦听端口</h2><p>netstat -a<br>netstat -an 以数字的形式查看端口<br>netstat -n 查看建立的会话<br>netstat -nb 查看建立会话的进程<br>telnet 192.168.80.100 3389 测试到远程计算机某个端口是否打开</p>
<h2 id="传输层功能和端口范围"><a href="#传输层功能和端口范围" class="headerlink" title="传输层功能和端口范围"></a>传输层功能和端口范围</h2><p><img src="https://wx2.sbimg.cn/2020/07/22/DUOaj.png" alt="DUOaj.png"></p>
<h3 id="传输层协议与网络层协议的主要区别"><a href="#传输层协议与网络层协议的主要区别" class="headerlink" title="传输层协议与网络层协议的主要区别"></a>传输层协议与网络层协议的主要区别</h3><p>网络层实现如何把数据包从这个地址(服务器)发送到另一个地址(服务器)。<br>传输层实现如何让这个应用程序找到对应计算机的应用程序(相对应的应用程序实现逻辑通信)。</p>
<p><img src="https://wx1.sbimg.cn/2020/07/22/DUSfk.png" alt="DUSfk.png"></p>
<h3 id="传输层的主要功能"><a href="#传输层的主要功能" class="headerlink" title="传输层的主要功能"></a>传输层的主要功能</h3><p>(1)传输层为应用进程之间提供了端到端的逻辑通信(但网络层是为主机之间提供逻辑通信)。<br>(2)传输层还要对收到的报文进行差错检验。<br>(3)传输层提供面向连接(TCP)和无连接(UDP)的服务。</p>
<h3 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h3><p><img src="https://wx2.sbimg.cn/2020/07/22/DUyQn.png" alt="DUyQn.png"></p>
<p>TCP的端口：</p>
<ul>
<li>端口用一个16位端口号进行标志。</li>
<li>端口号只具有本地意义，即端口号只是为了标志本计算机应用层的各进程。</li>
<li>在Internet中不同计算机的相同端口号是没有联系的(最好不要有冲突)。</li>
</ul>
<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>(1)UDP是无连接的，即发送数据之前不需要建立连接。<br>(2)UDP使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。<br>(3)UDP是面向报文的，适合多媒体通信的要求。<br>(4)UDP支持一对一，一对多，多对一，多对多交互通信。<br>(5)UDP首部开销小，只有8个字节。</p>
<p><img src="https://wx1.sbimg.cn/2020/07/22/DUV7h.png" alt="DUV7h.png"></p>
<h3 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h3><p><img src="https://wx2.sbimg.cn/2020/07/22/DUFSM.png" alt="DUFSM.png"></p>
<p>首部中的长度指的是UDP用户数据报的长度(首部+数据)。<br>伪首部用于检验和，伪首部是IP数据包首部的后</p>
<p><img src="https://wx1.sbimg.cn/2020/07/22/DUfPa.png" alt="DUfPa.png"></p>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><ul>
<li>TCP是面向连接的传输层协议。(三次握手)</li>
<li>每一条TCP连接智能有两个端点(endpoint)，每一条TCP连接只能时点对点的(一对一)。</li>
<li>TCP提供可靠交付的服务。(确保不丢包)</li>
<li>TCP提供全双工通信。(因为需要接收端的反馈，例如如果接收端处理不过来，可让发送端慢一点，流量控制)</li>
<li>面向字节流。</li>
<li>TCP实现全双工通信就一定得建立双向通信，不能用户机只在服务器端下载，应该还要有回应，就像打电话一样，一个人说话，一个人只在听但是也得回应“嗯”确保这个通信是正常的</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/22/Di41R.png" alt="Di41R.png"></p>
<blockquote>
<p>如果要传输一个比较大的数据，首先一次只会传输一小块，这个数据块的大小是没有规律的。加上数据包数据帧的头，发送给接收端，接收端去掉首部，再次拼接。</p>
</blockquote>
<h3 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h3><ul>
<li>TCP把连接作为最基本的抽象。</li>
<li>每一条TCP连接有两个端点。</li>
<li>TCP连接的端点不是主机，不是主机的IP地址，不是应用程序，也不是传输层协议端口，TCP连接的端点叫 套接字(socket).</li>
</ul>
<blockquote>
<ul>
<li>套接字socket = (IP地址:端口号)</li>
<li>每一条TCP连接唯一地被通信两端的两个套接字所确定，即：</li>
<li>TCP连接 ::= {socket1, socket2} = {(IP1:port1), (IP2:port2)}</li>
<li>端口号拼接到IP地址即构成了套接字。</li>
</ul>
</blockquote>
<h3 id="TCP如何实现可靠传输"><a href="#TCP如何实现可靠传输" class="headerlink" title="TCP如何实现可靠传输"></a>TCP如何实现可靠传输</h3><p><strong>可靠传输的工作原理——停止等待协议</strong>:</p>
<p><img src="https://wx1.sbimg.cn/2020/07/22/Di58I.png" alt="Di58I.png"></p>
<p>在发送完一个分组后，必须暂时保留已发送的分组的副本。</p>
<ul>
<li>分组和确认分组都必须进行编号。</li>
<li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。</li>
</ul>
<p><strong>确认丢失和确认迟到</strong>:</p>
<p><img src="https://wx2.sbimg.cn/2020/07/22/DiXpK.png" alt="DiXpK.png"></p>
<ul>
<li>可靠通信的实现<blockquote>
<ul>
<li>使用上述的确认和重传机制，微秒就可以在不可靠的传输网络上实现可靠的通信。</li>
<li>这种可靠传输的协议常称为自动重传请求ARQ(Automatic Repeat reQuest)。</li>
<li>ARQ表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。</li>
<li>缺点，信道利用率低。</li>
</ul>
</blockquote>
</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/22/DipaT.png" alt="DipaT.png"></p>
<p><strong>信道利用率</strong></p>
<p><img src="https://wx1.sbimg.cn/2020/07/23/Dikfw.png" alt="Dikfw.png"></p>
<h3 id="流水线传输"><a href="#流水线传输" class="headerlink" title="流水线传输"></a>流水线传输</h3><blockquote>
<p>发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。由于信道上一直有数据不间断的传送，这种传输方式可获得很高的信道利用率。</p>
</blockquote>
<p><img src="https://wx2.sbimg.cn/2020/07/23/Di2Ao.png" alt="Di2Ao.png"></p>
<h3 id="连续AQR协议"><a href="#连续AQR协议" class="headerlink" title="连续AQR协议"></a>连续AQR协议</h3><p><img src="https://wx1.sbimg.cn/2020/07/23/DiC7l.png" alt="DiC7l.png"><br><img src="https://wx2.sbimg.cn/2020/07/23/DiDS1.png" alt="DiDS1.png"></p>
<p>如果1确认收到了，则滑动窗口。如果12收到了，3没有收到，则滑动窗口会会回溯到3位置，重新发送。</p>
<blockquote>
<p>滑动窗口技术：发送端的滑动窗口大小不能大于接收端的窗口大小</p>
</blockquote>
<ul>
<li>累计确认(接收方)<blockquote>
<ul>
<li>接收方一般采用累计确认的方式。</li>
<li>优点：容易实现，信道利用率高。</li>
<li>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h2><p><img src="https://wx1.sbimg.cn/2020/07/23/Dioo2.png" alt="Dioo2.png"></p>
<ul>
<li>源端口：2个字节16位。</li>
<li>目的端口：2个字节16位。</li>
<li>序号：当前数据的第一个字节在整个文件中的序号。</li>
<li>确认号ack：接收端发送，提示发送端下一次该发的数据在整个文件中的序号。接收端收到后，会把这个序号之前的数据从缓存中删掉。</li>
<li>数据偏移：当前TCP报文段第多少个字节后是TCP的数据部分了。数据偏移最多表示1111，即15，他最多可以表示15乘以4，即60个字节的偏移量，所以选项+填充最多只能是40个字节。</li>
<li>保留：6位，无作用。</li>
<li>URG：urgent，意思是优先级高，发送端优先发送，而不是在缓存中排队。</li>
<li>ACK：acknowledge，1意味着确认建立了会话。</li>
<li>PSH：1意味着接收端优先读取，而不是在缓存中排队。</li>
<li>RST：reset，1意味着TCP会话出现严重错误，必须释放和重新连接。</li>
<li>SYN：同步。1意味着要发起会话。</li>
<li>FIN：finish，1意味着释放连接。</li>
<li>窗口：接收端先发，发送端根据接收端的窗口尺寸确定发送端窗口尺寸。</li>
<li>检验和：和UDP一样要在TCP报文段的前端加一个12字节的伪首部，和UDP差不多相同</li>
<li>紧急指针：指明了紧急数据段的尾部位置</li>
<li>选项：可以规定最大数据报的长度，MSS，确认的时候是不是支持选择性确认，如果选项不够4个字节，那么它就会填充.</li>
</ul>
<p>从建立会话，到传输数据到确认反馈的一个过程如下:</p>
<p><img src="https://wx1.sbimg.cn/2020/07/23/Di6EJ.png" alt="Di6EJ.png"></p>
<h2 id="TCP如何实现可靠传输-1"><a href="#TCP如何实现可靠传输-1" class="headerlink" title="TCP如何实现可靠传输"></a>TCP如何实现可靠传输</h2><h3 id="以字节为单位的滑动窗口技术"><a href="#以字节为单位的滑动窗口技术" class="headerlink" title="以字节为单位的滑动窗口技术"></a>以字节为单位的滑动窗口技术</h3><ul>
<li>A的发送窗口是由B的接受窗口长度决定的。</li>
<li>在没有收到B确认收到之前，A不能删掉滑动窗口内的内容。</li>
<li>A可以持续给B发送，直到A的滑动窗口内数据都发了。</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/23/DiGkm.png" alt="DiGkm.png"></p>
<p>B收到后给A发确认收到的反馈ACK，序号是下一个应该发送的字节的序号，A收到后，就可以滑动窗口到对应的位置。例如B反馈ACK是7，那么A的滑窗可以移动到7位置，1-6删除。21-26可以发送</p>
<p><img src="https://wx1.sbimg.cn/2020/07/23/DiQhU.png" alt="DiQhU.png"></p>
<p>B收到1-6之后，也开始滑窗，B的应用程序可以读取1-6的数据。B的滑窗继续接收。</p>
<p><img src="https://wx2.sbimg.cn/2020/07/23/DiAvd.png" alt="DiAvd.png"></p>
<p>以上是正常状态下的情况。如果出现丢失情况，例如7-9丢失，此时B反馈的ACK=7.因为10-12收到了，因此B发送SACK(选择性确认)，A只发送7-9.</p>
<p><img src="https://wx1.sbimg.cn/2020/07/23/DiR44.png" alt="DiR44.png"></p>
<h3 id="超时重传时间的确定"><a href="#超时重传时间的确定" class="headerlink" title="超时重传时间的确定"></a>超时重传时间的确定</h3><p>T- CP每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到了，但是还没有收到数据，那么就重传这一报文段。</p>
<ul>
<li>RTTs(new) = (1 - alpha) x (RTTs(old)) + alpha x (new RTT样本)</li>
<li>超时重传时间应略大于上面得出的加权平均往返时间RTTs。alpha推荐值是0.125.</li>
<li>这个公式的目的是根据网速和带宽的实时情况调整往返时间。</li>
</ul>
<h2 id="TCP如何实现流量控制P68"><a href="#TCP如何实现流量控制P68" class="headerlink" title="TCP如何实现流量控制P68"></a>TCP如何实现流量控制P68</h2><blockquote>
<p>解决通信两端处理时间不一样的问题。通过实时调整滑窗尺寸的大小(尺寸甚至可以是0)来实现流量控制。接收端主动调整滑窗大小，发送端根据接收端发送的报文调整相应的滑窗。发送端也会定时发送报文向接收端确认滑窗信息，避免接收端发送的相关调整滑窗大小的报文丢失带来的影响。</p>
</blockquote>
<h2 id="TCP如何避免网络拥塞"><a href="#TCP如何避免网络拥塞" class="headerlink" title="TCP如何避免网络拥塞"></a>TCP如何避免网络拥塞</h2><ul>
<li>出现资源拥塞的条件：对资源需求的总和&gt;可用资源。</li>
<li>拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由区，以及与降低网络传输性能有关的所有因素。</li>
<li>流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制，它所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
</ul>
<h3 id="拥塞控制起到的作用"><a href="#拥塞控制起到的作用" class="headerlink" title="拥塞控制起到的作用"></a>拥塞控制起到的作用</h3><p>红线和绿线之间是数据丢失内容。</p>
<p><img src="https://wx2.sbimg.cn/2020/07/23/DicAY.png" alt="DicAY.png"></p>
<h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><ul>
<li>发送方维持拥塞窗口cwnd(congestion window)</li>
<li>发送方控制拥塞窗口的原则是：<blockquote>
<ul>
<li>只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去；</li>
<li>只要网络出现拥塞，拥塞窗口就减少一些，以减少注入到网络中的分组数。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>慢开始算法的原理</strong>:</p>
<p><img src="https://wx1.sbimg.cn/2020/07/23/DidHA.png" alt="DidHA.png"></p>
<ul>
<li><p>设置慢开始门限状态变量ssthresh<br>慢开始门限状态变量ssthresh的用法如下：</p>
<blockquote>
<ul>
<li>当cwnd&lt;ssthresh时，使用慢开始算法；</li>
<li>当cwnd&gt;ssthresh时，停止使用慢开始算法，改用拥塞避免算法；</li>
<li>当cwnd=ssthresh时，使用慢开始算法或拥塞避免算法均可；</li>
</ul>
</blockquote>
</li>
<li><p>拥塞避免算法的思路<br>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，使拥塞窗口cwnd按线性规律缓慢增长。</p>
</li>
<li><p>当网络出现拥塞时对策<br>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(其根据就是没有按时收到确认)，就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半(但是不能小于2)。<br>然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。</p>
<blockquote>
<p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够的时间吧队列中积压的分组处理完毕。</p>
</blockquote>
</li>
<li><p>慢开始和拥塞避免算法的实现举例</p>
</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/23/DigSV.png" alt="DigSV.png"></p>
<blockquote>
<ul>
<li>拥塞避免并非指完全能够避免拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。</li>
<li>拥塞避免是说在拥塞避免阶段吧拥塞避免窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</li>
</ul>
</blockquote>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><ul>
<li>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，这样做可以让发送方及早知道有报文段没有到达接收方。</li>
<li>当发送端收到连续三个重复的确认时，就执行“乘法减少”算法，即把慢开始门限ssthresh减半，但拥塞窗口cwnd现在不设置为1，而是设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法(“加法增大”)，使拥塞窗口缓慢地线性增大。</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/23/Diso7.png" alt="Diso7.png"></p>
<h3 id="发送窗口的实际上限制"><a href="#发送窗口的实际上限制" class="headerlink" title="发送窗口的实际上限制"></a>发送窗口的实际上限制</h3><p>取接收方窗口和 拥塞窗口 这两个变量中的较小值。<br>发送窗口的上限制 = min {rwnd, cwnd}.</p>
<h3 id="TCP传输连接管理"><a href="#TCP传输连接管理" class="headerlink" title="TCP传输连接管理"></a>TCP传输连接管理</h3><blockquote>
<p>传输连接有三个阶段，即：</p>
<ul>
<li>连接建立</li>
<li>数据传送</li>
<li>连接释放</li>
</ul>
</blockquote>
<ul>
<li>TCP连接的建立都是采用客户服务器方式。</li>
<li>主动发起连接建立的应用进程叫做客户(client)。</li>
<li>被动等待连接建立的应用进程叫做服务器(server)。</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://wx2.sbimg.cn/2020/07/23/DiJq6.png" alt="DiJq6.png"></p>
<ul>
<li>头两次握手除了确定双方都能联通外，还通知了双方的一些端口信息。</li>
<li>第三次握手原因：假如把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机A和B之间的通信，假定A给B发送一个连接请求分组，B收到了这个分组，并发送了确认应答分组。按照两次握手的协定，B认为连接已经成功地建立了，可以开始发送数据分组。可是，B的应答分组在传输中被丢失的情况下，A将不知道B是否已准备好，A认为连接还未建立成功，将忽略B发来的任何数据分组，这样就形成了死锁。</li>
</ul>
<h3 id="四次分手"><a href="#四次分手" class="headerlink" title="四次分手"></a>四次分手</h3><p><img src="https://wx1.sbimg.cn/2020/07/23/DiLEO.png" alt="DiLEO.png"></p>
<blockquote>
<p>为什么要四次挥手？在第二步b-&gt;a要发送两次呢。因为TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p>
</blockquote>
<p>参考：<br>韩立刚老师《计算机网络》课程<br><a href="https://blog.csdn.net/iwanderu/article/details/103812974" target="_blank" rel="noopener">https://blog.csdn.net/iwanderu/article/details/103812974</a></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机网络】应用层</title>
    <url>/2020/07/23/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<p><strong>计算机网络不看后悔系列blog(六）应用层/超详细！！ℰ⋆‿⋆ℰ</strong></p>
<a id="more"></a>
<h2 id="域名协议DNS（Domain-Name-System）"><a href="#域名协议DNS（Domain-Name-System）" class="headerlink" title="域名协议DNS（Domain Name System）"></a>域名协议DNS（Domain Name System）</h2><h3 id="DNS的作用"><a href="#DNS的作用" class="headerlink" title="DNS的作用"></a>DNS的作用</h3><p>把域名解析为IP地址。例如打得开QQ(可以直接用IP地址登陆)，打不开网络可能是域名问题。<br>8.8.8.8 是google的DNS服务器，222.222.222.222是电信的DNS服务器，能够用来帮忙解析域名地址。</p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><ul>
<li>根：“.”</li>
<li>顶级域名 com,edu,net,cn,org,gov,top</li>
<li>级域名 easonhe,baidu例如eaosnhe.top是全球唯一的域名。</li>
<li>三级域名 dba，例如<a href="http://www.dba.easonhe.com" target="_blank" rel="noopener">www.dba.easonhe.com</a></li>
<li>www是主机</li>
<li>eason.top是域名</li>
<li>ping easonhe.top可以得到对应连接是否通常还可以查看地址 nslookup easonhe.top或直接输入easonhe.top均可以查看域名对应的信息</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/23/Dx8P1.png" alt="Dx8P1.png"></p>
<h2 id="DHCP动态主机配置系统"><a href="#DHCP动态主机配置系统" class="headerlink" title="DHCP动态主机配置系统"></a>DHCP动态主机配置系统</h2><h3 id="IP类型"><a href="#IP类型" class="headerlink" title="IP类型"></a>IP类型</h3><p><img src="https://wx1.sbimg.cn/2020/07/23/DxE12.png" alt="DxE12.png"></p>
<blockquote>
<p>静态地址适用于一般不挪动的主机，这样分配静态地址方便使用地址来直接连接到服务<strong>DHCP服务器必须是静态地址</strong></p>
</blockquote>
<p><img src="https://wx2.sbimg.cn/2020/07/23/DxN88.png" alt="DxN88.png"></p>
<blockquote>
<p>动态地址：而经常更换位置的主机，如学生的电脑要经常更换教师上网，这样就需要使用动态地址分配了，不然自己设置的话就会很乱。</p>
</blockquote>
<h3 id="DHCP运行的过程"><a href="#DHCP运行的过程" class="headerlink" title="DHCP运行的过程"></a>DHCP运行的过程</h3><ul>
<li>DHCP会动态的为需要获取IP地址的主机分配IP地址，DHCP会收听广播分配地址。</li>
<li>如果网络中有多个DHCP服务段都为主机分配了地址，主机可以返回一个消息来确认最终用了谁分配的IP地址。</li>
<li>网络中不能有太多的DHCP服务端。</li>
<li>ipconfig /release释放iP地址</li>
</ul>
<h3 id="跨网段分配IP"><a href="#跨网段分配IP" class="headerlink" title="跨网段分配IP"></a>跨网段分配IP</h3><p>需要使用DHCP跨网段分配IP的时候需哟啊它所在的网络的路由器的网关上配置IPhelper address再访问DHCP</p>
<h2 id="远程终端协议Telnet"><a href="#远程终端协议Telnet" class="headerlink" title="远程终端协议Telnet"></a>远程终端协议Telnet</h2><blockquote>
<p>可以远程配置路由器和主机</p>
</blockquote>
<h2 id="远程桌面协议RDP"><a href="#远程桌面协议RDP" class="headerlink" title="远程桌面协议RDP"></a>远程桌面协议RDP</h2><ul>
<li>远程桌面协议RDP和Telnet协议类似，但是<strong>这个是拥有图形界面的</strong></li>
<li>mstsc(微软远程终端客户端)（使用TCP的3389端口，多用户操作，允许多个用户同时操作，互相不影响，只能同时连两个人，不能再有第三个人连接（XP与win7））</li>
<li>将用户添加到Remote Desktop Users组中就可以远程操作计算机了。</li>
<li>本地硬盘映射到远程，即远程连接主机的时候，可以在主机的磁盘界面直接访问本机的界面，然后直接进行操作，使用3389端口.</li>
</ul>
<h2 id="FTP文件传输协议（File-Transfer-Protocol）"><a href="#FTP文件传输协议（File-Transfer-Protocol）" class="headerlink" title="FTP文件传输协议（File Transfer Protocol）"></a>FTP文件传输协议（File Transfer Protocol）</h2><h3 id="FTP使用的两个TCP连接"><a href="#FTP使用的两个TCP连接" class="headerlink" title="FTP使用的两个TCP连接"></a>FTP使用的两个TCP连接</h3><p>FTP的连接方式包括控制连接和数据连接。每上传/下载一个文件就会建立一个会话。</p>
<ul>
<li>控制连接：标准端口为21，用于发送FTP命令信息。</li>
<li>数据连接：标准端口为20，用于上传/下载数据。</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/23/DxlpJ.png" alt="DxlpJ.png"></p>
<h3 id="FTP数据连接"><a href="#FTP数据连接" class="headerlink" title="FTP数据连接"></a>FTP数据连接</h3><p>两种模式：主动模式和被动模式</p>
<ul>
<li>主动模式：FTP客户端告诉FTP服务器(的21端口)它在使用什么端口侦听，然后FTP服务器(的20端口)主动地和FTP客户端的这个端口建立连接。</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/23/Dxrhm.png" alt="Dxrhm.png"></p>
<ul>
<li>被动模式：FTP服务器端打开在指定范围内的某个新的端口(例如1089端口)并且进行侦听，被动地等待客户端发起连接。</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/23/DxOaU.png" alt="DxOaU.png"></p>
<blockquote>
<p>在有防火墙的情况下，如果使用被动模式，防火墙不得不开很多端口来监听。因此<strong>应该使用主动模式来进行数据连接，并在防火墙开21和20端口</strong>。</p>
</blockquote>
<h3 id="FTP的传输模式"><a href="#FTP的传输模式" class="headerlink" title="FTP的传输模式"></a>FTP的传输模式</h3><ul>
<li>文本模式：ASCII模式，以文本序列传输数据。</li>
<li>二进制模式：Binary模式，以二进制序列传输数据。</li>
</ul>
<h2 id="HTTP超文本传输协议（Hyper-Text-Transfer-Protocol"><a href="#HTTP超文本传输协议（Hyper-Text-Transfer-Protocol" class="headerlink" title="HTTP超文本传输协议（Hyper Text Transfer Protocol)"></a>HTTP超文本传输协议（Hyper Text Transfer Protocol)</h2><p>简单来说这个协议就是用来访问web服务的</p>
<h3 id="www万维网（World-Wide-Web）"><a href="#www万维网（World-Wide-Web）" class="headerlink" title="www万维网（World Wide Web）"></a>www万维网（World Wide Web）</h3><ul>
<li>www提供分布式服务</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/23/DxSfd.png" alt="DxSfd.png"></p>
<blockquote>
<ul>
<li>客户服务器方式</li>
<li>客户程序</li>
<li>浏览器</li>
<li>服务器程序</li>
<li>万维网服务器</li>
<li>页面</li>
<li>URL统一资源定位符</li>
<li>HTTP使用TCP连接</li>
<li>超文本标记语言HTMl</li>
<li>搜索引擎</li>
</ul>
</blockquote>
<h4 id="URL同一资源定位符（Uniform-Resource-Locator"><a href="#URL同一资源定位符（Uniform-Resource-Locator" class="headerlink" title="URL同一资源定位符（Uniform Resource Locator)"></a>URL同一资源定位符（Uniform Resource Locator)</h4><p><img src="https://wx1.sbimg.cn/2020/07/23/DxyA4.png" alt="DxyA4.png"></p>
<p>类似于web页面的在服务器中的地址，网站的标识有多种方式，不同的端口，不同的IP地址，不同的域名(主机头)来区分。</p>
<h3 id="使用Web代理服务器访问网站"><a href="#使用Web代理服务器访问网站" class="headerlink" title="使用Web代理服务器访问网站"></a>使用Web代理服务器访问网站</h3><p>内网其它主机不能通过路由访问Internet，只能由web代理(在同一个网段里)访问外网，然后内网其它主机访问这个web代理来实现上网功能。如果web代理在外网，反而速度更慢。</p>
<p>使用Web代理服务起访问网站的好处有：</p>
<ul>
<li>节省内网访问Internet的带宽(便于访问内容变化不大的网站)。</li>
<li>绕过防火墙访问外网。例如访问某个禁止的网站A，但是假如通过在与A同一个网络中的web代理，就可以访问该网站。</li>
<li>通过web代理避免被跟踪。</li>
</ul>
<h2 id="SMTP-POP3-IMAP协议（邮件系统协议）"><a href="#SMTP-POP3-IMAP协议（邮件系统协议）" class="headerlink" title="SMTP POP3 IMAP协议（邮件系统协议）"></a>SMTP POP3 IMAP协议（邮件系统协议）</h2><ul>
<li>SMTP是发邮件用的协议</li>
<li>POP3和IMAP是收邮件用的协议，IMAP功能更强大一些</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/23/DxV7Y.png" alt="DxV7Y.png"></p>
<h2 id="配置邮件服务器"><a href="#配置邮件服务器" class="headerlink" title="配置邮件服务器"></a>配置邮件服务器</h2><ul>
<li><p>安装POP3和SMTP服务以及DNS服务</p>
</li>
<li><p>再DNS服务器上创建两个地址，如eaosnhe.com和he.com</p>
</li>
<li><p>创建主机记录 mail 地址</p>
</li>
<li><p>创建邮件交换记录（MX记录）</p>
</li>
<li><p>在POP3服务上创建域名，创建邮箱</p>
</li>
<li><p>配置SMTP服务器，创建远程域名*.com 允许发送到远程</p>
</li>
<li><p>配置outlookExpress指明收件的服务器和发邮件的服务器，使用POP3协议收邮件</p>
</li>
<li><p>搭建能够在Internet上使用的邮件服务器</p>
<blockquote>
<ul>
<li>在Internet上注册了域名，MX记录</li>
<li>邮件服务器有公网IP地址或端口映射到服务器</li>
</ul>
</blockquote>
</li>
</ul>
<p>参考：<br>韩立刚老师《计算机网络》课程<br><a href="https://blog.csdn.net/iwanderu/article/details/103812980" target="_blank" rel="noopener">https://blog.csdn.net/iwanderu/article/details/103812980</a></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机网络】物理层</title>
    <url>/2020/07/19/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<p><strong>计算机网络不看后悔系列blog(二）物理层/超详细！！✧ (≖ ‿ ≖)✧</strong></p>
<a id="more"></a>
<h2 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h2><p>物理层解决<strong>如何在连接各种计算机的传输媒体上传输数据比特流</strong>而不是指具体的传输媒体（如光纤，无线）和具体的介质没有关系</p>
<h3 id="物理层主要任务描述"><a href="#物理层主要任务描述" class="headerlink" title="物理层主要任务描述"></a>物理层主要任务描述</h3><p>确定与传输媒体的接口的一些特性</p>
<ul>
<li>机械特性：例如接口形状，大小，引线数目</li>
<li>电气特性：例如规定电压范围（-5V到+5V）</li>
<li>功能特性：例如规定-5V表示0，+5V表示1</li>
<li>过程特性：也称为规程特性，规定建立连接时各个相关部件的工作步骤</li>
</ul>
<h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><h3 id="典型的数据通信模型"><a href="#典型的数据通信模型" class="headerlink" title="典型的数据通信模型"></a>典型的数据通信模型</h3><p><img src="https://wx2.sbimg.cn/2020/07/18/CNw6o.png" alt="CNw6o.png"></p>
<blockquote>
<p>但是对于通过交换机进行连接的PC机之间没有调制和解调步骤，直接通过数字比特流进行传输</p>
</blockquote>
<h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><h4 id="数据（data）"><a href="#数据（data）" class="headerlink" title="数据（data）"></a>数据（data）</h4><blockquote>
<p>通信的目的是传送消息，数据就是运送消息的实体(数据本身不一定具有意义，但是组合而成的消息就具有了意义)</p>
</blockquote>
<h4 id="信号（signal）"><a href="#信号（signal）" class="headerlink" title="信号（signal）"></a>信号（signal）</h4><p>数据的电气的或电磁的表现（网线传输时电压的高低，光纤传输时就是光信号，红绿灯颜色的信号）</p>
<ul>
<li>“模拟信号”–代表消息的参数的取值是连续的（如说话的声音）</li>
<li>“数字信号”–代表消息的参数的取值是离散的（0和1）</li>
</ul>
<h4 id="码元（code）"><a href="#码元（code）" class="headerlink" title="码元（code）"></a>码元（code）</h4><p>在使用时间域的波形表示数字信号时，则代表不同离散数值的基本波形就成为码元。在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号就称为二进制码元。而这个间隔被称为码元长度，1码元可以携带nbit的信息量</p>
<h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><blockquote>
<p>信道一般表示向一个方向传输信息的媒体。所以通信线路往往包含一条发送信息的信道和一条接收信息的信道。(三种通信方式在上一篇博文中)</p>
</blockquote>
<blockquote>
<p>理想低通信道的最高码元传输速率=2WBaud<br>（其中W是理想低通信道的带宽，单位为HZ，Baud是波特，是码元传输速率的单位）</p>
</blockquote>
<h3 id="基带信号与代通信号"><a href="#基带信号与代通信号" class="headerlink" title="基带信号与代通信号"></a>基带信号与代通信号</h3><ul>
<li>基带信号(基本频率信号)：来自信源的信号，例如计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的<strong>直接表达</strong>了要传输的信息的信号，比如说我们说话的声波。</li>
<li>带通信号：把基带信号<strong>经过载波调制后，把信号的频率范围迁移到较高的频段</strong>以便在信道中传输(即仅在一段频率范围内能够通过信道)。</li>
</ul>
<blockquote>
<p>因此在传输距离较近时，采用基带传输方式(衰减不大，信号内容不会变化)。传输距离较远时，采用带通传输方式。</p>
</blockquote>
<h3 id="基本调制方法"><a href="#基本调制方法" class="headerlink" title="基本调制方法"></a>基本调制方法</h3><p>从基带信号到带通信号：</p>
<ul>
<li>调幅（AM）</li>
<li>调频（FM）</li>
<li>调相（PM）<br><img src="https://wx1.sbimg.cn/2020/07/18/ClB1h.png" alt="ClB1h.png"></li>
</ul>
<h3 id="常用的编码方式"><a href="#常用的编码方式" class="headerlink" title="常用的编码方式"></a>常用的编码方式</h3><ul>
<li>单极性不归零编码：只使用一个电压值，高电平表示1，低电平表示0.</li>
<li>双极性不归零编码：用幅值相等的正负电平表示二进制数1和0.</li>
<li>单极性归零编码：发送码1时高电平在整个码元期间只持续一段时间，其余时间返回零电平。</li>
<li>双极性归零编码：正负零三个电平，信号本身携带同步信息。</li>
<li>曼彻斯特编码：<strong>单极性编码</strong>的缺点是没有办法区分此时是没有信号，还是有信号，还是信号是0（因为一直传输0的时候的电平一直不变）。而这种编码方式是bit中间有信号，低-高跳转表示0，高-低跳转表示1，一个时钟周期只可以表示一个bit，并且必须通过两次采样才能得到一个bit。<strong>它能携带时钟信号，而且能区分此时是没有信号还是信号为0</strong>（<strong>bit中间有信号低-高跳变为0，有高-低跳变为1</strong>）。</li>
<li>差分曼彻斯特编码：抗干扰能力比曼彻斯特编码更强。<strong>bit与bit之间有信号跳变，表示下一个bit为0，bit与bit之间没有信号跳变，表示下一个bit为1</strong>。<br><img src="https://wx2.sbimg.cn/2020/07/18/Clqoo.png" alt="Clqoo.png"><br><img src="https://wx1.sbimg.cn/2020/07/18/Cle1l.png" alt="Cle1l.png"></li>
</ul>
<h3 id="信道极限容量"><a href="#信道极限容量" class="headerlink" title="信道极限容量"></a>信道极限容量</h3><blockquote>
<p>信道极限容量取决于失真的大小，当失真过大时，接收信号无法还原发送信号。</p>
</blockquote>
<p><img src="https://wx2.sbimg.cn/2020/07/18/CltE1.png" alt="CltE1.png"></p>
<h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><p>在理想条件下(无噪声/干扰/失真)，为了避免码间串扰，<strong>码元的传输速率是有上限的</strong>。如果信道的频带越宽(信号高频分量越多)，则用更高的速率传输码元也不会出现码间串扰。</p>
<h3 id="信噪比与香农公式"><a href="#信噪比与香农公式" class="headerlink" title="信噪比与香农公式"></a>信噪比与香农公式</h3><p>信道的极限信息传输速率C(带宽受限且有Gauss白噪声干扰时的信道极限且无差错时的信息传输速率)可表示为：</p>
<blockquote>
<p>C = W log2(1 + S / N) b/s</p>
</blockquote>
<p>其中：</p>
<ul>
<li>W是信道的带宽(Hz)；</li>
<li>S是信道内所传信号的平均功率；</li>
<li>N是信道内的Gauss噪声的功率。</li>
</ul>
<blockquote>
<p>可以发现：</p>
<ul>
<li>减少速度和增大功率能提高准确度。</li>
<li>信道的带宽或信道中的信噪比(S/N)越大，则信息的极限传输速率C就越高。</li>
<li>只要信息传输速率小于信道的极限传输速率C，就一定能实现某种无差错传输。</li>
<li>若带宽W或信噪比(S/N)没有上限，则极限传输速率C也没有上限(现实不可能)。</li>
<li>实际上，信道能达到的最高传输速率要比C低不少。</li>
</ul>
</blockquote>
<h3 id="奈氏准则与香农公式的应用范围"><a href="#奈氏准则与香农公式的应用范围" class="headerlink" title="奈氏准则与香农公式的应用范围"></a>奈氏准则与香农公式的应用范围</h3><p><img src="https://wx2.sbimg.cn/2020/07/18/ClW4m.png" alt="ClW4m.png"></p>
<blockquote>
<p>在这里面源点向发送器的输入数据是二进制的数据流（基带信号），发送器向传输系统发送的信号虚拟信号（带通信号）</p>
</blockquote>
<h2 id="物理层下的传输介质"><a href="#物理层下的传输介质" class="headerlink" title="物理层下的传输介质"></a>物理层下的传输介质</h2><h3 id="导向传输媒体"><a href="#导向传输媒体" class="headerlink" title="导向传输媒体"></a>导向传输媒体</h3><p><strong>导向传输媒体中，电磁波沿着固体媒体传播</strong>。</p>
<ul>
<li>双绞线：</li>
</ul>
<p><strong>屏蔽/非屏蔽双绞线(STP/UTP)</strong>（屏蔽双绞线传输的距离更远，抗干扰能力更强）<br><img src="https://wx2.sbimg.cn/2020/07/18/ClZHd.png" alt="ClZHd.png"></p>
<ul>
<li>同轴电缆：50欧姆同轴电缆(基带同轴电缆)用于数字传输，<strong>多用于基带传输</strong>；<br>75欧姆同轴电缆(宽带同轴电缆)——用于模拟传输，<strong>多用于带通传输</strong>；</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/18/CliqA.png" alt="CliqA.png"></p>
<ul>
<li>网线：1.直通线：双绞线夹线顺序两端一致(1白橙2橙3白绿4蓝5白蓝6绿7白棕8棕，口诀“橙白橙/绿白蓝/蓝白绿/棕白棕”)，这是100M的标准(568B)，也称正线/标准线/直通线。当用于10M和100M时，下图只用了1，3，2，6线。对于1000M的网络，8根线都会用上。直通线应用最广，这种类型的以太网电缆用来实现以下连接：主机到交换机/集线器，路由器到交换机/集线器。<br><img src="https://wx2.sbimg.cn/2020/07/18/Cl8k7.png" alt="Cl8k7.png"></li>
</ul>
<p>2.交叉线：一般不同设备连接用直通线，同类设备用交叉线。也用于集线器到交换机，路由器到主机连接。注意，现在网卡能够自动协商，所以交叉线和直通线已经无所谓了，连错了也没关系<br><img src="https://wx2.sbimg.cn/2020/07/18/ClNvO.png" alt="ClNvO.png"></p>
<ul>
<li>光纤：<br><img src="https://wx1.sbimg.cn/2020/07/18/CrkTT.png" alt="CrkTT.png"></li>
</ul>
<p>1.单模光纤只能传输一种电磁波，直径小，用于有线电视网络，传播特性好，带宽可达10GHz，可以在一根光纤中传输60套PAL-D电视节目。<br><img src="https://wx2.sbimg.cn/2020/07/18/Cr23w.png" alt="Cr23w.png"><br>2.多模光纤——能传输多种电磁波，直径大，多模光纤可以通过入射角来区分。<br>微波需要建立发射塔，因为微波是直线传播，若不建立发射塔则很可能接受不到信号<br><img src="https://wx1.sbimg.cn/2020/07/18/CrCeo.png" alt="CrCeo.png"><br>短波通信靠大气中的电离层反射，质量比较差</p>
<h3 id="非导向传输媒体"><a href="#非导向传输媒体" class="headerlink" title="非导向传输媒体"></a>非导向传输媒体</h3><p>非导向传输媒体指自由空间，其中的电磁波传输称为无线传输。无线传输的频段很广。短波通信主要是靠电离层的反射，但短波信道的通信质量较差；<br>微波在空间主要是直线传播(延迟大)——地面微波接力通信；微信通信。电信领域使用的电磁波的频谱如下：<br><img src="https://wx1.sbimg.cn/2020/07/18/Cro01.png" alt="Cro01.png"></p>
<h3 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h3><p>集线器工作特点是在网络中只起到信号放大和重发作用，目的是扩大网络的传输范围，而不具备信号的定向传送能力。最大传输距离是100m；集线器是一个大的冲突域(意思是某个时间点只能是2台设备进行通信)。<strong>现在大都被转换器替代掉了</strong>，如果是多台计算机则集线器会把收到的信号放大传递给所有的计算机，并且只允许一个线道通信，被动接受的两台计算机就不能进行通信了（半双工通信），并且带宽确定，连的机器越多分得的带宽越少，并且不安全。</p>
<h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p><strong>复用是通信技术中的基本概念</strong>复用技术对比图：<br><img src="https://wx2.sbimg.cn/2020/07/18/Cr3J2.png" alt="Cr3J2.png"><br><img src="https://wx1.sbimg.cn/2020/07/18/Cr6U8.png" alt="Cr6U8.png"></p>
<h3 id="频分复用FDN"><a href="#频分复用FDN" class="headerlink" title="频分复用FDN"></a>频分复用FDN</h3><p>用户在分配到一定的频带后，在通信过程中始终站用这个频带。频分复用的所有用户在同样的时间占用不同的带宽频率：<br><img src="https://wx1.sbimg.cn/2020/07/18/CrQRm.png" alt="CrQRm.png"><br><img src="https://wx1.sbimg.cn/2020/07/18/CrByd.png" alt="CrByd.png"><br><img src="https://wx2.sbimg.cn/2020/07/18/Crc64.png" alt="Crc64.png"></p>
<h3 id="时分复用TDN"><a href="#时分复用TDN" class="headerlink" title="时分复用TDN"></a>时分复用TDN</h3><p>时分复用是使用相同的带宽频率但是所分配子信道不通（可以理解为在一个相同的信道中大家的时间利用点不同）时分复用可能会造成线路资源的浪费，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般不高。因为时分复用里的某个线路可能没有数据<br><img src="https://wx1.sbimg.cn/2020/07/18/CrLi6.png" alt="CrLi6.png"><br><img src="https://wx1.sbimg.cn/2020/07/18/CrJJ7.png" alt="CrJJ7.png"><br><img src="https://wx1.sbimg.cn/2020/07/18/Crs0V.png" alt="Crs0V.png"></p>
<h3 id="统计时分复用STDM"><a href="#统计时分复用STDM" class="headerlink" title="统计时分复用STDM"></a>统计时分复用STDM</h3><p>就是在时分复用得基础上在时分复用帧上增加标记<br><img src="https://wx2.sbimg.cn/2020/07/18/Cru5O.png" alt="Cru5O.png"></p>
<h3 id="波分复用WDM"><a href="#波分复用WDM" class="headerlink" title="波分复用WDM"></a>波分复用WDM</h3><p>简单的说就是光的频分复用<br><img src="https://wx1.sbimg.cn/2020/07/19/Cr1Re.png" alt="Cr1Re.png"></p>
<h3 id="码分复用CDMA"><a href="#码分复用CDMA" class="headerlink" title="码分复用CDMA"></a>码分复用CDMA</h3><p><strong>各用户使用不同码型</strong>，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。每一个比特时间划分为m个短的间隔，称为码片(chip)。码分复用中比如联通公司所发出的都是同一个频率的信号，采用的就是码分复用来区分，码片正交后得到0表示没有信号，1或-1则可以接收到。<strong>任何一个码片向量和该码片向量自己的规格化内积都是1，任何一个码片向量和该码片反码向量的规格化内积都是-1</strong>，缺点是表示一个bit需要更多的数据。<br><img src="https://wx2.sbimg.cn/2020/07/19/CrqWD.png" alt="CrqWD.png"><br><img src="https://wx2.sbimg.cn/2020/07/18/CrdeY.png" alt="CrdeY.png"><br><img src="https://wx1.sbimg.cn/2020/07/19/CreyN.png" alt="CreyN.png"></p>
<h2 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h2><p>广域网的数据传输：脉码调制(PCM)技术。欧洲是E1标准(30路)，北美是T1(24路，时分复用)。</p>
<h2 id="带宽接入技术"><a href="#带宽接入技术" class="headerlink" title="带宽接入技术"></a>带宽接入技术</h2><h3 id="ADSL非对称数字用户链路"><a href="#ADSL非对称数字用户链路" class="headerlink" title="ADSL非对称数字用户链路"></a>ADSL非对称数字用户链路</h3><p>使用电话线。用数字技术对现有的模拟电话用户线进行改造(xDSL)，把0-4kHz留给传统电话使用，把原来没有利用的高频谱段留给用户上网使用。<strong>ADSL上属于那一部分的频率范围可以分割成若干个频率来进行频分复用</strong><br><img src="https://wx2.sbimg.cn/2020/07/19/Cr7bn.png" alt="Cr7bn.png"><br>接入网组成图：<br><img src="https://wx1.sbimg.cn/2020/07/19/CrK2h.png" alt="CrK2h.png"><br>其中：</p>
<ul>
<li>数字用户线接入复用器DSLAM(DSL Access Multiplexer)</li>
<li>接入端单元(Access Termination Unit)</li>
<li>ATU-C(C表示端局Central Office)</li>
<li>ATU-R(R代表远端Remote)</li>
<li>电话分离器PS(POTS Splitter)</li>
</ul>
<h3 id="DMT技术"><a href="#DMT技术" class="headerlink" title="DMT技术"></a>DMT技术</h3><p>采用频分复用，把40kHz以上一直到1.1MHz的高频谱划分为徐队子信道，其中25个子信道用于上行信道，249个子信道用于下行信道(因为下载的情景多于上传)。每个子信道占据4kHz的带宽，并使用不同的载波进行数字调制。这种做法相当于在一对用户线上使用许多小的调制解调器并行地传输数据。</p>
<h3 id="光纤同轴混合网HFC"><a href="#光纤同轴混合网HFC" class="headerlink" title="光纤同轴混合网HFC"></a>光纤同轴混合网HFC</h3><p>HFC网是在目前覆盖范围很广的有线电视网CATV基础上开发的一种<strong>居民宽带接入网</strong>。除了可以传送CATV外，还可以提供电话/数据/和其它宽带交互型业务。现有CATV网是树形拓扑结构的同轴电缆网络，它采用 模拟技术的频分复用对电视节目进行单向传输。HFC需要对CATV网进行改造：其中每个用户要安装一个用户接口盒：<br><img src="https://wx2.sbimg.cn/2020/07/19/CrWLM.png" alt="CrWLM.png"><br><img src="https://wx1.sbimg.cn/2020/07/19/CrYia.png" alt="CrYia.png"></p>
<h3 id="FTT技术"><a href="#FTT技术" class="headerlink" title="FTT技术"></a>FTT技术</h3><ul>
<li>光纤到家技术(Fiber to the home):光纤一直铺设到用户家庭(155MB/s)。</li>
<li>光纤到大楼技术(Fiber to the building):光纤进入大楼后就转为电信号，然后用电缆或双绞线分配到各用户。</li>
<li>光纤到路边技术(Fiber to the curb):从路边到各用户可以使用星形结构的双绞线作为传输媒体(155MB/s)。</li>
</ul>
<p>参考：<br><a href="https://blog.csdn.net/iwanderu/article/details/103802457" target="_blank" rel="noopener">https://blog.csdn.net/iwanderu/article/details/103802457</a><br>《计算机组成原理》课程</p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机网络】网络层</title>
    <url>/2020/07/21/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<p><strong>计算机网络不看后悔系列blog(四）网络层/超详细！！(๑´ڡ`๑)</strong></p>
<a id="more"></a>
<h2 id="网络层的作用"><a href="#网络层的作用" class="headerlink" title="网络层的作用"></a>网络层的作用</h2><blockquote>
<p>负责在不同的网络之间(基于数据包的IP地址)尽力转发数据包，不负责丢包重传和接收顺序。有点像送快递，一个人往另一个地方寄快递，每个快递走不同的路线，可能后发的先到了，也可能丢件了。但是网络层不管这些，只管寄快递。</p>
</blockquote>
<p><img src="https://wx2.sbimg.cn/2020/07/21/DMnNI.png" alt="DMnNI.png"></p>
<p>数据包在Internet中的传输，Internet既有局域网，又有广域网，既有光纤，又有铜线，无线，还有不同的协议，这是Internet复杂所在。<br>路由器是三层设备：能看到网络层的IP地址来选择路径:</p>
<p><img src="https://wx1.sbimg.cn/2020/07/21/DM80K.png" alt="DM80K.png"></p>
<p>典型的路由器结构：</p>
<p><img src="https://wx2.sbimg.cn/2020/07/20/D5emT.png" alt="D5emT.png"></p>
<h2 id="网络层向运输层提供的两种服务"><a href="#网络层向运输层提供的两种服务" class="headerlink" title="网络层向运输层提供的两种服务"></a>网络层向运输层提供的两种服务</h2><ul>
<li>电信网：虚电路服务：指定所传送的分组都沿着相通的一条虚电路传送，也就是为分组指定路径，这个方式可以不用写目标地址，因为线路已经确定了（可靠性应到由网络来保证）</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/20/CF1cM.png" alt="CF1cM.png"></p>
<ul>
<li>因特网：数据包服务：网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务，网络在发送分组时不需要先建立连接，每一个分组（即IP数据报）独立发送，与其前后的分组无关（不进行编号），网络层不提供服务质量的承诺，即所传送的分组可能出错、丢失、重复、失序（不按序达到终点），当然也不保证分组传送的时限。（可靠通信应当由主机来保证）</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/20/CFqWa.png" alt="CFqWa.png"></p>
<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>如果计算机没有配网关，那么计算机将不能到其他网段，但是可以访问本网段的计算机，网关就是到其他网段的路由器的接口，一个计算机可以指定多个网关 （得是存在的路由器接口）还可以指定多个IP地址</p>
<h2 id="IP协议简介"><a href="#IP协议简介" class="headerlink" title="IP协议简介"></a>IP协议简介</h2><p>网际协议IP是TCP/IP体系中最重要的协议之一，网络层还有四个协议：</p>
<ul>
<li>地址解析协议ARP</li>
<li>逆地址解析协议RARP</li>
<li>国际控制报文协议ICMP</li>
<li>国际组管理协议IGMP</li>
</ul>
<blockquote>
<p>第一和第二协议一般被认为是同一回事，所以就直接用ARP协议代替，组成网络层的四种协议</p>
</blockquote>
<h2 id="网络层4个协议之间的层次"><a href="#网络层4个协议之间的层次" class="headerlink" title="网络层4个协议之间的层次"></a>网络层4个协议之间的层次</h2><p><img src="https://wx2.sbimg.cn/2020/07/20/CFeVR.png" alt="CFeVR.png"></p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><h3 id="网络部分与主机部分"><a href="#网络部分与主机部分" class="headerlink" title="网络部分与主机部分"></a>网络部分与主机部分</h3><p><img src="https://wx1.sbimg.cn/2020/07/20/CFw6I.png" alt="CFw6I.png"></p>
<p><strong>前半段为网络地址，后半段为主机地址</strong></p>
<h3 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h3><p>网络地址（也可以称为网络号）唯一指定了每个网络，同一网络中的每台计算机都共享相同的网络地址，并用它作为自己IP地址的一部分，其中划分的几个类别的区分网络地址段与主机地址段的区别：</p>
<p><img src="https://wx2.sbimg.cn/2020/07/20/CFztK.png" alt="CFztK.png"></p>
<h3 id="IP地址及其表示方法"><a href="#IP地址及其表示方法" class="headerlink" title="IP地址及其表示方法"></a>IP地址及其表示方法</h3><p>我们把整个因特网看成为一个单一的、抽象的网络。IP地址就是给连接再因特网上的主机或路由器的每一个接口分配一个再全世界范围是唯一的32位标识符，IP地址现在由因特网名字与号码指派公司ICANN进行分配。IP地址的编址方法：</p>
<ul>
<li>分类的IP地址，这是最基本的编址方法。</li>
<li>子网的划分。这是对基本的编址方法的改进。</li>
<li>构成超网。这是比较新的无分类编址方法</li>
</ul>
<h3 id="IP地址-1"><a href="#IP地址-1" class="headerlink" title="IP地址"></a>IP地址</h3><p><img src="https://wx2.sbimg.cn/2020/07/20/CIszJ.png" alt="CIszJ.png"></p>
<p><strong>可以看到A类地址的网络号字段只有8位而主机号字段有24位，即A类地址可以接254^3台主机为他们分配不同的地址，同样的道理，C类地址只有8位主机号字段，那么它只能给254台主机分配不同的地址</strong></p>
<p>原因牵扯到十进制与二进制的关系：</p>
<p><img src="https://wx1.sbimg.cn/2020/07/20/CIJOm.png" alt="CIJOm.png"></p>
<ul>
<li>当第一段为0-127则为A类地址</li>
<li>128-191则为B类地址</li>
<li>192-224则为C类地址</li>
</ul>
<p>也就是说</p>
<ul>
<li>0开头的为A类地址</li>
<li>10开头的为B类地址</li>
<li>110开头的为C类地址</li>
</ul>
<h3 id="常用的三种类别的IP地址"><a href="#常用的三种类别的IP地址" class="headerlink" title="常用的三种类别的IP地址"></a>常用的三种类别的IP地址</h3><p><img src="https://wx2.sbimg.cn/2020/07/20/CIjDU.png" alt="CIjDU.png"></p>
<p><strong>主机的网段不能全为0或1，所以A类可用网络号到126因为127全为1，128全为0，向下的以此类推</strong></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://wx1.sbimg.cn/2020/07/20/CIuud.png" alt="CIuud.png"></p>
<p><strong>在这个例子中的首段为133，说明这个为B类IP地址，B类IP地址的前两段为网络号字段，所以TAB键自动填充两个255，也就是告诉计算机我的前两个字段为网络号字段</strong></p>
<h3 id="几个特殊的IP地址"><a href="#几个特殊的IP地址" class="headerlink" title="几个特殊的IP地址"></a>几个特殊的IP地址</h3><ul>
<li>127.0.0.1本机环回地址</li>
<li>169.254.0.0没有地址而分配到的默认地址（所有默认这个地址的人是在一个网段的）</li>
<li>10.0.0.0保留的A类私网地址（在互联网上这个地址没有被服务器拿来用，可以让企业或学校来用）</li>
<li>172.16.0.0–172.31.0.0保留的B类私网地址</li>
<li>192.168.0.0–192.168.255.0保留的C类私网地址</li>
</ul>
<p><strong>注意：保留的私网地址是不能通过互联网连接的，因为互联网没有这些地址的服务器，所以不知道怎么走，这肯定是在某个机构的内网里，这些地址重叠都没关系，因为私网之间不互相通信。</strong>公网地址才能通过互联网访问</p>
<h2 id="IP数据包的格式"><a href="#IP数据包的格式" class="headerlink" title="IP数据包的格式"></a>IP数据包的格式</h2><p>注意，ARP数据包不是这个格式。</p>
<ul>
<li>首部：第一部分是固定长度，20字节，是所有IP数据包必须具有的。后一部分是可选字段，长度可变。</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/21/DMNUT.png" alt="DMNUT.png"></p>
<p>每一行32bit相当于1个字节，一共5行，共20字节</p>
<p><img src="https://wx2.sbimg.cn/2020/07/21/DMl5w.png" alt="DMl5w.png"></p>
<ul>
<li>版本：用来表示TCP/IP是哪个版本，ipv4还是ipv6.</li>
<li>区分服务：确定更高的传输优先级。</li>
<li>总长度：确定数据部分长度。一共是16位，最多有2^16-1=65535字节。</li>
</ul>
<blockquote>
<p>注意，网络层，数据包最大65535字节；而数据链路层数据最大是1500字节，是不一样的。所以说，一旦超过数据链路层的最大要求时(网络层数据部分超过1480字节)，数据包会分片。最大传输单元MTU。</p>
</blockquote>
<p><img src="https://wx1.sbimg.cn/2020/07/21/DMrRo.png" alt="DMrRo.png"></p>
<blockquote>
<p>数据包分片：把数据分割，分别添加IP地址，通过网络发给目标MAC地址。目标在通过网络层拼接。传送过程中可能会丢包，或者后发的先到(泪滴攻击就是利用目标机发送破坏的IP包(重叠的包货过大的包负荷)可以通过TCP/IP协议来瘫痪各种不同的操作系统)。所以需要编号。</p>
</blockquote>
<ul>
<li>标识：如果出现数据包分片，那么标识用来确定哪些数据包是需要组合的。</li>
<li>标志：确定该数据包是完整的还是分片中的一部分。占3位，只有前两位有用，标志字段最低位是MF(More Fragment)，MF=1表示后面还有分片，MF=0表示最后一个分片。标志字段中间一位是DF(Don’t Fragment)，只有DF=0才允许分片。</li>
<li>片偏移：偏移等于当前字节在数据部分的第几个再除以8.(下图是一个举例)</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/21/DMOKl.png" alt="DMOKl.png"></p>
<ul>
<li>生存时间：就是TTL，time to live，每过一个路由器就减1。8位二进制。防止数据包在网络中循环。</li>
<li>协议：用协议号标识数据部分是什么数据。</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/21/DMSy1.png" alt="DMSy1.png"></p>
<blockquote>
<ul>
<li>ICMP协议号：1；</li>
<li>IGMP协议号：2；</li>
<li>TCP协议号：6；</li>
<li>UDP协议号：17；域名解析</li>
<li>IPv6协议号：41；</li>
<li>OSPF协议号：89；</li>
</ul>
</blockquote>
<ul>
<li>首部检验和：16位，只检验数据报的首部，不检验数据部分。这里不是采用CRC检验码而是采用简单的计算方法。每经过一个路由器就会检验一次。</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/21/DMy62.png" alt="DMy62.png"></p>
<ul>
<li>源地址和目的地址都是IP地址，32位，只符合IPv4。IPv6是128位。</li>
<li>可变部分：一般没用。</li>
</ul>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p><strong>在两个地址准备通信时，子网掩码会比较两个地址的网络号段是否相同（即是否是在同一个网段）若相同则直接通信，若不相同则转发给.1.0的网关路由器再转发给对应的地址</strong></p>
<p><img src="https://wx2.sbimg.cn/2020/07/20/CIemY.png" alt="CIemY.png"></p>
<p>注意：子网掩码的格式错误也会产生错误，造成线路不同，所以一定要配置正确的子网掩码<br>具体的比较过程：</p>
<p><img src="https://wx2.sbimg.cn/2020/07/20/CI184.png" alt="CI184.png"></p>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>网络畅通的条件下沿途路由器必须知道下一跳给谁，数据包有去有回。</p>
<p><img src="https://wx1.sbimg.cn/2020/07/21/DMVe8.png" alt="DMVe8.png"></p>
<h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><ul>
<li>数据路由：路由器在不同网段转发数据包</li>
<li>静态路由问题：ping连接一通一断很有规律很可能就是路由造成的，它可能加了两个网关，每次发到一个，一次一回就导致了这个问题。如果要通信的那个地址不在默认网关的一端，那么久route add手动添加一条和指定地址联系的道路</li>
<li>需要管理员告诉路由器所有没有直连的网络下一跳给谁。</li>
<li>适合于小规模网络，不能自动调整路由。</li>
</ul>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><h4 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h4><p>周期性广播(30s)路由表，选择路径的依据是最少的跳数，最大跳数是15跳，所以一般不适合大网络。</p>
<h4 id="内部网关协议OSPF（Open-Shortest-Path-First）"><a href="#内部网关协议OSPF（Open-Shortest-Path-First）" class="headerlink" title="内部网关协议OSPF（Open Shortest Path First）"></a>内部网关协议OSPF（Open Shortest Path First）</h4><blockquote>
<ul>
<li>向本自治系统中所有路由器发送信息，实力使用的方法是洪泛法</li>
<li>发送的消息就是与本路由器小林的所有路由器的链路状态，但这只是路由器所知道的部分信息</li>
<li>只有当链路状态发生变化时，路由器采用洪泛法向所有路由器发送此信息</li>
</ul>
</blockquote>
<blockquote>
<p>OSPF带宽度量值，支持多区域，触发式更新，有三个表，</p>
<ul>
<li>邻居表，hello包（和邻居互相打一下招呼）</li>
<li>链路状态表（交换邻居表就能得出谁连着谁）</li>
<li>计算路由表（算一下看看最短路径）</li>
</ul>
</blockquote>
<p><img src="https://wx1.sbimg.cn/2020/07/20/D5sza.png" alt="D5sza.png"></p>
<p>OSPF划分为两种不同的区域</p>
<p><img src="https://wx2.sbimg.cn/2020/07/20/D5hQM.png" alt="D5hQM.png"></p>
<p>OSPF下的路由器只会和自己所在自治系统（也就是不同的区域用各自的协议就是自治系统）的路由器互相交互，不会影响到其他区域的路由器，自治区域汇成一条线路与主干区域相连</p>
<p><strong>OSPF的其他特点</strong>：</p>
<ul>
<li>ISPF不用UDP而是直接用IP数据报传送</li>
<li>OSPf对不同的链路可根据IP分组的不同服务类型而设置成不同的代价。因此，对于不同类型的业务可计算出不同的路由</li>
<li>如果到同一个目的网络有多条代价相同的路径，那么可以将信息量分配给这几条路径，这叫做多路径间的负载平衡</li>
<li>所有在OSPF了路由器之间交换的分组都具有鉴别功能</li>
<li>支持可变长度的子网划分和无分类编址CIDR</li>
<li>每一个链路状态都带上一个32位的序号，序号越大状态就越新</li>
<li>OSPF对子网掩码的要求是反过来的</li>
</ul>
<h3 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h3><p>BGP协议是不同自治系统的路由器之间交换路由信息的协议。边界网关BGP只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。每一个自治系统的管理员要选择至少一个路由器作为该自制系统的“BGP发言人”：</p>
<p><img src="https://wx2.sbimg.cn/2020/07/20/D5uuK.png" alt="D5uuK.png"></p>
<p><img src="https://wx1.sbimg.cn/2020/07/20/D518G.png" alt="D518G.png"></p>
<p>BGP协议的特点:</p>
<ul>
<li>BGP协议交换路由信息的数量不是很多</li>
<li>BGP发言人数目不多，路由选择相对简单</li>
<li>BGP协议支持CIDR</li>
<li>BGP建立时，交换整个路由表但之后只交换变化部分</li>
</ul>
<h3 id="动态路由配置问题"><a href="#动态路由配置问题" class="headerlink" title="动态路由配置问题"></a>动态路由配置问题</h3><blockquote>
<p>动态路由添加的时候如果是统一网段那么就写一个就行了，如果不是同一个网段那么则要全部添加</p>
</blockquote>
<h2 id="子网的划分"><a href="#子网的划分" class="headerlink" title="子网的划分"></a>子网的划分</h2><p>划分子网为了充分利用IP地址</p>
<h3 id="等分子网的划分"><a href="#等分子网的划分" class="headerlink" title="等分子网的划分"></a>等分子网的划分</h3><p><img src="https://wx1.sbimg.cn/2020/07/20/CIff1.png" alt="CIff1.png"><br><img src="https://wx1.sbimg.cn/2020/07/20/CIFho.png" alt="CIFho.png"><br><img src="https://wx1.sbimg.cn/2020/07/20/Cf5A2.png" alt="Cf5A2.png"><br><img src="https://wx1.sbimg.cn/2020/07/20/CIIal.png" alt="CIIal.png"></p>
<p>（B类网络的子网划分以此类推）</p>
<blockquote>
<p><strong>在这个里面0-64字段里面能使用的字段为1-62，因为0是管理员63为广播字段，以此类推其他的字段，第一个和倒数的两个都不能用</strong> 128往前移几位就是处于几个2，就得到了第一个0-*的网段，等分成几个子网，网络号段就往后移一半位，一直向后移到0-4，这样这个往里面只有两个地址，这样就变成了两个主机，点对点的的子网掩码就变成了11111100（252）</p>
</blockquote>
<p><img src="https://wx1.sbimg.cn/2020/07/20/CfXSJ.png" alt="CfXSJ.png"><br>每个网断最大地址的为广播地址，所以最大地址为理论最大地址-1位</p>
<h3 id="等分子网划分的规律"><a href="#等分子网划分的规律" class="headerlink" title="等分子网划分的规律"></a>等分子网划分的规律</h3><p>划分子网的各子网的内部主机数量与2相关，比如200台机器划分为150与50是不能划分的，因为中间数为128，无法划分</p>
<h3 id="变长子网的划分"><a href="#变长子网的划分" class="headerlink" title="变长子网的划分"></a>变长子网的划分</h3><p><img src="https://wx1.sbimg.cn/2020/07/20/CfjHa.png" alt="CfjHa.png"></p>
<h2 id="超网合并网络"><a href="#超网合并网络" class="headerlink" title="超网合并网络"></a>超网合并网络</h2><p><strong>这种情况下A与B通信需要经过路由器转发，但是这样是很多此一举的（两台计算机接在了一个网关的两个接口，是在两个C类地址里）</strong></p>
<p><img src="https://wx1.sbimg.cn/2020/07/20/CfVee.png" alt="CfVee.png"></p>
<p><strong>合并方式其实就是子网划分的反过程</strong>：</p>
<p><img src="https://wx2.sbimg.cn/2020/07/20/CfFbD.png" alt="CfFbD.png"></p>
<p><strong>这两个地址都被合并到了192.168.0这个网段里了，以此类推，192.168.2与192.168.3也可以合并，10和11，但是需要向前移动两位，但是并不是所有的网段都可以合并，比如192.168.1与192.168.2，01和10，这样需要向前移动两位，但是这样的话1，3也将被纳入到一个网段，所以是不能合并的</strong></p>
<h3 id="超网合并的规律"><a href="#超网合并的规律" class="headerlink" title="超网合并的规律"></a>超网合并的规律</h3><p><img src="https://wx2.sbimg.cn/2020/07/20/D45ik.png" alt="D45ik.png"></p>
<p><strong>117与118就不能合并，小的是偶数才能合并</strong>。</p>
<h2 id="IP地址与MAC地址"><a href="#IP地址与MAC地址" class="headerlink" title="IP地址与MAC地址"></a>IP地址与MAC地址</h2><p><strong><em>IP地址决定了数据的终点是谁，MAC地址决定了下一设备是谁</em></strong></p>
<blockquote>
<p>arp -a可以查看本机所缓存的MAC地址</p>
</blockquote>
<p><img src="https://wx2.sbimg.cn/2020/07/20/D4mRh.png" alt="D4mRh.png"></p>
<p>通信过程中M系列为各端口的MAC地址</p>
<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><h3 id="ARP-amp-RARP"><a href="#ARP-amp-RARP" class="headerlink" title="ARP&amp;RARP"></a>ARP&amp;RARP</h3><p><img src="https://wx1.sbimg.cn/2020/07/20/D4pWM.png" alt="D4pWM.png"></p>
<h3 id="TCP-IP协议层次关系"><a href="#TCP-IP协议层次关系" class="headerlink" title="TCP/IP协议层次关系"></a>TCP/IP协议层次关系</h3><p><img src="https://wx2.sbimg.cn/2020/07/21/DMFbJ.png" alt="DMFbJ.png"></p>
<ul>
<li>IP协议：把数据包从一个网段转到另一个网段，就是用来选择路径用的。</li>
<li>ARP为IP服务，IP为ICMP/IGMP服务。</li>
</ul>
<h3 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h3><p>将IP地址通过广播(本网段，不通过路由器)，目标MAC地址是FF-FF-FF-FF-FF-FF，解析目标IP地址的MAC地址。ARP是解决同一个局域网上的主机或路由器的IP地址和MAC地址的映射关系。如果所找的主机和原主机不在同一个局域网上，那么就要通过ARP找一个位于本局域网上的某个路由器的MAC地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。从IP地址到MAC地址的解析是自动进行的，主机的用户对这种地址解析过程是不知情的。<strong>只要主机或路由器要和本网络上的另一个已知IP地址的主机或路由器进行通信，ARP协议就会自动地将该IP地址解析为链路层所需要的MAC地址</strong>。</p>
<h3 id="使用ARP的四种典型情况"><a href="#使用ARP的四种典型情况" class="headerlink" title="使用ARP的四种典型情况"></a>使用ARP的四种典型情况</h3><ul>
<li>发送方是主机，要把IP数据报发送到本网络的另一个主机，此时用ARP找到目标主机的MAC地址；</li>
<li>发送方是主机，要把IP数据报发送到另一个网络的另一个主机，此时用ARP找到本网络上一个路由器的MAC地址，剩下的工作由路由器进行；</li>
<li>发送方是路由器，要把IP数据报发送到本网络的另一个主机，此时用ARP找到目标主机的MAC地址；</li>
<li>发送方是路由器，要把IP数据报发送到另一个网络的另一个主机，此时用ARP找到本网络上一个路由器的MAC地址，剩下的工作由路由器进行；</li>
</ul>
<h3 id="逆地址解析协议RARP"><a href="#逆地址解析协议RARP" class="headerlink" title="逆地址解析协议RARP"></a>逆地址解析协议RARP</h3><blockquote>
<p>只知道自己MAC地址就能获得其IP地址。</p>
</blockquote>
<h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><h3 id="ICMP报文格式"><a href="#ICMP报文格式" class="headerlink" title="ICMP报文格式"></a>ICMP报文格式</h3><p><img src="https://wx1.sbimg.cn/2020/07/20/D4fw8.png" alt="D4fw8.png"></p>
<p><strong>ICMP报文的前4个字节是统一的格式，共有三个字段：类型、代码、检验和，接着4个字节的内容与ICMP的类型有关</strong></p>
<h3 id="ICMP报文的类型"><a href="#ICMP报文的类型" class="headerlink" title="ICMP报文的类型"></a>ICMP报文的类型</h3><p>两种类型：</p>
<ul>
<li><p>ICMP差错报告报文</p>
<blockquote>
<ul>
<li>终点不可达</li>
<li>源点抑制</li>
<li>时间超过</li>
<li>参数问题</li>
<li>改变路由（重定向）</li>
</ul>
</blockquote>
</li>
<li><p>ICMP询问报文</p>
<blockquote>
<ul>
<li>回送请求和回答报文</li>
<li>时间戳请求和回答报文</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="差错报告报文的字段和内容"><a href="#差错报告报文的字段和内容" class="headerlink" title="差错报告报文的字段和内容"></a>差错报告报文的字段和内容</h3><p><img src="https://wx2.sbimg.cn/2020/07/20/D5XjU.png" alt="D5XjU.png"></p>
<p><strong>其中B收到报文后将数据区拿出来，然后加上蓝色部分到最后的首部+ICMP差错报告报文，然后将其返回</strong></p>
<h3 id="ping-Packet-Internet-Grope-命令诊断网络故障"><a href="#ping-Packet-Internet-Grope-命令诊断网络故障" class="headerlink" title="ping(Packet Internet Grope)命令诊断网络故障"></a>ping(Packet Internet Grope)命令诊断网络故障</h3><ul>
<li><p>PING是网络层命令。</p>
</li>
<li><p>TTL是数据报的生存时间每过一个路由器就会减1，作用是防止数据报在网络中循环。TTL默认初始值如下：</p>
<blockquote>
<ul>
<li>Linux 64</li>
<li>Windows 128</li>
<li>Unix 256</li>
</ul>
</blockquote>
</li>
<li><p>可以根据TTL值粗略判定对方是什么系统。</p>
</li>
<li><p>PING,因特网包套所起，用于测试网络连接量的程序。ping发送一饿ICMP回声请求消息给目的地并报告是否收到所希望的ICMP回声应答。</p>
</li>
<li><p>ping指端对端联通，通常用作可用性检测，但是某些病毒会强行大量远程执行ping命令抢占你的网络资源，导致系统网速变慢。严禁ping入侵作为大多数防火墙的一个基本功能提供给用户进行选择。</p>
</li>
<li><p>如果打开IE浏览器访问网站失败，可以通过ping命令测试到Internet的网络连通，可以为你排除网络故障提供线索。</p>
</li>
</ul>
<h3 id="ping和pathping命令"><a href="#ping和pathping命令" class="headerlink" title="ping和pathping命令"></a>ping和pathping命令</h3><blockquote>
<p>QQ能登上，网页打不开是为什么？网络层没有问题，域名解析有问题。</p>
</blockquote>
<p>pathping 能跟踪数据包路径，发现出问题的位置。<br>pathping 还可以列出丢包率</p>
<h2 id="NAT和PAT"><a href="#NAT和PAT" class="headerlink" title="NAT和PAT"></a>NAT和PAT</h2><h3 id="NAT网络地址转换的过程"><a href="#NAT网络地址转换的过程" class="headerlink" title="NAT网络地址转换的过程"></a>NAT网络地址转换的过程</h3><ul>
<li>内部主机X用本机地址（私网地址）IPx和因特网上的主机Y通信所发送的数据报必须经过NAT路由器</li>
<li>NAT路由器将数据报的源地址IPg），但目的地址IPy保持不变，然后发送到因特网</li>
<li>NAT路由器收到主机Y发挥的数据报时，知道数据报中的源地址时IPy而目的地址是IPg</li>
<li>根据NAT转换表，NAT路由器将目的地址IPg转换为IPx转发给最终的内部主机X</li>
</ul>
<blockquote>
<p>NAT不节省公网IP，如果NAT路由器绑定了5个公网地址，那么如果局域网有10台主机那么将会有5台主机无法上网，并且只能出去不能访问进来</p>
</blockquote>
<p>利用这样的特性有另一种应用：单向访问</p>
<p><img src="https://wx1.sbimg.cn/2020/07/21/D5tgw.png" alt="D5tgw.png"></p>
<blockquote>
<p>在图中左边区域为私密主机不能让右边区域访问但得让外部的那个机器访问，但左边区域要访问右边区域，这样就可以利用外部这个机器充当NAT，让左边区域当内网（私网）访问右边机器时统一使用外部机器转换的那个公网地址，这样一来，右边的机器只知道访问它们的是一个公网地址，而不知道左边机器的具体地址</p>
</blockquote>
<h3 id="PAT端口地址转换"><a href="#PAT端口地址转换" class="headerlink" title="PAT端口地址转换"></a>PAT端口地址转换</h3><p><strong>PAT(port address translation,端口地址转换)是NAT（network address translation，网络地址转换）最常用的一种实现方式。NAT通过将企业内部的私有IP地址转换为全球唯一的公网IP地址，使内部网络可以连接外网（internet），而PAT可以在上述转换过程中，实现企业内网的多个私有IP对一个或是多个IP复用，从而实现IP地址的节约.</strong></p>
<h2 id="IGMP组播协议"><a href="#IGMP组播协议" class="headerlink" title="IGMP组播协议"></a>IGMP组播协议</h2><p>组播可以想象成是一个频道，主机就是电视台，IGMP就是管理组播成员的。当电视台向其他路由器传输组播数据包时，路由器会利用IGMP协议查看是否有用户连接，如果没有就会返回不再接受组播数包了</p>
<p>参考：<br>韩立刚老师《计算机网络》课程<br><a href="https://blog.csdn.net/iwanderu/article/details/103812967" target="_blank" rel="noopener">https://blog.csdn.net/iwanderu/article/details/103812967</a></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机网络】网络安全</title>
    <url>/2020/07/24/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p><strong>计算机网络不看后悔系列blog(七）网络安全/超详细！！ʅ(‾◡◝)ʃ</strong></p>
<a id="more"></a>
<h2 id="网络安全简介"><a href="#网络安全简介" class="headerlink" title="网络安全简介"></a>网络安全简介</h2><p>所谓网络安全主要是针对以下几个方面：</p>
<ul>
<li>数据（文件文件夹）存储安全</li>
<li>应用程序安全</li>
<li>操作系统安全</li>
<li>网络安全</li>
<li>物理安全</li>
<li>用户安全教育</li>
</ul>
<h2 id="威胁通信"><a href="#威胁通信" class="headerlink" title="威胁通信"></a>威胁通信</h2><h3 id="截获"><a href="#截获" class="headerlink" title="截获"></a>截获</h3><blockquote>
<p>从网络上窃听两台主机之间的通信内容（被动攻击如cain）</p>
</blockquote>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><blockquote>
<p>故意中断他人在网络上的通信（主动攻击）</p>
</blockquote>
<h3 id="篡改"><a href="#篡改" class="headerlink" title="篡改"></a>篡改</h3><blockquote>
<p>故意篡改网络上通信所使用的报文（主动攻击如cain软件）</p>
</blockquote>
<h3 id="伪造"><a href="#伪造" class="headerlink" title="伪造"></a>伪造</h3><blockquote>
<p>伪造信息在网络上传送（主动攻击）</p>
</blockquote>
<p><strong>例如(cain软件的ARP欺骗）</strong></p>
<blockquote>
<p>cain软件能够截获和篡改本网段的的报文。它是在主机通过ARP协议寻找网关地址(想上网)的时候，用ARP欺骗，把本电脑的地址当成要上网的路由器MAC地址发给那个主机，此时，网段内的所有的计算机想上网发送的报文都会先发给cain，这样主机访问外网的时候，都是通过cain访问的(主机访问cain提供的假域名，cain去访问真的域名，再把信息转给主机，这是一种<strong>DNS劫持</strong>)，既能篡改DNS解析结果，还能获取密码。同样的道理，局域网管理员可以在网关设置监视端口，获得本网段的所有信息。</p>
</blockquote>
<p><img src="https://wx1.sbimg.cn/2020/07/24/DN0rn.png" alt="DN0rn.png"></p>
<h3 id="主动攻击与被动攻击"><a href="#主动攻击与被动攻击" class="headerlink" title="主动攻击与被动攻击"></a>主动攻击与被动攻击</h3><p><img src="https://wx2.sbimg.cn/2020/07/24/DNCDh.png" alt="DNCDh.png"></p>
<ul>
<li>中断——拒绝服务式攻击<blockquote>
<p>如DoS拒绝服务式攻击，通过在网络上拥挤一些没用的数据包来组断网络。一般会占用下载通道ADSL而不是上传通道UDP，因为下载的带宽要大得多。<br>DDoS分布式攻击，可以在网络上找很多有漏洞的网站(肉鸡)，给指定的服务器发流量来使网络拥挤吃掉带宽，对于这种方式没有什么好办法。</p>
</blockquote>
</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/24/DNDuM.png" alt="DNDuM.png"></p>
<ul>
<li><p>篡改——修改域名解析的结果</p>
<blockquote>
<p>类似于钓鱼网站，当用户想进入银行的Web页面，解析错误导致用户访问了错误的网站（这个网站可能和要访问的网站的页面相同），当用户输入账号密码的话就会导致信息泄漏。</p>
</blockquote>
</li>
<li><p>伪造——伪装成其它主机的IP地址</p>
<blockquote>
<p>趁其它主机关机时，把IP地址伪装成该主机的IP地址，访问一些特定的服务器，从而获取信息。</p>
</blockquote>
</li>
</ul>
<h2 id="恶意程序-rogue-program"><a href="#恶意程序-rogue-program" class="headerlink" title="恶意程序(rogue program)"></a>恶意程序(rogue program)</h2><ul>
<li>计算机病毒——会“传染”其它程序，“传染”是通过修改其它程序来把自身或其变种复制进去完成的。(熊猫烧香)</li>
<li>计算机蠕虫——通过网络的通信功能将自身从一个结点发送到另一个结点并启动运行的程序。(消耗CPU资源)</li>
<li>特洛伊木马——一种程序，它执行的功能超过所声称的功能。(和(1)(2)的区别是会和外界通信)</li>
<li>逻辑炸弹——一种当运行环境满足某种特定条件时执行其它特殊功能的程序。</li>
</ul>
<h3 id="木马程序的识别"><a href="#木马程序的识别" class="headerlink" title="木马程序的识别"></a>木马程序的识别</h3><ul>
<li>查看会话netstat -n看看是否有可疑的会话；</li>
<li>运行msconfig服务，把隐藏微软服务掉，看看剩下的有哪些刻意；</li>
<li>杀毒软件。</li>
</ul>
<h2 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a>加密技术</h2><p>广泛应用于应用层加密。</p>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><blockquote>
<p>加密密钥和解密密钥是同一个。</p>
<ul>
<li>缺点：密钥不适合在网上传；密钥是一对一的，如果很多主机相互通信，有很多密钥需要维护；</li>
<li>优点：效率高（因为一般不会增大文件的大小，并且加密解密都用同一个密钥）。加密包括加密算法和加密密钥。</li>
</ul>
</blockquote>
<h3 id="数据加密标准DES"><a href="#数据加密标准DES" class="headerlink" title="数据加密标准DES"></a>数据加密标准DES</h3><ul>
<li><p>它属于常规密钥密码体制，是一种分组密码。在加密前，先对整个铭文进行分组，每一个组长为64位，然后对每一个64位二进制数据进行加密处理，产生一组64位密文数据。最后将各组密文串接起来，即得出整个密文。使用的密钥是64位(实际密钥长度位56位，有8位数用来奇偶校验)。</p>
</li>
<li><p>DES的保密性：仅取决于对密钥的保密，而算法本身是公开的。尽管人在破译DES上有很多进展，但是至今没有找到比穷举搜索密钥更有效的方法。</p>
</li>
<li><p>DES是世界上第一个公认的使用密码算法标准，它曾对密码学的发展做出了重大贡献。</p>
</li>
<li><p>目前较为严重的问题是DES的密钥的长度。</p>
</li>
<li><p>现在已经设计出来搜索DES密钥的专用芯片。</p>
</li>
<li><p>DES算法公开，所以破解取决于密钥长度，56位密码破解需要3.5-21min；128位密钥破解需要5.4*10^18年。</p>
</li>
</ul>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><ul>
<li>加密密钥和解密密钥是不同的，有一对密钥对，公钥和私钥。要么公钥加密私钥解密；要么私钥加密公钥解密。</li>
<li>优点：安全性高，给出私钥和公钥其中一个无法算出另一个。</li>
<li>缺点：效率低。</li>
<li>非对称加密实现细节：<blockquote>
<p>设A是非对称加密机制；B为对称加密机制；A1要给A2传一组数据，很大，如果直接用非对称加密花的时间很长；为了加快速度，用对称加密手段B来加密这个数据得到加密后数据B’和密钥B给A1，速度很快；然后A1对密钥B进行非对称加密得到公钥A1’；A1把密钥A1’和数据B’发给A2；A2运用私钥解密A1’获得密钥B，再用密钥B解密这个数据，最终得到想要的结果。<br>通过这种对数据采用对称加密，对对称加密的密钥进行非对称加密的方式能实现快速加密。</p>
</blockquote>
</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/24/DNzPA.png" alt="DNzPA.png"></p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>能够检查签名后的内容有没有被更改过，防止非法更改内容，并且能够证明是签名单位签发的。</p>
<p><img src="https://wx1.sbimg.cn/2020/07/24/DNH87.png" alt="DNH87.png"></p>
<blockquote>
<p>签名用私钥，加密用公钥</p>
</blockquote>
<h3 id="CA（证书颁发机构）"><a href="#CA（证书颁发机构）" class="headerlink" title="CA（证书颁发机构）"></a>CA（证书颁发机构）</h3><ul>
<li>用来来验证公钥是否是证书颁发机构认证过。</li>
<li>为企业和用户办法数字证书，确认这些企业和个人的身份；</li>
<li>如果证书丢失，它要发布证书吊销列表；</li>
<li>企业和个人是信任证书颁发机构的。</li>
</ul>
<h2 id="Internet上使用的安全协议"><a href="#Internet上使用的安全协议" class="headerlink" title="Internet上使用的安全协议"></a>Internet上使用的安全协议</h2><h3 id="安全套接字SSL-Secure-Sockets-Layer"><a href="#安全套接字SSL-Secure-Sockets-Layer" class="headerlink" title="安全套接字SSL(Secure Sockets Layer)"></a>安全套接字SSL(Secure Sockets Layer)</h3><ul>
<li>SSL的位置：是在<strong>应用层和传输层之间</strong>进行加密。好处是应用层和传输层都不需要来加密。</li>
<li><strong>不需要应用程序(应用层)来支持</strong>，但是需要在服务器配置证书。</li>
<li>例如，不使用SSL加密使用的是http://，使用SSL加密是https://。</li>
<li>注意，http://使用的是TCP的80端口，而https://使用的是TCP的443端口。</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/24/DNWp6.png" alt="DNWp6.png"></p>
<h3 id="SSL的配置-加密的实现-https"><a href="#SSL的配置-加密的实现-https" class="headerlink" title="SSL的配置(加密的实现)(https://)"></a>SSL的配置(加密的实现)(https://)</h3><ul>
<li>客户端有一个浏览器IE，想要访问服务器端的网站web；</li>
<li>浏览器IE要访问网站web，此时网站web会把他的公钥给浏览器IE；</li>
<li>浏览器IE通过校验CA证书确保网站web的公钥是可靠的；</li>
<li>浏览器IE会产生一个对称密钥；</li>
<li>浏览器IE拿着网站web的公钥对它的对称密钥进行加密，发给网站web；</li>
<li>网站web用它的私钥进行解密，就得到了浏览器IE的对称密钥；</li>
<li>本质上是用对称密钥对数据进行加密的，公钥和私钥是用来对这个对称密钥进行加密的。这也是为什么https://刚开始打开的时候会有一些慢。</li>
</ul>
<p><strong>另外一些服务协议使用的安全套接字SSL时对应的TCP端口</strong>：</p>
<blockquote>
<ul>
<li>imaps tcp-993</li>
<li>pop3s tcp-995</li>
<li>smtps tcp-465</li>
<li>https tcp-443</li>
</ul>
</blockquote>
<h3 id="SSL提供的三个功能"><a href="#SSL提供的三个功能" class="headerlink" title="SSL提供的三个功能"></a>SSL提供的三个功能</h3><ul>
<li>SSL服务器鉴别：允许用户证实服务器的身份；具有SSL功能的浏览器维持一个表，上面有一些可信赖的认证中心CA(Certificate Authority)和它们的公钥。</li>
<li>加密的SSL会话：客户和服务器交互的所有数据都在发送方加密，在接收方解密。</li>
<li>SSL客户鉴别：允许服务器证实客户的身份。</li>
</ul>
<h2 id="网络层安全IPSec"><a href="#网络层安全IPSec" class="headerlink" title="网络层安全IPSec"></a>网络层安全IPSec</h2><p>网络层安全是<strong>底层安全</strong>，<strong>不需要应用程序支持，也不需要配置证书，对用户是透明的(感觉不到)</strong>。</p>
<ul>
<li><p>安全关联SA(Security Association):<br>在使用AH或ESP之前，先要从源主机到目的主机建立一条网络层的逻辑连接。此逻辑连接叫做安全关联SA。<br>IPsec就把传统的Internet无连接的网络层转换为具有逻辑连接的层。</p>
</li>
<li><p>SA是构成IPSec的基础，是两个通信实体经过协商(利用IKE协议)建立起来的一种协定，它决定了用来保护数据分组安全的安全协议<strong>AH协议(只签名：只关心发送方的身份而不关心数据是否被窃取</strong>)或<strong>ESP协议(既签名又对数据加密</strong>))，转码方式，密钥及密钥的生存周期等。</p>
</li>
</ul>
<h3 id="IPsec中最主要的2个协议-AH与ESP"><a href="#IPsec中最主要的2个协议-AH与ESP" class="headerlink" title="IPsec中最主要的2个协议(AH与ESP)"></a>IPsec中最主要的2个协议(AH与ESP)</h3><h4 id="鉴别首部AH-Authentication-Header-AH鉴别源点和检查数据完整性，但不能保密。"><a href="#鉴别首部AH-Authentication-Header-AH鉴别源点和检查数据完整性，但不能保密。" class="headerlink" title="鉴别首部AH(Authentication Header):AH鉴别源点和检查数据完整性，但不能保密。"></a>鉴别首部AH(Authentication Header):AH鉴别源点和检查数据完整性，但<strong>不能保密</strong>。</h4><ul>
<li>在使用AH时，把AH首部插在原数据报数据部分的签名，同时把IP首部中的协议字段设置为51.</li>
<li>在传输过程中，中间的路由器都不查看AH首部。当数据报到达终点时，目的主机才会处理AH字段，以鉴别源点和检查数据报的完整性。</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/24/DNZae.png" alt="DNZae.png"></p>
<h4 id="封装安全有效载荷ESP-Encapsulation-Security-Payload"><a href="#封装安全有效载荷ESP-Encapsulation-Security-Payload" class="headerlink" title="封装安全有效载荷ESP(Encapsulation Security Payload)"></a>封装安全有效载荷ESP(Encapsulation Security Payload)</h4><ul>
<li>ESP比AH复杂的多，它鉴别源点，检查数据完整性和提供保密。</li>
<li>使用ESP时，IP数据报首部的协议字段设置为50.当IP首部检查到协议字段是50时，就知道在IP首部后面紧跟着ESP首部，同时在原IP数据报后面增加了2个字段，即ESP尾部和ESP数据。</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/24/DNafD.png" alt="DNafD.png"></p>
<h2 id="防火墙-firewall"><a href="#防火墙-firewall" class="headerlink" title="防火墙(firewall)"></a>防火墙(firewall)</h2><ul>
<li>防火墙用来解决内联网和外联网的安全问题。</li>
<li>防火墙是由软件，硬件构成的系统，是一种特殊编程的路由器，用来在两个网络之间实施接入控制策略。接入控制策略是由防火墙的单位自行制定的，为的是可以最适合本单位的需要。</li>
<li>防火墙内的网络称为“可信赖的网络”(trusted network)，而将外部的Internet称为“不可信赖的网络”(untrusted network)。</li>
</ul>
<h3 id="防火墙在互联网中的位置"><a href="#防火墙在互联网中的位置" class="headerlink" title="防火墙在互联网中的位置"></a>防火墙在互联网中的位置</h3><p><img src="https://wx2.sbimg.cn/2020/07/24/DNUQN.png" alt="DNUQN.png"></p>
<h3 id="防火墙的功能"><a href="#防火墙的功能" class="headerlink" title="防火墙的功能"></a>防火墙的功能</h3><ul>
<li>阻止：阻止某种类型的通信量通过防火墙(从外部网络到内部网络，或反过来)。</li>
<li>允许：允许某种类型的通信量通过防火墙(从外部网络到内部网络，或反过来)。</li>
</ul>
<p>防火墙必须能够识别通信量的各种类型。一般是阻止功能。</p>
<h3 id="防火墙技术的分类"><a href="#防火墙技术的分类" class="headerlink" title="防火墙技术的分类"></a>防火墙技术的分类</h3><ul>
<li>网络层防火墙：用来防止整个网络出现外来非法的入侵。属于这类的有分组过滤和授权服务器。前者检查所有流入本网络的信息，然后拒绝不符合事先制订好的一套准则的数据，而后者则是检查用户的登录是否合法。可以基于数据包，源地址，目标地址，协议和端口来控制流量。</li>
<li>应用层防火墙：从应用程序来进行接入控制，通常使用应用网关或代理服务器来区分各种应用。例如，可以只允许用过访问www的应用，而阻止FTP应用的通过。<br>应用级防火墙可以检查数据报的内容。可以基于数据包，源地址，目标地址，协议和端口，用户名，时间段来控制内容，可以放病毒，可见功能更强大。</li>
</ul>
<h3 id="防火墙的结构"><a href="#防火墙的结构" class="headerlink" title="防火墙的结构"></a>防火墙的结构</h3><h4 id="边缘防火墙"><a href="#边缘防火墙" class="headerlink" title="边缘防火墙"></a>边缘防火墙</h4><p><img src="https://wx1.sbimg.cn/2020/07/24/DN8Pn.png" alt="DN8Pn.png"></p>
<h4 id="三向外围墙"><a href="#三向外围墙" class="headerlink" title="三向外围墙"></a>三向外围墙</h4><p><img src="https://wx2.sbimg.cn/2020/07/24/DNE1h.png" alt="DNE1h.png"></p>
<blockquote>
<p>DMZ是公司内部的服务器。内网可以访问外网，外网不能访问内网，只能访问服务器DMZ。</p>
</blockquote>
<h4 id="背靠背防火墙"><a href="#背靠背防火墙" class="headerlink" title="背靠背防火墙"></a>背靠背防火墙</h4><p><img src="https://wx1.sbimg.cn/2020/07/24/DNNEM.png" alt="DNNEM.png"></p>
<h4 id="单一网卡防火墙"><a href="#单一网卡防火墙" class="headerlink" title="单一网卡防火墙"></a>单一网卡防火墙</h4><p><img src="https://wx1.sbimg.cn/2020/07/24/DNrhR.png" alt="DNrhR.png"></p>
<p>参考：<br>韩立刚老师《计算机网络》课程<br><a href="https://blog.csdn.net/iwanderu/article/details/103812986" target="_blank" rel="noopener">https://blog.csdn.net/iwanderu/article/details/103812986</a></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】(二叉树的Java与C++实现)</title>
    <url>/2020/06/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84Java%E4%B8%8EC++%E5%AE%9E%E7%8E%B0)/</url>
    <content><![CDATA[<p><strong>二叉树作为重要的数据结构类型,本篇二叉树内部方法的实现多采用了递归,实现了诸如(四种遍历\结点删除\结点查找\叶子数量\高度\判断是否完全二叉树\某层结点数)等方法,是值得一读的二叉树的实现 ʅ(‾◡◝)ʃ</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>树结构的知识点比较复杂，在本篇中学习了很多Java用递归方式编写的函数体，值得一读。惰性删除是指当一个元素要被删除时，它仍被保留在树中，只是标记为删除了，这在有重复项的时候很常用，因为此时记录出现频率数的域可以减1，如果树中的实际节点数与“被删除”的节点数相同，那么树的深度预计只上升一个小的常数，因此存在一个与惰性删除相关的非常小的时间损耗，并且，如果被删除的项是重新插入的，那么久避免了分配一个新单元的开销了<br><img src="https://i.loli.net/2020/06/19/jkItJpTGE4qhO2u.jpg" alt="IMG_6581.jpg">   </p>
</blockquote>
<h2 id="二叉树的Java实现"><a href="#二叉树的Java实现" class="headerlink" title="二叉树的Java实现"></a>二叉树的Java实现</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package BinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> BiTree&#123;</span><br><span class="line"></span><br><span class="line">	private <span class="type">int</span> count;</span><br><span class="line">	private Node root;</span><br><span class="line">	<span class="built_in">public</span> <span class="type">int</span> <span class="keyword">index</span>;</span><br><span class="line">	<span class="keyword">class</span> Node &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">public</span> Node lchild;</span><br><span class="line">		<span class="built_in">public</span> Node rchild;</span><br><span class="line">		<span class="built_in">public</span> <span class="type">int</span> data;</span><br><span class="line">		<span class="built_in">public</span> Node(<span class="type">int</span> data) &#123;</span><br><span class="line">			this.data = data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> Node getLchild() &#123;</span><br><span class="line">			<span class="keyword">return</span> lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> <span class="type">void</span> setLchild(Node lchild) &#123;</span><br><span class="line">			this.lchild = lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> Node getRchild() &#123;</span><br><span class="line">			<span class="keyword">return</span> rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> <span class="type">void</span> setRchild(Node rchild) &#123;</span><br><span class="line">			this.rchild = rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> <span class="type">int</span> getData() &#123;</span><br><span class="line">			<span class="keyword">return</span> data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">public</span> <span class="type">void</span> setData(<span class="type">int</span> data) &#123;</span><br><span class="line">			this.data = data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//二叉树的建立</span><br><span class="line">	<span class="built_in">public</span> Node CreateBTree(<span class="type">int</span>[] a)&#123;</span><br><span class="line">		Node root = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[<span class="keyword">index</span>]!=<span class="string">'#'</span>)&#123;</span><br><span class="line">			root = <span class="built_in">new</span> Node(a[<span class="keyword">index</span>]);</span><br><span class="line">			<span class="keyword">index</span>++;</span><br><span class="line">			root.setLchild(CreateBTree(a));</span><br><span class="line">			<span class="keyword">index</span>++;</span><br><span class="line">			root.setRchild(CreateBTree(a));		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	//二叉树节点的删除</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> <span class="keyword">delete</span>(<span class="type">int</span> data) &#123;</span><br><span class="line">		Node <span class="keyword">current</span> = root;</span><br><span class="line">		Node parent = root;</span><br><span class="line">		<span class="type">boolean</span> isleftchild = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>.data!=data) &#123;</span><br><span class="line">			parent = <span class="keyword">current</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">current</span>.data&gt;data) &#123;</span><br><span class="line">				isleftchild = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">current</span> = <span class="keyword">current</span>.lchild;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				isleftchild = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">current</span> = <span class="keyword">current</span>.rchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">current</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//被删除的节点没有子节点</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">current</span>.lchild==<span class="keyword">null</span> &amp;&amp;<span class="keyword">current</span>.rchild==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">current</span>==root) &#123;</span><br><span class="line">				root = <span class="keyword">null</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(isleftchild) &#123;</span><br><span class="line">				parent.lchild = <span class="keyword">null</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				parent.rchild = <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		//被删除的节点有一个子节点</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">current</span>.lchild==<span class="keyword">null</span>&amp;&amp;<span class="keyword">current</span>.rchild!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(root == <span class="keyword">current</span>) &#123;</span><br><span class="line">				root = <span class="keyword">current</span>.rchild;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(isleftchild) &#123;</span><br><span class="line">				parent.lchild = <span class="keyword">current</span>.rchild;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				parent.rchild = <span class="keyword">current</span>.rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">current</span>.lchild!=<span class="keyword">null</span>&amp;&amp;<span class="keyword">current</span>.rchild==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(root == <span class="keyword">current</span>) &#123;</span><br><span class="line">				root = <span class="keyword">current</span>.lchild;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(isleftchild) &#123;</span><br><span class="line">				parent.lchild = <span class="keyword">current</span>.lchild;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				parent.rchild = <span class="keyword">current</span>.lchild;</span><br><span class="line">		    &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">		//被删除的节点有两个子节点</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">current</span>.lchild != <span class="keyword">null</span> &amp;&amp; <span class="keyword">current</span>.rchild != <span class="keyword">null</span>)&#123;</span><br><span class="line">            //获取删除节点的后继结点</span><br><span class="line">            Node successor = getSuccessor(<span class="keyword">current</span>);</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">current</span>) &#123;</span><br><span class="line">                root = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isleftchild) &#123;</span><br><span class="line">                parent.lchild = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.rchild = successor;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">public</span> Node getSuccessor(Node delNode) &#123;</span><br><span class="line">        Node successorParent = delNode;</span><br><span class="line">        Node successor = delNode;</span><br><span class="line">        Node <span class="keyword">current</span> = delNode.rchild;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">current</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">            successorParent = successor;</span><br><span class="line">            successor = <span class="keyword">current</span>;</span><br><span class="line">            <span class="keyword">current</span> = <span class="keyword">current</span>.lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (successor != delNode.rchild) &#123;</span><br><span class="line">            successorParent.lchild = successor.rchild;</span><br><span class="line">            successor.rchild = delNode.rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">    //先序遍历</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> prevOrder(Node root) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">System</span>.<span class="keyword">out</span>.print(root.getData()+" ");</span><br><span class="line">    	prevOrder(root.getLchild());</span><br><span class="line">    	prevOrder(root.getRchild());</span><br><span class="line">    &#125;</span><br><span class="line">    //中序遍历</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> inOrder(Node root) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	inOrder(root.getLchild());</span><br><span class="line">    	<span class="keyword">System</span>.<span class="keyword">out</span>.print(root.getData()+" ");</span><br><span class="line">    	inOrder(root.getRchild());</span><br><span class="line">    &#125;</span><br><span class="line">    //后序遍历</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> postOrder(Node root) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	postOrder(root.getLchild());</span><br><span class="line">    	postOrder(root.getRchild());</span><br><span class="line">    	<span class="keyword">System</span>.<span class="keyword">out</span>.print(root.getData()+" ");</span><br><span class="line">    &#125;</span><br><span class="line">    //层序遍历</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> BTreeLevelOrder()&#123;</span><br><span class="line">    	Node root = this.root;</span><br><span class="line">    	Queue &lt;Node&gt; queue = <span class="built_in">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    	LinkedList&lt;Node&gt; list = <span class="built_in">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    	queue.offer(root);</span><br><span class="line">    	<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">    		Node pre = queue.poll();</span><br><span class="line">    		list.<span class="keyword">add</span>(pre);</span><br><span class="line">    		<span class="keyword">if</span>(pre.getLchild()!=<span class="keyword">null</span>)</span><br><span class="line">    			queue.offer(pre.getLchild());</span><br><span class="line">    		<span class="keyword">if</span>(pre.getRchild()!=<span class="keyword">null</span>)</span><br><span class="line">    			queue.offer(pre.getRchild());</span><br><span class="line">    	&#125;</span><br><span class="line">    	Iterator&lt;Node&gt; it = list.iterator();</span><br><span class="line">    	<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    		Node cur = (Node)it.next();</span><br><span class="line">    		<span class="keyword">System</span>.<span class="keyword">out</span>.print(cur.getData()+" ");</span><br><span class="line">    	&#125;	</span><br><span class="line">    &#125;</span><br><span class="line">    //获得二叉树的高度</span><br><span class="line">  	<span class="built_in">public</span> <span class="type">int</span> getHeight(Node root)&#123;</span><br><span class="line">  		//递归获取</span><br><span class="line">  		<span class="type">int</span> leftHeight = <span class="number">0</span>;</span><br><span class="line">  		<span class="type">int</span> rightHeight = <span class="number">0</span>;</span><br><span class="line">  		<span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">  			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  			leftHeight = getHeight(root.getLchild());</span><br><span class="line">  			rightHeight = getHeight(root.getRchild());</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">return</span> leftHeight &gt;= rightHeight ? ++leftHeight:++rightHeight; //最终高度应是左右子树高度中最大的一个</span><br><span class="line">  	&#125;</span><br><span class="line">  	//获得二叉树的叶子结点</span><br><span class="line">  	<span class="built_in">public</span> <span class="type">int</span> getLeaf(Node root) &#123;</span><br><span class="line">  		<span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.getLchild()==<span class="keyword">null</span>&amp;&amp;root.getRchild()==<span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">System</span>.<span class="keyword">out</span>.println("叶子结点："+root.getData());</span><br><span class="line">  			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">return</span> getLeaf(root.getLchild())+getLeaf(root.getRchild());</span><br><span class="line">  	&#125;</span><br><span class="line">  	//获得二叉树某一层的节点</span><br><span class="line">  	<span class="built_in">public</span> <span class="type">int</span> getNum(Node root, <span class="type">int</span> deep) &#123;</span><br><span class="line">  		<span class="keyword">if</span>(deep == <span class="number">1</span>) &#123;</span><br><span class="line">  			<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">  				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  				<span class="keyword">System</span>.<span class="keyword">out</span>.println("结点："+root.getData());</span><br><span class="line">  				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">return</span> getNum(root.getLchild(), deep<span class="number">-1</span>)+getNum(root.getRchild(), deep<span class="number">-1</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">  	//查找某一值结点</span><br><span class="line">  	<span class="built_in">public</span> Node <span class="keyword">search</span>(Node root, <span class="type">int</span> key) &#123;</span><br><span class="line">  		<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.getData()==key) &#123;</span><br><span class="line">  			<span class="keyword">return</span> root;</span><br><span class="line">  		&#125;</span><br><span class="line">  		Node left = <span class="keyword">search</span>(root.getLchild(), key);</span><br><span class="line">  		<span class="keyword">if</span>(left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">return</span> left;</span><br><span class="line">  		&#125;</span><br><span class="line">  		Node right = <span class="keyword">search</span>(root.getRchild(), key);</span><br><span class="line">  		<span class="keyword">if</span>(right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">return</span> right;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">    //判断某一结点是否存在</span><br><span class="line">  	<span class="built_in">public</span> <span class="type">boolean</span> <span class="keyword">isNull</span>(Node root) &#123;</span><br><span class="line">  		<span class="keyword">return</span> root!=<span class="keyword">null</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">    //判断一棵树是否是完全二叉树</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> isCompleteBTree()&#123;</span><br><span class="line">		Node root = this.root;</span><br><span class="line">		Queue &lt;Node&gt; queue = <span class="built_in">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">		queue.offer(root);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">			Node pre = queue.poll();</span><br><span class="line">			<span class="keyword">if</span>(pre==<span class="keyword">null</span>)</span><br><span class="line">				break;</span><br><span class="line">			queue.offer(pre.getLchild());</span><br><span class="line">			queue.offer(pre.getRchild());</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">			Node cur = queue.poll();</span><br><span class="line">			<span class="keyword">if</span>(cur!=<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">		BiTree tree = <span class="built_in">new</span> BiTree();</span><br><span class="line">		<span class="type">int</span>[] a = <span class="built_in">new</span> <span class="type">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="string">'#'</span>,<span class="number">3</span>,<span class="string">'#'</span>,<span class="number">4</span>,<span class="string">'#'</span>,<span class="string">'#'</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">'#'</span>,<span class="string">'#'</span>,<span class="string">'#'</span> &#125;;</span><br><span class="line">		tree.root = tree.CreateBTree(a);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("先序遍历：");</span><br><span class="line">		tree.prevOrder(tree.root);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("中序遍历：");</span><br><span class="line">		tree.inOrder(tree.root);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("后序遍历：");</span><br><span class="line">		tree.postOrder(tree.root);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("层序遍历：");</span><br><span class="line">		tree.BTreeLevelOrder();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("此二叉树的高度为："+tree.getHeight(tree.root));</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("此二叉树的叶子结点数："+tree.getLeaf(tree.root));</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("第二层的结点树为："+tree.getNum(tree.root, <span class="number">2</span>));</span><br><span class="line">		Node <span class="keyword">order</span> =tree.<span class="keyword">search</span>(tree.root, <span class="number">6</span>);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("查找值为6的结点是否存在："+tree.<span class="keyword">isNull</span>(<span class="keyword">order</span>));</span><br><span class="line">		Node order1 = tree.<span class="keyword">search</span>(tree.root, <span class="number">7</span>);</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("查找值为7的结点是否存在："+tree.<span class="keyword">isNull</span>(order1));</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println("这是一棵完全二叉树吗："+tree.isCompleteBTree());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的C-实现"><a href="#二叉树的C-实现" class="headerlink" title="二叉树的C++实现"></a>二叉树的C++实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> elemtype;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//二叉树的存储结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    elemtype data;</span><br><span class="line">    bitree *lchild,*rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//建立二叉树</span></span><br><span class="line"><span class="function">bitree* <span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitree *root,*s,*q[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> front=<span class="number">1</span>,rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入结点值，（‘ # ’结束）"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">while</span>(ch!=<span class="string">'#'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch!=<span class="string">','</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s=<span class="keyword">new</span> bitree;</span><br><span class="line">            s-&gt;data=ch;</span><br><span class="line">            s-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">            s-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;</span><br><span class="line">        q[rear]=s; <span class="comment">// 进队</span></span><br><span class="line">        <span class="keyword">if</span>(rear==<span class="number">1</span>)</span><br><span class="line">        root=s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>((s!=<span class="literal">NULL</span>)&amp;&amp;(q[front]!=<span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(rear%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            q[front]-&gt;lchild=s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q[front]-&gt;rchild=s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rear%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            front++; <span class="comment">// 出队</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(bitree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitree *p;</span><br><span class="line">    p=root;</span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        preorder(p-&gt;lchild);</span><br><span class="line">        preorder(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(bitree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitree *p;</span><br><span class="line">    p=root;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inorder(p-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        inorder(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(bitree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitree *p;</span><br><span class="line">    p=root;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postorder(p-&gt;lchild);</span><br><span class="line">        postorder(p-&gt;rchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求二叉树中叶子结点的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(bitree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!T-&gt;lchild&amp;&amp;!T-&gt;rchild)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">(bitree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> L,R;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		L=Height(root-&gt;lchild);</span><br><span class="line">		R=Height(root-&gt;rchild);</span><br><span class="line">		<span class="keyword">return</span> (L&gt;R)?L+<span class="number">1</span>:R+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitree *root;</span><br><span class="line">    <span class="keyword">int</span> leaf;</span><br><span class="line">    root=create();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"各种遍历方式对应的遍历结果："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"先序遍历的结果："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    preorder(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"中序遍历的结果："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"后序遍历的结果："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    postorder(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"树的叶子结点个数为："</span>&lt;&lt;LeafCount(root)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"树的高度为："</span>&lt;&lt;Height(root)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机网络】计算机网络概述</title>
    <url>/2020/07/18/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p><strong>计算机网络不看后悔系列blog(一）计算机网络概述/超详细！！( ◉ืൠ◉ื)</strong></p>
<a id="more"></a>
<h2 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h2><h3 id="网络（Network）"><a href="#网络（Network）" class="headerlink" title="网络（Network）"></a>网络（Network）</h3><p>由多个主机通过链路连接结点（交换机）就组成了网络</p>
<h3 id="互联网（internet）"><a href="#互联网（internet）" class="headerlink" title="互联网（internet）"></a>互联网（internet）</h3><p>网络的网络，由多个网络连接路由器组成互联网，也就是将多个网络连接在一起组成互联网（注意这里的i为小写）</p>
<h3 id="因特网（Internet）"><a href="#因特网（Internet）" class="headerlink" title="因特网（Internet）"></a>因特网（Internet）</h3><p>全球最大的一个互联网（注意这里的I为大写）<br><img src="https://wx2.sbimg.cn/2020/07/18/CEuSA.png" alt="CEuSA.png"></p>
<p><img src="https://wx1.sbimg.cn/2020/07/18/CEqPV.png" alt="CEqPV.png"></p>
<h2 id="多层次ISP结构的互联网"><a href="#多层次ISP结构的互联网" class="headerlink" title="多层次ISP结构的互联网"></a>多层次ISP结构的互联网</h2><p><img src="https://wx2.sbimg.cn/2020/07/18/CEHvD.png" alt="CEHvD.png"></p>
<blockquote>
<p>在这个互联网结构图中，若第二层ISP为河南电信ISP那么连接它的本地ISP可能就是郑州ISP和濮阳ISP等等。</p>
</blockquote>
<blockquote>
<p>从这张图中可以看出两台主机通信需要走的最多的路径，所以说如果要创建一个网站只面向全国用户，那么将网站使用第二层ISP访问速度比较快，因为国内用户不需要再向第一层ISP访问，如果要创建一个网站面向全球用户那么就需要使用第一层的ISP了，因为这样相对于全球用户来说速度是比较快的了。</p>
</blockquote>
<h2 id="中国互联网"><a href="#中国互联网" class="headerlink" title="中国互联网"></a>中国互联网</h2><p><a href="https://sbimg.cn/image/CEYAj" target="_blank" rel="noopener"><img src="https://wx2.sbimg.cn/2020/07/18/CEYAj.png" alt="CEYAj.png"></a></p>
<blockquote>
<p>从图中可以看出每个运营商指向图外的数据为出口带宽，其他的运营商之间连线的数据为到其他运营商的带宽，有的运营商之间的带宽很低，所以有的网站会在多个运营商中配置，这样的话网民访问的时候可以选择本地的运营商访问，比如下载东西的时候就选择本地运营商下载比较快</p>
</blockquote>
<h2 id="因特网的组成及其通信方式"><a href="#因特网的组成及其通信方式" class="headerlink" title="因特网的组成及其通信方式"></a>因特网的组成及其通信方式</h2><p><img src="https://wx2.sbimg.cn/2020/07/18/CEaSn.png" alt="CEaSn.png"><br><img src="https://wx1.sbimg.cn/2020/07/18/CEUoh.png" alt="CEUoh.png"></p>
<blockquote>
<p>在图中可以看出，互联网的边缘部分指的就是一个个的主机，而核心部分就是由路由器和网络组成的可以让主机之间通信的网络</p>
</blockquote>
<h3 id="因特网的边缘主机之间的通信方式"><a href="#因特网的边缘主机之间的通信方式" class="headerlink" title="因特网的边缘主机之间的通信方式"></a>因特网的边缘主机之间的通信方式</h3><h4 id="客户服务器方式（Client-Server方式-C-s方式）"><a href="#客户服务器方式（Client-Server方式-C-s方式）" class="headerlink" title="客户服务器方式（Client/Server方式-C/s方式）"></a>客户服务器方式（Client/Server方式-C/s方式）</h4><p><img src="https://wx2.sbimg.cn/2020/07/18/CEiqM.png" alt="CEiqM.png"></p>
<blockquote>
<p>这里假如是要从网站上下载东西，那么客户机（用户所使用的消耗流量的软件）需要向服务器请求服务然后从服务器中得到服务，那么此时如果多个客户机同时需要从网站下载，那么都需要向服务器请求得到服务，那么这时候请求的越多，服务器的带宽压力越大，从而速度会越来越慢</p>
</blockquote>
<h4 id="对等连接方式（Peer-to-Peer-P2P"><a href="#对等连接方式（Peer-to-Peer-P2P" class="headerlink" title="对等连接方式（Peer-to-Peer P2P)"></a>对等连接方式（Peer-to-Peer P2P)</h4><p><img src="https://wx1.sbimg.cn/2020/07/18/CEnEa.png" alt="CEnEa.png"></p>
<blockquote>
<p>对等连接方式的精髓就是不区分客户机与服务器，客户机也可以是服务器，也就是说客户机下载数据可以从其他客户机（此时已作为服务器）处下载。如果我从服务器的100M数据中下载了50M，那么我可以作为服务器提供数据给其他客户机下载，这样的下载方式下载的端越多，速度就越快，因为多个端一起下载速度很快</p>
</blockquote>
<h3 id="因特网的核心数据交换方式"><a href="#因特网的核心数据交换方式" class="headerlink" title="因特网的核心数据交换方式"></a>因特网的核心数据交换方式</h3><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p><img src="https://wx2.sbimg.cn/2020/07/18/CE8kR.png" alt="CE8kR.png"><br>电路交换面向连接过程：</p>
<ul>
<li>建立连接（申请占用通信资源）</li>
<li>通话（一直占用通信资源）</li>
<li>释放链接（释放通信资源）</li>
</ul>
<blockquote>
<p>电路交换的缺陷很明显，需要一直占用通信资源，这样会导致其他连线无法成功，效率比较低</p>
</blockquote>
<blockquote>
<p>电路交换适合于数据量很大的实时性传输，如电话通话，还有核心路由器之间可以用电路交换）</p>
</blockquote>
<h4 id="分组交换方式"><a href="#分组交换方式" class="headerlink" title="分组交换方式"></a>分组交换方式</h4><p><img src="https://wx2.sbimg.cn/2020/07/18/CENvK.png" alt="CENvK.png"></p>
<ul>
<li>发送端：将要传输的完整的报文分成若干组，每一组加上首部（目的地，顺序等信息）然后独立的传送</li>
<li>接收端：将接收到的分组首部去掉再组成一个完整的报文即可完成传输<br><img src="https://wx1.sbimg.cn/2020/07/18/CEl4G.png" alt="CEl4G.png"><blockquote>
<p>这样的传输不占线，每个分组独立的选择最佳传输路线，路由器具有存储转发的功能，并且能够控制哪些连接不可以向外连接因特网，分组在里面查找转发表找到转发端口，不需要建立连接。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>分组交换方式的优点是高效灵活迅速可靠，缺点是时延和开</p>
</blockquote>
<h4 id="报文交换方式"><a href="#报文交换方式" class="headerlink" title="报文交换方式"></a>报文交换方式</h4><p>报文交换方式是对整个报文加上首部后直接传走，并不分组，它的缺点是一般比分组长的多，并且时延较长。</p>
<h4 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h4><p><img src="https://wx1.sbimg.cn/2020/07/18/CEOHw.png" alt="CEOHw.png"></p>
<blockquote>
<p>通过图可知，分组交换时延最短</p>
</blockquote>
<h2 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h2><h3 id="通过作用范围区分"><a href="#通过作用范围区分" class="headerlink" title="通过作用范围区分"></a>通过作用范围区分</h3><p>（现在主要看用的什么网的技术就是什么网，比如你和邻居之间都是通过运行商上网的，虽然你们两家离得很近，但仍然是使用的广域网）</p>
<ul>
<li>广域网WAN（花钱买服务，花钱买带宽）</li>
<li>城域网MAN（自己购买设备，自己维护，宽带固定，100米以内）</li>
<li>局域网LAN</li>
<li>个人区域网PAN<h3 id="通过使用者区分"><a href="#通过使用者区分" class="headerlink" title="通过使用者区分"></a>通过使用者区分</h3></li>
<li>公用网（Public Network）</li>
<li>专用网（Private Network）<h3 id="通过拓扑结构区分"><a href="#通过拓扑结构区分" class="headerlink" title="通过拓扑结构区分"></a>通过拓扑结构区分</h3></li>
<li>总线型</li>
<li>环形</li>
<li>星型</li>
<li>树型</li>
<li>网状<h3 id="通过交换方式进行区分"><a href="#通过交换方式进行区分" class="headerlink" title="通过交换方式进行区分"></a>通过交换方式进行区分</h3></li>
<li>电路交换网</li>
<li>报文交换网</li>
<li>分组交换网<h3 id="通过工作方式区分"><a href="#通过工作方式区分" class="headerlink" title="通过工作方式区分"></a>通过工作方式区分</h3></li>
<li>资源子网</li>
<li>通信子网</li>
<li>接入网</li>
</ul>
<h2 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h2><p><img src="https://wx1.sbimg.cn/2020/07/18/CEtE6.png" alt="CEtE6.png"></p>
<h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>连接在计算机网络上的主机在数字信道上传送数据位数的速率，也称data rate或bit rate(比特率)，单位是b/s, kb/s, Mb/s, Gb/s。和正常理解的网速的关系是除以8.</p>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>数据通信领域中，数字信道所能传送的最高数据率，单位是b/s, kb/s, Mb/s, Gb/s。常见的是Mpbs。</p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>在单位时间内通过某个网络的数据量，单位是b/s, Mb/s。</p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>包括发送时延，传播时延，处理时延，排队时延。发送时延等于数据块长度(bit)除以信道带宽(bit/s). 更快的发送速度意味着波长越短，链路上的数据量更大；更快的传播速度意味着在网线中更快的传播速度。</p>
<h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>表示一个宽带的链路商总的容纳量 即：<br>时延带宽积=传播时延*带宽</p>
<h3 id="往返时间-RTT-Round-Trip-Time"><a href="#往返时间-RTT-Round-Trip-Time" class="headerlink" title="往返时间(RTT, Round-Trip Time)"></a>往返时间(RTT, Round-Trip Time)</h3><p>从发送方发送数据开始，到发送方收到接收方确认数据的时间下。局域网的往返时间一般小于1ms<br><strong>可以通过ping指令查看时延</strong><br>例如 ping <a href="http://www.easonhe.top" target="_blank" rel="noopener">www.easonhe.top</a><br><img src="https://wx2.sbimg.cn/2020/07/18/CEzpO.png" alt="CEzpO.png"></p>
<blockquote>
<p>可以看到，由于easonhe.top是用了广域网所以时延很高，有时还会timeout   </p>
</blockquote>
<p>例如 ping 本机地址（本机地址可以通过ifconfig查看本机地址）<br><img src="https://wx1.sbimg.cn/2020/07/18/CE7he.png" alt="CE7he.png"></p>
<blockquote>
<p>这就属于局域网了，所以时延要小于1毫秒</p>
</blockquote>
<h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>包括信道利用率：有数据通过的时间/总时间<br>网络利用率：信道利用率的加权平均<br>网络当前时延D = 网络空闲时时延D0 / (1 - 信道利用率U)</p>
<h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><h3 id="几个基本概念"><a href="#几个基本概念" class="headerlink" title="几个基本概念"></a>几个基本概念</h3><ul>
<li>ISO：国际标准化组织</li>
<li>OSI/RM：互联网法律上的国际标准</li>
<li>TCP/IP Suite：因特网事实上的国际标准</li>
<li>Network Protocols：数据交换遵守的规则、标准或约定</li>
<li>网络体系结构：计算机网络各层及其协议的集合</li>
</ul>
<h3 id="OSI7层模型"><a href="#OSI7层模型" class="headerlink" title="OSI7层模型"></a>OSI7层模型</h3><p><strong>分层其实就是分步</strong>，<strong>体系结构分层的意义是为了标准化和降低各个步骤之间的关联</strong></p>
<ul>
<li>应用层：<strong>能够产生网络流量</strong>能够和用户交互的应用程序</li>
<li>表示层：加密 压缩 开发人员考虑</li>
<li>会话层：服务和客户端建立的会话 查木马 netstat -nb</li>
<li>传输层：可靠传输建立对话 不可靠传输扔包 流量控制</li>
<li>网络层：IP地址编址 选择最佳路径</li>
<li>数据链路层：输入如何封装 添加物理层地址MAC</li>
<li>物理层：电压 接口标准</li>
</ul>
<blockquote>
<ul>
<li>程序开发人员主要解决567层问题</li>
<li>网络工程师主要解决234层问题</li>
<li>物理层已经有标准化设备不用考虑了 </li>
</ul>
</blockquote>
<h3 id="其他体系结构"><a href="#其他体系结构" class="headerlink" title="其他体系结构"></a>其他体系结构</h3><ul>
<li>原理体系结构为5层（本次学习按照的就是原理体系结构的5层）应用层-传输层-网络层-数据链路层-物理层</li>
<li>TCP/IP为四层模型，应用层-传输层-网际层-网络接口层</li>
</ul>
<h3 id="网络排错"><a href="#网络排错" class="headerlink" title="网络排错"></a>网络排错</h3><blockquote>
<p>从最底层物理层到高层开始排，底层好排错，高层难排错，比如网线是否插好了，路由设备重启一下，是否欠费</p>
</blockquote>
<h3 id="网络安全与OSI参考模型"><a href="#网络安全与OSI参考模型" class="headerlink" title="网络安全与OSI参考模型"></a>网络安全与OSI参考模型</h3><ul>
<li>物理层安全：别人有可能直接接入你们网络的交换机，通过网线直接相连。应该拔掉已经不使用的网线接口</li>
<li>数据链路层安全 ADSL密码拨号 无线AP密码</li>
<li>网络层安全：两个设备通用一个路由器访问网络 但是可以在路由器上设置哪个网段可以连接互联网，哪个网段不可以连接互联网</li>
<li>应用层安全：SQL注入漏洞，应用开发相关的安全 上传漏洞：有些网站允许上传文件，比如PHP网站并且允许上传PHP文件，那么如果不改扩展名的话那么这个网址就可以直接解析这个php文件，网页就直接在这个服务器上运行了（网站漏洞）</li>
</ul>
<h2 id="开放系统信息交换涉及的几个概念"><a href="#开放系统信息交换涉及的几个概念" class="headerlink" title="开放系统信息交换涉及的几个概念"></a>开放系统信息交换涉及的几个概念</h2><ul>
<li>实体（entity）：交换信息的硬件或软件进程</li>
<li>协议（protocol)：控制两个对等实体通信的规则</li>
<li>服务（service）：下层向上层提供服务，上层需要使用下层提供的服务来实现本层的功能</li>
<li>服务访问点（SAP）：相邻两层实体间交换信息的地方<br><img src="https://wx1.sbimg.cn/2020/07/18/CNDN7.png" alt="CNDN7.png"><blockquote>
<p>其中的服务访问点比较抽象，可能就是一个函数或者参数，通过协议还有服务访问点会让其他非接收端的实体看不懂所传输的数据内容</p>
</blockquote>
</li>
</ul>
<h2 id="五层协议对应的数据单元"><a href="#五层协议对应的数据单元" class="headerlink" title="五层协议对应的数据单元"></a>五层协议对应的数据单元</h2><p><a href="https://sbimg.cn/image/CNo06" target="_blank" rel="noopener"><img src="https://wx2.sbimg.cn/2020/07/18/CNo06.png" alt="CNo06.png"></a><br>内容数据传输过程中：</p>
<ul>
<li>数据分段加上对应的使用协议称为段（运输层）<br>— 段加上网络层IP地址称为包（数据报）（网络层）</li>
<li>包外加上MAC物理层地址就变成了数据帧（数据链路层）</li>
<li>加上帧头帧尾就变成了比特（物理层）</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/18/CN3sO.png" alt="CN3sO.png"></p>
<blockquote>
<p>对应的接收端层层去掉对应的首部到应用层就可以得到完整的数据了</p>
</blockquote>
<h2 id="TCP-IP协议的结构与通信"><a href="#TCP-IP协议的结构与通信" class="headerlink" title="TCP/IP协议的结构与通信"></a>TCP/IP协议的结构与通信</h2><p><img src="https://wx1.sbimg.cn/2020/07/18/CNQBN.png" alt="CNQBN.png"><br><img src="https://wx1.sbimg.cn/2020/07/18/CNAKj.png" alt="CNAKj.png"><br><img src="https://wx1.sbimg.cn/2020/07/18/CNByk.png" alt="CNByk.png"></p>
<blockquote>
<p>对于功能比较强的计算机来说，可以同时有多个服务器，如SMTP服务、Web服务等等</p>
</blockquote>
<h2 id="其他计算机知识"><a href="#其他计算机知识" class="headerlink" title="其他计算机知识"></a>其他计算机知识</h2><blockquote>
<p>虽然本机的物理地址在出场时已经全球唯一不可更改了已经写在了芯片上，但是可以更改网络地址告诉计算机通信的时候不用网卡上的MAC地址而是用自己指定的MAC地址，这样做的好处是可以蹭企业的网 但是不能重复一样，因为如果这样数据报来了交换机就不知道该给谁了，这样网络就是一会通一会不通的了，有时候网络连接速度不同也不可以连接，比如服务器和交换机设置的连接速度不同或者两台计算机连接但是连接速度不同就会导致网络连接的上但就是不通 这是数据链路层的问题</p>
</blockquote>
<blockquote>
<p>一个网络相当于一个交换机</p>
</blockquote>
<blockquote>
<p>netstat 查看建立的会话<br>病毒消耗资源破坏系统 木马程序盗窃信息也可以远程控制机器 一般没有对话框 偷偷在后台运行 直接查看会话</p>
</blockquote>
<p><strong>计算机网络课程学习笔记</strong></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机网络】数据链路层</title>
    <url>/2020/07/20/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<p><strong>计算机网络不看后悔系列blog(三）数据链路层/超详细！！(｡◝‿◜｡)</strong></p>
<a id="more"></a>
<h2 id="数据链路层的基本概念"><a href="#数据链路层的基本概念" class="headerlink" title="数据链路层的基本概念"></a>数据链路层的基本概念</h2><h3 id="简单模型"><a href="#简单模型" class="headerlink" title="简单模型"></a>简单模型</h3><p><strong>数据链路层不关心物理层解决的问题，只关心帧头帧尾和校验</strong></p>
<p><img src="https://wx1.sbimg.cn/2020/07/20/CFx9J.png" alt="CFx9J.png"></p>
<h3 id="信道类型"><a href="#信道类型" class="headerlink" title="信道类型"></a>信道类型</h3><ul>
<li>点到点信道：这种信道使用一对一的点对点通信方式。</li>
<li>广播信道：广播信道上的主机很多，需要专用的共享信道协议来协调主机的数据发送。</li>
</ul>
<h3 id="链路与数据链路"><a href="#链路与数据链路" class="headerlink" title="链路与数据链路"></a>链路与数据链路</h3><ul>
<li>链路(link)——是一条点到点的物理线路段，中间没有任何其他的交换节点。一条链路只是一条通路的一个组成部分。</li>
<li>数据链路(data link)——除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。最常用的方法是使用适配器(网卡)来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。</li>
</ul>
<h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3><p><strong>在网络层，给数据包增加了接收端和发送端的IP地址。在数据链路层里，增加了帧头帧尾，MAC地址和校验值</strong>。</p>
<p><img src="https://wx2.sbimg.cn/2020/07/20/CF8wm.png" alt="CF8wm.png"></p>
<h2 id="数据链路层解决的基本问题"><a href="#数据链路层解决的基本问题" class="headerlink" title="数据链路层解决的基本问题"></a>数据链路层解决的基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p><strong>就是在一段数据的前后分别添加帧头和帧尾，构成一个帧，确定帧的界限</strong>。</p>
<p><img src="https://wx1.sbimg.cn/2020/07/20/CFElU.png" alt="CFElU.png"></p>
<blockquote>
<p>封装成帧中的MTU为最大传输单元，以太网传输最大不能超过1500个字节，如果只收到半截（即没有完整的收到帧的开始和结束）那么将会被丢弃，循环冗余检验中相除环节相同为0不同为1，最高位为1够除就上1，高位为0不够除就上0，除数越大能检验出差错的概率越大，但是也越复杂</p>
</blockquote>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>在封装成帧的过程中可能会出现这样的问题：</p>
<p><img src="https://wx2.sbimg.cn/2020/07/20/CFbCd.png" alt="CFbCd.png"></p>
<ul>
<li>用字节填充法解决透明传输问题。发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(十六进制数1B)。</li>
<li>字节填充(byte stuffing)或字符填充(character stuffing)——接收端的数据链路层在数据送往网络层之前拿出插入的转义字符。</li>
<li>如果转义字符也出现在数据之中，那么应该在转义字符前插入一个转义字符。当接收端收到连续的两个转义字符时，就删除前面的那一个。</li>
</ul>
<h3 id="差错检验"><a href="#差错检验" class="headerlink" title="差错检验"></a>差错检验</h3><ul>
<li>误码率BER(bit error rate)：传输过程中可能会产生bit差错：0变成1，1变成0.在一段时间内，传输错误的比特率占所传输比特总数的比率称为误码率</li>
<li>误码率和信噪比的关系很大。</li>
<li><strong>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检验措施</strong>。</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/20/CFlj4.png" alt="CFlj4.png"></p>
<p><strong>循环冗余检验CRC</strong>:<br>除数必须比后面添加的0的位数多一位，可以是任意的二进制数。每一步运算其实是不进位的加法。下图的001就是FCS帧检验序列。接收端计算101001001(也就是原数据加上FCS)除以1101，如果商为0，意味着传输过程没有差错，就接受，否则丢弃。（算数过程中高位为1就上1，高位为0就上0，过程中相同为0不同为1）</p>
<p><img src="https://wx2.sbimg.cn/2020/07/20/CFrnY.png" alt="CFrnY.png"></p>
<p><strong>特点</strong>：</p>
<ul>
<li>不能确定出错的bit的是哪一位；</li>
<li>可能会出错，但只要经过严格的挑选，并且除数位数足够大，就可以极大减少出错概率；</li>
<li>CRC只能做到无差错接受(意思是传输过程没有差错，有差错的一律丢弃)；</li>
<li>要做到可靠传输，必须加上确认和重传机制。</li>
</ul>
<p>在数据后面添加的冗余码称为<strong>帧检验序列FCS(frame check seqeunce)</strong>。<strong>CRC不是获得FCS的唯一方法</strong>。</p>
<h2 id="两种情况的数据链路层"><a href="#两种情况的数据链路层" class="headerlink" title="两种情况的数据链路层"></a>两种情况的数据链路层</h2><h3 id="广域网（使用点对点信道的数据链路层）"><a href="#广域网（使用点对点信道的数据链路层）" class="headerlink" title="广域网（使用点对点信道的数据链路层）"></a>广域网（使用点对点信道的数据链路层）</h3><h4 id="PPP协议-point-to-point-protocol-，是数据链路层协议，例如用户使用拨号上网。"><a href="#PPP协议-point-to-point-protocol-，是数据链路层协议，例如用户使用拨号上网。" class="headerlink" title="PPP协议(point to point protocol)，是数据链路层协议，例如用户使用拨号上网。"></a>PPP协议(point to point protocol)，是数据链路层协议，例如用户使用拨号上网。</h4><p><img src="https://wx1.sbimg.cn/2020/07/20/CFI9O.png" alt="CFI9O.png"></p>
<ul>
<li>PPP协议应该满足：<br>简单；封装成帧；透明性；多种网络层协议；多种类型链路；差错检验；检测连接状态；最大传送单元；网络层地址协商；数据压缩协商；</li>
<li>PPP协议不需要满足：<br>纠错；流量控制；序号；多点链接；半双工或单工连接。</li>
<li>PPP协议的组层部分：<br>数据链路层协议可以用于异步串行或同步串行介质；<br>使用LCP(链路控制协议)建立并维护数据链路连接，可以实现身份验证和欠费管理；只有满足了LCP即拨号成功才能实现NCP协议即才能获得IP地址</li>
<li>家庭上网拨号分配地址就是使用的PPP协议，但是直接插上网线就直接能上网就不用这个协议了。PPP协议具有记录功能，能记录下上网帐和时间，可以支持并标示多种网络层协议。网络层地址的协商：拨号成功后分配一个网络层的IP地址；</li>
</ul>
<p>网络控制协议(NCP)允许在点到点连接上使用多种网络层协议：</p>
<p><img src="https://wx1.sbimg.cn/2020/07/20/CFSXA.png" alt="CFSXA.png"></p>
<h4 id="PPP协议帧格式"><a href="#PPP协议帧格式" class="headerlink" title="PPP协议帧格式"></a>PPP协议帧格式</h4><blockquote>
<ul>
<li>标志字段F = 0x7E</li>
<li>地址字段A = 0xFF，它并不起作用</li>
<li>控制字段C = 0x03</li>
<li>PPP协议是面向字节的，所以所有的PPP帧的长度都是整数字节。</li>
<li>7E:0111 1110</li>
</ul>
</blockquote>
<p><img src="https://wx2.sbimg.cn/2020/07/20/CFTcV.png" alt="CFTcV.png"></p>
<h4 id="字节填充-类似于透明传输"><a href="#字节填充-类似于透明传输" class="headerlink" title="字节填充(类似于透明传输)"></a>字节填充(类似于透明传输)</h4><blockquote>
<ul>
<li>此时，信息部分是以字节为单位的。<br>将信息字段中出现的每个0x7E字节转变成为2字节序列(0x7D,0x5E);</li>
<li>将信息字段中出现的每个0x7E字节转变成为2字节序列(0x7D,0x5D);</li>
<li>将信息字段中出现的每个ASCII码控制字符(小于0x20字符)，在前面加入一个0x7E；</li>
</ul>
</blockquote>
<h4 id="0比特填充-类似于透明传输"><a href="#0比特填充-类似于透明传输" class="headerlink" title="0比特填充(类似于透明传输)"></a>0比特填充(类似于透明传输)</h4><blockquote>
<p>此时，信息部分是二进制流。PPP协议在SONET/SDH链路时，是使用同步传输。在发送端，只要发现有5个连续的1，则填充一个0，接收端删掉对应的0。</p>
</blockquote>
<p><img src="https://wx1.sbimg.cn/2020/07/20/CFyY7.png" alt="CFyY7.png"></p>
<h4 id="PPP协议不使用序号和确认机制的原因"><a href="#PPP协议不使用序号和确认机制的原因" class="headerlink" title="PPP协议不使用序号和确认机制的原因"></a>PPP协议不使用序号和确认机制的原因</h4><blockquote>
<p>在数据链路层出现错误的概率不大时，使用较简单的PPP协议较为合理；在Internet环境下，PPP的信息字段放入的数据是IP数据报。数据链路层的可靠传输并不能保证网络层的传输也是可靠的；<strong>帧检验序列FCS字段可以保证无差错接受</strong>。</p>
</blockquote>
<ul>
<li>PPP协议的工作状态<blockquote>
<ul>
<li>当用户拨号接入ISP(网络运营商)时，路由器的调制解调器对拨号进行确认，建立物理连接；</li>
<li>PC机箱路由器发送一些列的LCP(链路控制协议)分组(封装成多个PPP帧)；</li>
<li>这些分组及其响应选择一些PPP参数，和进行网络层配置，NCP(网络控制协议)给新接入的PC机分配一个临时的IP地址，使PC机成为Internet上的一个主机；</li>
<li>通信完毕后，NCP释放网络层连接，收回原来分配出去的IP地址；</li>
<li>接着，LCP释放数据链路层连接；最后释放的事物理层连接。</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<p>数据链路层的默认协议为HDLC 可以改为PPP </p>
</blockquote>
<p><img src="https://wx2.sbimg.cn/2020/07/20/CFfwe.png" alt="CFfwe.png"></p>
<h3 id="局域网（使用广播信道的数据链路层）"><a href="#局域网（使用广播信道的数据链路层）" class="headerlink" title="局域网（使用广播信道的数据链路层）"></a>局域网（使用广播信道的数据链路层）</h3><blockquote>
<p>一般为总线性,广播信道的冲突检测，由于发现冲突的时延最长高达两个单程的时延，所以以太网不适合长距离传输，因为发现冲突的时延会很长</p>
</blockquote>
<h4 id="局域网的拓扑"><a href="#局域网的拓扑" class="headerlink" title="局域网的拓扑"></a>局域网的拓扑</h4><p><img src="https://wx1.sbimg.cn/2020/07/20/CI4rD.png" alt="CI4rD.png"></p>
<h4 id="共享通信媒体"><a href="#共享通信媒体" class="headerlink" title="共享通信媒体"></a>共享通信媒体</h4><ul>
<li><p>静态划分信道(麻烦)：</p>
<blockquote>
<ul>
<li>频分复用；</li>
<li>时分复用；</li>
<li>波分复用；</li>
<li>码分复用；</li>
</ul>
</blockquote>
</li>
<li><p>动态媒体接入控制(多点接入)：</p>
<blockquote>
<ul>
<li>随机接入(主要是以太网)；</li>
<li>受控接入，如多点线路探询(polling)，轮询(不采用了)。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><p>最初的以太网是将许多计算机都连接到一根总线上，当初认为这样连接即简单又可靠，因为总线上没有有源器件。<br>总线上每一个主机都能检测到B发送的数据。但是只有D的地址和数据帧首部写入的地址一致，所以只有D接收。其余计算机都能检测到这不是发送给他们的数据帧，所以就丢弃这个数据帧。<strong>这是一种具有广播特性的总线上实现了一对一通信</strong>。这种方式不安全，而且效率不高</p>
<p><img src="https://wx2.sbimg.cn/2020/07/20/CIMCN.png" alt="CIMCN.png"></p>
<h4 id="带冲突检测的载波监听-碰撞检测"><a href="#带冲突检测的载波监听-碰撞检测" class="headerlink" title="带冲突检测的载波监听/碰撞检测"></a>带冲突检测的载波监听/碰撞检测</h4><ul>
<li>CSMA/CD：Carrier Sense Multiple Access with Collision Detection</li>
<li>多点接入：许多计算机以多点接入的方式连接在一根总线上。</li>
<li>载波监听：每一个站在发送数据之前都先要用电子技术检测一下总线时候有其它计算机在发送数据信号，如果有则不发送数据，以免发生碰撞；</li>
</ul>
<h4 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h4><p>碰撞检测就是计算机边发送数据边检测信道上信号电压的大小。（<strong>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大</strong>）当一个站检测到信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站在同时发送数据，表明产生了碰撞；<br>碰撞就是冲突，碰撞检测也称<strong>冲突检测</strong>。</p>
<blockquote>
<p>检测到碰撞后：在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息；<br>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就立即停止发送，避免浪费网络资源，等待一个随机的时间后再次发送。</p>
</blockquote>
<h4 id="传播时延对载波监听的影响"><a href="#传播时延对载波监听的影响" class="headerlink" title="传播时延对载波监听的影响"></a>传播时延对载波监听的影响</h4><p>能检查出出现碰撞的最长时延为2t。</p>
<p><img src="https://wx2.sbimg.cn/2020/07/20/CImxk.png" alt="CImxk.png"></p>
<h4 id="CSMA-CD的重要特性"><a href="#CSMA-CD的重要特性" class="headerlink" title="CSMA/CD的重要特性"></a>CSMA/CD的重要特性</h4><ul>
<li><strong>使用CSMA/CD协议的以太网不能进行全双工通信而只能进行双向交替通信(半双工)</strong>；</li>
<li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能；</li>
<li>这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</li>
</ul>
<h4 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h4><ul>
<li>最先发送数据帧的站，在发送数据帧后至多经过时间2t(2倍的端到端往返时延)就可知道发送的数据帧是否发生了碰撞。</li>
<li>经过争用期这段时间还没有检测到碰撞，就可以肯定不会发生碰撞；</li>
<li>以太网的争用期：<blockquote>
<ul>
<li>以太网的端到端往返时延2t称为争用期，或碰撞窗口，通常取51.2微秒为争用期的长度；如果网线过长，会导致争用期时间的延长，这也是为什么网线一般不超过100m；</li>
<li>对于10Mb/s的以太网，在争用期可以发送512bit，也就是64 byte；</li>
<li>以太网在发送数据的时候，若前64字节没有冲突，后续也不会发生冲突；</li>
</ul>
</blockquote>
</li>
<li>最短有效帧长：<blockquote>
<ul>
<li>如果发生冲突，一定是前64字节；</li>
<li>由于一旦发生冲突就立刻停止，所以已发送的数据一定小于64字节；</li>
<li>以太网规定了最短有效帧长为64字节，凡事小于64字节的帧一定是因为冲突而异常终止的无效帧。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="二进制指数类型退避算法"><a href="#二进制指数类型退避算法" class="headerlink" title="二进制指数类型退避算法"></a>二进制指数类型退避算法</h4><ul>
<li>发送碰撞的站在停止发送数据后，要推迟一个随机事件才能发送数据。</li>
<li>确定基本退避时间，一般是争用期2t；</li>
<li>定义参数k = min(重传次数，10)；</li>
<li>从整数集合{0,1,…,2^k-1}中随机取出一个数，记为r，重传所需的时延就是r倍的基本退避时间；</li>
<li>当重传达16次时仍不能成功时就丢弃该帧，并向高层报告。</li>
</ul>
<h2 id="以太网-1"><a href="#以太网-1" class="headerlink" title="以太网"></a>以太网</h2><h3 id="以太网的两个标准"><a href="#以太网的两个标准" class="headerlink" title="以太网的两个标准"></a>以太网的两个标准</h3><ul>
<li>DIX Ethernet V2一般是指这个。</li>
<li>IEEE 802.3 两个标准差别很小。以太网 是满足DIX Ethernet V2标准的局域网。</li>
</ul>
<h3 id="以太网与数据链路层的2个子层"><a href="#以太网与数据链路层的2个子层" class="headerlink" title="以太网与数据链路层的2个子层"></a>以太网与数据链路层的2个子层</h3><p><strong>为了使数据链路层更好的适应多种局域网标准，802委员会把局域网拆分为</strong>：</p>
<ul>
<li>逻辑链路控制LLC(Logical Link Control)子层；</li>
<li>媒体接入控制MAC(Medium Access Control)子层。<br>与接入到传输媒体有关的内容都放在MAC子层上，而LLC子层与传输媒体无关，不管什么协议的局域网对LLC子层都是透明的；</li>
</ul>
<blockquote>
<p>以太网是世界上第一个局域网产品,现代的以太网只有MAC这一层了没有LLC子层了。</p>
</blockquote>
<p>由于局域网标准一般是DIX Ethernet V2而不是IEEE 802.3，<strong>所以802.2标准的LLC子层作用已经不大了，很多厂商适配器没有LLC协议</strong>；</p>
<h3 id="以太网提供的服务"><a href="#以太网提供的服务" class="headerlink" title="以太网提供的服务"></a>以太网提供的服务</h3><ul>
<li>以太网提供服务是不可靠的交付，即最大努力的交付；</li>
<li>当接收站收到的有差错的数据帧时就丢弃此帧，其它什么也不做，差错的纠正由高层来处理；</li>
<li>如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新帧发送。</li>
</ul>
<h3 id="以太网的星型拓扑结构"><a href="#以太网的星型拓扑结构" class="headerlink" title="以太网的星型拓扑结构"></a>以太网的星型拓扑结构</h3><ul>
<li>物理上是星型，逻辑上是总线型。以太网的最初形态接到一根总线上的好处是不用再复用信道了，缺点是一根线路上只能有一个发一个收，占线。</li>
<li>为了降低成本，最初由粗的同轴电缆变成细的同轴电缆最后变成无屏蔽双绞线。每个站需要用两对双绞线，分别用于发送和接收；</li>
<li>在星形的中心增加了一种可靠性高的设备，为集线器(hub)。</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/20/CIkXn.png" alt="CIkXn.png"></p>
<h3 id="集线器的特点"><a href="#集线器的特点" class="headerlink" title="集线器的特点"></a>集线器的特点</h3><ul>
<li>集线器使用电子器件来模拟实际电缆线的工作，因此整个系统仍然是像一个传统的以太网那样运行。由于集线器使用了大规模集成电路芯片，所以可靠性更高；</li>
<li>使用集线器逻辑上仍然是一个总线网，各工作站使用的还是CSMA/CD协议，共享逻辑网络上的总线；<br>集线器像一个多接口的转发器，<strong>工作在物理层</strong>。</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/20/CI0dh.png" alt="CI0dh.png"></p>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p><img src="https://wx2.sbimg.cn/2020/07/20/CICFa.png" alt="CICFa.png"></p>
<p>从右向左：两个以太网口 两个广域网口 两个光纤接口 代号012345</p>
<h3 id="3-4-6-10Base-T-基于集线器的以太网标准"><a href="#3-4-6-10Base-T-基于集线器的以太网标准" class="headerlink" title="3.4.6 10Base-T 基于集线器的以太网标准"></a>3.4.6 10Base-T 基于集线器的以太网标准</h3><ul>
<li>它的通信距离稍短，每个站到集线器的距离不超过100m。</li>
<li>这种10MB/s的无屏蔽双绞线星形网的出现，能降低成本和提高可靠性。</li>
<li>10Base-T的出现有很大的意义，类似标准有100Base-FX，10Base-T，100Base-T4.</li>
</ul>
<h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><ul>
<li>争用期长度为2t；帧长为L bit，数据发送旅为C b/s，帧的发送时间为L/C = T0 秒。</li>
<li>一个帧从开始发送，经可能发生的碰撞后，将再次重传多次，直到发送成功且信道转为空闲(即再经过t使得信道上没有信号在传播)时为止，是发送一帧所需的平均时间。</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/20/CI2ZM.png" alt="CI2ZM.png"></p>
<blockquote>
<p>定义a = t / T0，是单程端到端时延t与帧发送时间T0的比值。a越小，说明碰撞检测越快，信道利用率高。当数据率(网速)一定时，以太网的连线长度受到限制，否则t会太长；以太网的帧长不能太短，否则T0太小，使a太大。</p>
</blockquote>
<h3 id="信道利用率的最大值"><a href="#信道利用率的最大值" class="headerlink" title="信道利用率的最大值"></a>信道利用率的最大值</h3><ul>
<li>假设理想状态下，以太网个展发送的数据都不会碰撞，一旦总线空闲就能有站立即发送数据，所以没有争用期；</li>
<li>发送一帧需要占用总线T0+t，而帧本身需要发送时间为T0，于是理想情况下极限信道利用率Smax = T0 / (T0 + t) = 1 / (1 + a).</li>
</ul>
<h2 id="MAC层"><a href="#MAC层" class="headerlink" title="MAC层"></a>MAC层</h2><h3 id="MAC层的硬件地址-MAC地址"><a href="#MAC层的硬件地址-MAC地址" class="headerlink" title="MAC层的硬件地址(MAC地址)"></a>MAC层的硬件地址(MAC地址)</h3><ul>
<li>802标准所说的“地址”严格地讲应该是每一个站的“名字”或标识符，但是大家已经习惯的将这种48位的“名字”称为“地址”，这种称呼不太严格</li>
<li>硬件地址 = 物理地址 = MAC地址</li>
<li>MAC地址前3个字节(24位)是厂家分配的地址字段，后3个字节(24位)是厂家自定义，称为扩展标识符；</li>
<li>一个地址块可以产生2^24个地址，这种48位地址称为MAC-48，通用名为EUI-48，这就是MAC地址；</li>
<li>MAC地址实际上是每一个站的名字或标识符。</li>
</ul>
<h3 id="适配器检查MAC地址"><a href="#适配器检查MAC地址" class="headerlink" title="适配器检查MAC地址"></a>适配器检查MAC地址</h3><p>适配器从网络上每收到一个MAC帧就要用硬件检查MAC帧中的MAC地址：<br>-&gt;如果是发往本站的帧就收下，然后进行其它处理；<br>-&gt;否则丢弃。<br>发往本站的帧包括：<br>-&gt;单播帧(unicast)(一对一)<br>-&gt;广播帧(broadcast)(一对全体)<br>-&gt;多播帧(multicast)(一对多)</p>
<h3 id="MAC帧的格式"><a href="#MAC帧的格式" class="headerlink" title="MAC帧的格式"></a>MAC帧的格式</h3><blockquote>
<p>由于以太网使用的是曼彻斯特编码所以只有一个帧开始标志就可以了,当后面不再有信号传输的时候就认为是结束了，不需要再添加帧的结束标志了</p>
</blockquote>
<p>6 + 6 + 2 + 46 + 4 =64 byte，这就是为什么IP数据报的最短长度为46字节。</p>
<p><img src="https://wx1.sbimg.cn/2020/07/20/CIPGR.png" alt="CIPGR.png"></p>
<blockquote>
<p>前8个字节的作用是实现比特同步，第一个字段共7个字节，称为前同步码，作用是实现快速MAC帧的比特同步；第二个字段是帧开始定界符，表示后面的信息是MAC帧。</p>
</blockquote>
<h3 id="无效的MAC帧"><a href="#无效的MAC帧" class="headerlink" title="无效的MAC帧"></a>无效的MAC帧</h3><ul>
<li>帧的长度不是整数个字节；</li>
<li>用收到的帧检验序列FCS查出有错误；</li>
<li>数据字段的长度不在46-1518字节内；</li>
<li>对于检查出来的无效MAC帧简单的丢弃。</li>
</ul>
<h3 id="帧间最小间隔"><a href="#帧间最小间隔" class="headerlink" title="帧间最小间隔"></a>帧间最小间隔</h3><blockquote>
<p>为9.6微秒。相当于96bit的发送时间。一个站在检测到总线空闲时，还需要等待9.6微秒后才能再次发送数据，这样做是为了使刚刚收到的数据帧的站接收缓存来得及清理，做好接收下一帧的准备。</p>
</blockquote>
<h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><h3 id="在物理层考虑扩展"><a href="#在物理层考虑扩展" class="headerlink" title="在物理层考虑扩展"></a>在物理层考虑扩展</h3><h4 id="距离的扩展"><a href="#距离的扩展" class="headerlink" title="距离的扩展"></a>距离的扩展</h4><p><strong>主机使用光纤和一对光纤调制解调器连接到集线器</strong>。</p>
<p><img src="https://wx1.sbimg.cn/2020/07/20/CI3rK.png" alt="CI3rK.png"></p>
<h4 id="数量的扩展"><a href="#数量的扩展" class="headerlink" title="数量的扩展"></a>数量的扩展</h4><p><strong>集线器集联：使网络中计算机增加，变成一个大的冲突域，会造成效率降低</strong>。</p>
<p><img src="https://wx2.sbimg.cn/2020/07/20/CI9DG.png" alt="CI9DG.png"></p>
<h3 id="在数据链路层考虑扩展"><a href="#在数据链路层考虑扩展" class="headerlink" title="在数据链路层考虑扩展"></a>在数据链路层考虑扩展</h3><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><ul>
<li>网桥工作在数据链路层，他根据MAC帧的目的地址对收到的帧进行转发。</li>
<li>网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是现检查此帧的目的MAC地址，然后再确定将该帧转发到对应的接口。</li>
</ul>
<p><img src="https://wx1.sbimg.cn/2020/07/20/CIGjT.png" alt="CIGjT.png"></p>
<h4 id="透明网桥-transparent"><a href="#透明网桥-transparent" class="headerlink" title="透明网桥(transparent )"></a>透明网桥(transparent )</h4><p>透明指局域网上的站点不知道所发送的帧将经过几个网桥，因为网桥对于各站点是看不见的。<br>透明网桥是一种即插即用的设备，标准是IEEE 802.1D。</p>
<p><img src="https://wx2.sbimg.cn/2020/07/20/CIQxw.png" alt="CIQxw.png"></p>
<p>透明网桥使用了生成树算法。避免产生转发的帧在网络中不停的转圈</p>
<p><img src="https://wx1.sbimg.cn/2020/07/20/CIBmo.png" alt="CIBmo.png"><br><img src="https://wx1.sbimg.cn/2020/07/20/CIBmo.png" alt="CIBmo.png"></p>
<h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><ul>
<li>随着网桥的接口的增加，后来网桥和集线器合并了，计算机可以直接和交换机连接，这就是交换机。</li>
<li>交换机就是网桥和集线器的合并升级版，能全双工，安全通信。</li>
<li>端口带宽独享；</li>
<li>安全；</li>
<li>基于MAC地址转发；</li>
<li>通过学习构建MAC地址表。</li>
</ul>
<blockquote>
<p>计算机可以直接和网桥连接，交换机直接在内部直接建立两个目标之间的通信，不再通过总线路类似广播一样的传输了，这样的话抓包工具也抓不到了，因为接收不到来自其他非自己接收端发送的数据了，而且交换机具有存储功能，两个同时向一个目标发送数据的时候可以进行排队，就没有冲突了，安全，效率高</p>
</blockquote>
<h4 id="数据链路层的安全："><a href="#数据链路层的安全：" class="headerlink" title="数据链路层的安全："></a>数据链路层的安全：</h4><blockquote>
<p>可以规定好每个交换机所能连接的设备的MAC地址，如果地址更改了或者地址变多了将会shutdown（这就是数据链路层安全的一个应用）</p>
</blockquote>
<h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>LAN：一个局域网（一个交换机构成的局域网）<br>VLAN：虚拟局域网，一个广播域=逻辑网段（子网）位于不同局域网的交换机相连并制定哪些地址的主机可以组成一个局域网<br><img src="https://wx1.sbimg.cn/2020/07/19/CVzkY.png" alt="CVzkY.png"></p>
<p><strong>放置在同一个转换器上的两个虚拟局域网，两个VLAN互不相通，如下</strong>：<br><img src="https://wx2.sbimg.cn/2020/07/19/CV7sA.png" alt="CV7sA.png"></p>
<p><strong>配置在多个转换器下的主机也可也组成多个虚拟局域网，如下所示</strong>：</p>
<p><img src="https://wx1.sbimg.cn/2020/07/19/CVHvV.png" alt="CVHvV.png"></p>
<p><strong>它们就等价于</strong>：<br><img src="https://wx2.sbimg.cn/2020/07/19/CVW47.png" alt="CVW47.png"></p>
<blockquote>
<p><strong>不同的交换机之间连接的设备有同属于一个虚拟机网的可以在交换机之间加一个干道链路，这个链路上可以跑多个VLAN的数据，它的带宽往往比单个网线连接的带宽要高很多数据包中加标记可以让干道链路识别出是哪一个VLAN的数据包，这里使用的是统计时分复用</strong>。<br><img src="https://wx1.sbimg.cn/2020/07/19/CVaTe.png" alt="CVaTe.png"></p>
</blockquote>
<p><strong>对于不用传输多个VLAN的链路就可以设置成普通的访问链路</strong><br><img src="https://wx1.sbimg.cn/2020/07/19/CViqN.png" alt="CViqN.png"></p>
<h3 id="ISL标记"><a href="#ISL标记" class="headerlink" title="ISL标记"></a>ISL标记</h3><p>思科公司的加标记的方法</p>
<p><img src="https://wx2.sbimg.cn/2020/07/19/CFG5V.png" alt="CFG5V.png"></p>
<p>在数据帧的地方加了几个字节</p>
<p><img src="https://wx1.sbimg.cn/2020/07/19/CFQR7.png" alt="CFQR7.png"></p>
<p>插入4个字节的VLAN标记</p>
<p><img src="https://wx2.sbimg.cn/2020/07/19/CFAW6.png" alt="CFAW6.png"></p>
<h2 id="快速以太网-fast-ethernet"><a href="#快速以太网-fast-ethernet" class="headerlink" title="快速以太网(fast ethernet)"></a>快速以太网(fast ethernet)</h2><h3 id="100Base-T以太网"><a href="#100Base-T以太网" class="headerlink" title="100Base-T以太网"></a>100Base-T以太网</h3><ul>
<li>速率在100Mb/s以上的以太网称为高速以太网。</li>
<li>在双绞线上传送100Mb/s基带信号的星型拓扑以太网，仍使用IEEE 802.3的CSMA/CD协议。</li>
<li>100Base-T以太网被称为快速以太网(fast ethernet)。</li>
<li>100Base-T以太网的物理层：<blockquote>
<ul>
<li>100Base-TX:使用2对UTP 5类线或屏蔽双绞线STP。</li>
<li>100Base-FX:使用2对光纤。</li>
<li>100Base-T4:使用4对UTP 3类线或5类线。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="100Base-T以太网的特点"><a href="#100Base-T以太网的特点" class="headerlink" title="100Base-T以太网的特点"></a>100Base-T以太网的特点</h3><p>可以实现全双工通信(注意，如果交换机上某一路连接着集线器(半双工)，则这一路不能实现全双工)而无冲突，此时不使用CSMA/CD协议。<br>MAC帧格式不变，仍是802.3 标准。<br>最短帧长度不变，但是一个网段的最大电缆长度减少到100m。<br>帧间间隔从9.6微秒缩小到0.96微秒。</p>
<h3 id="吉比特Gbit以太网"><a href="#吉比特Gbit以太网" class="headerlink" title="吉比特Gbit以太网"></a>吉比特Gbit以太网</h3><ul>
<li>允许在1 Gb/s下全双工或半双工工作方式。</li>
<li>使用802.3标准的帧格式。</li>
<li>在半双工下使用CSMA/CD协议。</li>
<li>与10Base-T和100Base-T技术向后兼容。</li>
<li>当吉比特以太网在全双工方式时，不用载波延伸和分组冲突。</li>
<li>1000Base-X以太网的物理层(基于光纤通道)：<blockquote>
<ul>
<li>1000Base-SX：SX表示短波长，传输距离上275m或550m。</li>
<li>1000Base-LX：LX表示长波长，传输距离上550m或5000m。</li>
<li>1000Base-CX：<br>1000Base-T以太网的物理层(基于双绞线)：</li>
<li>使用 4对 5类线UTP。</li>
</ul>
</blockquote>
</li>
</ul>
<p><img src="https://wx2.sbimg.cn/2020/07/20/CIRdl.png" alt="CIRdl.png"></p>
<h3 id="10Gbit-s以太网"><a href="#10Gbit-s以太网" class="headerlink" title="10Gbit/s以太网"></a>10Gbit/s以太网</h3><ul>
<li>MAC帧格式不变，仍是802.3 标准。</li>
<li>使用光纤而不是铜线。</li>
<li>只能工作在全双工方式，没有争用问题。</li>
<li>它的出现使工作范围从局域网扩大到城域网和广域网，实现了端到端的以太网传输，优点是：技术成熟；互操作性好；广域网中使用以太网便宜；统一的帧格式。</li>
</ul>
<h3 id="以太网10Mb-s到10Gb-s的演变"><a href="#以太网10Mb-s到10Gb-s的演变" class="headerlink" title="以太网10Mb/s到10Gb/s的演变"></a>以太网10Mb/s到10Gb/s的演变</h3><p>说明了:</p>
<ul>
<li>可拓展性；</li>
<li>灵活性(多种传输媒体，全/半双工，共享/交换)；</li>
<li>易于安装；</li>
<li>稳健性好。</li>
</ul>
<h3 id="Cisco建网的3层模型"><a href="#Cisco建网的3层模型" class="headerlink" title="Cisco建网的3层模型"></a>Cisco建网的3层模型</h3><p><img src="https://wx1.sbimg.cn/2020/07/20/CIcZ1.png" alt="CIcZ1.png"></p>
<p>参考：<br>《计算机网络》课程<br><a href="https://blog.csdn.net/iwanderu/article/details/103812828" target="_blank" rel="noopener">https://blog.csdn.net/iwanderu/article/details/103812828</a></p>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】(链表的Java实现与经典应用)</title>
    <url>/2020/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(Java%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0)/</url>
    <content><![CDATA[<p><strong>链表作为数据结构的基石,它的出现给很多的方法提供了优化措施,链表是最重要的数据结构之一,在我心里,链表就是数据结构的灵魂，本篇利用数组和内部类两种方式实现了链表的定义和基本方法的实现,当然我最爱内部类的实现形式( `)3’)▃▃▃▅▆▇▉</strong></p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://i.loli.net/2020/06/15/wJlYTC5oxUXtSZM.jpg" alt="IMG_7967.jpg"></p>
<blockquote>
<p>对于Java实现链表将Node作为内部类是个很好的选择，所以这里给出两个Java实现链表的版本，个人比较认同第二种。因为在链表的添加顺序是由右向左，先添加的节点对下一节点的引用可以为空，并且引用是引用下一节点而不是下一节点的对象，因为具有连续引用使得头节点可以操作所有节点，所以需要一个头节点和视情况而定的若干临时节点</p>
</blockquote>
<h2 id="链表的Java实现"><a href="#链表的Java实现" class="headerlink" title="链表的Java实现"></a>链表的Java实现</h2><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">package SqueneList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Sqlist</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span> MAXSIZE;</span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span>[] sqlist;</span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span> length;</span><br><span class="line">	<span class="comment">//用最大数组长度来初始化顺序表</span></span><br><span class="line">	<span class="keyword">public</span> Sqlist(<span class="built_in">int</span> MAXSIZE)&#123;</span><br><span class="line">		<span class="keyword">this</span>.sqlist = new <span class="built_in">int</span>[MAXSIZE];</span><br><span class="line">		<span class="keyword">this</span>.MAXSIZE=MAXSIZE;</span><br><span class="line">		<span class="keyword">this</span>.length=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//用数组来初始化顺序表</span></span><br><span class="line">	<span class="keyword">public</span> Sqlist(<span class="built_in">int</span>[] arr) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">			sqlist[i] = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.length = arr.length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对由数组实现的顺序表进行扩充</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> expandList()&#123;</span><br><span class="line">	    <span class="built_in">int</span>[] newarr = new <span class="built_in">int</span>[arr.length*<span class="number">2</span>]</span><br><span class="line">	    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">	        newarr[i]=arr[i]</span><br><span class="line">	    &#125;</span><br><span class="line">	    arr = newarr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//向顺序表指定位置插入元素</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> listInsert(<span class="built_in">int</span> i, <span class="built_in">int</span> e) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>) &#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"非法插入位置"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.length == <span class="keyword">this</span>.MAXSIZE) &#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"顺序表已满"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> k=length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--) &#123;</span><br><span class="line">			sqlist[k+<span class="number">1</span>]=sqlist[k];  <span class="comment">//数组中插入位置及其后的元素均向后移动一位</span></span><br><span class="line">		&#125;</span><br><span class="line">		sqlist[i<span class="number">-1</span>]=e;  <span class="comment">//将制定元素插入此位置</span></span><br><span class="line">		<span class="keyword">this</span>.length++;  <span class="comment">//插入后的顺序表长度+1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//清空顺序表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> listClear() &#123;</span><br><span class="line">		<span class="keyword">this</span>.length = <span class="number">0</span>;  <span class="comment">//仅用来判断是否为空，直接将长度设置为0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断顺序表是否为空</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">bool</span>ean isEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.length==<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取指定位置的顺序表元素</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">int</span> getElem(<span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;length)</span><br><span class="line">		&#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"获取位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sqlist[i<span class="number">-1</span>];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取制定元素的位置信息</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> getIndex(<span class="built_in">int</span> e, <span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;=length<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(sqlist[j]==e) &#123;</span><br><span class="line">				i=j++;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"顺序表中无对应元素"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印顺序表</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">void</span> printList() &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;=length<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">int</span> t=i+<span class="number">1</span>;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"第"</span>+t+<span class="string">"个元素为"</span>+sqlist[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除顺序表指定位置的元素</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">int</span> listDelete(<span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;length)</span><br><span class="line">		&#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"删除位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=i;j&lt;=length<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sqlist[j<span class="number">-1</span>]=sqlist[j];</span><br><span class="line">		&#125;</span><br><span class="line">		length--;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">		Sqlist sqlist = new Sqlist(<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			sqlist.listInsert(i, i);</span><br><span class="line">		&#125;</span><br><span class="line">		printList();</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"第3个元素为"</span>+getElem(<span class="number">3</span>));</span><br><span class="line">		listDelete(<span class="number">2</span>);</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"删除第二个元素后的顺序表的内容为："</span>);</span><br><span class="line">		printList();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> SqueneList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Linklist &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> Node head = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//使用内部类来作为普通结点，这样就只有头结点可以操作其他节点</span></span><br><span class="line">	<span class="keyword">class</span> Node&#123;</span><br><span class="line">		Node <span class="keyword">next</span>=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">int</span> data;</span><br><span class="line">		<span class="keyword">public</span> Node(<span class="keyword">int</span> data) &#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取单链表的长度</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> getLength() &#123;</span><br><span class="line">		<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">		Node temp = head;</span><br><span class="line">		<span class="keyword">while</span>(temp.<span class="keyword">next</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			length++;</span><br><span class="line">			temp = temp.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//单链表的增加</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> addNode(<span class="keyword">int</span> d) &#123;</span><br><span class="line">		Node newnode = <span class="keyword">new</span> Node(d);</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			head = newnode;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node temp = head;  <span class="comment">//临时结点</span></span><br><span class="line">		<span class="keyword">while</span>(temp.<span class="keyword">next</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">			temp = temp.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp.<span class="keyword">next</span> = newnode;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">//删除指定位置的结点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> deleteNode(<span class="keyword">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;getLength()) &#123;</span><br><span class="line">			System.out.<span class="keyword">println</span>(<span class="string">"删除位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) &#123;</span><br><span class="line">			head = head.<span class="keyword">next</span>;  <span class="comment">//若删除第一个结点则直接删去头结点即可</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">1</span>;</span><br><span class="line">		Node pre = head;  <span class="comment">//定义两个临时结点分别为前驱结点与后继结点</span></span><br><span class="line">		Node cur = pre.<span class="keyword">next</span>;</span><br><span class="line">		<span class="keyword">while</span>(cur!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(index == i-<span class="number">1</span>) &#123;</span><br><span class="line">				pre.<span class="keyword">next</span> = cur.<span class="keyword">next</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			pre = cur;</span><br><span class="line">			cur = cur.<span class="keyword">next</span>;</span><br><span class="line">			index++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印单链表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> printLinkList() &#123;</span><br><span class="line">		Node temp = head;</span><br><span class="line">		<span class="keyword">while</span>(temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.<span class="keyword">println</span>(temp.data);</span><br><span class="line">			temp = temp.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表的经典应用1:反转</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node reverseList(Node head) &#123;</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">		Node pre = head;</span><br><span class="line">		Node cur = head.<span class="keyword">next</span>;</span><br><span class="line">		Node tmp;</span><br><span class="line">		<span class="keyword">while</span>(cur!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			tmp = cur.<span class="keyword">next</span>;</span><br><span class="line">			cur.<span class="keyword">next</span> = pre;</span><br><span class="line">			pre = cur;</span><br><span class="line">			cur = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		head.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">return</span> pre;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表的经典应用2:查找单链表的中间节点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> searchMid() &#123;  <span class="comment">//这里对单链表中间位置查找使用的是快慢指针法</span></span><br><span class="line">		Node f = head;               <span class="comment">//即：快的指针一次走两个慢的指针一次走一个，快的指针到达</span></span><br><span class="line">		Node s = head;               <span class="comment">//表尾时慢指针刚好走到表中</span></span><br><span class="line">		<span class="keyword">while</span>(f!=<span class="keyword">null</span>&amp;&amp;f.<span class="keyword">next</span>!=<span class="keyword">null</span>&amp;&amp;f.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			f = f.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">			s = s.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s.data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表的经典应用2:删除单链表中倒数第k个节点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node searchElem(<span class="keyword">int</span> k) &#123;</span><br><span class="line">		<span class="keyword">if</span>(k&gt;getLength()||k&lt;<span class="number">1</span>) &#123;</span><br><span class="line">			System.out.<span class="keyword">println</span>(<span class="string">"删除位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node pf = head;</span><br><span class="line">		Node ps = head;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">			pf = pf.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(pf!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			pf = pf.<span class="keyword">next</span>;</span><br><span class="line">			ps = ps.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ps;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对链表进行排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node sortList() &#123;</span><br><span class="line">		Node nextNode = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">		Node curNode = head;</span><br><span class="line">		<span class="keyword">while</span>(curNode.<span class="keyword">next</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			nextNode = curNode.<span class="keyword">next</span>;</span><br><span class="line">			<span class="keyword">while</span>(nextNode!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(curNode.data&gt;nextNode.data) &#123;</span><br><span class="line">					temp = curNode.data;</span><br><span class="line">					curNode.data = nextNode.data;</span><br><span class="line">					nextNode.data = temp;</span><br><span class="line">				&#125;</span><br><span class="line">				nextNode = nextNode.<span class="keyword">next</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			curNode = curNode.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除链表中重复的节点就用简单的遍历方法 如果数据相同则p.next = p.next.next跳过就可以了</span></span><br><span class="line">	<span class="comment">//用递归的方法输出链表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> diGuiPrint(Node head) &#123;</span><br><span class="line">		<span class="keyword">if</span>(head!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			diGuiPrint(head.<span class="keyword">next</span>);</span><br><span class="line">			System.out.<span class="keyword">println</span>(<span class="string">"采用递归的方式输出链表："</span>+head.data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">		Linklist linklist = <span class="keyword">new</span> Linklist();</span><br><span class="line">		linklist.addNode(<span class="number">1</span>);</span><br><span class="line">		linklist.addNode(<span class="number">2</span>);</span><br><span class="line">		linklist.addNode(<span class="number">3</span>);</span><br><span class="line">		linklist.addNode(<span class="number">4</span>);</span><br><span class="line">		printLinkList();</span><br><span class="line">		deleteNode(<span class="number">2</span>);</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"删除第二个结点后的单链表为："</span>);</span><br><span class="line">		printLinkList();</span><br><span class="line">		head = reverseList(head);</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"单链表反转后变为："</span>);</span><br><span class="line">		printLinkList();</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"中间节点的数据为"</span>+searchMid());</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"倒数第2个节点的数据为"</span>+searchElem(<span class="number">2</span>).data);</span><br><span class="line">		sortList();</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"排序后的链表数据为:"</span>);</span><br><span class="line">		printLinkList();</span><br><span class="line">		diGuiPrint(head);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】(顺序表的Java与C++实现及经典应用)</title>
    <url>/2020/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84Java%E4%B8%8EC++%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8)/</url>
    <content><![CDATA[<p><strong>从入坑到入土的坑就是顺序表,珍惜最基础的数据结构,当然也要掌握好这个数据结构大厦的基石,顺序表的实现形式给很多复杂的数据结构形式提供了简单实现的方案,在有些时候,用顺序表的实现并非是差的选择(♥◠‿◠)ﾉ</strong></p>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/06/15/dqgl9kEIMwfuVAo.jpg" alt="IMG_7969.jpg"></p>
<h2 id="顺序表的Java实现"><a href="#顺序表的Java实现" class="headerlink" title="顺序表的Java实现"></a>顺序表的Java实现</h2><blockquote>
<p>Java代码是对顺序表的简单数组实现，对于顺序表的任何操作都可以利用数组来实现，但是往往使用数组时需要对数组的长度进行估计，这也很不符合实际也是很大的缺陷，但是在Java等现代语言中均不需要再对数组的长度进行估算，若数组长度达到了最大值可以用相应的方法进行扩充建立一个新的顺序表，当然对于顺序表的实现即使是数组实现但也有插入和删除需要大量移动数组带来的时间复杂度的问题。</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java代码实现</span></span><br><span class="line">package SquenceList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Sqlist</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span> MAXSIZE;</span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span>[] sqlist;</span><br><span class="line">	<span class="keyword">private</span> static <span class="built_in">int</span> length;</span><br><span class="line">	<span class="comment">//用最大数组长度来初始化顺序表</span></span><br><span class="line">	<span class="keyword">public</span> Sqlist(<span class="built_in">int</span> MAXSIZE)&#123;</span><br><span class="line">		<span class="keyword">this</span>.sqlist = new <span class="built_in">int</span>[MAXSIZE];</span><br><span class="line">		<span class="keyword">this</span>.MAXSIZE=MAXSIZE;</span><br><span class="line">		<span class="keyword">this</span>.length=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//用数组来初始化顺序表</span></span><br><span class="line">	<span class="keyword">public</span> Sqlist(<span class="built_in">int</span>[] arr) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">			sqlist[i] = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.length = arr.length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对由数组实现的顺序表进行扩充</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> expandList()&#123;</span><br><span class="line">	    <span class="built_in">int</span>[] newarr = new <span class="built_in">int</span>[arr.length*<span class="number">2</span>]</span><br><span class="line">	    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">	        newarr[i]=arr[i]</span><br><span class="line">	    &#125;</span><br><span class="line">	    arr = newarr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//向顺序表指定位置插入元素</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> listInsert(<span class="built_in">int</span> i, <span class="built_in">int</span> e) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>) &#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"非法插入位置"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.length == <span class="keyword">this</span>.MAXSIZE) &#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"顺序表已满"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> k=length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--) &#123;</span><br><span class="line">			sqlist[k+<span class="number">1</span>]=sqlist[k];  <span class="comment">//数组中插入位置及其后的元素均向后移动一位</span></span><br><span class="line">		&#125;</span><br><span class="line">		sqlist[i<span class="number">-1</span>]=e;  <span class="comment">//将制定元素插入此位置</span></span><br><span class="line">		<span class="keyword">this</span>.length++;  <span class="comment">//插入后的顺序表长度+1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//清空顺序表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> listClear() &#123;</span><br><span class="line">		<span class="keyword">this</span>.length = <span class="number">0</span>;  <span class="comment">//仅用来判断是否为空，直接将长度设置为0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断顺序表是否为空</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">bool</span>ean isEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.length==<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取指定位置的顺序表元素</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">int</span> getElem(<span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;length)</span><br><span class="line">		&#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"获取位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sqlist[i<span class="number">-1</span>];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取制定元素的位置信息</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> getIndex(<span class="built_in">int</span> e, <span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;=length<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(sqlist[j]==e) &#123;</span><br><span class="line">				i=j++;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"顺序表中无对应元素"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印顺序表</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">void</span> printList() &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;=length<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">int</span> t=i+<span class="number">1</span>;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"第"</span>+t+<span class="string">"个元素为"</span>+sqlist[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除顺序表指定位置的元素</span></span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">int</span> listDelete(<span class="built_in">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;length)</span><br><span class="line">		&#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"删除位置不合法"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j=i;j&lt;=length<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sqlist[j<span class="number">-1</span>]=sqlist[j];</span><br><span class="line">		&#125;</span><br><span class="line">		length--;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">		Sqlist sqlist = new Sqlist(<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			sqlist.listInsert(i, i);</span><br><span class="line">		&#125;</span><br><span class="line">		printList();</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"第3个元素为"</span>+getElem(<span class="number">3</span>));</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"删除第二个元素后的顺序表的内容为："</span>)</span><br><span class="line">		listDelete(<span class="number">2</span>);</span><br><span class="line">		printList();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺序表的C-实现"><a href="#顺序表的C-实现" class="headerlink" title="顺序表的C++实现"></a>顺序表的C++实现</h2><blockquote>
<p>C++代码实现顺序表的实现由于有指针的牵制而使得代码的实现比较复杂，需要多加理解和记忆。</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立顺序表的存储结构</span></span><br><span class="line">typedef <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> *elem;</span><br><span class="line">    <span class="built_in">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//构造一个空的顺序表</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">InitList(SqList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">L</span>.</span></span>elem=<span class="keyword">new</span> ElemType<span class="literal">[<span class="identifier">maxsize</span>]</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="module-access"><span class="module"><span class="identifier">L</span>.</span></span>elem) exit(overflow);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">L</span>.</span></span>length=<span class="number">0</span>;</span><br><span class="line">    return ok;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顺序表的插入</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ListInsert(SqList &amp;L,<span class="params">int</span> <span class="params">i</span>,<span class="params">int</span> <span class="params">e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((i&lt;<span class="number">1</span>)<span class="pattern-match"><span class="operator">||</span>(i&gt;<span class="constructor">L</span>.length+1)) return error; <span class="operator">/</span><span class="operator">/</span>插入位置是否合法的判断</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(<span class="constructor">L</span>.length<span class="operator">==</span>maxsize)  return error;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> j=<span class="constructor">L</span>.length-1;j&gt;=i-1;j--)</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">L</span>.elem[j+1]=<span class="constructor">L</span>.elem[j];  <span class="operator">/</span><span class="operator">/</span>插入后元素位置的移动变化</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">L</span>.elem[i-1]=e;</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">++</span><span class="constructor">L</span>.length;</span></span><br><span class="line"><span class="pattern-match">    return ok;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span>顺序表元素的获取</span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> <span class="constructor">GetElem(SqList L,<span class="params">int</span> <span class="params">i</span>,<span class="params">int</span> &amp;<span class="params">e</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(i&lt;1<span class="operator">||</span>i&gt;<span class="constructor">L</span>.length) return error;</span></span><br><span class="line"><span class="pattern-match">    e=<span class="constructor">L</span>.elem[i-1];</span></span><br><span class="line"><span class="pattern-match">    return e;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span>判断值是否相等</span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> <span class="constructor">EqualList(<span class="params">int</span> <span class="params">a</span>,<span class="params">int</span> <span class="params">b</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(a<span class="operator">==</span>b)</span></span><br><span class="line"><span class="pattern-match">        return ok;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">        return error;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span>判断顺序表中是否存在值为e的元素</span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> <span class="constructor">LocateElem(SqList L,ElemType <span class="params">e</span>,<span class="params">int</span> EqualList(<span class="params">int</span> <span class="params">a</span>, <span class="params">int</span> <span class="params">b</span>)</span>)</span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> i=1;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> <span class="operator">*</span>p=<span class="constructor">L</span>.elem;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">while</span>(i&lt;=<span class="constructor">L</span>.length<span class="operator">&amp;&amp;</span>!<span class="constructor">EqualList(<span class="operator">*</span><span class="params">p</span><span class="operator">++</span>,<span class="params">e</span>)</span>)</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">++</span>i;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(i&lt;=<span class="constructor">L</span>.length)</span></span><br><span class="line"><span class="pattern-match">        return 1;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">        return 0;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span>顺序表的打印</span></span><br><span class="line"><span class="pattern-match">void <span class="constructor">PrintList(SqList L)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> i=0; i&lt;<span class="constructor">L</span>.length; i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        cout&lt;&lt;<span class="constructor">L</span>.elem[i]&lt;&lt;" ";</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span>顺序表表示集合的并集</span></span><br><span class="line"><span class="pattern-match">void <span class="constructor">MergeList(SqList LA,SqList LB,SqList &amp; LC)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">   <span class="built_in">int</span> m,n,e;</span></span><br><span class="line"><span class="pattern-match">   m=<span class="constructor">LA</span>.length;n=<span class="constructor">LB</span>.length;</span></span><br><span class="line"><span class="pattern-match">   for(<span class="built_in">int</span> i=1;i&lt;=n;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">   &#123;</span></span><br><span class="line"><span class="pattern-match">       <span class="constructor">GetElem(LB,<span class="params">i</span>,<span class="params">e</span>)</span>;  <span class="operator">/</span><span class="operator">/</span>获取<span class="constructor">B</span>中第i个元素并返回给e</span></span><br><span class="line"><span class="pattern-match">       <span class="keyword">if</span>(!<span class="constructor">LocateElem(LA,<span class="params">e</span>,EqualList)</span> )</span></span><br><span class="line"><span class="pattern-match">           &#123;</span></span><br><span class="line"><span class="pattern-match">               <span class="constructor">ListInsert(LA,<span class="operator">++</span><span class="params">m</span>,<span class="params">e</span>)</span>;    <span class="operator">/</span><span class="operator">/</span>将e插在<span class="constructor">LC</span>的最后</span></span><br><span class="line"><span class="pattern-match">           &#125;</span></span><br><span class="line"><span class="pattern-match">   &#125;</span></span><br><span class="line"><span class="pattern-match">   for(<span class="built_in">int</span> i=1;i&lt;=m;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">GetElem(LA,<span class="params">i</span>,<span class="params">e</span>)</span>;   <span class="operator">/</span><span class="operator">/</span>获取<span class="constructor">A</span>中第i个元素并赋给e</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">ListInsert(LC,<span class="params">i</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> <span class="constructor">Mixture(SqList LA,SqList LB,SqList &amp;LC)</span></span></span><br><span class="line"><span class="pattern-match">&#123;<span class="operator">/</span><span class="operator">/</span>a与b的交集</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> m,n,e;</span></span><br><span class="line"><span class="pattern-match">    m=<span class="constructor">LA</span>.length;</span></span><br><span class="line"><span class="pattern-match">    n=<span class="constructor">LB</span>.length;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> j=0;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> p=m&lt;=n?<span class="constructor">LA</span>:<span class="constructor">LB</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> q=m&gt;n?<span class="constructor">LA</span>:<span class="constructor">LB</span>;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> i=1;i&lt;=p.length;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">GetElem(<span class="params">p</span>,<span class="params">i</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span>(<span class="constructor">LocateElem(<span class="params">q</span>,<span class="params">e</span>,EqualList)</span>)</span></span><br><span class="line"><span class="pattern-match">        &#123;</span></span><br><span class="line"><span class="pattern-match">            <span class="constructor">ListInsert(LC,<span class="operator">++</span><span class="params">j</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(<span class="constructor">LC</span>.length)</span></span><br><span class="line"><span class="pattern-match">        return ok;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">        return error;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> <span class="constructor">Different(SqList LA,SqList LB,SqList &amp;LC)</span></span></span><br><span class="line"><span class="pattern-match">&#123;<span class="operator">/</span><span class="operator">/</span>求<span class="constructor">A</span>-<span class="constructor">B</span>的集合</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> m=<span class="constructor">LA</span>.length;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> e;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> j=0;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> i=1;i&lt;=m;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">GetElem(LA,<span class="params">i</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span>(!<span class="constructor">LocateElem(LB,<span class="params">e</span>,EqualList)</span>)</span></span><br><span class="line"><span class="pattern-match">            <span class="constructor">ListInsert(LC,<span class="operator">++</span><span class="params">j</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span>(<span class="constructor">LC</span>.length)</span></span><br><span class="line"><span class="pattern-match">        return ok;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">        return error;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="built_in">int</span> main()</span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> <span class="constructor">LA</span>,<span class="constructor">LB</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">InitList(LA)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">InitList(LB)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"线性表a的长度："&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> la;</span></span><br><span class="line"><span class="pattern-match">    cin&gt;&gt;la;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"请输入a中的元素："&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> e;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> i=1;i&lt;=la;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        cin&gt;&gt;e;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">ListInsert(LA,<span class="params">i</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"<span class="constructor">A</span>中的元素:"&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">PrintList(LA)</span>;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"线性表b的长度："&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    <span class="built_in">int</span> lb;</span></span><br><span class="line"><span class="pattern-match">    cin&gt;&gt;lb;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"请输入b中的元素："&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    for(<span class="built_in">int</span> i=1;i&lt;=lb;i<span class="operator">++</span>)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        cin&gt;&gt;e;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">ListInsert(LB,<span class="params">i</span>,<span class="params">e</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"<span class="constructor">B</span>中的元素"&lt;&lt;endl;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">PrintList(LB)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"<span class="constructor">A</span>并<span class="constructor">B</span>:";</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> <span class="constructor">LC1</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">InitList(LC1)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">MergeList(LA,LB,LC1)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">PrintList(LC1)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"<span class="constructor">A</span>交<span class="constructor">B</span>：";</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> <span class="constructor">LC2</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">InitList(LC2)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">Mixture(LA,LB,LC2)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">PrintList(LC2)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    cout&lt;&lt;"<span class="constructor">A</span>差<span class="constructor">B</span>：";</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">SqList</span> <span class="constructor">LC3</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">InitList(LC3)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">Different(LA,LB,LC3)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">PrintList(LC3)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    return 0;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【置顶】和我的Blog认识一下吧</title>
    <url>/2022/07/03/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E5%92%8C%E6%88%91%E7%9A%84Blog%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%8B%E5%90%A7/</url>
    <content><![CDATA[<p><strong>Hi～欢迎来到小贺同学的blog，如果你不知道怎么来了解它的话先来康康我吧 o‿≖✧</strong></p>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>做这个blog的初心呢是想记录着自己在技术所做出的努力所带来的一些成果，也想用它来激励自己，还有就是想和你们交流啦，自从开始做撸码肥宅之后感觉真的是越来越和大家脱轨了，很多很多的想法想跟你们讲却又苦于如何开口，所以我就把它们都写在了这，希望能与你们共勉。（大家一定要来找我玩  (;´༎ຶД༎ຶ`)  ）还有就是因为我目前对于前端开发语言和框架不太熟悉，所以blog是建立在了前人开发的基础上做起来的，所以很遗憾很多想要实现的功能和想要更换的布置还没办法去完成，在后端开发学习进度不错的情况下将会将会对前端开发进行学习，如果有什么大家希望博客改进/改错的地方或者想要看那些方面的blog内容分享还烦请跟我联系喔～总之希望和大家一起成长～</p>
</blockquote>
<hr>
<h2 id="Blog导航"><a href="#Blog导航" class="headerlink" title="Blog导航"></a>Blog导航</h2><h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><p><img src="https://wx1.sbimg.cn/2020/07/03/2nWck.png" alt="2nWck.png"></p>
<blockquote>
<p>这里是通过索引和分区快速找到你感兴趣的blog的地方，它们的作用是这样</p>
<ol>
<li>首页：如果你不知道现在在哪那就一键首页吧，带你回到最初的这个样子；</li>
<li>分类：这里我目前把学习与生活分成了两个分区，你可以只挑你感兴趣的分区浏览喔；</li>
<li>归档：以时间轴为线整合了所有文章的地方；</li>
<li>搜索：通过关键字快速寻找文章（目前踩坑还未出坑）</li>
</ol>
</blockquote>
<h3 id="信息栏"><a href="#信息栏" class="headerlink" title="信息栏"></a>信息栏</h3><p><img src="https://wx1.sbimg.cn/2020/07/03/2nZVh.png" alt="2nZVh.png"></p>
<blockquote>
<p>点击左下角的菜单小图标将会显示Blog的信息栏，在这里你可以选择从哪里联系我（这个方面还比较鸡肋，后期会更新）还可以听一下我为Blog设定的BGM音乐并且还可以点击最下方的小箭头直接回到网页头部</p>
</blockquote>
<h2 id="分类导航"><a href="#分类导航" class="headerlink" title="分类导航"></a>分类导航</h2><blockquote>
<p>学习区：当然是博客的重头戏啦，我将按照我的Java开发路线进行不断前进，所以写技术博客就是对自己最好的督促了，我希望大家有兴趣的话可以跟着我的路线共勉，另外，大多数博客都是作为我在书籍或者网络上学习后写下来的学习笔记，所以若有不足或者错误之处还请不吝赐教，我也更希望大家可以跟我一起交流相关的开发知识，一起前进啦QAQ</p>
</blockquote>
<blockquote>
<p>生活区：喜欢的影音作品、好的App和实物的安利、对于某些作品及事物的观点看法、觉得不错的书籍推荐等等等等包罗万象的生活区将会是我更新日常的主阵地啦，还请大家多多联系我找我玩哦~。</p>
</blockquote>
<h2 id="文章导航"><a href="#文章导航" class="headerlink" title="文章导航"></a>文章导航</h2><blockquote>
<p>在更新的所有文章中我均设立了对应的目录结构，所以我在文章中对于各级标题都做了严格的梳理，所以既可以完整的阅读文章也可以通过目录结构直接定位到要阅读的部分～</p>
</blockquote>
<h2 id="更新计划"><a href="#更新计划" class="headerlink" title="更新计划"></a>更新计划</h2><p>更新原则（我要日更！！！）   </p>
<blockquote>
<ol>
<li>学习区：是将会在周日-周五每天更新至少一篇学习区的博客文章以督促自己的学习进度，周六将会着重复习和消化本周及之前的文章内容所以将不更新学习区的博客文章；</li>
<li>生活区：这个作为不定时更新的博客栏目所以会在有想分享或者想和大家交流以及当天目标完成比较早的时候（偷懒的时候）更新，更新的形式与篇幅均不确定。</li>
</ol>
</blockquote>
<h2 id="更新预告"><a href="#更新预告" class="headerlink" title="更新预告"></a>更新预告</h2><blockquote>
<p>由于小贺还是个技术萌新，所以Java的开发路线先按照编程基础进行：</p>
</blockquote>
<ul>
<li>准备考研英语</li>
<li>更新数据结构的深度学习，独立编写重要结构代码</li>
<li>准备更新操作系统这块的内容</li>
<li>…(完成后将更新此块内容)</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>【数据结构】(图的两种Java实现与经典应用)</title>
    <url>/2020/06/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%9B%BE%E7%9A%84%E4%B8%A4%E7%A7%8DJava%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8)/</url>
    <content><![CDATA[<p><strong>图已经是数据机构基础中最复杂的结构,它几乎涵盖了前面所有的基础数据结构,本篇涉及到了图的两种构造方式(邻接矩阵和邻接表),以及对应的深度优先遍历/广度优先遍历/Dijkstra/最小生成树/等方法,很多的方法代码复杂难以理解,共勉(●’◡’●)ﾉ♥</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>我们将会遇到的应用使用几乎都是稀疏图——《算法第四版》   </p>
</blockquote>
<blockquote>
<p>邻接矩阵的处理思路是将顶点和关系分别保存到一个一维数组和一个二维数组中。但是，即使我们保存的是int型数据，一旦数据量达到10万。那么这个数组需要使用的内存空间为：100000 * 100000 * 4Byte = 40GB 所以在这个时候邻接表的优势就很明显了.<br><img src="https://i.loli.net/2020/06/27/eXIdZO6mMg1CNt3.jpg" alt="IMG_5716.jpg"></p>
</blockquote>
<h3 id="邻接矩阵表示图"><a href="#邻接矩阵表示图" class="headerlink" title="邻接矩阵表示图"></a>邻接矩阵表示图</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package Graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> VERTEX_MAX = <span class="number">10</span>;  <span class="comment">//最大结点数</span></span><br><span class="line">	Vertex[] vertex;  <span class="comment">//结点</span></span><br><span class="line">	<span class="keyword">int</span> num; <span class="comment">//目前的结点数</span></span><br><span class="line">	<span class="keyword">int</span> [][] adjacency;  <span class="comment">//临街矩阵</span></span><br><span class="line">	<span class="comment">//内部类表示结点</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>&#123;</span>  </span><br><span class="line">		<span class="keyword">char</span> content;</span><br><span class="line">		<span class="keyword">boolean</span> isSearch;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(<span class="keyword">char</span> content)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.content = content;</span><br><span class="line">			<span class="keyword">this</span>.isSearch = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//内部类表示栈</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> STACK_MAX = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">stack</span>[];</span><br><span class="line">		<span class="keyword">int</span> top;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">stack</span> = <span class="keyword">new</span> <span class="keyword">int</span>[STACK_MAX];</span><br><span class="line">			top = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(top==<span class="number">9</span>) &#123;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="string">"栈已满，无法入栈啦"</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">stack</span>[++top]=content;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(top==<span class="number">-1</span>) &#123;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="string">"栈已空，无法出栈啦"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">stack</span>[top--];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">stack</span>[top];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> top==<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> QUEUE_MAX = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> [] <span class="built_in">queue</span>;</span><br><span class="line">		<span class="keyword">int</span> front;</span><br><span class="line">		<span class="keyword">int</span> rear;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">queue</span> = <span class="keyword">new</span> <span class="keyword">int</span>[QUEUE_MAX];</span><br><span class="line">			front = <span class="number">0</span>;</span><br><span class="line">			rear = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(rear==QUEUE_MAX) &#123;</span><br><span class="line">				rear=<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">queue</span>[++rear]=content;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(front==QUEUE_MAX) &#123;</span><br><span class="line">				front=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> temp = <span class="built_in">queue</span>[front++];</span><br><span class="line">			<span class="keyword">return</span> temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (rear+<span class="number">1</span>==front || front+QUEUE_MAX<span class="number">-1</span>==rear);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化图</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>.vertex = <span class="keyword">new</span> Vertex[VERTEX_MAX];</span><br><span class="line">		<span class="keyword">this</span>.adjacency = <span class="keyword">new</span> <span class="keyword">int</span>[VERTEX_MAX][VERTEX_MAX];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;VERTEX_MAX;i++) &#123;  <span class="comment">//邻接矩阵的初始化 所有的结点都没有被访问过</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;VERTEX_MAX;j++) &#123;</span><br><span class="line">				adjacency[i][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//添加结点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addVertex</span><span class="params">(<span class="keyword">char</span> content)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num&lt;VERTEX_MAX<span class="number">-1</span>) &#123;</span><br><span class="line">			vertex[num++] = <span class="keyword">new</span> Vertex(content);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"图已满最大结点，不可以再添加结点了喔～"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//无向图添加边</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNAdj</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(start&lt;VERTEX_MAX &amp;&amp; <span class="built_in">end</span>&lt;VERTEX_MAX) &#123;</span><br><span class="line">			adjacency[start][<span class="built_in">end</span>] =  <span class="number">1</span>;</span><br><span class="line">			adjacency[<span class="built_in">end</span>][start] = <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"连接的图结点位置不合法，无法连接～"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有向图添加边</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addYAdj</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(start&lt;VERTEX_MAX &amp;&amp; <span class="built_in">end</span>&lt;VERTEX_MAX) &#123;</span><br><span class="line">			adjacency[start][<span class="built_in">end</span>] = <span class="number">-1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"连接的图结点位置不合法，无法连接～"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印图中的某个结点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printVertex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(index&gt;=<span class="number">0</span> &amp;&amp; index&lt;VERTEX_MAX) &#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(<span class="keyword">this</span>.vertex[index].content);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"打印结点位置不合法，无法打印～"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印邻接矩阵</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAdjacency</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(j!=num<span class="number">-1</span>) &#123;</span><br><span class="line">					System.out.<span class="built_in">print</span>(adjacency[i][j]+<span class="string">" "</span>);</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					System.out.<span class="built_in">println</span>(adjacency[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//寻找某一结点的未被访问的邻接点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchUnsearchVertex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(adjacency[i][index]==<span class="number">1</span> &amp;&amp; vertex[i].isSearch==<span class="literal">false</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//图的深度优先遍历 Depth-first traversal</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dpt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Stack <span class="built_in">stack</span> = <span class="keyword">new</span> Stack();</span><br><span class="line">		vertex[<span class="number">0</span>].isSearch = <span class="literal">true</span>;</span><br><span class="line">		printVertex(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> index = searchUnsearchVertex(<span class="built_in">stack</span>.<span class="built_in">peek</span>());</span><br><span class="line">			<span class="keyword">if</span>(index==<span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="built_in">stack</span>.pop();</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				vertex[index].isSearch = <span class="literal">true</span>;</span><br><span class="line">				printVertex(index);</span><br><span class="line">				<span class="built_in">stack</span>.push(index);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//遍历结束后将原图返回初始值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">			vertex[i].isSearch=<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//图的广度优先遍历 Breadth-first traversal</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bpt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Queue <span class="built_in">queue</span> = <span class="keyword">new</span> Queue();</span><br><span class="line">		vertex[<span class="number">0</span>].isSearch = <span class="literal">true</span>;</span><br><span class="line">		printVertex(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">queue</span>.insert(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> v1 = <span class="built_in">queue</span>.<span class="built_in">remove</span>();</span><br><span class="line">			<span class="keyword">int</span> v2 = searchUnsearchVertex(v1); </span><br><span class="line">			<span class="keyword">if</span>(v2!=<span class="number">-1</span>) &#123;</span><br><span class="line">				vertex[v2].isSearch = <span class="literal">true</span>;</span><br><span class="line">				printVertex(v2);</span><br><span class="line">				<span class="built_in">queue</span>.insert(v2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">			vertex[i].isSearch = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最小生成树 Minimum spanning tree</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Stack <span class="built_in">stack</span> = <span class="keyword">new</span> Stack();</span><br><span class="line">		vertex[<span class="number">0</span>].isSearch = <span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> cur = <span class="built_in">stack</span>.<span class="built_in">peek</span>();</span><br><span class="line">			<span class="keyword">int</span> index = searchUnsearchVertex(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(index == <span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="built_in">stack</span>.pop();</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				vertex[index].isSearch = <span class="literal">true</span>;</span><br><span class="line">				<span class="built_in">stack</span>.push(index);</span><br><span class="line">				printVertex(cur);</span><br><span class="line">				printVertex(index);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">			vertex[i].isSearch = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		Graph graph = <span class="keyword">new</span> Graph();</span><br><span class="line">		graph.addVertex(<span class="string">'F'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'O'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'R'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'E'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'V'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'E'</span>);</span><br><span class="line">		graph.addVertex(<span class="string">'R'</span>);</span><br><span class="line">		graph.addNAdj(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">		graph.addNAdj(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">		graph.addNAdj(<span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">		graph.addNAdj(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">		graph.addNAdj(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">		graph.printAdjacency();</span><br><span class="line">		graph.printVertex(<span class="number">3</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"深度优先遍历："</span>);</span><br><span class="line">		graph.dpt();</span><br><span class="line">		System.out.<span class="built_in">println</span>();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"广度优先遍历："</span>);</span><br><span class="line">		graph.bpt();</span><br><span class="line">		System.out.<span class="built_in">println</span>();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"最小生成树："</span>);</span><br><span class="line">		graph.mst();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="邻接表的对应实现"><a href="#邻接表的对应实现" class="headerlink" title="邻接表的对应实现"></a>邻接表的对应实现</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package Graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.<span class="keyword">Array</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> GraphAdj&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">	VNode&lt;E&gt;[] vers; //用来存储图的结点</span><br><span class="line">	<span class="type">int</span> max_size; //图的最大结点数量</span><br><span class="line">	<span class="type">int</span> numofvers; //图的当前结点数量</span><br><span class="line">	//邻接表建立图的结点</span><br><span class="line">	<span class="keyword">class</span> VNode&lt;E&gt;&#123;</span><br><span class="line">		E data; //存储定点数据</span><br><span class="line">		LNode first; //结点的邻接表的第一个结点</span><br><span class="line">		<span class="type">boolean</span> isvisited = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//邻接表建立图的邻接表的结点</span><br><span class="line">	<span class="keyword">class</span> LNode&#123;</span><br><span class="line">		<span class="type">int</span> weight; //存储权值</span><br><span class="line">		<span class="type">int</span> firstadj; //邻接表结点的序号</span><br><span class="line">		LNode nextvex; //下一个邻接结点</span><br><span class="line">		<span class="built_in">public</span> LNode(<span class="type">int</span> weight, <span class="type">int</span> firstadj) &#123;</span><br><span class="line">			this.weight = weight;</span><br><span class="line">			this.firstadj = firstadj;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//邻接表建立图的初始化</span><br><span class="line">	<span class="built_in">public</span> GraphAdj(<span class="type">int</span> max_size) &#123;</span><br><span class="line">		this.max_size = max_size;</span><br><span class="line">		vers = (VNode[])<span class="keyword">Array</span>.newInstance(VNode.<span class="keyword">class</span>, max_size);</span><br><span class="line">	&#125;</span><br><span class="line">	//获取图结点的树木</span><br><span class="line">	<span class="built_in">public</span> <span class="type">int</span> getNumOfGraph() &#123;</span><br><span class="line">		<span class="keyword">return</span> numofvers;</span><br><span class="line">	&#125;</span><br><span class="line">	//向图中插入结点</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> <span class="keyword">insert</span>(E e) &#123;</span><br><span class="line">		<span class="keyword">if</span>(numofvers&gt;=max_size) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		VNode&lt;E&gt; ver = <span class="built_in">new</span> VNode&lt;E&gt;();</span><br><span class="line">		ver.data = e;</span><br><span class="line">		vers[numofvers++] = ver;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取某结点的位置</span><br><span class="line">	<span class="built_in">public</span> <span class="type">int</span> getIndex(E e) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numofvers;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vers[i].data == e) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取指定位置的结点</span><br><span class="line">	<span class="built_in">public</span> E gerData(<span class="type">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">index</span>&lt;<span class="number">0</span> || <span class="keyword">index</span>&gt;=numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> vers[<span class="keyword">index</span>].data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//向图中插入边</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> insertEdg(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v1&lt;<span class="number">0</span> || v2&lt;<span class="number">0</span> || v1&gt;=numofvers || v2&gt;=numofvers) &#123; //合法性判断</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LNode vers1 = <span class="built_in">new</span> LNode(v2, weight);</span><br><span class="line">		LNode vers2 = <span class="built_in">new</span> LNode(v1, weight);</span><br><span class="line">		//当v1结点没有邻接结点时</span><br><span class="line">		<span class="keyword">if</span>(vers[v1].first==<span class="keyword">null</span>) &#123;</span><br><span class="line">			vers[v1].first=vers1;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;//当v1结点有邻接结点时</span><br><span class="line">			vers1.nextvex = vers[v1].first;</span><br><span class="line">			vers[v1].first = vers1;</span><br><span class="line">		&#125;</span><br><span class="line">		//当v2结点没有邻接结点时</span><br><span class="line">		<span class="keyword">if</span>(vers[v2].first==<span class="keyword">null</span>) &#123;</span><br><span class="line">			vers[v2].first = vers2;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;//当v2结点有邻接结点时</span><br><span class="line">			vers2.nextvex = vers[v2].first;</span><br><span class="line">			vers[v2].first = vers2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//删除图中的某条边</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> deleteEdg(<span class="type">int</span> v1, <span class="type">int</span> v2) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v1&lt;<span class="number">0</span> || v2&lt;<span class="number">0</span> || v1&gt;=numofvers || v2&gt;=numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LNode <span class="keyword">current</span> = vers[v1].first;</span><br><span class="line">		LNode pre = <span class="keyword">null</span>;</span><br><span class="line">		//判断v1到v2之间是否存在边</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">current</span>.firstadj!=v2) &#123;</span><br><span class="line">			pre = <span class="keyword">current</span>;</span><br><span class="line">			<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">		&#125;</span><br><span class="line">		//v1到v2之间存在边则删除</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			pre.nextvex = <span class="keyword">current</span>.nextvex;</span><br><span class="line">		&#125;</span><br><span class="line">		//判断v2到v1之间是否存在边</span><br><span class="line">		<span class="keyword">current</span> = vers[v2].first;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">current</span>.firstadj!=v1) &#123;</span><br><span class="line">			pre = <span class="keyword">current</span>;</span><br><span class="line">			<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">		&#125;</span><br><span class="line">		//v2到v1之间存在边则删除</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			pre.nextvex = <span class="keyword">current</span>.nextvex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//获得指定的结点间的边</span><br><span class="line">	<span class="built_in">public</span> <span class="type">boolean</span> getEdg(<span class="type">int</span> v1, <span class="type">int</span> v2) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v1&lt;<span class="number">0</span> || v2&lt;<span class="number">0</span> || v1&gt;=numofvers || v2&gt;=numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LNode <span class="keyword">current</span> = vers[v1].first;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">current</span>.firstadj == v2) &#123;</span><br><span class="line">				<span class="keyword">System</span>.<span class="keyword">out</span>.println("结点v"+v1+"-&gt;"+"结点v"+v2+"边的权值为："+<span class="keyword">current</span>.weight);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">current</span> = vers[v2].first;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">current</span>.firstadj == v2) &#123;</span><br><span class="line">				<span class="keyword">System</span>.<span class="keyword">out</span>.println("结点v"+v2+"-&gt;"+"结点v"+v1+"边的权值为："+<span class="keyword">current</span>.weight);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	//深度优先遍历 Deep-first traversal</span><br><span class="line">	<span class="built_in">public</span> <span class="type">void</span> DFT(<span class="type">int</span> v) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;<span class="number">0</span> || v&gt;=numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Stack&lt;<span class="type">Integer</span>&gt; stack = <span class="built_in">new</span> Stack&lt;<span class="type">Integer</span>&gt;();</span><br><span class="line">		vers[v].isvisited = <span class="keyword">true</span>;</span><br><span class="line">		LNode <span class="keyword">current</span>;</span><br><span class="line">		stack.push(v);</span><br><span class="line">		<span class="keyword">while</span>(stack!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			v = stack.pop();</span><br><span class="line">			<span class="keyword">System</span>.<span class="keyword">out</span>.println(vers[v].data+" ");</span><br><span class="line">			<span class="keyword">current</span> = vers[v].first;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(vers[<span class="keyword">current</span>.firstadj].isvisited==<span class="keyword">false</span>) &#123;</span><br><span class="line">					stack.push(<span class="keyword">current</span>.firstadj);</span><br><span class="line">					vers[<span class="keyword">current</span>.firstadj].isvisited = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//遍历完成后恢复初始状态</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numofvers;i++) &#123;</span><br><span class="line">			vers[i].isvisited = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//广度优先遍历 Breadth-first traversal</span><br><span class="line">	<span class="built_in">public</span> <span class="type">void</span> BFT(<span class="type">int</span> v) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;<span class="number">0</span> || v&gt;=numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Queue&lt;<span class="type">Integer</span>&gt; queue = <span class="built_in">new</span> LinkedList&lt;<span class="type">Integer</span>&gt;();</span><br><span class="line">		LNode <span class="keyword">current</span>;</span><br><span class="line">		vers[v].isvisited = <span class="keyword">true</span>;</span><br><span class="line">		queue.offer(v);</span><br><span class="line">		<span class="keyword">while</span>(queue!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			v = queue.poll();</span><br><span class="line">			<span class="keyword">System</span>.<span class="keyword">out</span>.println(vers[v].data+" ");</span><br><span class="line">			<span class="keyword">current</span> = vers[v].first;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(vers[<span class="keyword">current</span>.firstadj].isvisited==<span class="keyword">false</span>) &#123;</span><br><span class="line">					queue.offer(<span class="keyword">current</span>.firstadj);</span><br><span class="line">					vers[<span class="keyword">current</span>.firstadj].isvisited = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//遍历完成后恢复初始状态</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numofvers;i++) &#123;</span><br><span class="line">			vers[i].isvisited = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//Dijkstra最短路径</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 基本思路就是先建立一个源点与各个结点的距离库</span></span><br><span class="line"><span class="comment">	 * 然后将结点作为入度的结点与源点通过的的各个结点距离相加 若小于最初的距离 则更新 直到全部更新完毕</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">public</span> <span class="type">int</span>[] Dijkstra(<span class="type">int</span> v) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v&lt;<span class="number">0</span> || v&gt;numofvers) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LNode <span class="keyword">current</span>;</span><br><span class="line">		<span class="keyword">current</span> = vers[v].first;</span><br><span class="line">		<span class="type">int</span>[] distance = <span class="built_in">new</span> <span class="type">int</span>[numofvers];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numofvers;i++) &#123;</span><br><span class="line">			distance[i] = <span class="type">Integer</span>.MAX_VALUE;  //即∞</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">current</span>!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			distance[<span class="keyword">current</span>.firstadj] = <span class="keyword">current</span>.weight;</span><br><span class="line">			<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">		&#125;</span><br><span class="line">		distance[v] = <span class="number">0</span>;</span><br><span class="line">		vers[v].isvisited = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numofvers;i++) &#123;</span><br><span class="line">			<span class="type">int</span> min = <span class="type">Integer</span>.MAX_VALUE;</span><br><span class="line">			<span class="type">int</span> <span class="keyword">index</span> = <span class="number">-1</span>;</span><br><span class="line">			// 比较从源点到其余顶点的路径长度</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numofvers; j++) &#123;</span><br><span class="line">				// 从源点到j顶点的最短路径还没有找到</span><br><span class="line">				<span class="keyword">if</span> (vers[j].isvisited == <span class="keyword">false</span>) &#123;</span><br><span class="line">					// 从源点到j顶点的路径长度最小</span><br><span class="line">					<span class="keyword">if</span> (distance[j] &lt; min) &#123;</span><br><span class="line">						<span class="keyword">index</span> = j;</span><br><span class="line">						min = distance[j];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			// 找到源点到索引为<span class="keyword">index</span>顶点的最短路径长度</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">index</span> != <span class="number">-1</span>)</span><br><span class="line">				vers[<span class="keyword">index</span>].isvisited = <span class="keyword">true</span>;</span><br><span class="line">			// 更新当前最短路径及距离</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; numofvers; t++)</span><br><span class="line">				<span class="keyword">if</span> (vers[t].isvisited == <span class="keyword">false</span>) &#123;</span><br><span class="line">					<span class="keyword">current</span> = vers[t].first;</span><br><span class="line">					<span class="keyword">while</span> (<span class="keyword">current</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">if</span> (<span class="keyword">current</span>.firstadj == <span class="keyword">index</span>)</span><br><span class="line">							<span class="keyword">if</span> ((min + <span class="keyword">current</span>.weight) &lt; distance[t]) &#123;</span><br><span class="line">								distance[t] = min + <span class="keyword">current</span>.weight;</span><br><span class="line">								break;</span><br><span class="line">							&#125;</span><br><span class="line">						<span class="keyword">current</span> = <span class="keyword">current</span>.nextvex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> distance;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】(队列的Java实现与经典应用)</title>
    <url>/2020/06/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%A4%E7%A7%8DJava%E5%AE%9E%E7%8E%B0%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8)/</url>
    <content><![CDATA[<p><strong>队列的出现迎合了很多Java复杂结构的应用,如二叉树的层序遍历,本篇用两种方法(数组\链表)实现了队列的定义,与此同时还有一些经典的方法进行了定义,涵盖了简单队列的内容,欢迎阅览喔( ͡° ͜ʖ ͡°)✧</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>与栈的结构相反，队列是一种先进先出的特殊表结构，普通队列的假溢出现象十分糟糕，所有目前对于队列的实现一般都使用循环队列，需要注意的是为了区分空队列和满队列的条件不同，故需要牺牲一个存储位置来满足循环队列的判断，具体可见数组形式的队列实现代码。<br><img src="https://i.loli.net/2020/06/14/HizbhIlXqKQ9f25.jpg" alt="IMG_7968.jpg"></p>
</blockquote>
<h2 id="队列的数组实现"><a href="#队列的数组实现" class="headerlink" title="队列的数组实现"></a>队列的数组实现</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package SquenceList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;T&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> T[] datas;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> maxsize;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> realmaxsize; <span class="comment">//真正储存的只有最大值-1个元素</span></span><br><span class="line">		<span class="comment">//队列的初始化</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> maxsize)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(maxsize&lt;<span class="number">1</span>) &#123;</span><br><span class="line">				maxsize=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.maxsize = maxsize;</span><br><span class="line">			realmaxsize = maxsize<span class="number">-1</span>;</span><br><span class="line">			rear = <span class="number">0</span>;</span><br><span class="line">			front = <span class="number">0</span>;</span><br><span class="line">			datas = (T[])<span class="keyword">new</span> Object[maxsize];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断队列是否为空</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; </span><br><span class="line">			<span class="keyword">return</span> (front==rear);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断队列是否已满</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">//注意循环队列判断是否已满的条件，为了和队空的条件区别</span></span><br><span class="line">			<span class="keyword">if</span>((rear+<span class="number">1</span>)%maxsize==front) &#123;</span><br><span class="line">				rear--;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;                                      <span class="comment">//所以这里牺牲了一个存储空间从而找到了判断队满的条件</span></span><br><span class="line">		<span class="comment">//进队</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="string">"队满啦，不能再进啦～"</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			datas[rear]=t;</span><br><span class="line">			rear++;</span><br><span class="line">			rear = rear%maxsize;  <span class="comment">//循环队列的特点，若要知其值则%maxsize</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//出队</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="string">"我队什么都没有，不可以再出去了～"</span>);</span><br><span class="line">				<span class="keyword">return</span> null;</span><br><span class="line">			&#125;</span><br><span class="line">			T data = datas[front++];</span><br><span class="line">			front = front%maxsize;</span><br><span class="line">			<span class="keyword">return</span> data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的队头位置</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> front;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的队尾位置</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> <span class="built_in">end</span> = rear<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">end</span>;  <span class="comment">//倒数第二个位置放着队列的队尾元素</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的对头位置元素</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">getFrontData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> datas[front];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的队尾位置元素</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">getRearData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> <span class="built_in">end</span> = rear<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">return</span> datas[<span class="built_in">end</span>]; <span class="comment">//队尾指针始终为空，故队尾元素在倒数第二个</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的元素</span></span><br><span class="line">		<span class="keyword">public</span> T[] getDatas() &#123;</span><br><span class="line">			<span class="keyword">return</span> datas;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取队列的最大长度</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> realmaxsize;  <span class="comment">//这里因为我们创建的是循环形式的队列，所以在判断队列是否满的时候需要牺牲一个位置</span></span><br><span class="line">		&#125;                      <span class="comment">//所以真实的存储空间应为空间数-1</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		ArrayQueue myqueue = <span class="keyword">new</span> ArrayQueue(<span class="number">5</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我的队列现在是空的吗:"</span>+myqueue.isEmpty());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我的队列现在是满的吗:"</span>+myqueue.isFull());</span><br><span class="line">		myqueue.push(<span class="number">1</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在队头是第几个呢:"</span>+myqueue.getFront());</span><br><span class="line">		myqueue.push(<span class="number">3</span>);</span><br><span class="line">		myqueue.push(<span class="number">5</span>);</span><br><span class="line">		<span class="comment">//myqueue.push(7);</span></span><br><span class="line">		<span class="comment">//myqueue.push(9); //空间只能存放最大数量-1个数量的元素</span></span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"在我入队了一些元素后，现在我的队列现在是空的吗:"</span>+myqueue.isEmpty());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"在我入队了一些元素后，现在我的队列现在是满的吗:"</span>+myqueue.isFull());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"出队:"</span>+myqueue.pop());</span><br><span class="line">		<span class="comment">//System.out.println("出队:"+myqueue.pop());</span></span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在我的队伍都有谁呢:"</span>+myqueue.getDatas());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在队头是第几个呢:"</span>+myqueue.getFront());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在队尾是第几个呢:"</span>+myqueue.getRear());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在队头是谁呢:"</span>+myqueue.getFrontData());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"现在队尾是谁呢:"</span>+myqueue.getRearData());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我的队列能放多少个元素呢:"</span>+myqueue.getLength());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列的链表实现"><a href="#队列的链表实现" class="headerlink" title="队列的链表实现"></a>队列的链表实现</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> LinkedQueue&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Node&lt;T&gt; front;</span><br><span class="line">	<span class="keyword">private</span> Node&lt;T&gt; rear;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxsize;</span><br><span class="line">	<span class="keyword">class</span> Node&lt;T&gt;&#123;  <span class="comment">//同样用内部类来作为节点的定义</span></span><br><span class="line">		<span class="keyword">private</span> T data;</span><br><span class="line">		<span class="keyword">public</span> Node&lt;T&gt; <span class="keyword">next</span>;</span><br><span class="line">		<span class="keyword">public</span> Node ()&#123;</span><br><span class="line">			<span class="keyword">this</span>.data=<span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">this</span>.<span class="keyword">next</span>=<span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> Node(T data) &#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">			<span class="keyword">this</span>.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> T getData() &#123;</span><br><span class="line">			<span class="keyword">return</span> data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> setData(T data) &#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> Node getNext() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//构造链队的初始化方法</span></span><br><span class="line">	<span class="keyword">public</span> LinkedQueue() &#123;</span><br><span class="line">		<span class="keyword">this</span>.front = <span class="keyword">new</span> Node();</span><br><span class="line">		<span class="keyword">this</span>.rear = <span class="keyword">new</span> Node();</span><br><span class="line">		maxsize = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化链队</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> initQueue() &#123;</span><br><span class="line">		<span class="keyword">this</span>.front = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">this</span>.rear = <span class="keyword">null</span>;</span><br><span class="line">		maxsize = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入队</span></span><br><span class="line">	<span class="comment">//判断链队是否为空</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> isEmpty() &#123;</span><br><span class="line">		<span class="keyword">if</span>(front.<span class="keyword">next</span>==<span class="keyword">null</span>||rear.<span class="keyword">next</span>==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入队</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">push</span>(T data) &#123;</span><br><span class="line">		Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;(data);</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			front.<span class="keyword">next</span> = node;</span><br><span class="line">			rear.<span class="keyword">next</span> = node;</span><br><span class="line">			maxsize++;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			node.<span class="keyword">next</span> = front.<span class="keyword">next</span>;</span><br><span class="line">			front.<span class="keyword">next</span> = node;</span><br><span class="line">			maxsize++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//出队</span></span><br><span class="line">	<span class="keyword">public</span> Node <span class="keyword">pop</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			System.out.<span class="keyword">println</span>(<span class="string">"这里是空的无法出队哦"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxsize ==<span class="number">1</span>) &#123;</span><br><span class="line">			Node node = front.<span class="keyword">next</span>;</span><br><span class="line">			initQueue();</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			Node end = front;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxsize-<span class="number">1</span>;i++) &#123;</span><br><span class="line">				end = end.<span class="keyword">next</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Node node = rear.<span class="keyword">next</span>;</span><br><span class="line">			rear.<span class="keyword">next</span> = end.<span class="keyword">next</span>;</span><br><span class="line">			maxsize--;</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">		LinkedQueue&lt;Integer&gt; lq = <span class="keyword">new</span> LinkedQueue&lt;Integer&gt;();</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"我现在还没有入队，队是空的吗？"</span>+lq.isEmpty());</span><br><span class="line">		lq.<span class="keyword">push</span>(<span class="number">1</span>);</span><br><span class="line">		lq.<span class="keyword">push</span>(<span class="number">2</span>);</span><br><span class="line">		lq.<span class="keyword">push</span>(<span class="number">3</span>);</span><br><span class="line">		lq.<span class="keyword">push</span>(<span class="number">4</span>);</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"我入队了一些元素，现在队还是空的吗？"</span>+lq.isEmpty());</span><br><span class="line">		System.out.<span class="keyword">println</span>(<span class="string">"出队所有元素元素："</span>);</span><br><span class="line">		System.out.<span class="keyword">println</span>(lq.<span class="keyword">pop</span>().data);</span><br><span class="line">		System.out.<span class="keyword">println</span>(lq.<span class="keyword">pop</span>().data);</span><br><span class="line">		System.out.<span class="keyword">println</span>(lq.<span class="keyword">pop</span>().data);</span><br><span class="line">		System.out.<span class="keyword">println</span>(lq.<span class="keyword">pop</span>().data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】(堆栈的三种Java实现与经典应用)</title>
    <url>/2020/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%A0%86%E6%A0%88%E7%9A%84%E4%B8%89%E7%A7%8DJava%E5%AE%9E%E7%8E%B0%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8)/</url>
    <content><![CDATA[<p><strong>堆栈在Java编程中无处不在,作为重要的数据结构类型之一,本篇使用了三种方式(数组\链表\共享数组空间)来实现堆栈,并且对一些经典的应用方法进行了定义,欢迎阅览ㄟ(◑‿◐ )ㄏ</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>LIFO(先进后出)的一种线性表，栈的优点是存取速度快，仅次于寄存器，并且栈的数据是可共享的，但是存放在栈的数据的大小和生存周期是固定的，缺乏一定的灵活性。在本篇对栈的实现使用的是链表与数组的形式，因为这两种形式简化了在ArrayList和LinkedList中的逻辑。<br><img src="https://i.loli.net/2020/06/15/cr2inNtdUVW1GK5.jpg" alt="IMG_7966.jpg"></p>
</blockquote>
<h2 id="数组形式对栈实现"><a href="#数组形式对栈实现" class="headerlink" title="数组形式对栈实现"></a>数组形式对栈实现</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;E&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Object[] data;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxsize;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line">	<span class="comment">//若没有定义初始长度则自定义一个5为初始长度</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//若有定义初始长度，则调用此构造函数来初始化数组长度</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> maxsize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(maxsize&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.maxsize = maxsize;</span><br><span class="line">			data = <span class="keyword">new</span> Object[maxsize];</span><br><span class="line">			top = <span class="number">-1</span>;  <span class="comment">//top目前指向第一个元素之前的位置</span></span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"初始化长度不能为0及小于0"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断栈是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top==<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(top&gt;=maxsize<span class="number">-1</span>) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"栈满，无法放入新元素"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			data[++top] = o;  <span class="comment">//若栈味满则此时top指针向上移动一位后存放入元素，此时成为栈顶元素</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取栈顶元素但不弹出</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"栈空，无栈顶元素"</span>);</span><br><span class="line">			<span class="keyword">return</span> null;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (E)data[top];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//出栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"栈空，无栈顶元素"</span>);</span><br><span class="line">			<span class="keyword">return</span> null;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (E)data[top--];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//寻找元素在栈中的位置</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(E order)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> toptem = top;  <span class="comment">//临时top节点，以便查找完成后回到初始状态</span></span><br><span class="line">		<span class="keyword">while</span>(top!=<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(data[top]==order) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				--top;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> result = ++top;</span><br><span class="line">		top = toptem;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		Stack mystack= <span class="keyword">new</span> Stack(<span class="number">6</span>);</span><br><span class="line">		mystack.push(<span class="number">1</span>);</span><br><span class="line">		mystack.push(<span class="number">2</span>);</span><br><span class="line">		mystack.push(<span class="number">3</span>);</span><br><span class="line">		mystack.push(<span class="number">4</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"mystack 是否为空？"</span>+mystack.isEmpty());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"mystack的栈顶元素为："</span>+mystack.<span class="built_in">peek</span>());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"依次出栈前两个:"</span>+mystack.pop()+mystack.pop());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"此时栈顶元素为："</span>+mystack.<span class="built_in">peek</span>());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"元素1此时在栈中的位置为："</span>+mystack.search(<span class="number">2</span>));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表形式堆栈实现"><a href="#链表形式堆栈实现" class="headerlink" title="链表形式堆栈实现"></a>链表形式堆栈实现</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkStack</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	Node&lt;T&gt; top = <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">//用内部类对栈的节点进行定义</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">T</span>&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> T <span class="keyword">data</span>;</span><br><span class="line">		<span class="keyword">private</span> Node&lt;T&gt; next=<span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">public</span> Node(T <span class="keyword">data</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入栈</span></span><br><span class="line">	<span class="keyword">public</span> void push(T <span class="keyword">data</span>) &#123;</span><br><span class="line">		Node&lt;T&gt; newnode = new Node&lt;T&gt;(<span class="keyword">data</span>);</span><br><span class="line">		newnode.next = top;</span><br><span class="line">		top = newnode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//出栈</span></span><br><span class="line">	<span class="keyword">public</span> T pop() &#123;</span><br><span class="line">		<span class="keyword">if</span>(top==<span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		T <span class="keyword">data</span> = top.<span class="keyword">data</span>;</span><br><span class="line">		top = top.next;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">data</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断栈是否为空</span></span><br><span class="line">	<span class="keyword">public</span> boolean isEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> top==<span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取栈顶的值</span></span><br><span class="line">	<span class="keyword">public</span> T peek() &#123;</span><br><span class="line">		<span class="keyword">if</span>(top==<span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> top.<span class="keyword">data</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">		LinkStack ls = new LinkStack();</span><br><span class="line">		ls.push(<span class="number">1</span>);</span><br><span class="line">		ls.push(<span class="number">6</span>);  <span class="comment">//依次入栈</span></span><br><span class="line">		ls.push(<span class="number">2</span>);</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"栈是否为空:"</span>+ls.isEmpty());</span><br><span class="line">		System.<span class="keyword">out</span>.println(ls.pop());</span><br><span class="line">		System.<span class="keyword">out</span>.println(ls.pop());  <span class="comment">//先入后出是栈的最大的特点</span></span><br><span class="line">		System.<span class="keyword">out</span>.println(ls.pop());</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"取出栈顶元素:"</span>+ls.peek()); <span class="comment">//栈已经全部弹出 栈顶元素为null</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>3.共享数组空间的双重栈形式</em></strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxsize = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> topl;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> topr;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DoubleStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		data = <span class="keyword">new</span> <span class="keyword">int</span>[maxsize];</span><br><span class="line">		topl = <span class="number">-1</span>;</span><br><span class="line">		topr = maxsize;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断是否栈空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ((topl==<span class="number">0</span>)&amp;&amp;(topr==maxsize));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断是否栈满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (topl+<span class="number">1</span>==topr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//清空栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		topl = <span class="number">-1</span>;</span><br><span class="line">		topr = maxsize;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取栈的长度</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">			<span class="keyword">return</span> maxsize;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> length = (topl+<span class="number">1</span>)+(maxsize-topr);</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取左栈栈顶值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(topl==<span class="number">-1</span>) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"左栈什么都没有喔～"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> data[topl];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取右栈栈顶值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(topr==maxsize) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"右栈什么都没有喔～"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> data[topr];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">String</span> stackdir, <span class="keyword">int</span> e)</span> </span>&#123;  <span class="comment">//stackdir分为左栈和右栈</span></span><br><span class="line">		<span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"嘻嘻嘻栈满啦，不能再入啦～～"</span>);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(stackdir==<span class="string">"左栈"</span>) &#123;</span><br><span class="line">			topl+=<span class="number">1</span>;</span><br><span class="line">			data[topl]=e;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(stackdir==<span class="string">"右栈"</span>) &#123;</span><br><span class="line">			topr-=<span class="number">1</span>;</span><br><span class="line">			data[topr]=e;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//出栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">String</span> stackdir)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"555这里什么都没有，不能再出了～～～"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(stackdir==<span class="string">"左栈"</span>) &#123;</span><br><span class="line">			result = data[topl--];</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(stackdir==<span class="string">"右栈"</span>) &#123;</span><br><span class="line">			result = data[topr++];</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历此双栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackTraverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;=topl) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(data[i]+<span class="string">" "</span>);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		i = topr;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;maxsize) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(data[i]+<span class="string">" "</span>);;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		DoubleStack <span class="built_in">stack</span> = <span class="keyword">new</span> DoubleStack();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"此时栈为空吗？"</span>+<span class="built_in">stack</span>.isEmpty());</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"左栈"</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"左栈"</span>, <span class="number">2</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"左栈"</span>, <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"右栈"</span>, <span class="number">4</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"右栈"</span>, <span class="number">5</span>);</span><br><span class="line">		<span class="built_in">stack</span>.push(<span class="string">"右栈"</span>, <span class="number">6</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"此时栈的长度为:"</span>+<span class="built_in">stack</span>.length());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我放入了一些元素，此时栈为空吗？"</span>+<span class="built_in">stack</span>.isEmpty());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我想看看左栈栈顶是什么:"</span>+<span class="built_in">stack</span>.getLeftStack());</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我还想看右栈栈顶是什么:"</span>+<span class="built_in">stack</span>.getRightStack());</span><br><span class="line">		System.out.<span class="built_in">print</span>(<span class="string">"让我看看栈里面都有什么吧："</span>);</span><br><span class="line">		<span class="built_in">stack</span>.stackTraverse();</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我想弹出一些左栈的元素"</span>+<span class="built_in">stack</span>.pop(<span class="string">"左栈"</span>)+<span class="built_in">stack</span>.pop(<span class="string">"左栈"</span>));</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"我想弹出一些右栈的元素"</span>+<span class="built_in">stack</span>.pop(<span class="string">"右栈"</span>)+<span class="built_in">stack</span>.pop(<span class="string">"右栈"</span>));</span><br><span class="line">		System.out.<span class="built_in">print</span>(<span class="string">"现在栈里都还剩哪些元素呢？:"</span>);</span><br><span class="line">		<span class="built_in">stack</span>.stackTraverse();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习区</category>
      </categories>
      <tags>
        <tag>学习区</tag>
      </tags>
  </entry>
</search>
